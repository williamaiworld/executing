{
    "bird.py": [
        [
            "LOAD_METHOD",
            "standard_library.install_aliases"
        ],
        [
            "CALL_METHOD",
            "standard_library.install_aliases()"
        ],
        [
            "CALL_FUNCTION",
            "warn_if_outdated('birdseye', __version__)"
        ],
        [
            "CALL_FUNCTION",
            "namedtuple('CodeInfo', 'db_func traced_file arg_names')"
        ],
        [
            "CALL_FUNCTION",
            "BirdsEye()"
        ],
        [
            "CALL_FUNCTION",
            "NamedTuple('HTMLPosition', [\n    ('index', int),\n    ('is_start', bool),\n    ('depth', int),\n    ('html', str),\n])"
        ],
        [
            "LOAD_ATTR",
            "eye.enter_call"
        ],
        [
            "LOAD_ATTR",
            "eye.enter_call.__code__"
        ],
        [
            "LOAD_ATTR",
            "eye.exit_call"
        ],
        [
            "LOAD_ATTR",
            "eye.exit_call.__code__"
        ],
        [
            "LOAD_ATTR",
            "eye.after_expr"
        ],
        [
            "LOAD_ATTR",
            "eye.after_expr.__code__"
        ],
        [
            "LOAD_ATTR",
            "eye.after_stmt"
        ],
        [
            "LOAD_ATTR",
            "eye.after_stmt.__code__"
        ],
        [
            "BINARY_SUBSCR",
            "Iterable[Iteration]"
        ],
        [
            "CALL_FUNCTION",
            "TypeRegistry()"
        ],
        [
            "CALL_FUNCTION",
            "try_register_repr('pandas', 'Series')"
        ],
        [
            "CALL_FUNCTION",
            "lru_cache()"
        ],
        [
            "CALL_FUNCTION",
            "super(BirdsEye, self)"
        ],
        [
            "LOAD_METHOD",
            "super(BirdsEye, self).__init__"
        ],
        [
            "CALL_METHOD",
            "super(BirdsEye, self).__init__()"
        ],
        [
            "CALL_FUNCTION_KW",
            "dict(\n                attributes=50,\n                dict=50,\n                list=30,\n                set=30,\n                pandas_rows=20,\n                pandas_cols=100,\n            )"
        ],
        [
            "CALL_FUNCTION_KW",
            "dict(\n                attributes=50,\n                dict=10,\n                list=6,\n                set=6,\n                pandas_rows=6,\n                pandas_cols=10,\n            )"
        ],
        [
            "CALL_FUNCTION_KW",
            "dict(\n            big=dict(\n                attributes=50,\n                dict=50,\n                list=30,\n                set=30,\n                pandas_rows=20,\n                pandas_cols=100,\n            ),\n            small=dict(\n                attributes=50,\n                dict=10,\n                list=6,\n                set=6,\n                pandas_rows=6,\n                pandas_cols=10,\n            ),\n        )"
        ],
        [
            "LOAD_ATTR",
            "self._db_uri"
        ],
        [
            "CALL_FUNCTION",
            "Database(self._db_uri)"
        ],
        [
            "LOAD_METHOD",
            "ast.walk"
        ],
        [
            "CALL_METHOD",
            "ast.walk(root)"
        ],
        [
            "LOAD_METHOD",
            "tracer.loops"
        ],
        [
            "CALL_METHOD",
            "tracer.loops(node)"
        ],
        [
            "LOAD_ATTR",
            "ast.expr"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node, ast.expr)"
        ],
        [
            "CALL_FUNCTION",
            "is_interesting_expression(node)"
        ],
        [
            "CALL_FUNCTION",
            "super(BirdsEye, self)"
        ],
        [
            "LOAD_METHOD",
            "super(BirdsEye, self).compile"
        ],
        [
            "CALL_METHOD",
            "super(BirdsEye, self).compile(source, filename, flags)"
        ],
        [
            "LOAD_ATTR",
            "traced_file.root"
        ],
        [
            "CALL_FUNCTION_KW",
            "ASTTokens(source, tree=traced_file.root)"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code not in self._code_infos"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_ATTR",
            "ast.For"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node.parent, ast.For)"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_ATTR",
            "node.parent.body"
        ],
        [
            "BINARY_SUBSCR",
            "node.parent.body[0]"
        ],
        [
            "IS_OP",
            "node is node.parent.body[0]"
        ],
        [
            "LOAD_METHOD",
            "self._add_iteration"
        ],
        [
            "LOAD_ATTR",
            "node._loops"
        ],
        [
            "CALL_METHOD",
            "self._add_iteration(node._loops, frame)"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_ATTR",
            "ast.While"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node.parent, ast.While)"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_ATTR",
            "node.parent.test"
        ],
        [
            "IS_OP",
            "node is node.parent.test"
        ],
        [
            "LOAD_METHOD",
            "self._add_iteration"
        ],
        [
            "LOAD_ATTR",
            "node._loops"
        ],
        [
            "CALL_METHOD",
            "self._add_iteration(node._loops, frame)"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "LOAD_ATTR",
            "self.stack[frame].iteration"
        ],
        [
            "CALL_FUNCTION",
            "enumerate(loops)"
        ],
        [
            "LOAD_ATTR",
            "iteration.loops"
        ],
        [
            "LOAD_ATTR",
            "loop_node._tree_index"
        ],
        [
            "BINARY_SUBSCR",
            "iteration.loops[loop_node._tree_index]"
        ],
        [
            "CALL_FUNCTION",
            "len(loops)"
        ],
        [
            "BINARY_SUBTRACT",
            "len(loops) - 1"
        ],
        [
            "COMPARE_OP",
            "i == len(loops) - 1"
        ],
        [
            "LOAD_METHOD",
            "loop.append"
        ],
        [
            "CALL_FUNCTION",
            "Iteration()"
        ],
        [
            "CALL_METHOD",
            "loop.append(Iteration())"
        ],
        [
            "LOAD_METHOD",
            "loop.last"
        ],
        [
            "CALL_METHOD",
            "loop.last()"
        ],
        [
            "CALL_FUNCTION",
            "_tracing_recursively(frame)"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code not in self._code_infos"
        ],
        [
            "LOAD_ATTR",
            "node._is_interesting_expression"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "BINARY_SUBSCR",
            "self._code_infos[frame.f_code]"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos[frame.f_code].traced_file"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos[frame.f_code].traced_file.is_ipython_cell"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_ATTR",
            "ast.Expr"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node.parent, ast.Expr)"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_ATTR",
            "node.parent.parent"
        ],
        [
            "LOAD_ATTR",
            "node.parent.parent.body"
        ],
        [
            "BINARY_SUBSCR",
            "node.parent.parent.body[-1]"
        ],
        [
            "IS_OP",
            "node.parent is node.parent.parent.body[-1]"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "LOAD_ATTR",
            "self.stack[frame].expression_values"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame].expression_values[node]"
        ],
        [
            "CALL_FUNCTION",
            "is_obvious_builtin(node, self.stack[frame].expression_values[node])"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "LOAD_METHOD",
            "self._exception_value"
        ],
        [
            "CALL_METHOD",
            "self._exception_value(node, frame, exc_value)"
        ],
        [
            "LOAD_ATTR",
            "NodeValue.expression"
        ],
        [
            "LOAD_ATTR",
            "self.num_samples"
        ],
        [
            "LOAD_ATTR",
            "node._loops"
        ],
        [
            "CALL_FUNCTION",
            "len(node._loops)"
        ],
        [
            "LOAD_METHOD",
            "self._is_first_loop_iteration"
        ],
        [
            "CALL_METHOD",
            "self._is_first_loop_iteration(node, frame)"
        ],
        [
            "UNARY_NOT",
            "not self._is_first_loop_iteration(node, frame)"
        ],
        [
            "BINARY_MULTIPLY",
            "len(node._loops) * (not self._is_first_loop_iteration(node, frame))"
        ],
        [
            "BINARY_SUBTRACT",
            "3 - len(node._loops) * (not self._is_first_loop_iteration(node, frame))"
        ],
        [
            "CALL_FUNCTION",
            "max(1, 3 - len(node._loops) * (not self._is_first_loop_iteration(node, frame)))"
        ],
        [
            "CALL_FUNCTION_KW",
            "NodeValue.expression(\n                    self.num_samples,\n                    value,\n                    level=max(1, 3 - len(node._loops) * (not self._is_first_loop_iteration(node, frame))),\n                )"
        ],
        [
            "LOAD_METHOD",
            "self._set_node_value"
        ],
        [
            "CALL_METHOD",
            "self._set_node_value(node, frame, node_value)"
        ],
        [
            "LOAD_METHOD",
            "self._check_inner_call"
        ],
        [
            "CALL_METHOD",
            "self._check_inner_call(frame_info, node, node_value)"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_ATTR",
            "ast.comprehension"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node.parent, ast.comprehension)"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_ATTR",
            "node.parent.iter"
        ],
        [
            "IS_OP",
            "node is node.parent.iter"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_ATTR",
            "node.parent.parent"
        ],
        [
            "LOAD_ATTR",
            "ast.GeneratorExp"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node.parent.parent, ast.GeneratorExp)"
        ],
        [
            "UNARY_NOT",
            "not isinstance(node.parent.parent, ast.GeneratorExp)"
        ],
        [
            "LOAD_METHOD",
            "self._set_node_value"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_METHOD",
            "NodeValue.covered"
        ],
        [
            "CALL_METHOD",
            "NodeValue.covered()"
        ],
        [
            "CALL_METHOD",
            "self._set_node_value(node.parent, frame, NodeValue.covered())"
        ],
        [
            "LOAD_ATTR",
            "node._loops"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "BINARY_ADD",
            "node._loops + (node.parent,)"
        ],
        [
            "CALL_FUNCTION",
            "comprehension_iter_proxy()"
        ],
        [
            "CALL_FUNCTION",
            "ChangeValue(comprehension_iter_proxy())"
        ],
        [
            "LOAD_METHOD",
            "self._add_iteration"
        ],
        [
            "CALL_METHOD",
            "self._add_iteration(loops, frame)"
        ],
        [
            "LOAD_ATTR",
            "frame_info.inner_calls"
        ],
        [
            "LOAD_METHOD",
            "frame_info.inner_calls.pop"
        ],
        [
            "CALL_METHOD",
            "frame_info.inner_calls.pop(node, None)"
        ],
        [
            "LOAD_METHOD",
            "node_value.set_meta"
        ],
        [
            "CALL_METHOD",
            "node_value.set_meta('inner_calls', inner_calls)"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "LOAD_ATTR",
            "self.stack[frame].iteration"
        ],
        [
            "LOAD_ATTR",
            "node._loops"
        ],
        [
            "LOAD_ATTR",
            "iteration.loops"
        ],
        [
            "LOAD_ATTR",
            "loop_node._tree_index"
        ],
        [
            "BINARY_SUBSCR",
            "iteration.loops[loop_node._tree_index]"
        ],
        [
            "LOAD_METHOD",
            "loop.last"
        ],
        [
            "CALL_METHOD",
            "loop.last()"
        ],
        [
            "LOAD_ATTR",
            "iteration.index"
        ],
        [
            "COMPARE_OP",
            "iteration.index > 0"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "LOAD_ATTR",
            "self.stack[frame].iteration"
        ],
        [
            "LOAD_ATTR",
            "node._loops"
        ],
        [
            "LOAD_ATTR",
            "iteration.loops"
        ],
        [
            "LOAD_ATTR",
            "loop_node._tree_index"
        ],
        [
            "BINARY_SUBSCR",
            "iteration.loops[loop_node._tree_index]"
        ],
        [
            "LOAD_METHOD",
            "loop.recorded_node"
        ],
        [
            "CALL_METHOD",
            "loop.recorded_node(node)"
        ],
        [
            "LOAD_METHOD",
            "loop.last"
        ],
        [
            "CALL_METHOD",
            "loop.last()"
        ],
        [
            "LOAD_ATTR",
            "iteration.vals"
        ],
        [
            "LOAD_ATTR",
            "node._tree_index"
        ],
        [
            "LOAD_METHOD",
            "NodeValue.exception"
        ],
        [
            "CALL_METHOD",
            "NodeValue.exception(exc_value)"
        ],
        [
            "LOAD_METHOD",
            "self._set_node_value"
        ],
        [
            "CALL_METHOD",
            "self._set_node_value(node, frame, value)"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code not in self._code_infos"
        ],
        [
            "CALL_FUNCTION",
            "_tracing_recursively(frame)"
        ],
        [
            "IS_OP",
            "node is exc_node"
        ],
        [
            "LOAD_METHOD",
            "self._exception_value"
        ],
        [
            "CALL_METHOD",
            "self._exception_value(node, frame, exc_value)"
        ],
        [
            "LOAD_METHOD",
            "NodeValue.covered"
        ],
        [
            "CALL_METHOD",
            "NodeValue.covered()"
        ],
        [
            "LOAD_METHOD",
            "self._set_node_value"
        ],
        [
            "CALL_METHOD",
            "self._set_node_value(node, frame, value)"
        ],
        [
            "LOAD_METHOD",
            "self._check_inner_call"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "CALL_METHOD",
            "self._check_inner_call(self.stack[frame], node, value)"
        ],
        [
            "LOAD_ATTR",
            "enter_info.current_frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code not in self._code_infos"
        ],
        [
            "CALL_FUNCTION",
            "_tracing_recursively(frame)"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "CALL_FUNCTION",
            "get_unfrozen_datetime()"
        ],
        [
            "CALL_FUNCTION",
            "Iteration()"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "BINARY_SUBSCR",
            "self._code_infos[frame.f_code]"
        ],
        [
            "LOAD_ATTR",
            "enter_info.enter_node"
        ],
        [
            "LOAD_ATTR",
            "enter_info.enter_node.parent"
        ],
        [
            "LOAD_ATTR",
            "ast.Module"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(enter_info.enter_node.parent, ast.Module)"
        ],
        [
            "LOAD_ATTR",
            "frame.f_locals"
        ],
        [
            "LOAD_METHOD",
            "frame.f_locals.copy"
        ],
        [
            "CALL_METHOD",
            "frame.f_locals.copy()"
        ],
        [
            "LOAD_ATTR",
            "code_info.arg_names"
        ],
        [
            "LOAD_METHOD",
            "f_locals.items"
        ],
        [
            "CALL_METHOD",
            "f_locals.items()"
        ],
        [
            "BINARY_ADD",
            "[(name, f_locals.pop(name))\n                         for name in code_info.arg_names\n                         if name] + [\n\n                            # Local variables other than actual arguments. These are variables from\n                            # the enclosing scope. It's handy to treat them like arguments in the UI\n                            it for it in f_locals.items()\n                            if it[0][0] != '.'  # Appears when using nested tuple arguments\n                        ]"
        ],
        [
            "LOAD_METHOD",
            "json.dumps"
        ],
        [
            "CALL_METHOD",
            "json.dumps([[k, cheap_repr(v)] for k, v in arguments])"
        ],
        [
            "LOAD_METHOD",
            "self._call_id"
        ],
        [
            "CALL_METHOD",
            "self._call_id()"
        ],
        [
            "CALL_FUNCTION",
            "defaultdict(list)"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_METHOD",
            "self.stack.get"
        ],
        [
            "LOAD_ATTR",
            "enter_info.caller_frame"
        ],
        [
            "CALL_METHOD",
            "self.stack.get(enter_info.caller_frame)"
        ],
        [
            "CALL_FUNCTION",
            "getattr(prev, 'inner_calls', None)"
        ],
        [
            "IS_OP",
            "inner_calls is not None"
        ],
        [
            "LOAD_ATTR",
            "enter_info.call_node"
        ],
        [
            "BINARY_SUBSCR",
            "inner_calls[enter_info.call_node]"
        ],
        [
            "LOAD_METHOD",
            "inner_calls[enter_info.call_node].append"
        ],
        [
            "LOAD_ATTR",
            "frame_info.call_id"
        ],
        [
            "CALL_METHOD",
            "inner_calls[enter_info.call_node].append(frame_info.call_id)"
        ],
        [
            "LOAD_METHOD",
            "f_locals.pop"
        ],
        [
            "CALL_METHOD",
            "f_locals.pop(name)"
        ],
        [
            "BINARY_SUBSCR",
            "it[0]"
        ],
        [
            "BINARY_SUBSCR",
            "it[0][0]"
        ],
        [
            "COMPARE_OP",
            "it[0][0] != '.'"
        ],
        [
            "CALL_FUNCTION",
            "cheap_repr(v)"
        ],
        [
            "CALL_FUNCTION",
            "uuid4()"
        ],
        [
            "LOAD_ATTR",
            "uuid4().hex"
        ],
        [
            "LOAD_ATTR",
            "exit_info.current_frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code not in self._code_infos"
        ],
        [
            "CALL_FUNCTION",
            "_tracing_recursively(frame)"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "LOAD_ATTR",
            "frame_info.iteration"
        ],
        [
            "CALL_FUNCTION",
            "_deep_dict()"
        ],
        [
            "LOAD_METHOD",
            "self._extract_node_values"
        ],
        [
            "CALL_METHOD",
            "self._extract_node_values(top_iteration, (), node_values)"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "BINARY_SUBSCR",
            "self._code_infos[frame.f_code]"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos[frame.f_code].db_func"
        ],
        [
            "LOAD_ATTR",
            "exit_info.exc_value"
        ],
        [
            "LOAD_METHOD",
            "''.join"
        ],
        [
            "LOAD_METHOD",
            "traceback.format_exception"
        ],
        [
            "CALL_FUNCTION",
            "type(exc)"
        ],
        [
            "LOAD_ATTR",
            "exit_info.exc_tb"
        ],
        [
            "CALL_METHOD",
            "traceback.format_exception(type(exc), exc, exit_info.exc_tb)"
        ],
        [
            "CALL_METHOD",
            "''.join(traceback.format_exception(type(exc), exc, exit_info.exc_tb))"
        ],
        [
            "CALL_FUNCTION",
            "exception_string(exc)"
        ],
        [
            "CALL_FUNCTION",
            "add_call()"
        ],
        [
            "LOAD_ATTR",
            "frame_info.call_id"
        ],
        [
            "LOAD_ATTR",
            "self.db"
        ],
        [
            "LOAD_ATTR",
            "self.db.Call"
        ],
        [
            "LOAD_ATTR",
            "frame_info.call_id"
        ],
        [
            "LOAD_ATTR",
            "frame_info.arguments"
        ],
        [
            "LOAD_ATTR",
            "exit_info.return_value"
        ],
        [
            "CALL_FUNCTION",
            "cheap_repr(exit_info.return_value)"
        ],
        [
            "LOAD_ATTR",
            "json.dumps"
        ],
        [
            "LOAD_METHOD",
            "top_iteration.extract_iterations"
        ],
        [
            "CALL_METHOD",
            "top_iteration.extract_iterations()"
        ],
        [
            "BINARY_SUBSCR",
            "top_iteration.extract_iterations()['loops']"
        ],
        [
            "LOAD_METHOD",
            "type_registry.names"
        ],
        [
            "CALL_METHOD",
            "type_registry.names()"
        ],
        [
            "LOAD_ATTR",
            "type_registry.num_special_types"
        ],
        [
            "CALL_FUNCTION_KW",
            "dict(\n                                node_values=node_values,\n                                loop_iterations=top_iteration.extract_iterations()['loops'],\n                                type_names=type_registry.names(),\n                                num_special_types=type_registry.num_special_types,\n                            )"
        ],
        [
            "CALL_FUNCTION_KW",
            "json.dumps(\n                            dict(\n                                node_values=node_values,\n                                loop_iterations=top_iteration.extract_iterations()['loops'],\n                                type_names=type_registry.names(),\n                                num_special_types=type_registry.num_special_types,\n                            ),\n                            cls=ProtocolEncoder,\n                            separators=(',', ':')\n                        )"
        ],
        [
            "LOAD_ATTR",
            "frame_info.start_time"
        ],
        [
            "CALL_FUNCTION_KW",
            "Call(id=frame_info.call_id,\n                        function_id=db_func,\n                        arguments=frame_info.arguments,\n                        return_value=cheap_repr(exit_info.return_value),\n                        exception=exception,\n                        traceback=traceback_str,\n                        data=json.dumps(\n                            dict(\n                                node_values=node_values,\n                                loop_iterations=top_iteration.extract_iterations()['loops'],\n                                type_names=type_registry.names(),\n                                num_special_types=type_registry.num_special_types,\n                            ),\n                            cls=ProtocolEncoder,\n                            separators=(',', ':')\n                        ),\n                        start_time=frame_info.start_time)"
        ],
        [
            "LOAD_ATTR",
            "self.db"
        ],
        [
            "LOAD_METHOD",
            "self.db.session_scope"
        ],
        [
            "CALL_METHOD",
            "self.db.session_scope()"
        ],
        [
            "LOAD_METHOD",
            "session.add"
        ],
        [
            "CALL_METHOD",
            "session.add(call)"
        ],
        [
            "LOAD_ATTR",
            "iteration.vals"
        ],
        [
            "LOAD_METHOD",
            "iteration.vals.items"
        ],
        [
            "CALL_METHOD",
            "iteration.vals.items()"
        ],
        [
            "BINARY_ADD",
            "(tree_index,) + path"
        ],
        [
            "BINARY_SUBSCR",
            "full_path[:-1]"
        ],
        [
            "BINARY_SUBSCR",
            "d[path_k]"
        ],
        [
            "BINARY_SUBSCR",
            "full_path[-1]"
        ],
        [
            "LOAD_ATTR",
            "iteration.loops"
        ],
        [
            "LOAD_METHOD",
            "iteration.loops.values"
        ],
        [
            "CALL_METHOD",
            "iteration.loops.values()"
        ],
        [
            "CALL_FUNCTION",
            "enumerate(loop)"
        ],
        [
            "LOAD_METHOD",
            "self._extract_node_values"
        ],
        [
            "BINARY_ADD",
            "path + (i,)"
        ],
        [
            "CALL_METHOD",
            "self._extract_node_values(iteration, path + (i,), node_values)"
        ],
        [
            "CALL_FUNCTION",
            "super(BirdsEye, self)"
        ],
        [
            "LOAD_METHOD",
            "super(BirdsEye, self).trace_function"
        ],
        [
            "CALL_METHOD",
            "super(BirdsEye, self).trace_function(func)"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "LOAD_METHOD",
            "self._code_infos.get"
        ],
        [
            "LOAD_ATTR",
            "new_func.__code__"
        ],
        [
            "CALL_METHOD",
            "self._code_infos.get(new_func.__code__)"
        ],
        [
            "LOAD_METHOD",
            "inspect.getsourcelines"
        ],
        [
            "CALL_METHOD",
            "inspect.getsourcelines(func)"
        ],
        [
            "CALL_FUNCTION",
            "len(lines)"
        ],
        [
            "BINARY_ADD",
            "start_lineno + len(lines)"
        ],
        [
            "CALL_FUNCTION",
            "safe_qualname(func)"
        ],
        [
            "LOAD_METHOD",
            "inspect.getsourcefile"
        ],
        [
            "CALL_METHOD",
            "inspect.getsourcefile(func)"
        ],
        [
            "LOAD_METHOD",
            "source_file.startswith"
        ],
        [
            "CALL_METHOD",
            "source_file.startswith('<ipython-input')"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.abspath"
        ],
        [
            "CALL_METHOD",
            "os.path.abspath(source_file)"
        ],
        [
            "LOAD_ATTR",
            "new_func.traced_file"
        ],
        [
            "LOAD_METHOD",
            "inspect.getargs"
        ],
        [
            "LOAD_ATTR",
            "new_func.__code__"
        ],
        [
            "CALL_METHOD",
            "inspect.getargs(new_func.__code__)"
        ],
        [
            "BINARY_SUBSCR",
            "arg_info[0]"
        ],
        [
            "CALL_FUNCTION",
            "flatten_list(arg_info[0])"
        ],
        [
            "BINARY_SUBSCR",
            "arg_info[1:]"
        ],
        [
            "CALL_FUNCTION",
            "chain(flatten_list(arg_info[0]), arg_info[1:])"
        ],
        [
            "CALL_FUNCTION",
            "list(chain(flatten_list(arg_info[0]), arg_info[1:]))"
        ],
        [
            "LOAD_ATTR",
            "self._trace"
        ],
        [
            "LOAD_ATTR",
            "new_func.__code__"
        ],
        [
            "CALL_FUNCTION_KW",
            "self._trace(name, filename, traced_file, new_func.__code__, typ='function',\n                    start_lineno=start_lineno, end_lineno=end_lineno,\n                    arg_names=arg_names)"
        ],
        [
            "CALL_FUNCTION",
            "get_ipython()"
        ],
        [
            "LOAD_ATTR",
            "shell.compile"
        ],
        [
            "LOAD_METHOD",
            "shell.compile.cache"
        ],
        [
            "CALL_METHOD",
            "shell.compile.cache(source)"
        ],
        [
            "LOAD_ATTR",
            "shell.compile"
        ],
        [
            "LOAD_ATTR",
            "shell.compile.flags"
        ],
        [
            "LOAD_METHOD",
            "self.compile"
        ],
        [
            "CALL_METHOD",
            "self.compile(source, filename, flags)"
        ],
        [
            "LOAD_ATTR",
            "traced_file.root"
        ],
        [
            "LOAD_ATTR",
            "traced_file.root.body"
        ],
        [
            "CALL_FUNCTION",
            "is_future_import(node)"
        ],
        [
            "CALL_FUNCTION",
            "ValueError('from __future__ import ... statements '\n                                 'are not allowed in cells traced with %%eye')"
        ],
        [
            "LOAD_ATTR",
            "shell.user_global_ns"
        ],
        [
            "LOAD_METHOD",
            "shell.user_global_ns.update"
        ],
        [
            "LOAD_METHOD",
            "self._trace_methods_dict"
        ],
        [
            "CALL_METHOD",
            "self._trace_methods_dict(traced_file)"
        ],
        [
            "CALL_METHOD",
            "shell.user_global_ns.update(self._trace_methods_dict(traced_file))"
        ],
        [
            "LOAD_METHOD",
            "self._trace"
        ],
        [
            "LOAD_ATTR",
            "traced_file.code"
        ],
        [
            "CALL_METHOD",
            "self._trace(name, filename, traced_file, traced_file.code, 'module', source)"
        ],
        [
            "LOAD_METHOD",
            "shell.ex"
        ],
        [
            "LOAD_ATTR",
            "traced_file.code"
        ],
        [
            "CALL_METHOD",
            "shell.ex(traced_file.code)"
        ],
        [
            "LOAD_ATTR",
            "self._ipython_cell_value"
        ],
        [
            "LOAD_ATTR",
            "self._last_call_id"
        ],
        [
            "CALL_FUNCTION",
            "callback(self._last_call_id)"
        ],
        [
            "LOAD_ATTR",
            "self._last_call_id"
        ],
        [
            "CALL_FUNCTION",
            "callback(self._last_call_id)"
        ],
        [
            "LOAD_METHOD",
            "inspect.currentframe"
        ],
        [
            "CALL_METHOD",
            "inspect.currentframe()"
        ],
        [
            "COMPARE_OP",
            "context >= 0"
        ],
        [
            "LOAD_ATTR",
            "frame.f_back"
        ],
        [
            "LOAD_METHOD",
            "inspect.getsourcefile"
        ],
        [
            "CALL_METHOD",
            "inspect.getsourcefile(frame)"
        ],
        [
            "IS_OP",
            "filename is not None"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.abspath"
        ],
        [
            "CALL_METHOD",
            "os.path.abspath(filename)"
        ],
        [
            "LOAD_ATTR",
            "frame.f_globals"
        ],
        [
            "LOAD_METHOD",
            "frame.f_globals.get"
        ],
        [
            "CALL_METHOD",
            "frame.f_globals.get('__name__')"
        ],
        [
            "COMPARE_OP",
            "frame.f_globals.get('__name__') != '__main__'"
        ],
        [
            "LOAD_ATTR",
            "self._treetrace_hidden_with_stmt"
        ],
        [
            "LOAD_ATTR",
            "self._treetrace_hidden_with_stmt.__name__"
        ],
        [
            "LOAD_ATTR",
            "frame.f_globals"
        ],
        [
            "CONTAINS_OP",
            "self._treetrace_hidden_with_stmt.__name__ not in frame.f_globals"
        ],
        [
            "CALL_FUNCTION",
            "RuntimeError(\n                    'To trace an imported module, you must import birdseye before '\n                    'importing that module.')"
        ],
        [
            "CALL_FUNCTION",
            "read_source_file(filename)"
        ],
        [
            "LOAD_METHOD",
            "read_source_file(filename).splitlines"
        ],
        [
            "CALL_METHOD",
            "read_source_file(filename).splitlines()"
        ],
        [
            "LOAD_ATTR",
            "frame.f_lineno"
        ],
        [
            "BINARY_MULTIPLY",
            "[''] * frame.f_lineno"
        ],
        [
            "LOAD_ATTR",
            "frame.f_lineno"
        ],
        [
            "LOAD_METHOD",
            "'\\n'.join"
        ],
        [
            "CALL_METHOD",
            "'\\n'.join(lines)"
        ],
        [
            "LOAD_METHOD",
            "self.exec_string"
        ],
        [
            "LOAD_ATTR",
            "frame.f_globals"
        ],
        [
            "LOAD_ATTR",
            "frame.f_locals"
        ],
        [
            "CALL_METHOD",
            "self.exec_string(source, filename, frame.f_globals, frame.f_locals, deep)"
        ],
        [
            "LOAD_METHOD",
            "sys.exit"
        ],
        [
            "CALL_METHOD",
            "sys.exit(0)"
        ],
        [
            "LOAD_METHOD",
            "self.compile"
        ],
        [
            "CALL_METHOD",
            "self.compile(source, filename)"
        ],
        [
            "LOAD_METHOD",
            "globs.update"
        ],
        [
            "LOAD_METHOD",
            "self._trace_methods_dict"
        ],
        [
            "CALL_METHOD",
            "self._trace_methods_dict(traced_file)"
        ],
        [
            "CALL_METHOD",
            "globs.update(self._trace_methods_dict(traced_file))"
        ],
        [
            "LOAD_METHOD",
            "self._trace"
        ],
        [
            "LOAD_ATTR",
            "traced_file.code"
        ],
        [
            "CALL_METHOD",
            "self._trace(FILE_SENTINEL_NAME, filename, traced_file, traced_file.code, 'module', source)"
        ],
        [
            "LOAD_ATTR",
            "traced_file.nodes"
        ],
        [
            "LOAD_ATTR",
            "traced_file.code"
        ],
        [
            "CALL_FUNCTION",
            "find_code(traced_file.code)"
        ],
        [
            "LOAD_ATTR",
            "traced_file.code"
        ],
        [
            "CALL_FUNCTION",
            "exec(traced_file.code, globs, locs)"
        ],
        [
            "LOAD_ATTR",
            "ast.FunctionDef"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node, ast.FunctionDef)"
        ],
        [
            "LOAD_ATTR",
            "node.lineno"
        ],
        [
            "LOAD_ATTR",
            "root_code.co_consts"
        ],
        [
            "LOAD_METHOD",
            "inspect.iscode"
        ],
        [
            "CALL_METHOD",
            "inspect.iscode(code)"
        ],
        [
            "LOAD_ATTR",
            "code.co_name"
        ],
        [
            "LOAD_METHOD",
            "code.co_name.startswith"
        ],
        [
            "CALL_METHOD",
            "code.co_name.startswith('<')"
        ],
        [
            "CALL_FUNCTION",
            "find_code(code)"
        ],
        [
            "LOAD_ATTR",
            "code.co_firstlineno"
        ],
        [
            "LOAD_METHOD",
            "nodes_by_lineno.get"
        ],
        [
            "CALL_METHOD",
            "nodes_by_lineno.get(lineno)"
        ],
        [
            "LOAD_ATTR",
            "self._trace"
        ],
        [
            "LOAD_ATTR",
            "code.co_name"
        ],
        [
            "LOAD_ATTR",
            "node.last_token"
        ],
        [
            "LOAD_ATTR",
            "node.last_token.end"
        ],
        [
            "BINARY_SUBSCR",
            "node.last_token.end[0]"
        ],
        [
            "BINARY_ADD",
            "node.last_token.end[0] + 1"
        ],
        [
            "CALL_FUNCTION_KW",
            "self._trace(\n                        code.co_name, filename, traced_file, code,\n                        typ='function',\n                        source=source,\n                        start_lineno=lineno,\n                        end_lineno=node.last_token.end[0] + 1,\n                    )"
        ],
        [
            "LOAD_METHOD",
            "source.splitlines"
        ],
        [
            "CALL_METHOD",
            "source.splitlines()"
        ],
        [
            "CALL_FUNCTION",
            "len(source.splitlines())"
        ],
        [
            "BINARY_ADD",
            "start_lineno + len(source.splitlines())"
        ],
        [
            "LOAD_METHOD",
            "self._nodes_of_interest"
        ],
        [
            "CALL_METHOD",
            "self._nodes_of_interest(traced_file, start_lineno, end_lineno)"
        ],
        [
            "CALL_FUNCTION",
            "list(self._nodes_of_interest(traced_file, start_lineno, end_lineno))"
        ],
        [
            "LOAD_METHOD",
            "self._nodes_html"
        ],
        [
            "CALL_METHOD",
            "self._nodes_html(nodes, start_lineno, end_lineno, traced_file)"
        ],
        [
            "CALL_FUNCTION_KW",
            "dict(\n            # This maps each node to the loops enclosing that node\n            node_loops={\n                node._tree_index: [n._tree_index for n in node._loops]\n                for node, _ in nodes\n                if node._loops\n            },\n        )"
        ],
        [
            "COMPARE_OP",
            "typ == 'function'"
        ],
        [
            "LOAD_ATTR",
            "traced_file.tokens"
        ],
        [
            "CALL_FUNCTION",
            "only(node\n                             for node, _ in nodes\n                             if isinstance(node, ast.FunctionDef)\n                             and node.first_token.start[0] == start_lineno)"
        ],
        [
            "CALL_FUNCTION",
            "source_without_decorators(tokens, func_node)"
        ],
        [
            "LOAD_ATTR",
            "data_dict.update"
        ],
        [
            "LOAD_METHOD",
            "self._node_ranges"
        ],
        [
            "CALL_METHOD",
            "self._node_ranges(nodes, tokens, func_startpos)"
        ],
        [
            "CALL_FUNCTION",
            "list(self._node_ranges(nodes, tokens, func_startpos))"
        ],
        [
            "LOAD_METHOD",
            "self._loop_ranges"
        ],
        [
            "CALL_METHOD",
            "self._loop_ranges(nodes, tokens, func_startpos)"
        ],
        [
            "CALL_FUNCTION",
            "list(self._loop_ranges(nodes, tokens, func_startpos))"
        ],
        [
            "CALL_FUNCTION_KW",
            "data_dict.update(\n                node_ranges=list(self._node_ranges(nodes, tokens, func_startpos)),\n                loop_ranges=list(self._loop_ranges(nodes, tokens, func_startpos)),\n            )"
        ],
        [
            "LOAD_ATTR",
            "json.dumps"
        ],
        [
            "CALL_FUNCTION_KW",
            "json.dumps(data_dict, sort_keys=True)"
        ],
        [
            "LOAD_METHOD",
            "self._db_func"
        ],
        [
            "CALL_METHOD",
            "self._db_func(data, filename, html_body, name, start_lineno, source, typ)"
        ],
        [
            "CALL_FUNCTION",
            "CodeInfo(db_func, traced_file, arg_names)"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "LOAD_ATTR",
            "node._loops"
        ],
        [
            "LOAD_ATTR",
            "node._tree_index"
        ],
        [
            "LOAD_ATTR",
            "node._loops"
        ],
        [
            "LOAD_ATTR",
            "n._tree_index"
        ],
        [
            "LOAD_ATTR",
            "ast.FunctionDef"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node, ast.FunctionDef)"
        ],
        [
            "LOAD_ATTR",
            "node.first_token"
        ],
        [
            "LOAD_ATTR",
            "node.first_token.start"
        ],
        [
            "BINARY_SUBSCR",
            "node.first_token.start[0]"
        ],
        [
            "COMPARE_OP",
            "node.first_token.start[0] == start_lineno"
        ],
        [
            "CONTAINS_OP",
            "'loop' not in classes"
        ],
        [
            "LOAD_ATTR",
            "node.target"
        ],
        [
            "LOAD_ATTR",
            "node.test"
        ],
        [
            "LOAD_METHOD",
            "tokens.get_text_range"
        ],
        [
            "CALL_METHOD",
            "tokens.get_text_range(target)"
        ],
        [
            "LOAD_ATTR",
            "node._tree_index"
        ],
        [
            "CALL_FUNCTION_KW",
            "dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end\n            )"
        ],
        [
            "LOAD_METHOD",
            "tokens.get_text_range"
        ],
        [
            "CALL_METHOD",
            "tokens.get_text_range(node)"
        ],
        [
            "COMPARE_OP",
            "start < 0"
        ],
        [
            "COMPARE_OP",
            "end < 0"
        ],
        [
            "LOAD_ATTR",
            "ast.FunctionDef"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node, ast.FunctionDef)"
        ],
        [
            "LOAD_ATTR",
            "node._tree_index"
        ],
        [
            "LOAD_ATTR",
            "node._depth"
        ],
        [
            "CALL_FUNCTION_KW",
            "dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end,\n                depth=node._depth,\n                classes=classes,\n            )"
        ],
        [
            "BINARY_ADD",
            "filename + name"
        ],
        [
            "BINARY_ADD",
            "filename + name + html_body"
        ],
        [
            "BINARY_ADD",
            "filename + name + html_body + data"
        ],
        [
            "CALL_FUNCTION",
            "str(start_lineno)"
        ],
        [
            "BINARY_ADD",
            "filename + name + html_body + data + str(start_lineno)"
        ],
        [
            "CALL_FUNCTION",
            "h(filename + name + html_body + data + str(start_lineno))"
        ],
        [
            "LOAD_ATTR",
            "self.db"
        ],
        [
            "LOAD_ATTR",
            "self.db.Function"
        ],
        [
            "LOAD_ATTR",
            "self.db"
        ],
        [
            "LOAD_METHOD",
            "self.db.session_scope"
        ],
        [
            "CALL_METHOD",
            "self.db.session_scope()"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "CALL_METHOD",
            "session.query(Function)"
        ],
        [
            "LOAD_ATTR",
            "session.query(Function).filter_by"
        ],
        [
            "CALL_FUNCTION_KW",
            "session.query(Function).filter_by(hash=function_hash)"
        ],
        [
            "CALL_FUNCTION",
            "one_or_none(session.query(Function).filter_by(hash=function_hash))"
        ],
        [
            "CALL_FUNCTION",
            "h(source)"
        ],
        [
            "CALL_FUNCTION_KW",
            "Function(file=filename,\n                                   name=name,\n                                   type=typ,\n                                   html_body=html_body,\n                                   lineno=start_lineno,\n                                   data=data,\n                                   body_hash=h(source),\n                                   hash=function_hash)"
        ],
        [
            "LOAD_METHOD",
            "session.add"
        ],
        [
            "CALL_METHOD",
            "session.add(db_func)"
        ],
        [
            "LOAD_METHOD",
            "session.commit"
        ],
        [
            "CALL_METHOD",
            "session.commit()"
        ],
        [
            "LOAD_ATTR",
            "db_func.id"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(db_func.id, int)"
        ],
        [
            "LOAD_ATTR",
            "db_func.id"
        ],
        [
            "LOAD_METHOD",
            "hashlib.sha256"
        ],
        [
            "LOAD_METHOD",
            "s.encode"
        ],
        [
            "CALL_METHOD",
            "s.encode('utf8')"
        ],
        [
            "CALL_METHOD",
            "hashlib.sha256(s.encode('utf8'))"
        ],
        [
            "LOAD_METHOD",
            "hashlib.sha256(s.encode('utf8')).hexdigest"
        ],
        [
            "CALL_METHOD",
            "hashlib.sha256(s.encode('utf8')).hexdigest()"
        ],
        [
            "LOAD_ATTR",
            "traced_file.nodes"
        ],
        [
            "LOAD_ATTR",
            "ast.While"
        ],
        [
            "LOAD_ATTR",
            "ast.For"
        ],
        [
            "LOAD_ATTR",
            "ast.comprehension"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node, (ast.While, ast.For, ast.comprehension))"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_ATTR",
            "ast.GeneratorExp"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node.parent, ast.GeneratorExp)"
        ],
        [
            "LOAD_METHOD",
            "classes.append"
        ],
        [
            "CALL_METHOD",
            "classes.append('loop')"
        ],
        [
            "LOAD_ATTR",
            "ast.stmt"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node, ast.stmt)"
        ],
        [
            "LOAD_METHOD",
            "classes.append"
        ],
        [
            "CALL_METHOD",
            "classes.append('stmt')"
        ],
        [
            "LOAD_ATTR",
            "ast.expr"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node, ast.expr)"
        ],
        [
            "LOAD_ATTR",
            "node._is_interesting_expression"
        ],
        [
            "LOAD_ATTR",
            "ast.AST"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node, ast.AST)"
        ],
        [
            "CALL_FUNCTION",
            "hasattr(node, 'first_token')"
        ],
        [
            "LOAD_ATTR",
            "node.first_token"
        ],
        [
            "LOAD_ATTR",
            "node.first_token.start"
        ],
        [
            "BINARY_SUBSCR",
            "node.first_token.start[0]"
        ],
        [
            "LOAD_ATTR",
            "traced_file.tokens"
        ],
        [
            "LOAD_METHOD",
            "traced_file.tokens.get_text_range"
        ],
        [
            "CALL_METHOD",
            "traced_file.tokens.get_text_range(node)"
        ],
        [
            "LOAD_ATTR",
            "traced_file.root"
        ],
        [
            "LOAD_METHOD",
            "ast.walk"
        ],
        [
            "LOAD_ATTR",
            "traced_file.root"
        ],
        [
            "CALL_METHOD",
            "ast.walk(traced_file.root)"
        ],
        [
            "LOAD_METHOD",
            "ast.iter_child_nodes"
        ],
        [
            "CALL_METHOD",
            "ast.iter_child_nodes(node)"
        ],
        [
            "LOAD_ATTR",
            "node._depth"
        ],
        [
            "BINARY_ADD",
            "node._depth + 1"
        ],
        [
            "LOAD_METHOD",
            "positions.extend"
        ],
        [
            "LOAD_ATTR",
            "node._depth"
        ],
        [
            "LOAD_ATTR",
            "node._depth"
        ],
        [
            "LOAD_ATTR",
            "node._tree_index"
        ],
        [
            "LOAD_METHOD",
            "' '.join"
        ],
        [
            "CALL_METHOD",
            "' '.join(classes)"
        ],
        [
            "BINARY_MODULO",
            "'<span data-index=\"%s\" class=\"%s\">' % (node._tree_index, ' '.join(classes))"
        ],
        [
            "CALL_FUNCTION",
            "map(\n                HTMLPosition,\n                [start, end],\n                [True, False],  # is_start\n                [node._depth, node._depth],\n                ['<span data-index=\"%s\" class=\"%s\">' % (node._tree_index, ' '.join(classes)),\n                 '</span>'])"
        ],
        [
            "CALL_METHOD",
            "positions.extend(map(\n                HTMLPosition,\n                [start, end],\n                [True, False],  # is_start\n                [node._depth, node._depth],\n                ['<span data-index=\"%s\" class=\"%s\">' % (node._tree_index, ' '.join(classes)),\n                 '</span>']))"
        ],
        [
            "LOAD_METHOD",
            "self._separate_comprehensions"
        ],
        [
            "CALL_METHOD",
            "self._separate_comprehensions(\n            [n[0] for n in nodes],\n            end_lineno, positions, traced_file)"
        ],
        [
            "LOAD_METHOD",
            "positions.append"
        ],
        [
            "LOAD_ATTR",
            "traced_file.source"
        ],
        [
            "CALL_FUNCTION",
            "len(traced_file.source)"
        ],
        [
            "CALL_FUNCTION",
            "HTMLPosition(len(traced_file.source), False, 0, '')"
        ],
        [
            "CALL_METHOD",
            "positions.append(HTMLPosition(len(traced_file.source), False, 0, ''))"
        ],
        [
            "LOAD_METHOD",
            "positions.sort"
        ],
        [
            "CALL_METHOD",
            "positions.sort()"
        ],
        [
            "LOAD_METHOD",
            "html_parts.append"
        ],
        [
            "LOAD_METHOD",
            "html.escape"
        ],
        [
            "LOAD_ATTR",
            "traced_file.source"
        ],
        [
            "LOAD_ATTR",
            "position.index"
        ],
        [
            "BINARY_SUBSCR",
            "traced_file.source[start:position.index]"
        ],
        [
            "CALL_METHOD",
            "html.escape(traced_file.source[start:position.index])"
        ],
        [
            "CALL_METHOD",
            "html_parts.append(html.escape(traced_file.source[start:position.index]))"
        ],
        [
            "LOAD_METHOD",
            "html_parts.append"
        ],
        [
            "LOAD_ATTR",
            "position.html"
        ],
        [
            "CALL_METHOD",
            "html_parts.append(position.html)"
        ],
        [
            "LOAD_ATTR",
            "position.index"
        ],
        [
            "LOAD_METHOD",
            "''.join"
        ],
        [
            "CALL_METHOD",
            "''.join(html_parts)"
        ],
        [
            "LOAD_METHOD",
            "'\\n'.join"
        ],
        [
            "LOAD_METHOD",
            "html_body.split"
        ],
        [
            "CALL_METHOD",
            "html_body.split('\\n')"
        ],
        [
            "BINARY_SUBTRACT",
            "start_lineno - 1"
        ],
        [
            "BINARY_SUBTRACT",
            "end_lineno - 1"
        ],
        [
            "BINARY_SUBSCR",
            "html_body.split('\\n')[start_lineno - 1:end_lineno - 1]"
        ],
        [
            "CALL_METHOD",
            "'\\n'.join(html_body.split('\\n')[start_lineno - 1:end_lineno - 1])"
        ],
        [
            "LOAD_METHOD",
            "html_body.strip"
        ],
        [
            "CALL_METHOD",
            "html_body.strip('\\n')"
        ],
        [
            "BINARY_SUBSCR",
            "n[0]"
        ],
        [
            "LOAD_ATTR",
            "ast.comprehension"
        ],
        [
            "LOAD_ATTR",
            "ast.While"
        ],
        [
            "LOAD_ATTR",
            "ast.For"
        ],
        [
            "CALL_FUNCTION",
            "of_type((ast.comprehension, ast.While, ast.For), nodes)"
        ],
        [
            "CALL_FUNCTION",
            "group_by_key_func(of_type((ast.comprehension, ast.While, ast.For), nodes),\n                                           lambda c: c.first_token.start[0]\n                                           )"
        ],
        [
            "LOAD_METHOD",
            "comprehensions.values"
        ],
        [
            "CALL_METHOD",
            "comprehensions.values()"
        ],
        [
            "CALL_FUNCTION_KW",
            "sorted(comp_list, key=lambda c: c.first_token.startpos)"
        ],
        [
            "LOAD_ATTR",
            "ast.comprehension"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(comp, ast.comprehension)"
        ],
        [
            "LOAD_ATTR",
            "comp.parent"
        ],
        [
            "LOAD_ATTR",
            "comp.parent.generators"
        ],
        [
            "BINARY_SUBSCR",
            "comp.parent.generators[0]"
        ],
        [
            "IS_OP",
            "comp is comp.parent.generators[0]"
        ],
        [
            "LOAD_ATTR",
            "comp.parent"
        ],
        [
            "CALL_FUNCTION",
            "get_start(comp.parent)"
        ],
        [
            "IS_OP",
            "prev_start is not None"
        ],
        [
            "COMPARE_OP",
            "start < prev_start"
        ],
        [
            "CALL_FUNCTION",
            "get_start(comp)"
        ],
        [
            "CALL_FUNCTION",
            "get_start(comp)"
        ],
        [
            "IS_OP",
            "prev_start is not None"
        ],
        [
            "LOAD_METHOD",
            "positions.append"
        ],
        [
            "CALL_FUNCTION",
            "HTMLPosition(start, True, 0, '\\n ')"
        ],
        [
            "CALL_METHOD",
            "positions.append(HTMLPosition(start, True, 0, '\\n '))"
        ],
        [
            "LOAD_ATTR",
            "c.first_token"
        ],
        [
            "LOAD_ATTR",
            "c.first_token.start"
        ],
        [
            "BINARY_SUBSCR",
            "c.first_token.start[0]"
        ],
        [
            "LOAD_ATTR",
            "traced_file.tokens"
        ],
        [
            "LOAD_METHOD",
            "traced_file.tokens.get_text_range"
        ],
        [
            "CALL_METHOD",
            "traced_file.tokens.get_text_range(n)"
        ],
        [
            "BINARY_SUBSCR",
            "traced_file.tokens.get_text_range(n)[0]"
        ],
        [
            "LOAD_ATTR",
            "c.first_token"
        ],
        [
            "LOAD_ATTR",
            "c.first_token.startpos"
        ],
        [
            "CALL_FUNCTION",
            "defaultdict(_deep_dict)"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code in _bad_codes"
        ],
        [
            "LOAD_ATTR",
            "frame.f_back"
        ],
        [
            "CALL_FUNCTION",
            "defaultdict(IterationList)"
        ],
        [
            "LOAD_ATTR",
            "self.index"
        ],
        [
            "LOAD_ATTR",
            "self.loops"
        ],
        [
            "LOAD_METHOD",
            "self.loops.items"
        ],
        [
            "CALL_METHOD",
            "self.loops.items()"
        ],
        [
            "LOAD_METHOD",
            "iteration.extract_iterations"
        ],
        [
            "CALL_METHOD",
            "iteration.extract_iterations()"
        ],
        [
            "LOAD_ATTR",
            "self.side_len"
        ],
        [
            "CALL_FUNCTION_KW",
            "deque(maxlen=self.side_len)"
        ],
        [
            "CALL_FUNCTION",
            "Counter()"
        ],
        [
            "LOAD_ATTR",
            "self.length"
        ],
        [
            "LOAD_ATTR",
            "self.side_len"
        ],
        [
            "COMPARE_OP",
            "self.length < self.side_len"
        ],
        [
            "LOAD_ATTR",
            "self.start"
        ],
        [
            "LOAD_METHOD",
            "self.start.append"
        ],
        [
            "CALL_METHOD",
            "self.start.append(iteration)"
        ],
        [
            "LOAD_ATTR",
            "self.end"
        ],
        [
            "CALL_FUNCTION",
            "len(self.end)"
        ],
        [
            "LOAD_ATTR",
            "self.side_len"
        ],
        [
            "COMPARE_OP",
            "len(self.end) >= self.side_len"
        ],
        [
            "LOAD_ATTR",
            "self.end"
        ],
        [
            "BINARY_SUBSCR",
            "self.end[0]"
        ],
        [
            "LOAD_ATTR",
            "self.end[0].keep"
        ],
        [
            "LOAD_ATTR",
            "self.start"
        ],
        [
            "LOAD_METHOD",
            "self.start.append"
        ],
        [
            "LOAD_ATTR",
            "self.end"
        ],
        [
            "BINARY_SUBSCR",
            "self.end[0]"
        ],
        [
            "CALL_METHOD",
            "self.start.append(self.end[0])"
        ],
        [
            "LOAD_ATTR",
            "self.end"
        ],
        [
            "LOAD_METHOD",
            "self.end.append"
        ],
        [
            "CALL_METHOD",
            "self.end.append(iteration)"
        ],
        [
            "LOAD_ATTR",
            "self.length"
        ],
        [
            "LOAD_ATTR",
            "self.start"
        ],
        [
            "LOAD_ATTR",
            "self.end"
        ],
        [
            "CALL_FUNCTION",
            "chain(self.start, self.end)"
        ],
        [
            "LOAD_ATTR",
            "self.end"
        ],
        [
            "LOAD_ATTR",
            "self.end"
        ],
        [
            "BINARY_SUBSCR",
            "self.end[-1]"
        ],
        [
            "LOAD_ATTR",
            "self.start"
        ],
        [
            "BINARY_SUBSCR",
            "self.start[-1]"
        ],
        [
            "LOAD_ATTR",
            "self.recorded"
        ],
        [
            "BINARY_SUBSCR",
            "self.recorded[node]"
        ],
        [
            "COMPARE_OP",
            "self.recorded[node] >= 2"
        ],
        [
            "LOAD_METHOD",
            "self.last"
        ],
        [
            "CALL_METHOD",
            "self.last()"
        ],
        [
            "LOAD_ATTR",
            "self.recorded"
        ],
        [
            "CALL_FUNCTION",
            "type(None)"
        ],
        [
            "BINARY_ADD",
            "basic_types + (list, dict, tuple, set, frozenset, str)"
        ],
        [
            "CALL_FUNCTION",
            "len(special_types)"
        ],
        [
            "CALL_FUNCTION",
            "Lock()"
        ],
        [
            "CALL_FUNCTION",
            "defaultdict(lambda: len(self.data))"
        ],
        [
            "LOAD_ATTR",
            "self.special_types"
        ],
        [
            "LOAD_ATTR",
            "self.data"
        ],
        [
            "BINARY_SUBSCR",
            "self.data[t]"
        ],
        [
            "LOAD_ATTR",
            "self.data"
        ],
        [
            "CALL_FUNCTION",
            "len(self.data)"
        ],
        [
            "CALL_FUNCTION",
            "correct_type(item)"
        ],
        [
            "LOAD_ATTR",
            "self.lock"
        ],
        [
            "LOAD_ATTR",
            "self.data"
        ],
        [
            "BINARY_SUBSCR",
            "self.data[t]"
        ],
        [
            "LOAD_ATTR",
            "self.data"
        ],
        [
            "LOAD_METHOD",
            "self.data.items"
        ],
        [
            "CALL_METHOD",
            "self.data.items()"
        ],
        [
            "CALL_FUNCTION",
            "dict((v, k) for k, v in self.data.items())"
        ],
        [
            "CALL_FUNCTION",
            "len(rev)"
        ],
        [
            "CALL_FUNCTION",
            "range(len(rev))"
        ],
        [
            "BINARY_SUBSCR",
            "rev[i]"
        ],
        [
            "CALL_FUNCTION",
            "safe_qualname(rev[i])"
        ],
        [
            "LOAD_ATTR",
            "self.meta"
        ],
        [
            "LOAD_ATTR",
            "self.meta"
        ],
        [
            "LOAD_ATTR",
            "self.children"
        ],
        [
            "LOAD_ATTR",
            "self.children"
        ],
        [
            "LOAD_METHOD",
            "self.children.append"
        ],
        [
            "LOAD_METHOD",
            "NodeValue.expression"
        ],
        [
            "CALL_METHOD",
            "NodeValue.expression(samples, value, level)"
        ],
        [
            "CALL_METHOD",
            "self.children.append((key, NodeValue.expression(samples, value, level)))"
        ],
        [
            "LOAD_ATTR",
            "self.val_repr"
        ],
        [
            "LOAD_ATTR",
            "self.type_index"
        ],
        [
            "LOAD_ATTR",
            "self.meta"
        ],
        [
            "LOAD_ATTR",
            "self.children"
        ],
        [
            "LOAD_METHOD",
            "result.extend"
        ],
        [
            "LOAD_ATTR",
            "self.children"
        ],
        [
            "CALL_METHOD",
            "result.extend(self.children)"
        ],
        [
            "CALL_FUNCTION",
            "cls('', -2)"
        ],
        [
            "CALL_FUNCTION",
            "exception_string(exc_value)"
        ],
        [
            "CALL_FUNCTION",
            "cls(exception_string(exc_value), -1)"
        ],
        [
            "CALL_FUNCTION",
            "cheap_repr(val)"
        ],
        [
            "BINARY_SUBSCR",
            "type_registry[val]"
        ],
        [
            "CALL_FUNCTION",
            "cls(cheap_repr(val), type_registry[val])"
        ],
        [
            "LOAD_ATTR",
            "TypeRegistry.basic_types"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(val, (TypeRegistry.basic_types, BirdsEye))"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(val, QuerySet)"
        ],
        [
            "CALL_FUNCTION",
            "len(val)"
        ],
        [
            "LOAD_METHOD",
            "result.set_meta"
        ],
        [
            "CALL_METHOD",
            "result.set_meta('len', length)"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(val, ModuleType)"
        ],
        [
            "CALL_FUNCTION",
            "min(level, 2)"
        ],
        [
            "LOAD_ATTR",
            "result.add_child"
        ],
        [
            "BINARY_SUBTRACT",
            "level - 1"
        ],
        [
            "CALL_FUNCTION",
            "partial(result.add_child, samples, level - 1)"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(val, (Series, ndarray))"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(val, ndarray)"
        ],
        [
            "LOAD_METHOD",
            "attrs.append"
        ],
        [
            "CALL_METHOD",
            "attrs.append('shape')"
        ],
        [
            "CALL_FUNCTION",
            "getattr(val, name)"
        ],
        [
            "CALL_FUNCTION",
            "add_child(name, attr)"
        ],
        [
            "COMPARE_OP",
            "level >= 3"
        ],
        [
            "COMPARE_OP",
            "level >= 2"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(val, Series)"
        ],
        [
            "BINARY_SUBSCR",
            "samples[sample_type]"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(val, DataFrame)"
        ],
        [
            "LOAD_METHOD",
            "result.set_meta"
        ],
        [
            "CALL_METHOD",
            "result.set_meta('dataframe', meta)"
        ],
        [
            "BINARY_SUBSCR",
            "samples['pandas_rows']"
        ],
        [
            "BINARY_SUBSCR",
            "samples['pandas_cols']"
        ],
        [
            "BINARY_ADD",
            "max_rows + 2"
        ],
        [
            "COMPARE_OP",
            "length > max_rows + 2"
        ],
        [
            "BINARY_FLOOR_DIVIDE",
            "max_rows // 2"
        ],
        [
            "LOAD_ATTR",
            "val.columns"
        ],
        [
            "CALL_FUNCTION",
            "len(columns)"
        ],
        [
            "BINARY_ADD",
            "max_cols + 2"
        ],
        [
            "COMPARE_OP",
            "num_cols > max_cols + 2"
        ],
        [
            "BINARY_FLOOR_DIVIDE",
            "max_cols // 2"
        ],
        [
            "CALL_FUNCTION",
            "_sample_indices(num_cols, max_cols)"
        ],
        [
            "CALL_FUNCTION",
            "set(_sample_indices(num_cols, max_cols))"
        ],
        [
            "LOAD_ATTR",
            "val.columns"
        ],
        [
            "LOAD_ATTR",
            "val.columns.format"
        ],
        [
            "CALL_FUNCTION_KW",
            "val.columns.format(sparsify=False)"
        ],
        [
            "LOAD_ATTR",
            "val.columns"
        ],
        [
            "CALL_FUNCTION",
            "zip(val.columns.format(sparsify=False),\n                                                            val.columns)"
        ],
        [
            "CALL_FUNCTION",
            "enumerate(zip(val.columns.format(sparsify=False),\n                                                            val.columns))"
        ],
        [
            "CONTAINS_OP",
            "i in indices"
        ],
        [
            "BINARY_SUBSCR",
            "val[label]"
        ],
        [
            "CALL_FUNCTION",
            "add_child(formatted_name, val[label])"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(val, Series)"
        ],
        [
            "BINARY_SUBSCR",
            "samples['pandas_rows']"
        ],
        [
            "CALL_FUNCTION",
            "_sample_indices(length, samples['pandas_rows'])"
        ],
        [
            "LOAD_ATTR",
            "val.index"
        ],
        [
            "BINARY_ADD",
            "i + 1"
        ],
        [
            "BINARY_SUBSCR",
            "val.index[i:i + 1]"
        ],
        [
            "LOAD_ATTR",
            "val.index[i:i + 1].format"
        ],
        [
            "CALL_FUNCTION_KW",
            "val.index[i:i + 1].format(sparsify=False)"
        ],
        [
            "BINARY_SUBSCR",
            "val.index[i:i + 1].format(sparsify=False)[0]"
        ],
        [
            "LOAD_ATTR",
            "val.iloc"
        ],
        [
            "BINARY_SUBSCR",
            "val.iloc[i]"
        ],
        [
            "CALL_FUNCTION",
            "add_child(k, v)"
        ],
        [
            "COMPARE_OP",
            "level <= 0"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(val,\n                           (str, bytes, range)\n                           if PY3 else\n                           (str, unicode, xrange))"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(val, (Sequence, ndarray))"
        ],
        [
            "IS_OP",
            "length is not None"
        ],
        [
            "BINARY_SUBSCR",
            "samples['list']"
        ],
        [
            "CALL_FUNCTION",
            "_sample_indices(length, samples['list'])"
        ],
        [
            "BINARY_SUBSCR",
            "val[i]"
        ],
        [
            "CALL_FUNCTION",
            "str(i)"
        ],
        [
            "CALL_FUNCTION",
            "add_child(str(i), v)"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(val, Mapping)"
        ],
        [
            "CALL_FUNCTION",
            "_safe_iter(val, iteritems)"
        ],
        [
            "BINARY_SUBSCR",
            "samples['dict']"
        ],
        [
            "CALL_FUNCTION",
            "islice(_safe_iter(val, iteritems), samples['dict'])"
        ],
        [
            "CALL_FUNCTION",
            "cheap_repr(k)"
        ],
        [
            "CALL_FUNCTION",
            "add_child(cheap_repr(k), v)"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(val, Set)"
        ],
        [
            "CALL_FUNCTION",
            "_safe_iter(val)"
        ],
        [
            "BINARY_SUBSCR",
            "samples['set']"
        ],
        [
            "IS_OP",
            "length is None"
        ],
        [
            "BINARY_ADD",
            "num_items + 2"
        ],
        [
            "COMPARE_OP",
            "length > num_items + 2"
        ],
        [
            "CALL_FUNCTION",
            "islice(vals, num_items)"
        ],
        [
            "CALL_FUNCTION",
            "enumerate(vals)"
        ],
        [
            "BINARY_MODULO",
            "'<%s>' % i"
        ],
        [
            "CALL_FUNCTION",
            "add_child('<%s>' % i, v)"
        ],
        [
            "CALL_FUNCTION",
            "getattr(val, '__dict__', None)"
        ],
        [
            "CALL_FUNCTION",
            "_safe_iter(d)"
        ],
        [
            "BINARY_SUBSCR",
            "samples['attributes']"
        ],
        [
            "CALL_FUNCTION",
            "islice(_safe_iter(d),\n                                   samples['attributes'])"
        ],
        [
            "CALL_FUNCTION_KW",
            "sorted(islice(_safe_iter(d),\n                                   samples['attributes']),\n                            key=str)"
        ],
        [
            "BINARY_SUBSCR",
            "d[k]"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(v, TracedFile)"
        ],
        [
            "CALL_FUNCTION",
            "str(k)"
        ],
        [
            "CALL_FUNCTION",
            "add_child(str(k), v)"
        ],
        [
            "CALL_FUNCTION",
            "type(val)"
        ],
        [
            "CALL_FUNCTION",
            "getattr(type(val), '__slots__', None)"
        ],
        [
            "CALL_FUNCTION",
            "sorted(getattr(type(val), '__slots__', None) or ())"
        ],
        [
            "CALL_FUNCTION",
            "getattr(val, s)"
        ],
        [
            "CALL_FUNCTION",
            "str(s)"
        ],
        [
            "CALL_FUNCTION",
            "add_child(str(s), attr)"
        ],
        [
            "CALL_FUNCTION",
            "f(val)"
        ],
        [
            "BINARY_ADD",
            "max_length + 2"
        ],
        [
            "COMPARE_OP",
            "length <= max_length + 2"
        ],
        [
            "CALL_FUNCTION",
            "range(length)"
        ],
        [
            "BINARY_FLOOR_DIVIDE",
            "max_length // 2"
        ],
        [
            "CALL_FUNCTION",
            "range(max_length // 2)"
        ],
        [
            "BINARY_FLOOR_DIVIDE",
            "max_length // 2"
        ],
        [
            "BINARY_SUBTRACT",
            "length - max_length // 2"
        ],
        [
            "CALL_FUNCTION",
            "range(length - max_length // 2,\n                           length)"
        ],
        [
            "CALL_FUNCTION",
            "chain(range(max_length // 2),\n                     range(length - max_length // 2,\n                           length))"
        ],
        [
            "CALL_FUNCTION",
            "len(x)"
        ],
        [
            "COMPARE_OP",
            "n == 0"
        ],
        [
            "CALL_FUNCTION",
            "repr(x)"
        ],
        [
            "LOAD_ATTR",
            "helper.level"
        ],
        [
            "BINARY_SUBTRACT",
            "helper.level - 1"
        ],
        [
            "LOAD_ATTR",
            "_repr_series_one_line.maxparts"
        ],
        [
            "CALL_FUNCTION",
            "_sample_indices(n, maxparts)"
        ],
        [
            "LOAD_ATTR",
            "x.index"
        ],
        [
            "BINARY_ADD",
            "i + 1"
        ],
        [
            "BINARY_SUBSCR",
            "x.index[i:i + 1]"
        ],
        [
            "LOAD_ATTR",
            "x.index[i:i + 1].format"
        ],
        [
            "CALL_FUNCTION_KW",
            "x.index[i:i + 1].format(sparsify=False)"
        ],
        [
            "BINARY_SUBSCR",
            "x.index[i:i + 1].format(sparsify=False)[0]"
        ],
        [
            "LOAD_ATTR",
            "x.iloc"
        ],
        [
            "BINARY_SUBSCR",
            "x.iloc[i]"
        ],
        [
            "LOAD_METHOD",
            "pieces.append"
        ],
        [
            "CALL_FUNCTION",
            "cheap_repr(v, newlevel)"
        ],
        [
            "BINARY_MODULO",
            "'%s = %s' % (k, cheap_repr(v, newlevel))"
        ],
        [
            "CALL_METHOD",
            "pieces.append('%s = %s' % (k, cheap_repr(v, newlevel)))"
        ],
        [
            "BINARY_ADD",
            "maxparts + 2"
        ],
        [
            "COMPARE_OP",
            "n > maxparts + 2"
        ],
        [
            "LOAD_METHOD",
            "pieces.insert"
        ],
        [
            "BINARY_FLOOR_DIVIDE",
            "maxparts // 2"
        ],
        [
            "CALL_METHOD",
            "pieces.insert(maxparts // 2, '...')"
        ],
        [
            "LOAD_METHOD",
            "'; '.join"
        ],
        [
            "CALL_METHOD",
            "'; '.join(pieces)"
        ],
        [
            "LOAD_ATTR",
            "ast.expr"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node, ast.expr)"
        ],
        [
            "LOAD_ATTR",
            "ast.Num"
        ],
        [
            "LOAD_ATTR",
            "ast.Str"
        ],
        [
            "CALL_FUNCTION",
            "getattr(ast, 'NameConstant', ())"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node, (ast.Num, ast.Str, getattr(ast, 'NameConstant', ())))"
        ],
        [
            "CALL_FUNCTION",
            "getattr(node, 'ctx', None)"
        ],
        [
            "LOAD_ATTR",
            "ast.Store"
        ],
        [
            "LOAD_ATTR",
            "ast.Del"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(getattr(node, 'ctx', None),\n                            (ast.Store, ast.Del))"
        ],
        [
            "LOAD_ATTR",
            "ast.UnaryOp"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node, ast.UnaryOp)"
        ],
        [
            "LOAD_ATTR",
            "node.op"
        ],
        [
            "LOAD_ATTR",
            "ast.UAdd"
        ],
        [
            "LOAD_ATTR",
            "ast.USub"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node.op, (ast.UAdd, ast.USub))"
        ],
        [
            "LOAD_ATTR",
            "node.operand"
        ],
        [
            "LOAD_ATTR",
            "ast.Num"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node.operand, ast.Num)"
        ],
        [
            "LOAD_ATTR",
            "ast.List"
        ],
        [
            "LOAD_ATTR",
            "ast.Tuple"
        ],
        [
            "LOAD_ATTR",
            "ast.Dict"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node, (ast.List, ast.Tuple, ast.Dict))"
        ],
        [
            "LOAD_METHOD",
            "ast.iter_child_nodes"
        ],
        [
            "CALL_METHOD",
            "ast.iter_child_nodes(node)"
        ],
        [
            "CALL_FUNCTION",
            "any(is_interesting_expression(n) for n in ast.iter_child_nodes(node))"
        ],
        [
            "UNARY_NOT",
            "not any(is_interesting_expression(n) for n in ast.iter_child_nodes(node))"
        ],
        [
            "UNARY_NOT",
            "not (isinstance(node, (ast.Num, ast.Str, getattr(ast, 'NameConstant', ()))) or\n                 isinstance(getattr(node, 'ctx', None),\n                            (ast.Store, ast.Del)) or\n                 (isinstance(node, ast.UnaryOp) and\n                  isinstance(node.op, (ast.UAdd, ast.USub)) and\n                  isinstance(node.operand, ast.Num)) or\n                 (isinstance(node, (ast.List, ast.Tuple, ast.Dict)) and\n                  not any(is_interesting_expression(n) for n in ast.iter_child_nodes(node))))"
        ],
        [
            "CALL_FUNCTION",
            "is_interesting_expression(n)"
        ],
        [
            "CALL_FUNCTION",
            "cast(dict, __builtins__)"
        ],
        [
            "LOAD_ATTR",
            "ast.Name"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node, ast.Name)"
        ],
        [
            "LOAD_ATTR",
            "node.id"
        ],
        [
            "CONTAINS_OP",
            "node.id in builtins"
        ],
        [
            "LOAD_ATTR",
            "node.id"
        ],
        [
            "BINARY_SUBSCR",
            "builtins[node.id]"
        ],
        [
            "IS_OP",
            "builtins[node.id] is value"
        ],
        [
            "CALL_FUNCTION",
            "getattr(ast, 'NameConstant', ())"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node, getattr(ast, 'NameConstant', ()))"
        ]
    ],
    "configuration.py": [
        [
            "LOAD_ATTR",
            "ctypes.windll"
        ],
        [
            "LOAD_ATTR",
            "ctypes.windll.kernel32"
        ],
        [
            "LOAD_METHOD",
            "kernel32.SetConsoleMode"
        ],
        [
            "LOAD_METHOD",
            "kernel32.GetStdHandle"
        ],
        [
            "CALL_METHOD",
            "kernel32.GetStdHandle(-11)"
        ],
        [
            "CALL_METHOD",
            "kernel32.SetConsoleMode(kernel32.GetStdHandle(-11), 7)"
        ],
        [
            "LOAD_ATTR",
            "os.name"
        ],
        [
            "COMPARE_OP",
            "os.name != 'nt'"
        ],
        [
            "LOAD_ATTR",
            "package.snoop"
        ],
        [
            "CALL_FUNCTION",
            "setattr(builtins_module, snoop, package.snoop)"
        ],
        [
            "LOAD_ATTR",
            "package.pp"
        ],
        [
            "CALL_FUNCTION",
            "setattr(builtins_module, pp, package.pp)"
        ],
        [
            "LOAD_ATTR",
            "package.spy"
        ],
        [
            "CALL_FUNCTION",
            "setattr(builtins_module, spy, package.spy)"
        ],
        [
            "CALL_FUNCTION_KW",
            "Config(\n        out=out,\n        prefix=prefix,\n        columns=columns,\n        overwrite=overwrite,\n        color=color,\n        enabled=enabled,\n        watch_extras=watch_extras,\n        replace_watch_extras=replace_watch_extras,\n        formatter_class=formatter_class,\n    )"
        ],
        [
            "LOAD_ATTR",
            "package.snoop"
        ],
        [
            "LOAD_ATTR",
            "package.pp"
        ],
        [
            "LOAD_ATTR",
            "package.spy"
        ],
        [
            "IS_OP",
            "color is None"
        ],
        [
            "LOAD_ATTR",
            "sys.stderr"
        ],
        [
            "CALL_FUNCTION",
            "getattr(out or sys.stderr, 'isatty', lambda: False)"
        ],
        [
            "CALL_FUNCTION",
            "isatty()"
        ],
        [
            "CALL_FUNCTION",
            "bool(isatty())"
        ],
        [
            "CALL_FUNCTION",
            "get_write_function(out, overwrite)"
        ],
        [
            "CALL_FUNCTION",
            "formatter_class(prefix, columns, color)"
        ],
        [
            "CALL_FUNCTION",
            "PP(self)"
        ],
        [
            "CALL_FUNCTION",
            "Spy(self)"
        ],
        [
            "LOAD_METHOD",
            "threading.local"
        ],
        [
            "CALL_METHOD",
            "threading.local()"
        ],
        [
            "IS_OP",
            "replace_watch_extras is not None"
        ],
        [
            "CALL_FUNCTION",
            "ensure_tuple(replace_watch_extras)"
        ],
        [
            "CALL_FUNCTION",
            "ensure_tuple(watch_extras)"
        ],
        [
            "BINARY_ADD",
            "(len_shape_watch, dtype_watch) + ensure_tuple(watch_extras)"
        ],
        [
            "LOAD_ATTR",
            "value.shape"
        ],
        [
            "LOAD_METHOD",
            "inspect.ismethod"
        ],
        [
            "CALL_METHOD",
            "inspect.ismethod(shape)"
        ],
        [
            "LOAD_METHOD",
            "'{}.shape'.format"
        ],
        [
            "CALL_METHOD",
            "'{}.shape'.format(source)"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(value, QuerySet)"
        ],
        [
            "CALL_FUNCTION",
            "len(value)"
        ],
        [
            "LOAD_ATTR",
            "six.string_types"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(value, six.string_types)"
        ],
        [
            "COMPARE_OP",
            "length < 50"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(value, (Mapping, Set, Sequence))"
        ],
        [
            "COMPARE_OP",
            "length == 0"
        ],
        [
            "LOAD_METHOD",
            "'len({})'.format"
        ],
        [
            "CALL_METHOD",
            "'len({})'.format(source)"
        ],
        [
            "LOAD_ATTR",
            "value.dtype"
        ],
        [
            "LOAD_METHOD",
            "inspect.ismethod"
        ],
        [
            "CALL_METHOD",
            "inspect.ismethod(dtype)"
        ],
        [
            "LOAD_METHOD",
            "'{}.dtype'.format"
        ],
        [
            "CALL_METHOD",
            "'{}.dtype'.format(source)"
        ],
        [
            "LOAD_ATTR",
            "six.string_types"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(output, six.string_types)"
        ],
        [
            "CALL_FUNCTION",
            "is_pathlike(output)"
        ],
        [
            "CALL_FUNCTION",
            "FileWriter(output, overwrite)"
        ],
        [
            "LOAD_ATTR",
            "FileWriter(output, overwrite).write"
        ],
        [
            "CALL_FUNCTION",
            "callable(output)"
        ],
        [
            "IS_OP",
            "stream is None"
        ],
        [
            "LOAD_ATTR",
            "sys.stderr"
        ],
        [
            "LOAD_METHOD",
            "stream.write"
        ],
        [
            "CALL_METHOD",
            "stream.write(s)"
        ],
        [
            "LOAD_METHOD",
            "stream.write"
        ],
        [
            "CALL_FUNCTION",
            "shitcode(s)"
        ],
        [
            "CALL_METHOD",
            "stream.write(shitcode(s))"
        ],
        [
            "LOAD_METHOD",
            "six.text_type"
        ],
        [
            "CALL_METHOD",
            "six.text_type(path)"
        ],
        [
            "LOAD_ATTR",
            "self.path"
        ],
        [
            "LOAD_ATTR",
            "self.overwrite"
        ],
        [
            "CALL_FUNCTION_KW",
            "open(self.path, 'w' if self.overwrite else 'a', encoding='utf-8')"
        ],
        [
            "LOAD_METHOD",
            "f.write"
        ],
        [
            "CALL_METHOD",
            "f.write(s)"
        ]
    ],
    "db.py": [
        [
            "LOAD_METHOD",
            "standard_library.install_aliases"
        ],
        [
            "CALL_METHOD",
            "standard_library.install_aliases()"
        ],
        [
            "LOAD_METHOD",
            "RESERVED_WORDS.add"
        ],
        [
            "CALL_METHOD",
            "RESERVED_WORDS.add('function')"
        ],
        [
            "CALL_FUNCTION",
            "retry(3, (InterfaceError, OperationalError, InternalError, ProgrammingError))"
        ],
        [
            "LOAD_ATTR",
            "os.environ"
        ],
        [
            "LOAD_METHOD",
            "os.environ.get"
        ],
        [
            "CALL_METHOD",
            "os.environ.get('BIRDSEYE_DB')"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.join"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.expanduser"
        ],
        [
            "CALL_METHOD",
            "os.path.expanduser('~')"
        ],
        [
            "CALL_METHOD",
            "os.path.join(os.path.expanduser('~'),\n                                '.birdseye.db')"
        ],
        [
            "CALL_FUNCTION_KW",
            "dict(\n            pool_recycle=280,\n            echo=False,  # for convenience when debugging\n        )"
        ],
        [
            "CALL_FUNCTION_EX",
            "create_engine(db_uri, **kwargs)"
        ],
        [
            "BINARY_ADD",
            "'sqlite:///' + db_uri"
        ],
        [
            "CALL_FUNCTION_EX",
            "create_engine(db_uri, **kwargs)"
        ],
        [
            "CALL_FUNCTION_KW",
            "sessionmaker(bind=engine)"
        ],
        [
            "CALL_FUNCTION_KW",
            "declarative_base(cls=Base)"
        ],
        [
            "LOAD_ATTR",
            "engine.name"
        ],
        [
            "COMPARE_OP",
            "engine.name == 'mysql'"
        ],
        [
            "CALL_FUNCTION",
            "KeyValueStore()"
        ],
        [
            "LOAD_METHOD",
            "self.table_exists"
        ],
        [
            "CALL_METHOD",
            "self.table_exists(Function)"
        ],
        [
            "LOAD_ATTR",
            "Base.metadata"
        ],
        [
            "LOAD_METHOD",
            "Base.metadata.create_all"
        ],
        [
            "CALL_METHOD",
            "Base.metadata.create_all(engine)"
        ],
        [
            "LOAD_METHOD",
            "self.table_exists"
        ],
        [
            "CALL_METHOD",
            "self.table_exists(KeyValue)"
        ],
        [
            "LOAD_ATTR",
            "kv.version"
        ],
        [
            "CALL_FUNCTION",
            "int(kv.version)"
        ],
        [
            "COMPARE_OP",
            "int(kv.version) < DB_VERSION"
        ],
        [
            "LOAD_METHOD",
            "sys.exit"
        ],
        [
            "CALL_METHOD",
            "sys.exit('The birdseye database schema is out of date. '\n                     'Run \"python -m birdseye.clear_db\" to delete the existing tables.')"
        ],
        [
            "LOAD_ATTR",
            "cls.__name__"
        ],
        [
            "LOAD_METHOD",
            "cls.__name__.lower"
        ],
        [
            "CALL_METHOD",
            "cls.__name__.lower()"
        ],
        [
            "CALL_FUNCTION",
            "String(50)"
        ],
        [
            "CALL_FUNCTION_KW",
            "Column(String(50), primary_key=True)"
        ],
        [
            "CALL_FUNCTION",
            "Column(Text)"
        ],
        [
            "LOAD_METHOD",
            "db_self.session_scope"
        ],
        [
            "CALL_METHOD",
            "db_self.session_scope()"
        ],
        [
            "LOAD_METHOD",
            "session\n                            .query"
        ],
        [
            "LOAD_ATTR",
            "KeyValue.value"
        ],
        [
            "CALL_METHOD",
            "session\n                            .query(KeyValue.value)"
        ],
        [
            "LOAD_ATTR",
            "session\n                            .query(KeyValue.value)\n                            .filter_by"
        ],
        [
            "CALL_FUNCTION_KW",
            "session\n                            .query(KeyValue.value)\n                            .filter_by(key=item)"
        ],
        [
            "LOAD_METHOD",
            "session\n                            .query(KeyValue.value)\n                            .filter_by(key=item)\n                            .scalar"
        ],
        [
            "CALL_METHOD",
            "session\n                            .query(KeyValue.value)\n                            .filter_by(key=item)\n                            .scalar()"
        ],
        [
            "LOAD_METHOD",
            "db_self.session_scope"
        ],
        [
            "CALL_METHOD",
            "db_self.session_scope()"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "CALL_METHOD",
            "session.query(KeyValue)"
        ],
        [
            "LOAD_ATTR",
            "session.query(KeyValue).filter_by"
        ],
        [
            "CALL_FUNCTION_KW",
            "session.query(KeyValue).filter_by(key=key)"
        ],
        [
            "LOAD_METHOD",
            "session.query(KeyValue).filter_by(key=key).delete"
        ],
        [
            "CALL_METHOD",
            "session.query(KeyValue).filter_by(key=key).delete()"
        ],
        [
            "LOAD_METHOD",
            "session.add"
        ],
        [
            "CALL_FUNCTION",
            "str(value)"
        ],
        [
            "CALL_FUNCTION_KW",
            "KeyValue(key=key, value=str(value))"
        ],
        [
            "CALL_METHOD",
            "session.add(KeyValue(key=key, value=str(value)))"
        ],
        [
            "CALL_FUNCTION_KW",
            "String(length=32)"
        ],
        [
            "CALL_FUNCTION_KW",
            "Column(String(length=32), primary_key=True)"
        ],
        [
            "CALL_FUNCTION",
            "ForeignKey('function.id')"
        ],
        [
            "CALL_FUNCTION_KW",
            "Column(Integer, ForeignKey('function.id'), index=True)"
        ],
        [
            "CALL_FUNCTION_KW",
            "backref('calls', lazy='dynamic')"
        ],
        [
            "CALL_FUNCTION_KW",
            "relationship('Function', backref=backref('calls', lazy='dynamic'))"
        ],
        [
            "CALL_FUNCTION",
            "Column(Text)"
        ],
        [
            "CALL_FUNCTION",
            "Column(Text)"
        ],
        [
            "CALL_FUNCTION",
            "Column(Text)"
        ],
        [
            "CALL_FUNCTION",
            "Column(Text)"
        ],
        [
            "CALL_FUNCTION",
            "Column(LongText)"
        ],
        [
            "CALL_FUNCTION_KW",
            "Column(DateTime, index=True)"
        ],
        [
            "LOAD_METHOD",
            "self._pretty_time"
        ],
        [
            "LOAD_ATTR",
            "self.start_time"
        ],
        [
            "CALL_METHOD",
            "self._pretty_time(self.start_time)"
        ],
        [
            "LOAD_METHOD",
            "dt.strftime"
        ],
        [
            "CALL_METHOD",
            "dt.strftime('%Y-%m-%d&nbsp;%H:%M:%S')"
        ],
        [
            "CALL_FUNCTION",
            "naturaltime(dt)"
        ],
        [
            "BINARY_MODULO",
            "'%s (%s)' % (\n                    dt.strftime('%Y-%m-%d&nbsp;%H:%M:%S'),\n                    naturaltime(dt))"
        ],
        [
            "CALL_FUNCTION",
            "Markup('%s (%s)' % (\n                    dt.strftime('%Y-%m-%d&nbsp;%H:%M:%S'),\n                    naturaltime(dt)))"
        ],
        [
            "LOAD_ATTR",
            "self.success"
        ],
        [
            "BINARY_MODULO",
            "'<span class=\"glyphicon glyphicon-%s\" '\n                              'style=\"color: %s\"></span>' % (\n                                  ('ok', 'green') if self.success else\n                                  ('remove', 'red'))"
        ],
        [
            "CALL_FUNCTION",
            "Markup('<span class=\"glyphicon glyphicon-%s\" '\n                              'style=\"color: %s\"></span>' % (\n                                  ('ok', 'green') if self.success else\n                                  ('remove', 'red')))"
        ],
        [
            "LOAD_ATTR",
            "self.exception"
        ],
        [
            "LOAD_ATTR",
            "self.traceback"
        ],
        [
            "LOAD_ATTR",
            "self.return_value"
        ],
        [
            "COMPARE_OP",
            "self.return_value == 'None'"
        ],
        [
            "LOAD_ATTR",
            "self.traceback"
        ],
        [
            "LOAD_ATTR",
            "self.success"
        ],
        [
            "LOAD_ATTR",
            "self.return_value"
        ],
        [
            "CALL_FUNCTION",
            "str(self.return_value)"
        ],
        [
            "LOAD_ATTR",
            "self.exception"
        ],
        [
            "CALL_FUNCTION",
            "str(self.exception)"
        ],
        [
            "LOAD_METHOD",
            "json.loads"
        ],
        [
            "LOAD_ATTR",
            "self.arguments"
        ],
        [
            "CALL_METHOD",
            "json.loads(self.arguments)"
        ],
        [
            "LOAD_METHOD",
            "json.loads"
        ],
        [
            "LOAD_ATTR",
            "self.data"
        ],
        [
            "CALL_METHOD",
            "json.loads(self.data)"
        ],
        [
            "LOAD_ATTR",
            "call.arguments_list"
        ],
        [
            "CALL_FUNCTION",
            "select_attrs(call, 'id function_id return_value traceback '\n                                                 'exception start_time')"
        ],
        [
            "CALL_FUNCTION_EX",
            "dict(arguments=call.arguments_list,\n                            **select_attrs(call, 'id function_id return_value traceback '\n                                                 'exception start_time'))"
        ],
        [
            "CALL_FUNCTION",
            "Sequence('function_id_seq')"
        ],
        [
            "CALL_FUNCTION_KW",
            "Column(Integer, Sequence('function_id_seq'), primary_key=True)"
        ],
        [
            "CALL_FUNCTION",
            "Column(Text)"
        ],
        [
            "CALL_FUNCTION",
            "Column(Text)"
        ],
        [
            "CALL_FUNCTION",
            "Column(Text)"
        ],
        [
            "CALL_FUNCTION",
            "Column(LongText)"
        ],
        [
            "CALL_FUNCTION",
            "Column(Integer)"
        ],
        [
            "CALL_FUNCTION",
            "Column(LongText)"
        ],
        [
            "CALL_FUNCTION_KW",
            "String(length=64)"
        ],
        [
            "CALL_FUNCTION_KW",
            "Column(String(length=64), index=True)"
        ],
        [
            "CALL_FUNCTION_KW",
            "String(length=64)"
        ],
        [
            "CALL_FUNCTION_KW",
            "Column(String(length=64), index=True)"
        ],
        [
            "CALL_FUNCTION_KW",
            "UniqueConstraint('hash',\n                                 name='everything_unique')"
        ],
        [
            "CALL_FUNCTION_KW",
            "Index('idx_file', 'file', mysql_length=256)"
        ],
        [
            "CALL_FUNCTION_KW",
            "Index('idx_name', 'name', mysql_length=32)"
        ],
        [
            "LOAD_METHOD",
            "json.loads"
        ],
        [
            "LOAD_ATTR",
            "self.data"
        ],
        [
            "CALL_METHOD",
            "json.loads(self.data)"
        ],
        [
            "CALL_FUNCTION",
            "select_attrs(func, 'file name lineno hash body_hash type')"
        ],
        [
            "LOAD_ATTR",
            "self.engine"
        ],
        [
            "LOAD_ATTR",
            "self.engine.dialect"
        ],
        [
            "LOAD_METHOD",
            "self.engine.dialect.has_table"
        ],
        [
            "LOAD_ATTR",
            "self.engine"
        ],
        [
            "LOAD_ATTR",
            "table.__name__"
        ],
        [
            "CALL_METHOD",
            "self.engine.dialect.has_table(self.engine, table.__name__)"
        ],
        [
            "LOAD_METHOD",
            "self.session_scope"
        ],
        [
            "CALL_METHOD",
            "self.session_scope()"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "LOAD_ATTR",
            "self.Function"
        ],
        [
            "LOAD_ATTR",
            "self.Function.file"
        ],
        [
            "CALL_METHOD",
            "session.query(self.Function.file)"
        ],
        [
            "LOAD_METHOD",
            "session.query(self.Function.file).distinct"
        ],
        [
            "CALL_METHOD",
            "session.query(self.Function.file).distinct()"
        ],
        [
            "LOAD_METHOD",
            "paths.sort"
        ],
        [
            "CALL_METHOD",
            "paths.sort()"
        ],
        [
            "CONTAINS_OP",
            "IPYTHON_FILE_PATH in paths"
        ],
        [
            "LOAD_METHOD",
            "paths.remove"
        ],
        [
            "CALL_METHOD",
            "paths.remove(IPYTHON_FILE_PATH)"
        ],
        [
            "LOAD_METHOD",
            "paths.insert"
        ],
        [
            "CALL_METHOD",
            "paths.insert(0, IPYTHON_FILE_PATH)"
        ],
        [
            "BINARY_SUBSCR",
            "f[0]"
        ],
        [
            "CALL_FUNCTION",
            "is_ipython_cell(f[0])"
        ],
        [
            "BINARY_SUBSCR",
            "f[0]"
        ],
        [
            "LOAD_ATTR",
            "self.Call"
        ],
        [
            "LOAD_ATTR",
            "self.Function"
        ],
        [
            "LOAD_ATTR",
            "self._KeyValue"
        ],
        [
            "LOAD_METHOD",
            "self.table_exists"
        ],
        [
            "CALL_METHOD",
            "self.table_exists(model)"
        ],
        [
            "LOAD_ATTR",
            "model.__table__"
        ],
        [
            "LOAD_METHOD",
            "model.__table__.drop"
        ],
        [
            "LOAD_ATTR",
            "self.engine"
        ],
        [
            "CALL_METHOD",
            "model.__table__.drop(self.engine)"
        ],
        [
            "LOAD_METHOD",
            "self.Session"
        ],
        [
            "CALL_METHOD",
            "self.Session()"
        ],
        [
            "LOAD_METHOD",
            "session.commit"
        ],
        [
            "CALL_METHOD",
            "session.commit()"
        ],
        [
            "LOAD_METHOD",
            "session.rollback"
        ],
        [
            "CALL_METHOD",
            "session.rollback()"
        ],
        [
            "LOAD_METHOD",
            "session.close"
        ],
        [
            "CALL_METHOD",
            "session.close()"
        ],
        [
            "LOAD_METHOD",
            "session.close"
        ],
        [
            "CALL_METHOD",
            "session.close()"
        ],
        [
            "LOAD_METHOD",
            "functools.wraps"
        ],
        [
            "CALL_METHOD",
            "functools.wraps(func)"
        ],
        [
            "CALL_FUNCTION",
            "retry_db(wrapper)"
        ],
        [
            "LOAD_METHOD",
            "self.session_scope"
        ],
        [
            "CALL_METHOD",
            "self.session_scope()"
        ],
        [
            "CALL_FUNCTION_EX",
            "func(session, *args, **kwargs)"
        ]
    ],
    "executing.py": [
        [
            "LOAD_ATTR",
            "sys.version_info"
        ],
        [
            "BINARY_SUBSCR",
            "sys.version_info[0]"
        ],
        [
            "COMPARE_OP",
            "sys.version_info[0] == 3"
        ],
        [
            "CALL_FUNCTION_KW",
            "lru_cache(maxsize=None)"
        ],
        [
            "LOAD_ATTR",
            "dis.get_instructions"
        ],
        [
            "CALL_FUNCTION",
            "namedtuple('Instruction', 'offset argval opname')"
        ],
        [
            "LOAD_ATTR",
            "ast.NodeVisitor"
        ],
        [
            "LOAD_ATTR",
            "__future__.all_feature_names"
        ],
        [
            "CALL_FUNCTION",
            "sum(\n    getattr(__future__, fname).compiler_flag\n    for fname in __future__.all_feature_names\n)"
        ],
        [
            "CALL_FUNCTION",
            "RLock()"
        ],
        [
            "LOAD_METHOD",
            "functools.wraps"
        ],
        [
            "CALL_METHOD",
            "functools.wraps(func)"
        ],
        [
            "CONTAINS_OP",
            "args in d"
        ],
        [
            "BINARY_SUBSCR",
            "d[args]"
        ],
        [
            "CALL_FUNCTION_EX",
            "func(*args)"
        ],
        [
            "LOAD_ATTR",
            "co.co_code"
        ],
        [
            "CALL_FUNCTION",
            "len(code)"
        ],
        [
            "COMPARE_OP",
            "i < n"
        ],
        [
            "BINARY_SUBSCR",
            "code[i]"
        ],
        [
            "CALL_FUNCTION",
            "ord(c)"
        ],
        [
            "BINARY_ADD",
            "i + 1"
        ],
        [
            "COMPARE_OP",
            "op >= HAVE_ARGUMENT"
        ],
        [
            "BINARY_SUBSCR",
            "code[i]"
        ],
        [
            "CALL_FUNCTION",
            "ord(code[i])"
        ],
        [
            "BINARY_ADD",
            "i + 1"
        ],
        [
            "BINARY_SUBSCR",
            "code[i + 1]"
        ],
        [
            "CALL_FUNCTION",
            "ord(code[i + 1])"
        ],
        [
            "BINARY_MULTIPLY",
            "ord(code[i + 1]) * 256"
        ],
        [
            "BINARY_ADD",
            "ord(code[i]) + ord(code[i + 1]) * 256"
        ],
        [
            "BINARY_ADD",
            "ord(code[i]) + ord(code[i + 1]) * 256 + extended_arg"
        ],
        [
            "BINARY_ADD",
            "i + 2"
        ],
        [
            "COMPARE_OP",
            "op == EXTENDED_ARG"
        ],
        [
            "BINARY_MULTIPLY",
            "oparg * 65536"
        ],
        [
            "CONTAINS_OP",
            "op in hasconst"
        ],
        [
            "LOAD_ATTR",
            "co.co_consts"
        ],
        [
            "BINARY_SUBSCR",
            "co.co_consts[oparg]"
        ],
        [
            "BINARY_SUBSCR",
            "opname[op]"
        ],
        [
            "CALL_FUNCTION",
            "Instruction(offset, argval, opname[op])"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(it, Sized)"
        ],
        [
            "CALL_FUNCTION",
            "len(it)"
        ],
        [
            "COMPARE_OP",
            "len(it) != 1"
        ],
        [
            "CALL_FUNCTION",
            "len(it)"
        ],
        [
            "BINARY_MODULO",
            "'Expected one value, found %s' % len(it)"
        ],
        [
            "CALL_FUNCTION",
            "NotOneValueFound('Expected one value, found %s' % len(it))"
        ],
        [
            "CALL_FUNCTION",
            "list(it)"
        ],
        [
            "BINARY_SUBSCR",
            "list(it)[0]"
        ],
        [
            "CALL_FUNCTION",
            "islice(it, 2)"
        ],
        [
            "CALL_FUNCTION",
            "tuple(islice(it, 2))"
        ],
        [
            "CALL_FUNCTION",
            "len(lst)"
        ],
        [
            "COMPARE_OP",
            "len(lst) == 0"
        ],
        [
            "CALL_FUNCTION",
            "NotOneValueFound('Expected one value, found 0')"
        ],
        [
            "CALL_FUNCTION",
            "len(lst)"
        ],
        [
            "COMPARE_OP",
            "len(lst) > 1"
        ],
        [
            "CALL_FUNCTION",
            "NotOneValueFound('Expected one value, found several')"
        ],
        [
            "BINARY_SUBSCR",
            "lst[0]"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(text, text_type)"
        ],
        [
            "LOAD_METHOD",
            "self.decode_source"
        ],
        [
            "CALL_METHOD",
            "self.decode_source(text)"
        ],
        [
            "LOAD_METHOD",
            "''.join"
        ],
        [
            "LOAD_METHOD",
            "text.splitlines"
        ],
        [
            "CALL_METHOD",
            "text.splitlines(True)"
        ],
        [
            "CALL_FUNCTION",
            "enumerate(text.splitlines(True))"
        ],
        [
            "CALL_METHOD",
            "''.join([\n                '\\n' if i < 2 and encoding_pattern.match(line)\n                else line\n                for i, line in enumerate(text.splitlines(True))\n            ])"
        ],
        [
            "CALL_FUNCTION",
            "defaultdict(list)"
        ],
        [
            "LOAD_ATTR",
            "ast.parse"
        ],
        [
            "CALL_FUNCTION_KW",
            "ast.parse(ast_text, filename=filename)"
        ],
        [
            "LOAD_METHOD",
            "ast.walk"
        ],
        [
            "LOAD_ATTR",
            "self.tree"
        ],
        [
            "CALL_METHOD",
            "ast.walk(self.tree)"
        ],
        [
            "LOAD_METHOD",
            "ast.iter_child_nodes"
        ],
        [
            "CALL_METHOD",
            "ast.iter_child_nodes(node)"
        ],
        [
            "CALL_FUNCTION",
            "hasattr(node, 'lineno')"
        ],
        [
            "LOAD_ATTR",
            "self._nodes_by_line"
        ],
        [
            "LOAD_ATTR",
            "node.lineno"
        ],
        [
            "BINARY_SUBSCR",
            "self._nodes_by_line[node.lineno]"
        ],
        [
            "LOAD_METHOD",
            "self._nodes_by_line[node.lineno].append"
        ],
        [
            "CALL_METHOD",
            "self._nodes_by_line[node.lineno].append(node)"
        ],
        [
            "CALL_FUNCTION",
            "QualnameVisitor()"
        ],
        [
            "LOAD_METHOD",
            "visitor.visit"
        ],
        [
            "LOAD_ATTR",
            "self.tree"
        ],
        [
            "CALL_METHOD",
            "visitor.visit(self.tree)"
        ],
        [
            "LOAD_ATTR",
            "visitor.qualnames"
        ],
        [
            "COMPARE_OP",
            "i < 2"
        ],
        [
            "LOAD_METHOD",
            "encoding_pattern.match"
        ],
        [
            "CALL_METHOD",
            "encoding_pattern.match(line)"
        ],
        [
            "LOAD_METHOD",
            "cls.for_filename"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_filename"
        ],
        [
            "LOAD_ATTR",
            "frame.f_globals"
        ],
        [
            "CALL_METHOD",
            "cls.for_filename(frame.f_code.co_filename, frame.f_globals or {})"
        ],
        [
            "LOAD_METHOD",
            "cls._class_local"
        ],
        [
            "CALL_METHOD",
            "cls._class_local('__source_cache', {})"
        ],
        [
            "BINARY_SUBSCR",
            "source_cache[filename]"
        ],
        [
            "LOAD_METHOD",
            "linecache.getlines"
        ],
        [
            "CALL_METHOD",
            "linecache.getlines(filename, module_globals)"
        ],
        [
            "LOAD_METHOD",
            "''.join"
        ],
        [
            "CALL_METHOD",
            "''.join(lines)"
        ],
        [
            "CALL_FUNCTION",
            "cls(filename, ''.join(lines))"
        ],
        [
            "CALL_FUNCTION",
            "hasattr(linecache, 'lazycache')"
        ],
        [
            "LOAD_METHOD",
            "linecache.lazycache"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_filename"
        ],
        [
            "LOAD_ATTR",
            "frame.f_globals"
        ],
        [
            "CALL_METHOD",
            "linecache.lazycache(frame.f_code.co_filename, frame.f_globals)"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_lasti"
        ],
        [
            "LOAD_METHOD",
            "cls._class_local"
        ],
        [
            "CALL_METHOD",
            "cls._class_local('__executing_cache', {})"
        ],
        [
            "BINARY_SUBSCR",
            "executing_cache[key]"
        ],
        [
            "LOAD_METHOD",
            "cls.for_frame"
        ],
        [
            "CALL_METHOD",
            "cls.for_frame(frame)"
        ],
        [
            "LOAD_ATTR",
            "source.tree"
        ],
        [
            "LOAD_METHOD",
            "source.statements_at_line"
        ],
        [
            "LOAD_ATTR",
            "frame.f_lineno"
        ],
        [
            "CALL_METHOD",
            "source.statements_at_line(frame.f_lineno)"
        ],
        [
            "LOAD_ATTR",
            "source.tree"
        ],
        [
            "CALL_FUNCTION",
            "NodeFinder(frame, stmts, source.tree)"
        ],
        [
            "LOAD_ATTR",
            "NodeFinder(frame, stmts, source.tree).result"
        ],
        [
            "CALL_FUNCTION",
            "statement_containing_node(node)"
        ],
        [
            "COMPARE_OP",
            "new_stmts <= stmts"
        ],
        [
            "CALL_FUNCTION_EX",
            "Executing(frame, *args)"
        ],
        [
            "LOAD_ATTR",
            "cls.__dict__"
        ],
        [
            "LOAD_METHOD",
            "cls.__dict__.get"
        ],
        [
            "CALL_METHOD",
            "cls.__dict__.get(name, default)"
        ],
        [
            "CALL_FUNCTION",
            "setattr(cls, name, result)"
        ],
        [
            "LOAD_ATTR",
            "self._nodes_by_line"
        ],
        [
            "BINARY_SUBSCR",
            "self._nodes_by_line[lineno]"
        ],
        [
            "CALL_FUNCTION",
            "statement_containing_node(node)"
        ],
        [
            "LOAD_ATTR",
            "self.text"
        ],
        [
            "LOAD_ATTR",
            "self.tree"
        ],
        [
            "LOAD_ATTR",
            "self.filename"
        ],
        [
            "CALL_FUNCTION_KW",
            "ASTTokens(\n            self.text,\n            tree=self.tree,\n            filename=self.filename,\n        )"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(source, bytes)"
        ],
        [
            "LOAD_METHOD",
            "io.BytesIO"
        ],
        [
            "CALL_METHOD",
            "io.BytesIO(source)"
        ],
        [
            "LOAD_ATTR",
            "io.BytesIO(source).readline"
        ],
        [
            "CALL_FUNCTION",
            "detect_encoding(io.BytesIO(source).readline)"
        ],
        [
            "LOAD_METHOD",
            "source.decode"
        ],
        [
            "CALL_METHOD",
            "source.decode(encoding)"
        ],
        [
            "LOAD_ATTR",
            "code.co_filename"
        ],
        [
            "LOAD_ATTR",
            "self.filename"
        ],
        [
            "COMPARE_OP",
            "code.co_filename == self.filename"
        ],
        [
            "LOAD_ATTR",
            "self._qualnames"
        ],
        [
            "LOAD_METHOD",
            "self._qualnames.get"
        ],
        [
            "LOAD_ATTR",
            "code.co_name"
        ],
        [
            "LOAD_ATTR",
            "code.co_firstlineno"
        ],
        [
            "LOAD_ATTR",
            "code.co_name"
        ],
        [
            "CALL_METHOD",
            "self._qualnames.get((code.co_name, code.co_firstlineno), code.co_name)"
        ],
        [
            "LOAD_ATTR",
            "self.source"
        ],
        [
            "LOAD_METHOD",
            "self.source.code_qualname"
        ],
        [
            "LOAD_ATTR",
            "self.frame"
        ],
        [
            "LOAD_ATTR",
            "self.frame.f_code"
        ],
        [
            "CALL_METHOD",
            "self.source.code_qualname(self.frame.f_code)"
        ],
        [
            "LOAD_ATTR",
            "self.source"
        ],
        [
            "LOAD_METHOD",
            "self.source.asttokens"
        ],
        [
            "CALL_METHOD",
            "self.source.asttokens()"
        ],
        [
            "LOAD_METHOD",
            "self.source.asttokens().get_text"
        ],
        [
            "LOAD_ATTR",
            "self.node"
        ],
        [
            "CALL_METHOD",
            "self.source.asttokens().get_text(self.node)"
        ],
        [
            "LOAD_ATTR",
            "self.source"
        ],
        [
            "LOAD_METHOD",
            "self.source.asttokens"
        ],
        [
            "CALL_METHOD",
            "self.source.asttokens()"
        ],
        [
            "LOAD_METHOD",
            "self.source.asttokens().get_text_range"
        ],
        [
            "LOAD_ATTR",
            "self.node"
        ],
        [
            "CALL_METHOD",
            "self.source.asttokens().get_text_range(self.node)"
        ],
        [
            "CALL_FUNCTION",
            "super(QualnameVisitor, self)"
        ],
        [
            "LOAD_METHOD",
            "super(QualnameVisitor, self).__init__"
        ],
        [
            "CALL_METHOD",
            "super(QualnameVisitor, self).__init__()"
        ],
        [
            "LOAD_ATTR",
            "node.name"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_METHOD",
            "self.stack.append"
        ],
        [
            "CALL_METHOD",
            "self.stack.append(name)"
        ],
        [
            "LOAD_ATTR",
            "self.qualnames"
        ],
        [
            "LOAD_METHOD",
            "self.qualnames.setdefault"
        ],
        [
            "LOAD_ATTR",
            "node.lineno"
        ],
        [
            "LOAD_METHOD",
            "\".\".join"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "CALL_METHOD",
            "\".\".join(self.stack)"
        ],
        [
            "CALL_METHOD",
            "self.qualnames.setdefault((name, node.lineno), \".\".join(self.stack))"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_METHOD",
            "self.stack.append"
        ],
        [
            "CALL_METHOD",
            "self.stack.append('<locals>')"
        ],
        [
            "LOAD_ATTR",
            "ast.Lambda"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node, ast.Lambda)"
        ],
        [
            "LOAD_ATTR",
            "node.body"
        ],
        [
            "LOAD_ATTR",
            "node.body"
        ],
        [
            "LOAD_METHOD",
            "self.visit"
        ],
        [
            "CALL_METHOD",
            "self.visit(child)"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_METHOD",
            "self.stack.pop"
        ],
        [
            "CALL_METHOD",
            "self.stack.pop()"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_METHOD",
            "self.stack.pop"
        ],
        [
            "CALL_METHOD",
            "self.stack.pop()"
        ],
        [
            "LOAD_METHOD",
            "ast.iter_fields"
        ],
        [
            "CALL_METHOD",
            "ast.iter_fields(node)"
        ],
        [
            "COMPARE_OP",
            "field == 'body'"
        ],
        [
            "LOAD_ATTR",
            "ast.AST"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(child, ast.AST)"
        ],
        [
            "LOAD_METHOD",
            "self.visit"
        ],
        [
            "CALL_METHOD",
            "self.visit(child)"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(child, list)"
        ],
        [
            "LOAD_ATTR",
            "ast.AST"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(grandchild, ast.AST)"
        ],
        [
            "LOAD_METHOD",
            "self.visit"
        ],
        [
            "CALL_METHOD",
            "self.visit(grandchild)"
        ],
        [
            "LOAD_METHOD",
            "self.visit_FunctionDef"
        ],
        [
            "CALL_METHOD",
            "self.visit_FunctionDef(node, '<lambda>')"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_METHOD",
            "self.stack.append"
        ],
        [
            "LOAD_ATTR",
            "node.name"
        ],
        [
            "CALL_METHOD",
            "self.stack.append(node.name)"
        ],
        [
            "LOAD_METHOD",
            "self.generic_visit"
        ],
        [
            "CALL_METHOD",
            "self.generic_visit(node)"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_METHOD",
            "self.stack.pop"
        ],
        [
            "CALL_METHOD",
            "self.stack.pop()"
        ],
        [
            "CALL_FUNCTION",
            "getattr(__future__, fname)"
        ],
        [
            "LOAD_ATTR",
            "getattr(__future__, fname).compiler_flag"
        ],
        [
            "LOAD_ATTR",
            "matching_code.co_filename"
        ],
        [
            "LOAD_ATTR",
            "matching_code.co_flags"
        ],
        [
            "BINARY_AND",
            "future_flags & matching_code.co_flags"
        ],
        [
            "CALL_FUNCTION_KW",
            "compile(\n        source,\n        matching_code.co_filename,\n        'exec',\n        flags=future_flags & matching_code.co_flags,\n        dont_inherit=True,\n    )"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_lasti"
        ],
        [
            "BINARY_SUBSCR",
            "frame.f_code.co_code[frame.f_lasti]"
        ],
        [
            "CALL_FUNCTION",
            "ord(b)"
        ],
        [
            "LOAD_ATTR",
            "dis.opname"
        ],
        [
            "BINARY_SUBSCR",
            "dis.opname[b]"
        ],
        [
            "LOAD_METHOD",
            "op_name.startswith"
        ],
        [
            "CALL_METHOD",
            "op_name.startswith('CALL_')"
        ],
        [
            "LOAD_ATTR",
            "ast.Call"
        ],
        [
            "COMPARE_OP",
            "op_name == 'BINARY_SUBSCR'"
        ],
        [
            "LOAD_ATTR",
            "ast.Subscript"
        ],
        [
            "LOAD_METHOD",
            "op_name.startswith"
        ],
        [
            "CALL_METHOD",
            "op_name.startswith('BINARY_')"
        ],
        [
            "LOAD_ATTR",
            "ast.BinOp"
        ],
        [
            "LOAD_METHOD",
            "op_name.startswith"
        ],
        [
            "CALL_METHOD",
            "op_name.startswith('UNARY_')"
        ],
        [
            "LOAD_ATTR",
            "ast.UnaryOp"
        ],
        [
            "CONTAINS_OP",
            "op_name in ('LOAD_ATTR', 'LOAD_METHOD', 'LOOKUP_METHOD')"
        ],
        [
            "LOAD_ATTR",
            "ast.Attribute"
        ],
        [
            "COMPARE_OP",
            "op_name == 'COMPARE_OP'"
        ],
        [
            "LOAD_ATTR",
            "ast.Compare"
        ],
        [
            "CALL_FUNCTION",
            "RuntimeError(op_name)"
        ],
        [
            "LOAD_METHOD",
            "self.matching_nodes"
        ],
        [
            "CALL_METHOD",
            "self.matching_nodes(exprs)"
        ],
        [
            "CALL_FUNCTION",
            "list(self.matching_nodes(exprs))"
        ],
        [
            "CALL_FUNCTION",
            "only(list(self.matching_nodes(exprs)))"
        ],
        [
            "LOAD_METHOD",
            "ast.walk"
        ],
        [
            "CALL_METHOD",
            "ast.walk(stmt)"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node, typ)"
        ],
        [
            "CALL_FUNCTION",
            "hasattr(node, \"ctx\")"
        ],
        [
            "LOAD_ATTR",
            "node.ctx"
        ],
        [
            "LOAD_ATTR",
            "ast.Load"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node.ctx, ast.Load)"
        ],
        [
            "CALL_FUNCTION",
            "enumerate(exprs)"
        ],
        [
            "CALL_FUNCTION",
            "get_setter(expr)"
        ],
        [
            "LOAD_ATTR",
            "ast.BinOp"
        ],
        [
            "LOAD_METHOD",
            "ast.Pow"
        ],
        [
            "CALL_METHOD",
            "ast.Pow()"
        ],
        [
            "LOAD_ATTR",
            "ast.Str"
        ],
        [
            "CALL_FUNCTION_KW",
            "ast.Str(s=sentinel)"
        ],
        [
            "CALL_FUNCTION_KW",
            "ast.BinOp(\n                left=expr,\n                op=ast.Pow(),\n                right=ast.Str(s=sentinel),\n            )"
        ],
        [
            "LOAD_METHOD",
            "ast.fix_missing_locations"
        ],
        [
            "CALL_METHOD",
            "ast.fix_missing_locations(replacement)"
        ],
        [
            "CALL_FUNCTION",
            "setter(replacement)"
        ],
        [
            "LOAD_METHOD",
            "self.compile_instructions"
        ],
        [
            "CALL_METHOD",
            "self.compile_instructions()"
        ],
        [
            "CALL_FUNCTION",
            "setter(expr)"
        ],
        [
            "CALL_FUNCTION",
            "setter(expr)"
        ],
        [
            "CALL_FUNCTION",
            "setter(expr)"
        ],
        [
            "CALL_FUNCTION",
            "enumerate(instructions)"
        ],
        [
            "CALL_FUNCTION",
            "only(indices)"
        ],
        [
            "BINARY_SUBTRACT",
            "only(indices) - 1"
        ],
        [
            "BINARY_SUBSCR",
            "instructions[arg_index]"
        ],
        [
            "LOAD_ATTR",
            "instructions[arg_index].opname"
        ],
        [
            "COMPARE_OP",
            "instructions[arg_index].opname == 'EXTENDED_ARG'"
        ],
        [
            "BINARY_SUBSCR",
            "instructions[arg_index]"
        ],
        [
            "LOAD_ATTR",
            "instructions[arg_index].offset"
        ],
        [
            "LOAD_ATTR",
            "self.frame"
        ],
        [
            "LOAD_ATTR",
            "self.frame.f_lasti"
        ],
        [
            "COMPARE_OP",
            "instructions[arg_index].offset == self.frame.f_lasti"
        ],
        [
            "LOAD_ATTR",
            "instruction.argval"
        ],
        [
            "COMPARE_OP",
            "instruction.argval == sentinel"
        ],
        [
            "LOAD_ATTR",
            "self.tree"
        ],
        [
            "LOAD_ATTR",
            "self.frame"
        ],
        [
            "LOAD_ATTR",
            "self.frame.f_code"
        ],
        [
            "CALL_FUNCTION",
            "compile_similar_to(self.tree, self.frame.f_code)"
        ],
        [
            "LOAD_ATTR",
            "self.frame"
        ],
        [
            "LOAD_ATTR",
            "self.frame.f_code"
        ],
        [
            "CALL_FUNCTION",
            "find_codes(module_code, self.frame.f_code)"
        ],
        [
            "CALL_FUNCTION",
            "only(find_codes(module_code, self.frame.f_code))"
        ],
        [
            "CALL_FUNCTION",
            "get_instructions(code)"
        ],
        [
            "CALL_FUNCTION",
            "list(get_instructions(code))"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_METHOD",
            "ast.iter_fields"
        ],
        [
            "CALL_METHOD",
            "ast.iter_fields(parent)"
        ],
        [
            "IS_OP",
            "field is node"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(field, list)"
        ],
        [
            "CALL_FUNCTION",
            "enumerate(field)"
        ],
        [
            "IS_OP",
            "item is node"
        ],
        [
            "CALL_FUNCTION",
            "setattr(parent, name, new_node)"
        ],
        [
            "CALL_FUNCTION",
            "matches(root_code)"
        ],
        [
            "LOAD_METHOD",
            "code_options.append"
        ],
        [
            "CALL_METHOD",
            "code_options.append(root_code)"
        ],
        [
            "CALL_FUNCTION",
            "finder(root_code)"
        ],
        [
            "CALL_FUNCTION",
            "attrgetter('co_firstlineno')"
        ],
        [
            "CALL_FUNCTION",
            "attrgetter('co_name')"
        ],
        [
            "CALL_FUNCTION",
            "all(\n            f(c) == f(matching)\n            for f in [\n                attrgetter('co_firstlineno'),\n                attrgetter('co_name'),\n                code_names,\n            ]\n        )"
        ],
        [
            "CALL_FUNCTION",
            "f(c)"
        ],
        [
            "CALL_FUNCTION",
            "f(matching)"
        ],
        [
            "COMPARE_OP",
            "f(c) == f(matching)"
        ],
        [
            "LOAD_ATTR",
            "code.co_consts"
        ],
        [
            "LOAD_METHOD",
            "inspect.iscode"
        ],
        [
            "CALL_METHOD",
            "inspect.iscode(const)"
        ],
        [
            "CALL_FUNCTION",
            "matches(const)"
        ],
        [
            "LOAD_METHOD",
            "code_options.append"
        ],
        [
            "CALL_METHOD",
            "code_options.append(const)"
        ],
        [
            "CALL_FUNCTION",
            "finder(const)"
        ],
        [
            "CALL_FUNCTION",
            "frozenset()"
        ],
        [
            "LOAD_METHOD",
            "frozenset().union"
        ],
        [
            "LOAD_ATTR",
            "code.co_names"
        ],
        [
            "LOAD_ATTR",
            "code.co_varnames"
        ],
        [
            "LOAD_ATTR",
            "code.co_freevars"
        ],
        [
            "LOAD_ATTR",
            "code.co_cellvars"
        ],
        [
            "CALL_METHOD",
            "frozenset().union(\n        code.co_names,\n        code.co_varnames,\n        code.co_freevars,\n        code.co_cellvars,\n    )"
        ],
        [
            "LOAD_ATTR",
            "ast.stmt"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node, ast.stmt)"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ]
    ],
    "import_hook.py": [
        [
            "LOAD_ATTR",
            "eye.exec_string"
        ],
        [
            "LOAD_ATTR",
            "self.source"
        ],
        [
            "LOAD_ATTR",
            "self._spec"
        ],
        [
            "LOAD_ATTR",
            "self._spec.origin"
        ],
        [
            "LOAD_ATTR",
            "module.__dict__"
        ],
        [
            "LOAD_ATTR",
            "module.__dict__"
        ],
        [
            "LOAD_ATTR",
            "self.deep"
        ],
        [
            "CALL_FUNCTION_KW",
            "eye.exec_string(\n            source=self.source,\n            filename=self._spec.origin,\n            globs=module.__dict__,\n            locs=module.__dict__,\n            deep=self.deep,\n        )"
        ],
        [
            "LOAD_ATTR",
            "self._spec"
        ],
        [
            "LOAD_ATTR",
            "self._spec.loader"
        ],
        [
            "LOAD_METHOD",
            "self._spec.loader.get_filename"
        ],
        [
            "CALL_METHOD",
            "self._spec.loader.get_filename(fullname)"
        ],
        [
            "LOAD_ATTR",
            "self._spec"
        ],
        [
            "LOAD_ATTR",
            "self._spec.loader"
        ],
        [
            "LOAD_METHOD",
            "self._spec.loader.is_package"
        ],
        [
            "CALL_METHOD",
            "self._spec.loader.is_package(fullname)"
        ],
        [
            "LOAD_ATTR",
            "sys.meta_path"
        ],
        [
            "IS_OP",
            "finder is self"
        ],
        [
            "LOAD_ATTR",
            "finder.__module__"
        ],
        [
            "CONTAINS_OP",
            "'pytest' in finder.__module__"
        ],
        [
            "CALL_FUNCTION",
            "hasattr(finder, 'find_spec')"
        ],
        [
            "LOAD_ATTR",
            "finder.find_spec"
        ],
        [
            "CALL_FUNCTION_KW",
            "finder.find_spec(fullname, path, target=target)"
        ],
        [
            "CALL_FUNCTION",
            "hasattr(finder, 'load_module')"
        ],
        [
            "CALL_FUNCTION",
            "spec_from_loader(fullname, finder)"
        ],
        [
            "IS_OP",
            "spec is not None"
        ],
        [
            "LOAD_ATTR",
            "spec.origin"
        ],
        [
            "COMPARE_OP",
            "spec.origin != 'builtin'"
        ],
        [
            "LOAD_METHOD",
            "self._find_plain_spec"
        ],
        [
            "CALL_METHOD",
            "self._find_plain_spec(fullname, path, target)"
        ],
        [
            "IS_OP",
            "spec is None"
        ],
        [
            "LOAD_ATTR",
            "spec.loader"
        ],
        [
            "CALL_FUNCTION",
            "hasattr(spec.loader, 'get_source')"
        ],
        [
            "LOAD_ATTR",
            "spec.loader"
        ],
        [
            "LOAD_ATTR",
            "spec.loader.get_source"
        ],
        [
            "CALL_FUNCTION",
            "callable(spec.loader.get_source)"
        ],
        [
            "COMPARE_OP",
            "fullname != 'org'"
        ],
        [
            "LOAD_METHOD",
            "logging.debug"
        ],
        [
            "CALL_METHOD",
            "logging.debug('Failed finding spec for %s', fullname)"
        ],
        [
            "LOAD_ATTR",
            "spec.loader"
        ],
        [
            "LOAD_METHOD",
            "spec.loader.get_source"
        ],
        [
            "CALL_METHOD",
            "spec.loader.get_source(fullname)"
        ],
        [
            "LOAD_METHOD",
            "logging.debug"
        ],
        [
            "CALL_METHOD",
            "logging.debug('Loader for %s was unable to find the sources',\n                          fullname)"
        ],
        [
            "LOAD_METHOD",
            "logging.exception"
        ],
        [
            "CALL_METHOD",
            "logging.exception('Loader for %s raised an error', fullname)"
        ],
        [
            "CONTAINS_OP",
            "'birdseye' not in source"
        ],
        [
            "CALL_FUNCTION",
            "should_trace(source)"
        ],
        [
            "CALL_FUNCTION",
            "BirdsEyeLoader(spec, source, deep)"
        ],
        [
            "CALL_FUNCTION",
            "spec_from_loader(fullname, loader)"
        ],
        [
            "LOAD_METHOD",
            "ast.parse"
        ],
        [
            "CALL_METHOD",
            "ast.parse(source)"
        ],
        [
            "LOAD_ATTR",
            "ast.parse(source).body"
        ],
        [
            "LOAD_ATTR",
            "ast.Import"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(stmt, ast.Import)"
        ],
        [
            "LOAD_ATTR",
            "stmt.names"
        ],
        [
            "LOAD_ATTR",
            "alias.name"
        ],
        [
            "LOAD_METHOD",
            "alias.name.startswith"
        ],
        [
            "CALL_METHOD",
            "alias.name.startswith('birdseye.trace_module')"
        ],
        [
            "LOAD_ATTR",
            "alias.name"
        ],
        [
            "LOAD_METHOD",
            "alias.name.endswith"
        ],
        [
            "CALL_METHOD",
            "alias.name.endswith('deep')"
        ],
        [
            "LOAD_ATTR",
            "ast.ImportFrom"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(stmt, ast.ImportFrom)"
        ],
        [
            "LOAD_ATTR",
            "stmt.module"
        ],
        [
            "COMPARE_OP",
            "stmt.module == 'birdseye'"
        ],
        [
            "LOAD_ATTR",
            "stmt.names"
        ],
        [
            "LOAD_ATTR",
            "alias.name"
        ],
        [
            "LOAD_METHOD",
            "alias.name.startswith"
        ],
        [
            "CALL_METHOD",
            "alias.name.startswith('trace_module')"
        ],
        [
            "LOAD_ATTR",
            "alias.name"
        ],
        [
            "LOAD_METHOD",
            "alias.name.endswith"
        ],
        [
            "CALL_METHOD",
            "alias.name.endswith('deep')"
        ]
    ],
    "ipython.py": [
        [
            "LOAD_ATTR",
            "sys.stderr"
        ],
        [
            "CALL_FUNCTION",
            "stream_proxy(sys.stderr)"
        ],
        [
            "LOAD_ATTR",
            "sys.stdout"
        ],
        [
            "CALL_FUNCTION",
            "stream_proxy(sys.stdout)"
        ],
        [
            "CALL_FUNCTION",
            "PackageLoader('birdseye', 'templates')"
        ],
        [
            "CALL_FUNCTION",
            "select_autoescape(['html', 'xml'])"
        ],
        [
            "CALL_FUNCTION_KW",
            "Environment(\n    loader=PackageLoader('birdseye', 'templates'),\n    autoescape=select_autoescape(['html', 'xml'])\n)"
        ],
        [
            "CALL_FUNCTION",
            "LocalProxy(p)"
        ],
        [
            "LOAD_METHOD",
            "inspect.currentframe"
        ],
        [
            "CALL_METHOD",
            "inspect.currentframe()"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "ThreadingMixIn.process_request_thread"
        ],
        [
            "LOAD_ATTR",
            "ThreadingMixIn.process_request_thread.__code__"
        ],
        [
            "COMPARE_OP",
            "frame.f_code == ThreadingMixIn.process_request_thread.__code__"
        ],
        [
            "CALL_FUNCTION",
            "fake_stream()"
        ],
        [
            "LOAD_ATTR",
            "frame.f_back"
        ],
        [
            "LOAD_METHOD",
            "thread_proxies.get"
        ],
        [
            "CALL_FUNCTION",
            "currentThread()"
        ],
        [
            "LOAD_ATTR",
            "currentThread().ident"
        ],
        [
            "CALL_METHOD",
            "thread_proxies.get(currentThread().ident,\n                                  original)"
        ],
        [
            "CALL_FUNCTION",
            "fake_stream()"
        ],
        [
            "CALL_FUNCTION",
            "currentThread()"
        ],
        [
            "LOAD_ATTR",
            "currentThread().ident"
        ],
        [
            "LOAD_ATTR",
            "server.app"
        ],
        [
            "LOAD_ATTR",
            "server.app.run"
        ],
        [
            "CALL_FUNCTION_KW",
            "server.app.run(\n            debug=True,\n            port=port,\n            host=bind_host,\n            use_reloader=False,\n        )"
        ],
        [
            "LOAD_ATTR",
            "socket.error"
        ],
        [
            "CALL_FUNCTION_KW",
            "Unicode(\n        u'', config=True,\n        help='If set, a server will not be automatically started by %%eye. '\n             'The iframe containing birdseye output will use this value as the base '\n             'of its URL.'\n    )"
        ],
        [
            "CALL_FUNCTION_KW",
            "Int(\n        7777, config=True,\n        help='Port number for the server started by %%eye.'\n    )"
        ],
        [
            "CALL_FUNCTION_KW",
            "Unicode(\n        '127.0.0.1', config=True,\n        help='Host that the server started by %%eye listens on. '\n             'Set to 0.0.0.0 to make it accessible anywhere.'\n    )"
        ],
        [
            "CALL_FUNCTION_KW",
            "Bool(\n        False, config=True,\n        help='Set to True to show stdout and stderr from the server started by %%eye.'\n    )"
        ],
        [
            "CALL_FUNCTION_KW",
            "Unicode(\n        u'', config=True,\n        help='The database URL that the server started by %%eye reads from. '\n             'Equivalent to the environment variable BIRDSEYE_DB.'\n    )"
        ],
        [
            "LOAD_ATTR",
            "self.server_url"
        ],
        [
            "LOAD_ATTR",
            "self.db_url"
        ],
        [
            "CALL_FUNCTION",
            "Database(self.db_url)"
        ],
        [
            "LOAD_ATTR",
            "server.db"
        ],
        [
            "LOAD_ATTR",
            "server.db.Function"
        ],
        [
            "LOAD_ATTR",
            "server.db"
        ],
        [
            "LOAD_ATTR",
            "server.db.Call"
        ],
        [
            "LOAD_ATTR",
            "server.db"
        ],
        [
            "LOAD_ATTR",
            "server.db.Session"
        ],
        [
            "LOAD_ATTR",
            "self.port"
        ],
        [
            "LOAD_ATTR",
            "self.bind_host"
        ],
        [
            "LOAD_ATTR",
            "self.show_server_output"
        ],
        [
            "CALL_FUNCTION_KW",
            "Thread(\n                target=run_server,\n                args=(\n                    self.port,\n                    self.bind_host,\n                    self.show_server_output,\n                ),\n            )"
        ],
        [
            "LOAD_METHOD",
            "Thread(\n                target=run_server,\n                args=(\n                    self.port,\n                    self.bind_host,\n                    self.show_server_output,\n                ),\n            ).start"
        ],
        [
            "CALL_METHOD",
            "Thread(\n                target=run_server,\n                args=(\n                    self.port,\n                    self.bind_host,\n                    self.show_server_output,\n                ),\n            ).start()"
        ],
        [
            "LOAD_ATTR",
            "self.db_url"
        ],
        [
            "CALL_FUNCTION",
            "Database(self.db_url)"
        ],
        [
            "LOAD_METHOD",
            "eye.exec_ipython_cell"
        ],
        [
            "CALL_METHOD",
            "eye.exec_ipython_cell(cell, callback)"
        ],
        [
            "IS_OP",
            "call_id is None"
        ],
        [
            "LOAD_METHOD",
            "templates_env.get_template"
        ],
        [
            "CALL_METHOD",
            "templates_env.get_template('ipython_iframe.html')"
        ],
        [
            "LOAD_ATTR",
            "templates_env.get_template('ipython_iframe.html').render"
        ],
        [
            "LOAD_ATTR",
            "self.server_url"
        ],
        [
            "LOAD_METHOD",
            "self.server_url.rstrip"
        ],
        [
            "CALL_METHOD",
            "self.server_url.rstrip('/')"
        ],
        [
            "LOAD_ATTR",
            "self.port"
        ],
        [
            "CALL_FUNCTION",
            "uuid4()"
        ],
        [
            "LOAD_ATTR",
            "uuid4().hex"
        ],
        [
            "CALL_FUNCTION_KW",
            "templates_env.get_template('ipython_iframe.html').render(\n                call_id=call_id,\n                url=self.server_url.rstrip('/'),\n                port=self.port,\n                container_id=uuid4().hex,\n            )"
        ],
        [
            "CALL_FUNCTION",
            "HTML(templates_env.get_template('ipython_iframe.html').render(\n                call_id=call_id,\n                url=self.server_url.rstrip('/'),\n                port=self.port,\n                container_id=uuid4().hex,\n            ))"
        ],
        [
            "CALL_FUNCTION",
            "display(html)"
        ]
    ],
    "server.py": [
        [
            "LOAD_METHOD",
            "standard_library.install_aliases"
        ],
        [
            "CALL_METHOD",
            "standard_library.install_aliases()"
        ],
        [
            "CALL_FUNCTION",
            "Flask('birdseye')"
        ],
        [
            "LOAD_ATTR",
            "app.jinja_env"
        ],
        [
            "CALL_FUNCTION",
            "Humanize(app)"
        ],
        [
            "LOAD_ATTR",
            "app.url_map"
        ],
        [
            "LOAD_ATTR",
            "app.url_map.converters"
        ],
        [
            "CALL_FUNCTION",
            "Database()"
        ],
        [
            "LOAD_ATTR",
            "db.Session"
        ],
        [
            "LOAD_ATTR",
            "db.Function"
        ],
        [
            "LOAD_ATTR",
            "db.Call"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL_METHOD",
            "app.route('/')"
        ],
        [
            "LOAD_ATTR",
            "db.provide_session"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL_METHOD",
            "app.route('/file/<file:path>')"
        ],
        [
            "LOAD_ATTR",
            "db.provide_session"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL_METHOD",
            "app.route('/file/<file:path>/__function__/<func_name>')"
        ],
        [
            "LOAD_ATTR",
            "db.provide_session"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL_METHOD",
            "app.route('/api/file/<file:path>/__function__/<func_name>/latest_call/')"
        ],
        [
            "LOAD_ATTR",
            "db.provide_session"
        ],
        [
            "LOAD_ATTR",
            "db.provide_session"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL_METHOD",
            "app.route('/call/<call_id>')"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL_METHOD",
            "app.route('/ipython_call/<call_id>')"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL_METHOD",
            "app.route('/ipython_iframe/<call_id>')"
        ],
        [
            "LOAD_ATTR",
            "app.route"
        ],
        [
            "CALL_FUNCTION_KW",
            "app.route('/kill', methods=['POST'])"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL_METHOD",
            "app.route('/api/call/<call_id>')"
        ],
        [
            "LOAD_ATTR",
            "db.provide_session"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL_METHOD",
            "app.route('/api/calls_by_body_hash/<body_hash>')"
        ],
        [
            "LOAD_ATTR",
            "db.provide_session"
        ],
        [
            "LOAD_ATTR",
            "app.route"
        ],
        [
            "CALL_FUNCTION_KW",
            "app.route('/api/body_hashes_present/', methods=['POST'])"
        ],
        [
            "LOAD_ATTR",
            "db.provide_session"
        ],
        [
            "LOAD_ATTR",
            "sys.argv"
        ],
        [
            "BINARY_SUBSCR",
            "sys.argv[1:]"
        ],
        [
            "COMPARE_OP",
            "__name__ == '__main__'"
        ],
        [
            "CALL_FUNCTION",
            "main()"
        ],
        [
            "LOAD_METHOD",
            "db.all_file_paths"
        ],
        [
            "CALL_METHOD",
            "db.all_file_paths()"
        ],
        [
            "LOAD_ATTR",
            "session.query"
        ],
        [
            "LOAD_ATTR",
            "Call.basic_columns"
        ],
        [
            "LOAD_ATTR",
            "Function.basic_columns"
        ],
        [
            "BINARY_ADD",
            "Call.basic_columns + Function.basic_columns"
        ],
        [
            "CALL_FUNCTION_EX",
            "session.query(*(Call.basic_columns + Function.basic_columns))"
        ],
        [
            "LOAD_METHOD",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                        .join"
        ],
        [
            "CALL_METHOD",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                        .join(Function)"
        ],
        [
            "LOAD_METHOD",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                        .join(Function)\n                        .order_by"
        ],
        [
            "LOAD_ATTR",
            "Call.start_time"
        ],
        [
            "LOAD_METHOD",
            "Call.start_time.desc"
        ],
        [
            "CALL_METHOD",
            "Call.start_time.desc()"
        ],
        [
            "CALL_METHOD",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                        .join(Function)\n                        .order_by(Call.start_time.desc())"
        ],
        [
            "BINARY_SUBSCR",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                        .join(Function)\n                        .order_by(Call.start_time.desc())[:100]"
        ],
        [
            "CALL_FUNCTION",
            "OrderedDict()"
        ],
        [
            "LOAD_ATTR",
            "row.file"
        ],
        [
            "CALL_FUNCTION",
            "is_ipython_cell(row.file)"
        ],
        [
            "LOAD_METHOD",
            "files.setdefault"
        ],
        [
            "LOAD_ATTR",
            "row.file"
        ],
        [
            "CALL_FUNCTION",
            "OrderedDict()"
        ],
        [
            "CALL_METHOD",
            "files.setdefault(\n            row.file, OrderedDict()\n        )"
        ],
        [
            "LOAD_METHOD",
            "files.setdefault(\n            row.file, OrderedDict()\n        ).setdefault"
        ],
        [
            "LOAD_ATTR",
            "row.name"
        ],
        [
            "CALL_METHOD",
            "files.setdefault(\n            row.file, OrderedDict()\n        ).setdefault(\n            row.name, row\n        )"
        ],
        [
            "LOAD_METHOD",
            "files.setdefault"
        ],
        [
            "CALL_FUNCTION",
            "OrderedDict()"
        ],
        [
            "CALL_METHOD",
            "files.setdefault(\n            path, OrderedDict()\n        )"
        ],
        [
            "CALL_FUNCTION_KW",
            "partial(short_path, all_paths=all_paths)"
        ],
        [
            "CALL_FUNCTION_KW",
            "render_template('index.html',\n                           short=short,\n                           files=files)"
        ],
        [
            "CALL_FUNCTION",
            "fix_abs_path(path)"
        ],
        [
            "LOAD_ATTR",
            "session.query"
        ],
        [
            "LOAD_ATTR",
            "Call.basic_columns"
        ],
        [
            "LOAD_ATTR",
            "Function.basic_columns"
        ],
        [
            "BINARY_ADD",
            "Call.basic_columns + Function.basic_columns"
        ],
        [
            "CALL_FUNCTION_EX",
            "session.query(*(Call.basic_columns + Function.basic_columns))"
        ],
        [
            "LOAD_METHOD",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                      .join"
        ],
        [
            "CALL_METHOD",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                      .join(Function)"
        ],
        [
            "LOAD_ATTR",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                      .join(Function)\n                      .filter_by"
        ],
        [
            "CALL_FUNCTION_KW",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                      .join(Function)\n                      .filter_by(file=path)"
        ],
        [
            "LOAD_METHOD",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                      .join(Function)\n                      .filter_by(file=path)\n                      .subquery"
        ],
        [
            "CALL_METHOD",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                      .join(Function)\n                      .filter_by(file=path)\n                      .subquery('filtered_calls')"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c.name"
        ],
        [
            "LOAD_ATTR",
            "sqlalchemy.func"
        ],
        [
            "LOAD_METHOD",
            "sqlalchemy.func.max"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c.start_time"
        ],
        [
            "CALL_METHOD",
            "sqlalchemy.func.max(filtered_calls.c.start_time)"
        ],
        [
            "LOAD_METHOD",
            "sqlalchemy.func.max(filtered_calls.c.start_time).label"
        ],
        [
            "CALL_METHOD",
            "sqlalchemy.func.max(filtered_calls.c.start_time).label('maxtime')"
        ],
        [
            "CALL_METHOD",
            "session.query(\n        filtered_calls.c.name,\n        sqlalchemy.func.max(filtered_calls.c.start_time).label('maxtime')\n    )"
        ],
        [
            "LOAD_METHOD",
            "session.query(\n        filtered_calls.c.name,\n        sqlalchemy.func.max(filtered_calls.c.start_time).label('maxtime')\n    ).group_by"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c.name"
        ],
        [
            "CALL_METHOD",
            "session.query(\n        filtered_calls.c.name,\n        sqlalchemy.func.max(filtered_calls.c.start_time).label('maxtime')\n    ).group_by(\n        filtered_calls.c.name,\n    )"
        ],
        [
            "LOAD_METHOD",
            "session.query(\n        filtered_calls.c.name,\n        sqlalchemy.func.max(filtered_calls.c.start_time).label('maxtime')\n    ).group_by(\n        filtered_calls.c.name,\n    ).subquery"
        ],
        [
            "CALL_METHOD",
            "session.query(\n        filtered_calls.c.name,\n        sqlalchemy.func.max(filtered_calls.c.start_time).label('maxtime')\n    ).group_by(\n        filtered_calls.c.name,\n    ).subquery('latest_calls')"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "CALL_METHOD",
            "session.query(filtered_calls)"
        ],
        [
            "LOAD_METHOD",
            "session.query(filtered_calls).join"
        ],
        [
            "LOAD_METHOD",
            "sqlalchemy.and_"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c.name"
        ],
        [
            "LOAD_ATTR",
            "latest_calls.c"
        ],
        [
            "LOAD_ATTR",
            "latest_calls.c.name"
        ],
        [
            "COMPARE_OP",
            "filtered_calls.c.name == latest_calls.c.name"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c.start_time"
        ],
        [
            "LOAD_ATTR",
            "latest_calls.c"
        ],
        [
            "LOAD_ATTR",
            "latest_calls.c.maxtime"
        ],
        [
            "COMPARE_OP",
            "filtered_calls.c.start_time == latest_calls.c.maxtime"
        ],
        [
            "CALL_METHOD",
            "sqlalchemy.and_(\n            filtered_calls.c.name == latest_calls.c.name,\n            filtered_calls.c.start_time == latest_calls.c.maxtime,\n        )"
        ],
        [
            "CALL_METHOD",
            "session.query(filtered_calls).join(\n        latest_calls,\n        sqlalchemy.and_(\n            filtered_calls.c.name == latest_calls.c.name,\n            filtered_calls.c.start_time == latest_calls.c.maxtime,\n        )\n    )"
        ],
        [
            "LOAD_METHOD",
            "session.query(filtered_calls).join(\n        latest_calls,\n        sqlalchemy.and_(\n            filtered_calls.c.name == latest_calls.c.name,\n            filtered_calls.c.start_time == latest_calls.c.maxtime,\n        )\n    ).order_by"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c.start_time"
        ],
        [
            "LOAD_METHOD",
            "filtered_calls.c.start_time.desc"
        ],
        [
            "CALL_METHOD",
            "filtered_calls.c.start_time.desc()"
        ],
        [
            "CALL_METHOD",
            "session.query(filtered_calls).join(\n        latest_calls,\n        sqlalchemy.and_(\n            filtered_calls.c.name == latest_calls.c.name,\n            filtered_calls.c.start_time == latest_calls.c.maxtime,\n        )\n    ).order_by(filtered_calls.c.start_time.desc())"
        ],
        [
            "CALL_FUNCTION",
            "group_by_attr(query, 'type')"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "LOAD_ATTR",
            "Function.name"
        ],
        [
            "LOAD_ATTR",
            "Function.type"
        ],
        [
            "CALL_METHOD",
            "session.query(Function.name, Function.type)"
        ],
        [
            "LOAD_ATTR",
            "session.query(Function.name, Function.type)\n                       .filter_by"
        ],
        [
            "CALL_FUNCTION_KW",
            "session.query(Function.name, Function.type)\n                       .filter_by(file=path)"
        ],
        [
            "LOAD_METHOD",
            "session.query(Function.name, Function.type)\n                       .filter_by(file=path)\n                       .distinct"
        ],
        [
            "CALL_METHOD",
            "session.query(Function.name, Function.type)\n                       .filter_by(file=path)\n                       .distinct()"
        ],
        [
            "CALL_FUNCTION",
            "sorted(session.query(Function.name, Function.type)\n                       .filter_by(file=path)\n                       .distinct())"
        ],
        [
            "LOAD_ATTR",
            "func.name"
        ],
        [
            "CONTAINS_OP",
            "func.name not in func_names"
        ],
        [
            "LOAD_ATTR",
            "func.type"
        ],
        [
            "BINARY_SUBSCR",
            "funcs[func.type]"
        ],
        [
            "LOAD_METHOD",
            "funcs[func.type].append"
        ],
        [
            "CALL_METHOD",
            "funcs[func.type].append(func)"
        ],
        [
            "COMPARE_OP",
            "path == IPYTHON_FILE_PATH"
        ],
        [
            "CALL_FUNCTION",
            "basename(path)"
        ],
        [
            "CALL_FUNCTION_KW",
            "render_template('file.html',\n                           funcs=funcs,\n                           is_ipython=path == IPYTHON_FILE_PATH,\n                           full_path=path,\n                           short_path=basename(path))"
        ],
        [
            "LOAD_ATTR",
            "row.name"
        ],
        [
            "CALL_FUNCTION",
            "fix_abs_path(path)"
        ],
        [
            "CALL_FUNCTION",
            "get_calls(session, path, func_name, 200)"
        ],
        [
            "BINARY_SUBSCR",
            "query[0]"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "CALL_METHOD",
            "session.query(Function)"
        ],
        [
            "LOAD_ATTR",
            "session.query(Function).filter_by"
        ],
        [
            "CALL_FUNCTION_KW",
            "session.query(Function).filter_by(file=path, name=func_name)"
        ],
        [
            "BINARY_SUBSCR",
            "session.query(Function).filter_by(file=path, name=func_name)[0]"
        ],
        [
            "CALL_FUNCTION",
            "basename(path)"
        ],
        [
            "CALL_FUNCTION_KW",
            "render_template('function.html',\n                           func=func,\n                           short_path=basename(path),\n                           calls=calls)"
        ],
        [
            "CALL_FUNCTION",
            "Call()"
        ],
        [
            "LOAD_METHOD",
            "row._asdict"
        ],
        [
            "CALL_METHOD",
            "row._asdict()"
        ],
        [
            "CALL_FUNCTION_EX",
            "withattrs(Call(), **row._asdict())"
        ],
        [
            "CALL_FUNCTION",
            "fix_abs_path(path)"
        ],
        [
            "CALL_FUNCTION",
            "get_calls(session, path, func_name, 1)"
        ],
        [
            "BINARY_SUBSCR",
            "get_calls(session, path, func_name, 1)[0]"
        ],
        [
            "LOAD_ATTR",
            "call.id"
        ],
        [
            "LOAD_ATTR",
            "call_view.__name__"
        ],
        [
            "LOAD_ATTR",
            "call.id"
        ],
        [
            "CALL_FUNCTION_KW",
            "url_for(call_view.__name__,\n                    call_id=call.id)"
        ],
        [
            "CALL_FUNCTION_KW",
            "dict(\n        id=call.id,\n        url=url_for(call_view.__name__,\n                    call_id=call.id),\n    )"
        ],
        [
            "CALL_FUNCTION",
            "jsonify(dict(\n        id=call.id,\n        url=url_for(call_view.__name__,\n                    call_id=call.id),\n    ))"
        ],
        [
            "LOAD_ATTR",
            "session.query"
        ],
        [
            "LOAD_ATTR",
            "Call.basic_columns"
        ],
        [
            "LOAD_ATTR",
            "Function.basic_columns"
        ],
        [
            "BINARY_ADD",
            "Call.basic_columns + Function.basic_columns"
        ],
        [
            "CALL_FUNCTION_EX",
            "session.query(*(Call.basic_columns + Function.basic_columns))"
        ],
        [
            "LOAD_METHOD",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                .join"
        ],
        [
            "CALL_METHOD",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                .join(Function)"
        ],
        [
            "LOAD_ATTR",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                .join(Function)\n                .filter_by"
        ],
        [
            "CALL_FUNCTION_KW",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                .join(Function)\n                .filter_by(file=path, name=func_name)"
        ],
        [
            "LOAD_METHOD",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                .join(Function)\n                .filter_by(file=path, name=func_name)\n                .order_by"
        ],
        [
            "LOAD_ATTR",
            "Call.start_time"
        ],
        [
            "LOAD_METHOD",
            "Call.start_time.desc"
        ],
        [
            "CALL_METHOD",
            "Call.start_time.desc()"
        ],
        [
            "CALL_METHOD",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                .join(Function)\n                .filter_by(file=path, name=func_name)\n                .order_by(Call.start_time.desc())"
        ],
        [
            "BINARY_SUBSCR",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                .join(Function)\n                .filter_by(file=path, name=func_name)\n                .order_by(Call.start_time.desc())[:limit]"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "CALL_METHOD",
            "session.query(Call)"
        ],
        [
            "LOAD_ATTR",
            "session.query(Call).filter_by"
        ],
        [
            "CALL_FUNCTION_KW",
            "session.query(Call).filter_by(id=call_id)"
        ],
        [
            "LOAD_METHOD",
            "session.query(Call).filter_by(id=call_id).one"
        ],
        [
            "CALL_METHOD",
            "session.query(Call).filter_by(id=call_id).one()"
        ],
        [
            "LOAD_ATTR",
            "call.function"
        ],
        [
            "LOAD_ATTR",
            "func.file"
        ],
        [
            "CALL_FUNCTION",
            "basename(func.file)"
        ],
        [
            "CALL_FUNCTION_KW",
            "render_template(template,\n                           short_path=basename(func.file),\n                           call=call,\n                           func=func)"
        ],
        [
            "CALL_FUNCTION",
            "base_call_view(call_id, 'call.html')"
        ],
        [
            "CALL_FUNCTION",
            "base_call_view(call_id, 'ipython_call.html')"
        ],
        [
            "CALL_FUNCTION_KW",
            "render_template('ipython_iframe.html',\n                           container_id='1234',\n                           port=7777,\n                           call_id=call_id)"
        ],
        [
            "LOAD_ATTR",
            "request.environ"
        ],
        [
            "LOAD_METHOD",
            "request.environ.get"
        ],
        [
            "CALL_METHOD",
            "request.environ.get('werkzeug.server.shutdown')"
        ],
        [
            "IS_OP",
            "func is None"
        ],
        [
            "CALL_FUNCTION",
            "RuntimeError('Not running with the Werkzeug Server')"
        ],
        [
            "CALL_FUNCTION",
            "func()"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "CALL_METHOD",
            "session.query(Call)"
        ],
        [
            "LOAD_ATTR",
            "session.query(Call).filter_by"
        ],
        [
            "CALL_FUNCTION_KW",
            "session.query(Call).filter_by(id=call_id)"
        ],
        [
            "LOAD_METHOD",
            "session.query(Call).filter_by(id=call_id).one"
        ],
        [
            "CALL_METHOD",
            "session.query(Call).filter_by(id=call_id).one()"
        ],
        [
            "LOAD_ATTR",
            "call.function"
        ],
        [
            "CALL_FUNCTION",
            "DecentJSONEncoder()"
        ],
        [
            "LOAD_METHOD",
            "DecentJSONEncoder().encode"
        ],
        [
            "LOAD_ATTR",
            "call.parsed_data"
        ],
        [
            "LOAD_METHOD",
            "Call.basic_dict"
        ],
        [
            "CALL_METHOD",
            "Call.basic_dict(call)"
        ],
        [
            "CALL_FUNCTION_EX",
            "dict(data=call.parsed_data, **Call.basic_dict(call))"
        ],
        [
            "LOAD_ATTR",
            "func.parsed_data"
        ],
        [
            "LOAD_METHOD",
            "Function.basic_dict"
        ],
        [
            "CALL_METHOD",
            "Function.basic_dict(func)"
        ],
        [
            "CALL_FUNCTION_EX",
            "dict(data=func.parsed_data, **Function.basic_dict(func))"
        ],
        [
            "CALL_FUNCTION_KW",
            "dict(\n        call=dict(data=call.parsed_data, **Call.basic_dict(call)),\n        function=dict(data=func.parsed_data, **Function.basic_dict(func)))"
        ],
        [
            "CALL_METHOD",
            "DecentJSONEncoder().encode(dict(\n        call=dict(data=call.parsed_data, **Call.basic_dict(call)),\n        function=dict(data=func.parsed_data, **Function.basic_dict(func))))"
        ],
        [
            "LOAD_ATTR",
            "session.query"
        ],
        [
            "LOAD_ATTR",
            "Call.basic_columns"
        ],
        [
            "LOAD_ATTR",
            "Function.data"
        ],
        [
            "BINARY_ADD",
            "Call.basic_columns + (Function.data,)"
        ],
        [
            "CALL_FUNCTION_EX",
            "session.query(*Call.basic_columns + (Function.data,))"
        ],
        [
            "LOAD_METHOD",
            "session.query(*Call.basic_columns + (Function.data,))\n                 .join"
        ],
        [
            "CALL_METHOD",
            "session.query(*Call.basic_columns + (Function.data,))\n                 .join(Function)"
        ],
        [
            "LOAD_ATTR",
            "session.query(*Call.basic_columns + (Function.data,))\n                 .join(Function)\n                 .filter_by"
        ],
        [
            "CALL_FUNCTION_KW",
            "session.query(*Call.basic_columns + (Function.data,))\n                 .join(Function)\n                 .filter_by(body_hash=body_hash)"
        ],
        [
            "LOAD_METHOD",
            "session.query(*Call.basic_columns + (Function.data,))\n                 .join(Function)\n                 .filter_by(body_hash=body_hash)\n                 .order_by"
        ],
        [
            "LOAD_ATTR",
            "Call.start_time"
        ],
        [
            "LOAD_METHOD",
            "Call.start_time.desc"
        ],
        [
            "CALL_METHOD",
            "Call.start_time.desc()"
        ],
        [
            "CALL_METHOD",
            "session.query(*Call.basic_columns + (Function.data,))\n                 .join(Function)\n                 .filter_by(body_hash=body_hash)\n                 .order_by(Call.start_time.desc())"
        ],
        [
            "BINARY_SUBSCR",
            "session.query(*Call.basic_columns + (Function.data,))\n                 .join(Function)\n                 .filter_by(body_hash=body_hash)\n                 .order_by(Call.start_time.desc())[:200]"
        ],
        [
            "CALL_FUNCTION",
            "set()"
        ],
        [
            "CALL_FUNCTION",
            "set()"
        ],
        [
            "LOAD_METHOD",
            "json.loads"
        ],
        [
            "CALL_METHOD",
            "json.loads(function_data)"
        ],
        [
            "CALL_FUNCTION",
            "add('node_ranges', ranges)"
        ],
        [
            "CALL_FUNCTION",
            "set()"
        ],
        [
            "CALL_FUNCTION",
            "add('loop_ranges', current_loop_ranges)"
        ],
        [
            "CALL_FUNCTION",
            "set()"
        ],
        [
            "CONTAINS_OP",
            "loop_ranges in (set(), current_loop_ranges)"
        ],
        [
            "CALL_FUNCTION",
            "DecentJSONEncoder()"
        ],
        [
            "LOAD_METHOD",
            "DecentJSONEncoder().encode"
        ],
        [
            "CALL_FUNCTION_KW",
            "dict(\n        calls=calls, ranges=ranges, loop_ranges=loop_ranges)"
        ],
        [
            "CALL_METHOD",
            "DecentJSONEncoder().encode(dict(\n        calls=calls, ranges=ranges, loop_ranges=loop_ranges))"
        ],
        [
            "LOAD_METHOD",
            "Call.basic_dict"
        ],
        [
            "CALL_FUNCTION",
            "Call()"
        ],
        [
            "LOAD_METHOD",
            "row._asdict"
        ],
        [
            "CALL_METHOD",
            "row._asdict()"
        ],
        [
            "CALL_FUNCTION_EX",
            "withattrs(Call(), **row._asdict())"
        ],
        [
            "CALL_METHOD",
            "Call.basic_dict(withattrs(Call(), **row._asdict()))"
        ],
        [
            "LOAD_ATTR",
            "row.data"
        ],
        [
            "BINARY_SUBSCR",
            "function_data[key]"
        ],
        [
            "LOAD_METHOD",
            "ranges_set.add"
        ],
        [
            "BINARY_SUBSCR",
            "node['start']"
        ],
        [
            "BINARY_SUBSCR",
            "node['end']"
        ],
        [
            "CALL_METHOD",
            "ranges_set.add((node['start'], node['end']))"
        ],
        [
            "CALL_FUNCTION_KW",
            "dict(start=start, end=end)"
        ],
        [
            "CALL_FUNCTION_KW",
            "dict(start=start, end=end)"
        ],
        [
            "LOAD_METHOD",
            "request.get_json"
        ],
        [
            "CALL_METHOD",
            "request.get_json()"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "LOAD_ATTR",
            "Function.body_hash"
        ],
        [
            "LOAD_ATTR",
            "sqlalchemy.func"
        ],
        [
            "LOAD_METHOD",
            "sqlalchemy.func.count"
        ],
        [
            "LOAD_ATTR",
            "Call.id"
        ],
        [
            "CALL_METHOD",
            "sqlalchemy.func.count(Call.id)"
        ],
        [
            "CALL_METHOD",
            "session.query(Function.body_hash, sqlalchemy.func.count(Call.id))"
        ],
        [
            "LOAD_METHOD",
            "session.query(Function.body_hash, sqlalchemy.func.count(Call.id))\n             .outerjoin"
        ],
        [
            "CALL_METHOD",
            "session.query(Function.body_hash, sqlalchemy.func.count(Call.id))\n             .outerjoin(Call)"
        ],
        [
            "LOAD_METHOD",
            "session.query(Function.body_hash, sqlalchemy.func.count(Call.id))\n             .outerjoin(Call)\n             .filter"
        ],
        [
            "LOAD_ATTR",
            "Function.body_hash"
        ],
        [
            "LOAD_METHOD",
            "Function.body_hash.in_"
        ],
        [
            "CALL_METHOD",
            "Function.body_hash.in_(hashes)"
        ],
        [
            "CALL_METHOD",
            "session.query(Function.body_hash, sqlalchemy.func.count(Call.id))\n             .outerjoin(Call)\n             .filter(Function.body_hash.in_(hashes))"
        ],
        [
            "LOAD_METHOD",
            "session.query(Function.body_hash, sqlalchemy.func.count(Call.id))\n             .outerjoin(Call)\n             .filter(Function.body_hash.in_(hashes))\n             .group_by"
        ],
        [
            "LOAD_ATTR",
            "Function.body_hash"
        ],
        [
            "CALL_METHOD",
            "session.query(Function.body_hash, sqlalchemy.func.count(Call.id))\n             .outerjoin(Call)\n             .filter(Function.body_hash.in_(hashes))\n             .group_by(Function.body_hash)"
        ],
        [
            "CALL_FUNCTION",
            "DecentJSONEncoder()"
        ],
        [
            "LOAD_METHOD",
            "DecentJSONEncoder().encode"
        ],
        [
            "CALL_METHOD",
            "DecentJSONEncoder().encode([\n        dict(hash=h, count=count)\n        for h, count in query\n    ])"
        ],
        [
            "CALL_FUNCTION_KW",
            "dict(hash=h, count=count)"
        ],
        [
            "CALL_FUNCTION",
            "len(argv)"
        ],
        [
            "COMPARE_OP",
            "len(argv) == 1"
        ],
        [
            "BINARY_SUBSCR",
            "argv[0]"
        ],
        [
            "LOAD_METHOD",
            "argv[0].isdigit"
        ],
        [
            "CALL_METHOD",
            "argv[0].isdigit()"
        ],
        [
            "LOAD_METHOD",
            "argv.insert"
        ],
        [
            "CALL_METHOD",
            "argv.insert(0, '--port')"
        ],
        [
            "LOAD_ATTR",
            "argparse.ArgumentParser"
        ],
        [
            "CALL_FUNCTION_KW",
            "argparse.ArgumentParser(description=\"Bird's Eye: A graphical Python debugger\")"
        ],
        [
            "LOAD_ATTR",
            "parser.add_argument"
        ],
        [
            "CALL_FUNCTION_KW",
            "parser.add_argument('-p', '--port', help='HTTP port, default is 7777', default=7777, type=int)"
        ],
        [
            "LOAD_ATTR",
            "parser.add_argument"
        ],
        [
            "CALL_FUNCTION_KW",
            "parser.add_argument('--host', help=\"HTTP host, default is 'localhost'\", default='localhost')"
        ],
        [
            "LOAD_METHOD",
            "parser.parse_args"
        ],
        [
            "CALL_METHOD",
            "parser.parse_args(argv)"
        ],
        [
            "LOAD_ATTR",
            "app.run"
        ],
        [
            "LOAD_ATTR",
            "args.port"
        ],
        [
            "LOAD_ATTR",
            "args.host"
        ],
        [
            "LOAD_ATTR",
            "os.environ"
        ],
        [
            "LOAD_METHOD",
            "os.environ.get"
        ],
        [
            "CALL_METHOD",
            "os.environ.get('BIRDSEYE_RELOADER')"
        ],
        [
            "COMPARE_OP",
            "os.environ.get('BIRDSEYE_RELOADER') == '1'"
        ],
        [
            "CALL_FUNCTION_KW",
            "app.run(\n        port=args.port,\n        host=args.host,\n        use_reloader=os.environ.get('BIRDSEYE_RELOADER') == '1',\n    )"
        ]
    ],
    "tests.py": [
        [
            "LOAD_ATTR",
            "unittest.TestCase"
        ],
        [
            "LOAD_ATTR",
            "unittest.TestCase"
        ],
        [
            "CALL_FUNCTION",
            "TestFile()"
        ],
        [
            "LOAD_METHOD",
            "TestFile().test_file"
        ],
        [
            "CALL_METHOD",
            "TestFile().test_file()"
        ],
        [
            "CALL_FUNCTION",
            "Tester()"
        ],
        [
            "CALL_FUNCTION",
            "tester([1, 2, 3])"
        ],
        [
            "COMPARE_OP",
            "tester([1, 2, 3]) == [1, 2, 3]"
        ],
        [
            "LOAD_ATTR",
            "tester.asd"
        ],
        [
            "IS_OP",
            "tester.asd is tester"
        ],
        [
            "BINARY_SUBSCR",
            "tester[19]"
        ],
        [
            "IS_OP",
            "tester[19] is tester"
        ],
        [
            "BINARY_POWER",
            "tester ** 4"
        ],
        [
            "IS_OP",
            "tester ** 4 is tester"
        ],
        [
            "BINARY_MULTIPLY",
            "tester * 3"
        ],
        [
            "IS_OP",
            "tester * 3 is tester"
        ],
        [
            "BINARY_SUBTRACT",
            "tester - 2"
        ],
        [
            "IS_OP",
            "tester - 2 is tester"
        ],
        [
            "BINARY_ADD",
            "tester + 1"
        ],
        [
            "IS_OP",
            "tester + 1 is tester"
        ],
        [
            "UNARY_NEGATIVE",
            "-tester"
        ],
        [
            "IS_OP",
            "-tester is tester"
        ],
        [
            "UNARY_POSITIVE",
            "+tester"
        ],
        [
            "IS_OP",
            "+tester is tester"
        ],
        [
            "UNARY_INVERT",
            "~tester"
        ],
        [
            "IS_OP",
            "~tester is tester"
        ],
        [
            "COMPARE_OP",
            "tester < 7"
        ],
        [
            "IS_OP",
            "(tester < 7) is tester"
        ],
        [
            "COMPARE_OP",
            "tester >= 78"
        ],
        [
            "IS_OP",
            "(tester >= 78) is tester"
        ],
        [
            "COMPARE_OP",
            "tester != 79"
        ],
        [
            "IS_OP",
            "(tester != 79) is tester"
        ],
        [
            "LOAD_METHOD",
            "tester.foo"
        ],
        [
            "CALL_METHOD",
            "tester.foo(45, False)"
        ],
        [
            "COMPARE_OP",
            "tester.foo(45, False) == 45"
        ],
        [
            "COMPARE_OP",
            "__name__ == '__main__'"
        ],
        [
            "LOAD_METHOD",
            "unittest.main"
        ],
        [
            "CALL_METHOD",
            "unittest.main()"
        ],
        [
            "CALL_FUNCTION",
            "tester(1)"
        ],
        [
            "CALL_FUNCTION",
            "tester(2)"
        ],
        [
            "CALL_FUNCTION",
            "tester(3)"
        ],
        [
            "CALL_FUNCTION",
            "tester(9\n               )"
        ],
        [
            "CALL_FUNCTION",
            "tester(\n            8)"
        ],
        [
            "CALL_FUNCTION",
            "tester(\n            99\n        )"
        ],
        [
            "CALL_FUNCTION",
            "tester(33)"
        ],
        [
            "CALL_FUNCTION",
            "tester([4,\n                               5, 6, [\n                                7]])"
        ],
        [
            "CALL_FUNCTION",
            "tester('123')"
        ],
        [
            "CALL_FUNCTION",
            "int()"
        ],
        [
            "CALL_FUNCTION_KW",
            "decorator_with_args(tester('123'), x=int())"
        ],
        [
            "CALL_FUNCTION",
            "tuple([1, 2])"
        ],
        [
            "CALL_FUNCTION",
            "list(tuple([1, 2]))"
        ],
        [
            "CALL_FUNCTION_KW",
            "tester(list(tuple([1, 2])), returns=empty_decorator)"
        ],
        [
            "CALL_FUNCTION",
            "tuple(\n                    [3, 4])"
        ],
        [
            "CALL_FUNCTION",
            "list(\n                tuple(\n                    [3, 4]))"
        ],
        [
            "CALL_FUNCTION_KW",
            "tester(\n            list(\n                tuple(\n                    [3, 4])),\n            returns=empty_decorator)"
        ],
        [
            "CALL_FUNCTION",
            "str()"
        ],
        [
            "CALL_FUNCTION",
            "int()"
        ],
        [
            "CALL_FUNCTION_KW",
            "decorator_with_args(\n            str(),\n            x=int())"
        ],
        [
            "CALL_FUNCTION",
            "tuple([5, 6])"
        ],
        [
            "CALL_FUNCTION",
            "list(tuple([5, 6]))"
        ],
        [
            "CALL_FUNCTION_KW",
            "tester(list(tuple([5, 6])), returns=empty_decorator)"
        ],
        [
            "CALL_FUNCTION",
            "tuple([7, 8])"
        ],
        [
            "CALL_FUNCTION",
            "list(tuple([7, 8]))"
        ],
        [
            "CALL_FUNCTION_KW",
            "tester(list(tuple([7, 8])), returns=empty_decorator)"
        ],
        [
            "CALL_FUNCTION",
            "tester('sdf')"
        ],
        [
            "CALL_FUNCTION",
            "tester('123234')"
        ],
        [
            "CALL_FUNCTION_KW",
            "decorator_with_args(tester('sdf'), x=tester('123234'))"
        ],
        [
            "CALL_FUNCTION",
            "str([{tester(x) for x in [1]}, {tester(y) for y in [1]}])"
        ],
        [
            "CALL_FUNCTION",
            "str([{tester(x) for x in [1]},\n             {tester(x) for x in [1]}])"
        ],
        [
            "CALL_FUNCTION",
            "list(tester(x) for x in [1])"
        ],
        [
            "CALL_FUNCTION",
            "str([{tester(x) for x in [1]}, list(tester(x) for x in [1])])"
        ],
        [
            "CALL_FUNCTION",
            "tester(x)"
        ],
        [
            "CALL_FUNCTION",
            "tester(y)"
        ],
        [
            "CALL_FUNCTION",
            "tester(x)"
        ],
        [
            "CALL_FUNCTION",
            "tester(x)"
        ],
        [
            "CALL_FUNCTION",
            "tester(x)"
        ],
        [
            "CALL_FUNCTION",
            "tester(x)"
        ],
        [
            "LOAD_METHOD",
            "self.assertEqual"
        ],
        [
            "CALL_FUNCTION",
            "tester(3)"
        ],
        [
            "CALL_FUNCTION",
            "(lambda x: (tester(x), tester(x)))(tester(3))"
        ],
        [
            "CALL_METHOD",
            "self.assertEqual(\n            (lambda x: (tester(x), tester(x)))(tester(3)),\n            (3, 3),\n        )"
        ],
        [
            "CALL_FUNCTION",
            "(lambda: (lambda: tester(1))())()"
        ],
        [
            "LOAD_METHOD",
            "self.assertEqual"
        ],
        [
            "CALL_FUNCTION",
            "(lambda: [tester(x) for x in tester([1, 2])])()"
        ],
        [
            "CALL_METHOD",
            "self.assertEqual(\n            (lambda: [tester(x) for x in tester([1, 2])])(),\n            [1, 2],\n        )"
        ],
        [
            "CALL_FUNCTION",
            "tester(x)"
        ],
        [
            "CALL_FUNCTION",
            "tester(x)"
        ],
        [
            "CALL_FUNCTION",
            "(lambda: tester(1))()"
        ],
        [
            "CALL_FUNCTION",
            "tester(1)"
        ],
        [
            "CALL_FUNCTION",
            "tester([1, 2])"
        ],
        [
            "CALL_FUNCTION",
            "tester(x)"
        ],
        [
            "CALL_FUNCTION",
            "tester([5, 6])"
        ],
        [
            "CALL_FUNCTION",
            "str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
        ],
        [
            "CALL_FUNCTION",
            "foo()"
        ],
        [
            "BINARY_ADD",
            "a+x"
        ],
        [
            "CALL_FUNCTION",
            "tester(a+x)"
        ],
        [
            "CALL_FUNCTION",
            "tester([3, 4])"
        ],
        [
            "BINARY_ADD",
            "b+x"
        ],
        [
            "CALL_FUNCTION",
            "tester(b+x)"
        ],
        [
            "CALL_FUNCTION",
            "tester([1, 2])"
        ],
        [
            "BINARY_ADD",
            "c+x"
        ],
        [
            "CALL_FUNCTION",
            "tester(c+x)"
        ],
        [
            "CALL_FUNCTION",
            "tester([5, 6])"
        ],
        [
            "CALL_FUNCTION",
            "str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
        ],
        [
            "CALL_FUNCTION",
            "tester([5, 6])"
        ],
        [
            "CALL_FUNCTION",
            "str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
        ],
        [
            "CALL_FUNCTION",
            "tester([5, 6])"
        ],
        [
            "CALL_FUNCTION",
            "str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
        ],
        [
            "CALL_FUNCTION",
            "bar()"
        ],
        [
            "BINARY_ADD",
            "a+x"
        ],
        [
            "CALL_FUNCTION",
            "tester(a+x)"
        ],
        [
            "CALL_FUNCTION",
            "tester([3, 4])"
        ],
        [
            "BINARY_ADD",
            "b+x"
        ],
        [
            "CALL_FUNCTION",
            "tester(b+x)"
        ],
        [
            "CALL_FUNCTION",
            "tester([1, 2])"
        ],
        [
            "BINARY_ADD",
            "c+x"
        ],
        [
            "CALL_FUNCTION",
            "tester(c+x)"
        ],
        [
            "BINARY_ADD",
            "a+y"
        ],
        [
            "CALL_FUNCTION",
            "tester(a+y)"
        ],
        [
            "CALL_FUNCTION",
            "tester([3, 4])"
        ],
        [
            "BINARY_ADD",
            "b+y"
        ],
        [
            "CALL_FUNCTION",
            "tester(b+y)"
        ],
        [
            "CALL_FUNCTION",
            "tester([1, 2])"
        ],
        [
            "BINARY_ADD",
            "c+y"
        ],
        [
            "CALL_FUNCTION",
            "tester(c+y)"
        ],
        [
            "BINARY_ADD",
            "a+x"
        ],
        [
            "BINARY_ADD",
            "a+x+y"
        ],
        [
            "CALL_FUNCTION",
            "tester(a+x+y)"
        ],
        [
            "CALL_FUNCTION",
            "tester([3, 4])"
        ],
        [
            "BINARY_ADD",
            "b+x"
        ],
        [
            "BINARY_ADD",
            "b+x+y"
        ],
        [
            "CALL_FUNCTION",
            "tester(b+x+y)"
        ],
        [
            "CALL_FUNCTION",
            "tester([1, 2])"
        ],
        [
            "BINARY_ADD",
            "c+x"
        ],
        [
            "BINARY_ADD",
            "c+x+y"
        ],
        [
            "CALL_FUNCTION",
            "tester(c+x+y)"
        ],
        [
            "CALL_FUNCTION",
            "tester([5, 6])"
        ],
        [
            "CALL_FUNCTION",
            "str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
        ],
        [
            "CALL_FUNCTION",
            "tester([5, 6])"
        ],
        [
            "CALL_FUNCTION",
            "str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
        ],
        [
            "CALL_FUNCTION",
            "tester([5, 6])"
        ],
        [
            "CALL_FUNCTION",
            "str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
        ],
        [
            "CALL_FUNCTION",
            "tester([5, 6])"
        ],
        [
            "CALL_FUNCTION",
            "str({tester(a+x+y+z): {tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
        ],
        [
            "BINARY_ADD",
            "a+x"
        ],
        [
            "CALL_FUNCTION",
            "tester(a+x)"
        ],
        [
            "CALL_FUNCTION",
            "tester([3, 4])"
        ],
        [
            "BINARY_ADD",
            "b+x"
        ],
        [
            "CALL_FUNCTION",
            "tester(b+x)"
        ],
        [
            "CALL_FUNCTION",
            "tester([1, 2])"
        ],
        [
            "BINARY_ADD",
            "c+x"
        ],
        [
            "CALL_FUNCTION",
            "tester(c+x)"
        ],
        [
            "BINARY_ADD",
            "a+y"
        ],
        [
            "CALL_FUNCTION",
            "tester(a+y)"
        ],
        [
            "CALL_FUNCTION",
            "tester([3, 4])"
        ],
        [
            "BINARY_ADD",
            "b+y"
        ],
        [
            "CALL_FUNCTION",
            "tester(b+y)"
        ],
        [
            "CALL_FUNCTION",
            "tester([1, 2])"
        ],
        [
            "BINARY_ADD",
            "c+y"
        ],
        [
            "CALL_FUNCTION",
            "tester(c+y)"
        ],
        [
            "BINARY_ADD",
            "a+x"
        ],
        [
            "BINARY_ADD",
            "a+x+y"
        ],
        [
            "CALL_FUNCTION",
            "tester(a+x+y)"
        ],
        [
            "CALL_FUNCTION",
            "tester([3, 4])"
        ],
        [
            "BINARY_ADD",
            "b+x"
        ],
        [
            "BINARY_ADD",
            "b+x+y"
        ],
        [
            "CALL_FUNCTION",
            "tester(b+x+y)"
        ],
        [
            "CALL_FUNCTION",
            "tester([1, 2])"
        ],
        [
            "BINARY_ADD",
            "c+x"
        ],
        [
            "BINARY_ADD",
            "c+x+y"
        ],
        [
            "CALL_FUNCTION",
            "tester(c+x+y)"
        ],
        [
            "BINARY_ADD",
            "a+x"
        ],
        [
            "BINARY_ADD",
            "a+x+y"
        ],
        [
            "BINARY_ADD",
            "a+x+y+z"
        ],
        [
            "CALL_FUNCTION",
            "tester(a+x+y+z)"
        ],
        [
            "CALL_FUNCTION",
            "tester([3, 4])"
        ],
        [
            "BINARY_ADD",
            "b+x"
        ],
        [
            "BINARY_ADD",
            "b+x+y"
        ],
        [
            "BINARY_ADD",
            "b+x+y+z"
        ],
        [
            "CALL_FUNCTION",
            "tester(b+x+y+z)"
        ],
        [
            "CALL_FUNCTION",
            "tester([1, 2])"
        ],
        [
            "BINARY_ADD",
            "c+x"
        ],
        [
            "BINARY_ADD",
            "c+x+y"
        ],
        [
            "BINARY_ADD",
            "c+x+y+z"
        ],
        [
            "CALL_FUNCTION",
            "tester(c+x+y+z)"
        ],
        [
            "CALL_FUNCTION_KW",
            "dict(x=tester)"
        ],
        [
            "BINARY_SUBSCR",
            "dict(x=tester)['x']"
        ],
        [
            "CALL_FUNCTION",
            "dict(x=tester)['x'](tester)"
        ],
        [
            "CALL_FUNCTION_KW",
            "dict(x=tester)['x'](tester)(3, check_func=False)"
        ],
        [
            "LOAD_METHOD",
            "self.assertRaises"
        ],
        [
            "CALL_METHOD",
            "self.assertRaises(TypeError)"
        ],
        [
            "CALL_FUNCTION",
            "tester([1, 2, 3])"
        ],
        [
            "CALL_FUNCTION",
            "tester(0)"
        ],
        [
            "CALL_FUNCTION",
            "tester(4)"
        ],
        [
            "CALL_FUNCTION",
            "tester(5)"
        ],
        [
            "CALL_FUNCTION",
            "tester(ValueError)"
        ],
        [
            "CALL_FUNCTION",
            "tester(9)"
        ],
        [
            "CALL_FUNCTION",
            "tester(10)"
        ],
        [
            "CALL_FUNCTION",
            "tester(10)"
        ],
        [
            "CALL_FUNCTION",
            "str()"
        ],
        [
            "LOAD_METHOD",
            "self.assertRaises"
        ],
        [
            "CALL_FUNCTION",
            "tester(Exception)"
        ],
        [
            "CALL_METHOD",
            "self.assertRaises(tester(Exception))"
        ],
        [
            "CALL_FUNCTION",
            "tester(0)"
        ],
        [
            "CALL_FUNCTION",
            "tester(0)"
        ],
        [
            "BINARY_TRUE_DIVIDE",
            "1 / 0"
        ],
        [
            "CALL_FUNCTION",
            "tester(1 / 0)"
        ],
        [
            "CALL_FUNCTION",
            "tester([1, 2])"
        ],
        [
            "CALL_FUNCTION",
            "gen()"
        ],
        [
            "CALL_FUNCTION",
            "list(gen())"
        ],
        [
            "CALL_FUNCTION",
            "list(gen2)"
        ],
        [
            "CALL_FUNCTION",
            "tester(x)"
        ],
        [
            "CALL_FUNCTION",
            "tester(x)"
        ],
        [
            "CALL_FUNCTION",
            "tester(4)"
        ],
        [
            "LOAD_METHOD",
            "time.time"
        ],
        [
            "CALL_METHOD",
            "time.time()"
        ],
        [
            "CALL_FUNCTION",
            "range(10000)"
        ],
        [
            "LOAD_METHOD",
            "Source.executing"
        ],
        [
            "LOAD_METHOD",
            "inspect.currentframe"
        ],
        [
            "CALL_METHOD",
            "inspect.currentframe()"
        ],
        [
            "CALL_METHOD",
            "Source.executing(inspect.currentframe())"
        ],
        [
            "LOAD_ATTR",
            "Source.executing(inspect.currentframe()).node"
        ],
        [
            "IS_OP",
            "node is None"
        ],
        [
            "LOAD_METHOD",
            "self.assertIs"
        ],
        [
            "CALL_METHOD",
            "self.assertIs(node, new_node)"
        ],
        [
            "LOAD_METHOD",
            "self.assertLess"
        ],
        [
            "LOAD_METHOD",
            "time.time"
        ],
        [
            "CALL_METHOD",
            "time.time()"
        ],
        [
            "BINARY_SUBTRACT",
            "time.time() - start"
        ],
        [
            "CALL_METHOD",
            "self.assertLess(time.time() - start, 1)"
        ],
        [
            "CALL_FUNCTION",
            "check(u'# coding=utf8\\n\u00e9', 'utf8')"
        ],
        [
            "CALL_FUNCTION",
            "check(u'# coding=gbk\\n\u00e9', 'gbk')"
        ],
        [
            "CALL_FUNCTION_KW",
            "check(u'# coding=utf8\\n\u00e9', 'gbk', exception=UnicodeDecodeError)"
        ],
        [
            "CALL_FUNCTION_KW",
            "check(u'# coding=gbk\\n\u00e9', 'utf8', matches=False)"
        ],
        [
            "CALL_FUNCTION",
            "check(u'\u00e9', 'utf8')"
        ],
        [
            "CALL_FUNCTION_KW",
            "check(u'\u00e9', 'gbk', exception=SyntaxError)"
        ],
        [
            "LOAD_METHOD",
            "source.encode"
        ],
        [
            "CALL_METHOD",
            "source.encode(encoding)"
        ],
        [
            "LOAD_METHOD",
            "self.assertRaises"
        ],
        [
            "CALL_METHOD",
            "self.assertRaises(exception)"
        ],
        [
            "LOAD_METHOD",
            "Source.decode_source"
        ],
        [
            "CALL_METHOD",
            "Source.decode_source(encoded)"
        ],
        [
            "LOAD_METHOD",
            "Source.decode_source"
        ],
        [
            "CALL_METHOD",
            "Source.decode_source(encoded)"
        ],
        [
            "LOAD_METHOD",
            "self.assertEqual"
        ],
        [
            "CALL_METHOD",
            "self.assertEqual(decoded, source)"
        ],
        [
            "LOAD_METHOD",
            "self.assertNotEqual"
        ],
        [
            "CALL_METHOD",
            "self.assertNotEqual(decoded, source)"
        ],
        [
            "CALL_FUNCTION",
            "tester('a')"
        ],
        [
            "CALL_FUNCTION",
            "tester('''\n            ab''')"
        ],
        [
            "CALL_FUNCTION",
            "tester('''\n                    abc\n                    def\n                    '''\n               )"
        ],
        [
            "CALL_FUNCTION",
            "tester(\n                '''\n                123\n                456\n                '''\n            )"
        ],
        [
            "CALL_FUNCTION",
            "tester(\n                '''\n                345\n                456786\n                '''\n            )"
        ],
        [
            "CALL_FUNCTION",
            "str([\n            tester(\n                '''\n                123\n                456\n                '''\n            ),\n            tester(\n                '''\n                345\n                456786\n                '''\n            ),\n        ])"
        ],
        [
            "CALL_FUNCTION",
            "tester(\n            [\n                '''\n                123\n                456\n                '''\n                '''\n                345\n                456786\n                '''\n                ,\n                '''\n                123\n                456\n                ''',\n                '''\n                345\n                456786\n                '''\n            ]\n        )"
        ],
        [
            "CALL_FUNCTION",
            "tester(1)"
        ],
        [
            "CALL_FUNCTION",
            "tester(2)"
        ],
        [
            "CALL_FUNCTION",
            "tester([1, 2])"
        ],
        [
            "CALL_FUNCTION",
            "tester(3)"
        ],
        [
            "LOAD_METHOD",
            "Source.for_filename"
        ],
        [
            "CALL_METHOD",
            "Source.for_filename(__file__)"
        ],
        [
            "LOAD_METHOD",
            "Source.for_filename(__file__).code_qualname"
        ],
        [
            "LOAD_ATTR",
            "func.__code__"
        ],
        [
            "CALL_METHOD",
            "Source.for_filename(__file__).code_qualname(func.__code__)"
        ],
        [
            "LOAD_METHOD",
            "self.assertEqual"
        ],
        [
            "CALL_METHOD",
            "self.assertEqual(qn, qualname)"
        ],
        [
            "LOAD_METHOD",
            "self.assertEqual"
        ],
        [
            "LOAD_ATTR",
            "func.__qualname__"
        ],
        [
            "CALL_METHOD",
            "self.assertEqual(qn, func.__qualname__)"
        ],
        [
            "LOAD_METHOD",
            "self.assertTrue"
        ],
        [
            "LOAD_METHOD",
            "qn.endswith"
        ],
        [
            "LOAD_ATTR",
            "func.__name__"
        ],
        [
            "CALL_METHOD",
            "qn.endswith(func.__name__)"
        ],
        [
            "CALL_METHOD",
            "self.assertTrue(qn.endswith(func.__name__))"
        ],
        [
            "LOAD_METHOD",
            "self.assert_qualname"
        ],
        [
            "LOAD_ATTR",
            "C.f"
        ],
        [
            "CALL_METHOD",
            "self.assert_qualname(C.f, 'C.f')"
        ],
        [
            "LOAD_METHOD",
            "self.assert_qualname"
        ],
        [
            "LOAD_ATTR",
            "C.D"
        ],
        [
            "LOAD_ATTR",
            "C.D.g"
        ],
        [
            "CALL_METHOD",
            "self.assert_qualname(C.D.g, 'C.D.g')"
        ],
        [
            "LOAD_METHOD",
            "self.assert_qualname"
        ],
        [
            "CALL_METHOD",
            "self.assert_qualname(f, 'f')"
        ],
        [
            "LOAD_METHOD",
            "self.assert_qualname"
        ],
        [
            "CALL_FUNCTION",
            "f()"
        ],
        [
            "CALL_METHOD",
            "self.assert_qualname(f(), 'f.<locals>.g')"
        ],
        [
            "LOAD_METHOD",
            "self.assert_qualname"
        ],
        [
            "LOAD_ATTR",
            "C.D"
        ],
        [
            "LOAD_METHOD",
            "C.D.h"
        ],
        [
            "CALL_METHOD",
            "C.D.h()"
        ],
        [
            "CALL_METHOD",
            "self.assert_qualname(C.D.h(), 'C.D.h.<locals>.i.<locals>.j')"
        ],
        [
            "LOAD_METHOD",
            "self.assert_qualname"
        ],
        [
            "CALL_METHOD",
            "self.assert_qualname(lamb, '<lambda>')"
        ],
        [
            "CALL_FUNCTION",
            "lambda_maker()"
        ],
        [
            "LOAD_METHOD",
            "self.assert_qualname"
        ],
        [
            "CALL_METHOD",
            "self.assert_qualname(foo, 'lambda_maker.<locals>.foo')"
        ],
        [
            "LOAD_METHOD",
            "self.assert_qualname"
        ],
        [
            "LOAD_ATTR",
            "foo.x"
        ],
        [
            "CALL_METHOD",
            "self.assert_qualname(foo.x, 'lambda_maker.<locals>.<lambda>')"
        ],
        [
            "LOAD_METHOD",
            "self.assert_qualname"
        ],
        [
            "CALL_FUNCTION",
            "foo()"
        ],
        [
            "CALL_METHOD",
            "self.assert_qualname(foo(), 'lambda_maker.<locals>.foo.<locals>.<lambda>')"
        ],
        [
            "LOAD_ATTR",
            "self.assert_qualname"
        ],
        [
            "CALL_FUNCTION",
            "foo()"
        ],
        [
            "CALL_FUNCTION",
            "foo()()"
        ],
        [
            "CALL_FUNCTION_KW",
            "self.assert_qualname(foo()(), 'lambda_maker.<locals>.foo.<locals>.<lambda>', check_actual_qualname=False)"
        ],
        [
            "CALL_FUNCTION",
            "range(66000)"
        ],
        [
            "CALL_FUNCTION",
            "list(range(66000))"
        ],
        [
            "BINARY_MODULO",
            "'tester(6)\\n%s\\ntester(9)' % list(range(66000))"
        ],
        [
            "LOAD_METHOD",
            "tempfile.mkstemp"
        ],
        [
            "CALL_METHOD",
            "tempfile.mkstemp()"
        ],
        [
            "CALL_FUNCTION",
            "compile(source, filename, 'exec')"
        ],
        [
            "CALL_FUNCTION",
            "open(filename, 'w')"
        ],
        [
            "LOAD_METHOD",
            "outfile.write"
        ],
        [
            "CALL_METHOD",
            "outfile.write(source)"
        ],
        [
            "CALL_FUNCTION",
            "exec(code)"
        ],
        [
            "CALL_FUNCTION",
            "range(5)"
        ],
        [
            "CALL_FUNCTION",
            "range(n)"
        ],
        [
            "COMPARE_OP",
            "n == 1"
        ],
        [
            "LOAD_METHOD",
            "self.assertEqual"
        ],
        [
            "CALL_FUNCTION",
            "only(gen)"
        ],
        [
            "CALL_METHOD",
            "self.assertEqual(only(gen), 0)"
        ],
        [
            "LOAD_METHOD",
            "self.assertRaises"
        ],
        [
            "CALL_METHOD",
            "self.assertRaises(NotOneValueFound)"
        ],
        [
            "CALL_FUNCTION",
            "only(gen)"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.join"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.dirname"
        ],
        [
            "CALL_METHOD",
            "os.path.dirname(__file__)"
        ],
        [
            "CALL_METHOD",
            "os.path.join(os.path.dirname(__file__), 'not_code.txt', )"
        ],
        [
            "LOAD_METHOD",
            "Source.for_filename"
        ],
        [
            "CALL_METHOD",
            "Source.for_filename(path)"
        ],
        [
            "LOAD_METHOD",
            "self.assertIsNone"
        ],
        [
            "LOAD_ATTR",
            "source.tree"
        ],
        [
            "CALL_METHOD",
            "self.assertIsNone(source.tree)"
        ],
        [
            "LOAD_METHOD",
            "inspect.currentframe"
        ],
        [
            "CALL_METHOD",
            "inspect.currentframe()"
        ],
        [
            "LOAD_METHOD",
            "Source.executing"
        ],
        [
            "CALL_METHOD",
            "Source.executing(frame)"
        ],
        [
            "LOAD_METHOD",
            "self.assertEqual"
        ],
        [
            "LOAD_METHOD",
            "executing.code_qualname"
        ],
        [
            "CALL_METHOD",
            "executing.code_qualname()"
        ],
        [
            "CALL_METHOD",
            "self.assertEqual(executing.code_qualname(), 'TestStuff.test_executing_methods')"
        ],
        [
            "LOAD_ATTR",
            "sys.version"
        ],
        [
            "LOAD_METHOD",
            "sys.version.lower"
        ],
        [
            "CALL_METHOD",
            "sys.version.lower()"
        ],
        [
            "CONTAINS_OP",
            "'pypy' not in sys.version.lower()"
        ],
        [
            "LOAD_METHOD",
            "self.assertEqual"
        ],
        [
            "LOAD_METHOD",
            "executing.text"
        ],
        [
            "CALL_METHOD",
            "executing.text()"
        ],
        [
            "CALL_METHOD",
            "self.assertEqual(executing.text(), text)"
        ],
        [
            "LOAD_METHOD",
            "executing.text_range"
        ],
        [
            "CALL_METHOD",
            "executing.text_range()"
        ],
        [
            "LOAD_METHOD",
            "self.assertEqual"
        ],
        [
            "LOAD_ATTR",
            "executing.source"
        ],
        [
            "LOAD_ATTR",
            "executing.source.text"
        ],
        [
            "BINARY_SUBSCR",
            "executing.source.text[start:end]"
        ],
        [
            "CALL_METHOD",
            "self.assertEqual(executing.source.text[start:end], text)"
        ],
        [
            "CALL_FUNCTION",
            "C()"
        ],
        [
            "LOAD_ATTR",
            "c.x"
        ],
        [
            "LOAD_ATTR",
            "c.x.x"
        ],
        [
            "LOAD_ATTR",
            "c.x"
        ],
        [
            "LOAD_ATTR",
            "c.x.y"
        ],
        [
            "LOAD_ATTR",
            "c.y"
        ],
        [
            "LOAD_ATTR",
            "c.y.x"
        ],
        [
            "LOAD_ATTR",
            "c.y"
        ],
        [
            "LOAD_ATTR",
            "c.y.y"
        ],
        [
            "LOAD_ATTR",
            "c.x"
        ],
        [
            "LOAD_ATTR",
            "c.x.asd"
        ],
        [
            "LOAD_ATTR",
            "c.y"
        ],
        [
            "LOAD_ATTR",
            "c.y.qwe"
        ],
        [
            "CALL_FUNCTION",
            "str((c.x.x, c.x.y, c.y.x, c.y.y, c.x.asd, c.y.qwe))"
        ],
        [
            "LOAD_METHOD",
            "Source.for_frame"
        ],
        [
            "LOAD_METHOD",
            "inspect.currentframe"
        ],
        [
            "CALL_METHOD",
            "inspect.currentframe()"
        ],
        [
            "CALL_METHOD",
            "Source.for_frame(inspect.currentframe())"
        ],
        [
            "LOAD_ATTR",
            "source.text"
        ],
        [
            "LOAD_ATTR",
            "source.filename"
        ],
        [
            "CALL_FUNCTION",
            "compile(source.text, source.filename, 'exec')"
        ],
        [
            "CALL_FUNCTION",
            "get_instructions(code)"
        ],
        [
            "LOAD_ATTR",
            "inst.starts_line"
        ],
        [
            "IS_OP",
            "inst.starts_line is not None"
        ],
        [
            "LOAD_ATTR",
            "inst.starts_line"
        ],
        [
            "LOAD_ATTR",
            "inst.opname"
        ],
        [
            "LOAD_METHOD",
            "inst.opname.startswith"
        ],
        [
            "CALL_METHOD",
            "inst.opname.startswith(\n                    ('BINARY_', 'UNARY_', 'LOAD_ATTR', 'LOAD_METHOD', 'LOOKUP_METHOD', 'COMPARE_OP'))"
        ],
        [
            "CALL_FUNCTION",
            "C()"
        ],
        [
            "LOAD_ATTR",
            "inst.offset"
        ],
        [
            "CALL_FUNCTION",
            "globals()"
        ],
        [
            "LOAD_ATTR",
            "inst.opname"
        ],
        [
            "CALL_FUNCTION",
            "print(inst.opname)"
        ],
        [
            "LOAD_METHOD",
            "Source.executing"
        ],
        [
            "CALL_METHOD",
            "Source.executing(frame)"
        ],
        [
            "LOAD_ATTR",
            "Source.executing(frame).node"
        ],
        [
            "IS_OP",
            "Source.executing(frame).node is not None"
        ],
        [
            "CALL_FUNCTION",
            "i()"
        ],
        [
            "CALL_FUNCTION",
            "assign(lambda: 1)"
        ],
        [
            "LOAD_METHOD",
            "inspect.currentframe"
        ],
        [
            "CALL_METHOD",
            "inspect.currentframe()"
        ],
        [
            "LOAD_ATTR",
            "inspect.currentframe().f_back"
        ],
        [
            "LOAD_ATTR",
            "inspect.currentframe().f_back.f_back"
        ],
        [
            "LOAD_METHOD",
            "Source.lazycache"
        ],
        [
            "CALL_METHOD",
            "Source.lazycache(frame)"
        ],
        [
            "LOAD_METHOD",
            "Source.executing"
        ],
        [
            "CALL_METHOD",
            "Source.executing(frame)"
        ],
        [
            "LOAD_ATTR",
            "Source.executing(frame).node"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node, typ)"
        ],
        [
            "LOAD_METHOD",
            "inspect.currentframe"
        ],
        [
            "CALL_METHOD",
            "inspect.currentframe()"
        ],
        [
            "LOAD_ATTR",
            "inspect.currentframe().f_back"
        ],
        [
            "LOAD_ATTR",
            "inspect.currentframe().f_back.f_back"
        ],
        [
            "LOAD_METHOD",
            "ast.Expression"
        ],
        [
            "CALL_METHOD",
            "ast.Expression(node)"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_filename"
        ],
        [
            "CALL_FUNCTION",
            "compile(ast.Expression(node), frame.f_code.co_filename, 'eval')"
        ],
        [
            "LOAD_ATTR",
            "frame.f_globals"
        ],
        [
            "LOAD_ATTR",
            "frame.f_locals"
        ],
        [
            "CALL_FUNCTION",
            "eval(\n            compile(ast.Expression(node), frame.f_code.co_filename, 'eval'),\n            frame.f_globals,\n            frame.f_locals,\n        )"
        ],
        [
            "COMPARE_OP",
            "result == value"
        ],
        [
            "LOAD_METHOD",
            "self.get_node"
        ],
        [
            "LOAD_ATTR",
            "ast.Call"
        ],
        [
            "CALL_METHOD",
            "self.get_node(ast.Call)"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_ATTR",
            "call.args"
        ],
        [
            "BINARY_SUBSCR",
            "call.args[0]"
        ],
        [
            "CALL_METHOD",
            "self.check(call.args[0], arg)"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_ATTR",
            "call.func"
        ],
        [
            "CALL_METHOD",
            "self.check(call.func, self)"
        ],
        [
            "IS_OP",
            "returns is None"
        ],
        [
            "LOAD_METHOD",
            "self.get_node"
        ],
        [
            "LOAD_ATTR",
            "ast.Attribute"
        ],
        [
            "CALL_METHOD",
            "self.get_node(ast.Attribute)"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_ATTR",
            "node.value"
        ],
        [
            "CALL_METHOD",
            "self.check(node.value, self)"
        ],
        [
            "LOAD_ATTR",
            "node.attr"
        ],
        [
            "COMPARE_OP",
            "node.attr == item"
        ],
        [
            "LOAD_METHOD",
            "self.get_node"
        ],
        [
            "LOAD_ATTR",
            "ast.Subscript"
        ],
        [
            "CALL_METHOD",
            "self.get_node(ast.Subscript)"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_ATTR",
            "node.value"
        ],
        [
            "CALL_METHOD",
            "self.check(node.value, self)"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_ATTR",
            "node.slice"
        ],
        [
            "LOAD_ATTR",
            "node.slice.value"
        ],
        [
            "CALL_METHOD",
            "self.check(node.slice.value, item)"
        ],
        [
            "LOAD_METHOD",
            "self.get_node"
        ],
        [
            "LOAD_ATTR",
            "ast.BinOp"
        ],
        [
            "CALL_METHOD",
            "self.get_node(ast.BinOp)"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_ATTR",
            "node.left"
        ],
        [
            "CALL_METHOD",
            "self.check(node.left, self)"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_ATTR",
            "node.right"
        ],
        [
            "CALL_METHOD",
            "self.check(node.right, other)"
        ],
        [
            "LOAD_METHOD",
            "self.get_node"
        ],
        [
            "LOAD_ATTR",
            "ast.UnaryOp"
        ],
        [
            "CALL_METHOD",
            "self.get_node(ast.UnaryOp)"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_ATTR",
            "node.operand"
        ],
        [
            "CALL_METHOD",
            "self.check(node.operand, self)"
        ],
        [
            "LOAD_METHOD",
            "self.get_node"
        ],
        [
            "LOAD_ATTR",
            "ast.Compare"
        ],
        [
            "CALL_METHOD",
            "self.get_node(ast.Compare)"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_ATTR",
            "node.left"
        ],
        [
            "CALL_METHOD",
            "self.check(node.left, self)"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_ATTR",
            "node.comparators"
        ],
        [
            "BINARY_SUBSCR",
            "node.comparators[0]"
        ],
        [
            "CALL_METHOD",
            "self.check(node.comparators[0], other)"
        ]
    ],
    "tracer.py": [
        [
            "LOAD_METHOD",
            "standard_library.install_aliases"
        ],
        [
            "CALL_METHOD",
            "standard_library.install_aliases()"
        ],
        [
            "LOAD_ATTR",
            "ast.expr"
        ],
        [
            "LOAD_ATTR",
            "ast.stmt"
        ],
        [
            "BINARY_SUBSCR",
            "Union[ast.expr, ast.stmt]"
        ],
        [
            "BINARY_SUBSCR",
            "Optional[Union[ast.expr, ast.stmt]]"
        ],
        [
            "LOAD_ATTR",
            "ast.AST"
        ],
        [
            "CALL_FUNCTION",
            "NamedTuple('EnterCallInfo', [\n\n    # Node  from where the call was made\n    ('call_node', Optional[Union[ast.expr, ast.stmt]]),\n\n    # Node where the call begins\n    ('enter_node', ast.AST),\n\n    # Frame from which the call was made\n    ('caller_frame', FrameType),\n\n    # Frame of the call\n    ('current_frame', FrameType)])"
        ],
        [
            "LOAD_ATTR",
            "ast.expr"
        ],
        [
            "LOAD_ATTR",
            "ast.stmt"
        ],
        [
            "BINARY_SUBSCR",
            "Union[ast.expr, ast.stmt]"
        ],
        [
            "BINARY_SUBSCR",
            "Optional[Union[ast.expr, ast.stmt]]"
        ],
        [
            "LOAD_ATTR",
            "ast.Return"
        ],
        [
            "BINARY_SUBSCR",
            "Optional[ast.Return]"
        ],
        [
            "BINARY_SUBSCR",
            "Optional[Exception]"
        ],
        [
            "BINARY_SUBSCR",
            "Optional[TracebackType]"
        ],
        [
            "CALL_FUNCTION",
            "NamedTuple('ExitCallInfo', [\n\n    # Node  from where the call was made\n    ('call_node', Optional[Union[ast.expr, ast.stmt]]),\n\n    # Node where the call explicitly returned\n    ('return_node', Optional[ast.Return]),\n\n    # Frame from which the call was made\n    ('caller_frame', FrameType),\n\n    # Frame of the call\n    ('current_frame', FrameType),\n\n    # Node where the call explicitly returned\n    ('return_value', Any),\n\n    # Exception raised in the call causing it to end,\n    # will propagate to the caller\n    ('exc_value', Optional[Exception]),\n\n    # Traceback corresponding to exc_value\n    ('exc_tb', Optional[TracebackType])])"
        ],
        [
            "CALL_FUNCTION",
            "namedtuple('ChangeValue', 'value')"
        ],
        [
            "LOAD_ATTR",
            "ast.NodeTransformer"
        ],
        [
            "LOAD_ATTR",
            "ast.For"
        ],
        [
            "LOAD_ATTR",
            "ast.While"
        ],
        [
            "LOAD_ATTR",
            "ast.comprehension"
        ],
        [
            "BINARY_SUBSCR",
            "Union[ast.For, ast.While, ast.comprehension]"
        ],
        [
            "LOAD_ATTR",
            "ast.PyCF_ONLY_AST"
        ],
        [
            "BINARY_OR",
            "ast.PyCF_ONLY_AST | flags"
        ],
        [
            "CALL_FUNCTION_KW",
            "compile(source, filename, 'exec', ast.PyCF_ONLY_AST | flags, dont_inherit=True)"
        ],
        [
            "LOAD_METHOD",
            "self.set_basic_node_attributes"
        ],
        [
            "CALL_METHOD",
            "self.set_basic_node_attributes()"
        ],
        [
            "LOAD_METHOD",
            "tracer.parse_extra"
        ],
        [
            "LOAD_ATTR",
            "self.root"
        ],
        [
            "CALL_METHOD",
            "tracer.parse_extra(self.root, source, filename)"
        ],
        [
            "IS_OP",
            "new_root is not None"
        ],
        [
            "LOAD_METHOD",
            "self.set_basic_node_attributes"
        ],
        [
            "CALL_METHOD",
            "self.set_basic_node_attributes()"
        ],
        [
            "LOAD_METHOD",
            "self.set_enter_call_nodes"
        ],
        [
            "CALL_METHOD",
            "self.set_enter_call_nodes()"
        ],
        [
            "LOAD_ATTR",
            "self.root"
        ],
        [
            "CALL_FUNCTION",
            "deepcopy(self.root)"
        ],
        [
            "CALL_FUNCTION",
            "_NodeVisitor()"
        ],
        [
            "LOAD_METHOD",
            "_NodeVisitor().visit"
        ],
        [
            "CALL_METHOD",
            "_NodeVisitor().visit(new_root)"
        ],
        [
            "CALL_FUNCTION_KW",
            "compile(new_root, filename, \"exec\", dont_inherit=True, flags=flags)"
        ],
        [
            "LOAD_METHOD",
            "ast.walk"
        ],
        [
            "LOAD_ATTR",
            "self.root"
        ],
        [
            "CALL_METHOD",
            "ast.walk(self.root)"
        ],
        [
            "LOAD_METHOD",
            "ast.iter_child_nodes"
        ],
        [
            "CALL_METHOD",
            "ast.iter_child_nodes(node)"
        ],
        [
            "LOAD_ATTR",
            "self.nodes"
        ],
        [
            "CALL_FUNCTION",
            "len(self.nodes)"
        ],
        [
            "LOAD_ATTR",
            "self.nodes"
        ],
        [
            "LOAD_METHOD",
            "self.nodes.append"
        ],
        [
            "CALL_METHOD",
            "self.nodes.append(node)"
        ],
        [
            "LOAD_ATTR",
            "self.root"
        ],
        [
            "LOAD_ATTR",
            "self.root.body"
        ],
        [
            "CALL_FUNCTION",
            "enumerate(self.root.body)"
        ],
        [
            "CALL_FUNCTION",
            "is_future_import(stmt)"
        ],
        [
            "LOAD_ATTR",
            "self.root"
        ],
        [
            "LOAD_ATTR",
            "self.root.body"
        ],
        [
            "BINARY_ADD",
            "i + 1"
        ],
        [
            "BINARY_SUBSCR",
            "self.root.body[:i + 1]"
        ],
        [
            "LOAD_METHOD",
            "ast.walk"
        ],
        [
            "CALL_METHOD",
            "ast.walk(s)"
        ],
        [
            "LOAD_ATTR",
            "self.nodes"
        ],
        [
            "LOAD_ATTR",
            "ast.Module"
        ],
        [
            "LOAD_ATTR",
            "ast.FunctionDef"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node, (ast.Module, ast.FunctionDef))"
        ],
        [
            "LOAD_ATTR",
            "node.body"
        ],
        [
            "CALL_FUNCTION",
            "is_future_import(stmt)"
        ],
        [
            "CALL_FUNCTION",
            "lru_cache()"
        ],
        [
            "CALL_FUNCTION",
            "defaultdict(list)"
        ],
        [
            "CALL_FUNCTION",
            "TracedFile(self, source, filename, flags)"
        ],
        [
            "LOAD_ATTR",
            "self._treetrace_hidden_with_stmt"
        ],
        [
            "LOAD_ATTR",
            "self._treetrace_hidden_before_expr"
        ],
        [
            "LOAD_ATTR",
            "self._treetrace_hidden_after_expr"
        ],
        [
            "LOAD_ATTR",
            "f.__name__"
        ],
        [
            "CALL_FUNCTION",
            "partial(f, traced_file)"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(func, FunctionType)"
        ],
        [
            "CALL_FUNCTION",
            "ValueError('You can only trace user-defined functions. '\n                             'The birdseye decorator must be applied first, '\n                             'at the bottom of the list.')"
        ],
        [
            "LOAD_METHOD",
            "inspect.iscoroutinefunction"
        ],
        [
            "CALL_METHOD",
            "inspect.iscoroutinefunction(func)"
        ],
        [
            "LOAD_METHOD",
            "inspect.isasyncgenfunction"
        ],
        [
            "CALL_METHOD",
            "inspect.isasyncgenfunction(func)"
        ],
        [
            "CALL_FUNCTION",
            "ValueError('You cannot trace async functions')"
        ],
        [
            "CALL_FUNCTION",
            "is_lambda(func)"
        ],
        [
            "CALL_FUNCTION",
            "ValueError('You cannot trace lambdas')"
        ],
        [
            "LOAD_METHOD",
            "inspect.getsourcefile"
        ],
        [
            "CALL_METHOD",
            "inspect.getsourcefile(func)"
        ],
        [
            "CALL_FUNCTION",
            "is_ipython_cell(filename)"
        ],
        [
            "CALL_FUNCTION",
            "get_ipython()"
        ],
        [
            "LOAD_ATTR",
            "get_ipython().compile"
        ],
        [
            "LOAD_ATTR",
            "get_ipython().compile.flags"
        ],
        [
            "LOAD_METHOD",
            "''.join"
        ],
        [
            "LOAD_ATTR",
            "linecache.cache"
        ],
        [
            "BINARY_SUBSCR",
            "linecache.cache[filename]"
        ],
        [
            "BINARY_SUBSCR",
            "linecache.cache[filename][2]"
        ],
        [
            "CALL_METHOD",
            "''.join(linecache.cache[filename][2])"
        ],
        [
            "CALL_FUNCTION",
            "read_source_file(filename)"
        ],
        [
            "LOAD_METHOD",
            "self.compile"
        ],
        [
            "CALL_METHOD",
            "self.compile(source, filename, flags)"
        ],
        [
            "LOAD_ATTR",
            "func.__dict__"
        ],
        [
            "CALL_FUNCTION",
            "ValueError('The birdseye decorator must be applied first, '\n                             'at the bottom of the list.')"
        ],
        [
            "LOAD_ATTR",
            "traced_file.code"
        ],
        [
            "CALL_FUNCTION",
            "find_code(traced_file.code)"
        ],
        [
            "CALL_FUNCTION",
            "len(code_options)"
        ],
        [
            "COMPARE_OP",
            "len(code_options) > 1"
        ],
        [
            "CALL_FUNCTION",
            "is_lambda(func)"
        ],
        [
            "CALL_FUNCTION",
            "ValueError(\"Failed to trace lambda. Convert the function to a def.\")"
        ],
        [
            "BINARY_SUBSCR",
            "code_options[0]"
        ],
        [
            "LOAD_ATTR",
            "func.__globals__"
        ],
        [
            "LOAD_METHOD",
            "func.__globals__.update"
        ],
        [
            "LOAD_METHOD",
            "self._trace_methods_dict"
        ],
        [
            "CALL_METHOD",
            "self._trace_methods_dict(traced_file)"
        ],
        [
            "CALL_METHOD",
            "func.__globals__.update(self._trace_methods_dict(traced_file))"
        ],
        [
            "LOAD_ATTR",
            "func.__globals__"
        ],
        [
            "LOAD_ATTR",
            "func.__name__"
        ],
        [
            "LOAD_ATTR",
            "func.__defaults__"
        ],
        [
            "LOAD_ATTR",
            "func.__closure__"
        ],
        [
            "CALL_FUNCTION",
            "FunctionType(new_func_code, func.__globals__, func.__name__, func.__defaults__, func.__closure__)"
        ],
        [
            "CALL_FUNCTION",
            "update_wrapper(new_func, func)"
        ],
        [
            "CALL_FUNCTION",
            "getattr(func, '__kwdefaults__', None)"
        ],
        [
            "LOAD_ATTR",
            "root_code.co_consts"
        ],
        [
            "LOAD_METHOD",
            "inspect.iscode"
        ],
        [
            "CALL_METHOD",
            "inspect.iscode(const)"
        ],
        [
            "LOAD_ATTR",
            "const.co_firstlineno"
        ],
        [
            "LOAD_ATTR",
            "func.__code__"
        ],
        [
            "LOAD_ATTR",
            "func.__code__.co_firstlineno"
        ],
        [
            "COMPARE_OP",
            "const.co_firstlineno == func.__code__.co_firstlineno"
        ],
        [
            "LOAD_ATTR",
            "const.co_name"
        ],
        [
            "LOAD_ATTR",
            "func.__code__"
        ],
        [
            "LOAD_ATTR",
            "func.__code__.co_name"
        ],
        [
            "COMPARE_OP",
            "const.co_name == func.__code__.co_name"
        ],
        [
            "LOAD_METHOD",
            "code_options.append"
        ],
        [
            "CALL_METHOD",
            "code_options.append(const)"
        ],
        [
            "CALL_FUNCTION",
            "find_code(const)"
        ],
        [
            "LOAD_METHOD",
            "inspect.isclass"
        ],
        [
            "CALL_METHOD",
            "inspect.isclass(func)"
        ],
        [
            "CALL_FUNCTION",
            "TypeError('Decorating classes is no longer supported')"
        ],
        [
            "LOAD_METHOD",
            "self.trace_function"
        ],
        [
            "CALL_METHOD",
            "self.trace_function(func)"
        ],
        [
            "LOAD_ATTR",
            "self.trace_function"
        ],
        [
            "LOAD_METHOD",
            "self.trace_function"
        ],
        [
            "CALL_METHOD",
            "self.trace_function(actual_func)"
        ],
        [
            "CALL_FUNCTION",
            "wraps(actual_func)"
        ],
        [
            "LOAD_METHOD",
            "kwargs.pop"
        ],
        [
            "CALL_METHOD",
            "kwargs.pop('trace_call', False)"
        ],
        [
            "CALL_FUNCTION_EX",
            "f(*args, **kwargs)"
        ],
        [
            "LOAD_METHOD",
            "sys._getframe"
        ],
        [
            "CALL_METHOD",
            "sys._getframe(2)"
        ],
        [
            "LOAD_ATTR",
            "self.secondary_to_main_frames"
        ],
        [
            "LOAD_METHOD",
            "self.secondary_to_main_frames.get"
        ],
        [
            "CALL_METHOD",
            "self.secondary_to_main_frames.get(frame)"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_name"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code.co_name in ('<listcomp>', '<dictcomp>', '<setcomp>')"
        ],
        [
            "LOAD_ATTR",
            "frame.f_back"
        ],
        [
            "CALL_FUNCTION",
            "ancestors(node)"
        ],
        [
            "LOAD_ATTR",
            "ast.FunctionDef"
        ],
        [
            "LOAD_ATTR",
            "ast.Lambda"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node, (ast.FunctionDef, ast.Lambda))"
        ],
        [
            "LOAD_ATTR",
            "ast.ClassDef"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node, ast.ClassDef)"
        ],
        [
            "LOAD_ATTR",
            "frame.f_back"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_name"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code.co_name in ('<lambda>', '<genexpr>')"
        ],
        [
            "LOAD_ATTR",
            "self.secondary_to_main_frames"
        ],
        [
            "LOAD_ATTR",
            "self.main_to_secondary_frames"
        ],
        [
            "BINARY_SUBSCR",
            "self.main_to_secondary_frames[frame]"
        ],
        [
            "LOAD_METHOD",
            "self.main_to_secondary_frames[frame].append"
        ],
        [
            "CALL_METHOD",
            "self.main_to_secondary_frames[frame].append(original_frame)"
        ],
        [
            "LOAD_ATTR",
            "traced_file.nodes"
        ],
        [
            "BINARY_SUBSCR",
            "traced_file.nodes[_tree_index]"
        ],
        [
            "LOAD_ATTR",
            "ast.stmt"
        ],
        [
            "CALL_FUNCTION",
            "cast(ast.stmt, node)"
        ],
        [
            "LOAD_METHOD",
            "self._main_frame"
        ],
        [
            "CALL_METHOD",
            "self._main_frame(node)"
        ],
        [
            "CALL_FUNCTION",
            "_StmtContext(self, node, frame)"
        ],
        [
            "LOAD_ATTR",
            "traced_file.nodes"
        ],
        [
            "BINARY_SUBSCR",
            "traced_file.nodes[_tree_index]"
        ],
        [
            "LOAD_ATTR",
            "ast.expr"
        ],
        [
            "CALL_FUNCTION",
            "cast(ast.expr, node)"
        ],
        [
            "LOAD_METHOD",
            "self._main_frame"
        ],
        [
            "CALL_METHOD",
            "self._main_frame(node)"
        ],
        [
            "IS_OP",
            "frame is None"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "LOAD_ATTR",
            "frame_info.expression_stack"
        ],
        [
            "LOAD_METHOD",
            "frame_info.expression_stack.append"
        ],
        [
            "CALL_METHOD",
            "frame_info.expression_stack.append(node)"
        ],
        [
            "LOAD_METHOD",
            "self.before_expr"
        ],
        [
            "CALL_METHOD",
            "self.before_expr(node, frame)"
        ],
        [
            "LOAD_METHOD",
            "self._main_frame"
        ],
        [
            "CALL_METHOD",
            "self._main_frame(node)"
        ],
        [
            "IS_OP",
            "frame is None"
        ],
        [
            "LOAD_METHOD",
            "self._after_expr"
        ],
        [
            "CALL_METHOD",
            "self._after_expr(node, frame, value, None, None)"
        ],
        [
            "IS_OP",
            "result is not None"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(result, ChangeValue)"
        ],
        [
            "LOAD_ATTR",
            "result.value"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "LOAD_ATTR",
            "frame_info.expression_stack"
        ],
        [
            "LOAD_METHOD",
            "frame_info.expression_stack.pop"
        ],
        [
            "CALL_METHOD",
            "frame_info.expression_stack.pop()"
        ],
        [
            "LOAD_ATTR",
            "frame_info.expression_values"
        ],
        [
            "LOAD_METHOD",
            "self.after_expr"
        ],
        [
            "CALL_METHOD",
            "self.after_expr(node, frame, value, exc_value, exc_tb)"
        ],
        [
            "LOAD_METHOD",
            "self._get_caller_stuff"
        ],
        [
            "CALL_METHOD",
            "self._get_caller_stuff(current_frame)"
        ],
        [
            "CALL_FUNCTION",
            "FrameInfo()"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_METHOD",
            "self.enter_call"
        ],
        [
            "CALL_FUNCTION",
            "EnterCallInfo(call_node, enter_node, caller_frame, current_frame)"
        ],
        [
            "CALL_METHOD",
            "self.enter_call(EnterCallInfo(call_node, enter_node, caller_frame, current_frame))"
        ],
        [
            "LOAD_ATTR",
            "frame.f_back"
        ],
        [
            "LOAD_ATTR",
            "self.secondary_to_main_frames"
        ],
        [
            "LOAD_METHOD",
            "self.secondary_to_main_frames.get"
        ],
        [
            "CALL_METHOD",
            "self.secondary_to_main_frames.get(caller_frame)"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[caller_frame]"
        ],
        [
            "LOAD_ATTR",
            "frame_info.expression_stack"
        ],
        [
            "BINARY_SUBSCR",
            "expression_stack[-1]"
        ],
        [
            "LOAD_ATTR",
            "frame_info.statement_stack"
        ],
        [
            "BINARY_SUBSCR",
            "frame_info.statement_stack[-1]"
        ],
        [
            "CALL_FUNCTION",
            "getattr(node, '_visit_ignore', False)"
        ],
        [
            "LOAD_ATTR",
            "ast.expr"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node, ast.expr)"
        ],
        [
            "CALL_FUNCTION",
            "hasattr(node, \"ctx\")"
        ],
        [
            "LOAD_ATTR",
            "node.ctx"
        ],
        [
            "LOAD_ATTR",
            "ast.Load"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node.ctx, ast.Load)"
        ],
        [
            "CALL_FUNCTION",
            "getattr(ast, 'Starred', ())"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node, getattr(ast, 'Starred', ()))"
        ],
        [
            "LOAD_METHOD",
            "self.visit_expr"
        ],
        [
            "CALL_METHOD",
            "self.visit_expr(node)"
        ],
        [
            "LOAD_ATTR",
            "ast.stmt"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node, ast.stmt)"
        ],
        [
            "LOAD_METHOD",
            "self.visit_stmt"
        ],
        [
            "CALL_METHOD",
            "self.visit_stmt(node)"
        ],
        [
            "CALL_FUNCTION",
            "super(_NodeVisitor, self)"
        ],
        [
            "LOAD_METHOD",
            "super(_NodeVisitor, self).generic_visit"
        ],
        [
            "CALL_METHOD",
            "super(_NodeVisitor, self).generic_visit(node)"
        ],
        [
            "LOAD_METHOD",
            "self._create_simple_marker_call"
        ],
        [
            "LOAD_ATTR",
            "TreeTracerBase._treetrace_hidden_before_expr"
        ],
        [
            "CALL_METHOD",
            "self._create_simple_marker_call(node, TreeTracerBase._treetrace_hidden_before_expr)"
        ],
        [
            "LOAD_METHOD",
            "ast.copy_location"
        ],
        [
            "CALL_METHOD",
            "ast.copy_location(before_marker, node)"
        ],
        [
            "LOAD_ATTR",
            "ast.Call"
        ],
        [
            "LOAD_ATTR",
            "ast.Name"
        ],
        [
            "LOAD_ATTR",
            "TreeTracerBase._treetrace_hidden_after_expr"
        ],
        [
            "LOAD_ATTR",
            "TreeTracerBase._treetrace_hidden_after_expr.__name__"
        ],
        [
            "LOAD_METHOD",
            "ast.Load"
        ],
        [
            "CALL_METHOD",
            "ast.Load()"
        ],
        [
            "CALL_FUNCTION_KW",
            "ast.Name(id=TreeTracerBase._treetrace_hidden_after_expr.__name__,\n                          ctx=ast.Load())"
        ],
        [
            "CALL_FUNCTION",
            "super(_NodeVisitor, self)"
        ],
        [
            "LOAD_METHOD",
            "super(_NodeVisitor, self).generic_visit"
        ],
        [
            "CALL_METHOD",
            "super(_NodeVisitor, self).generic_visit(node)"
        ],
        [
            "CALL_FUNCTION_KW",
            "ast.Call(\n            func=ast.Name(id=TreeTracerBase._treetrace_hidden_after_expr.__name__,\n                          ctx=ast.Load()),\n            args=[\n                before_marker,\n                super(_NodeVisitor, self).generic_visit(node),\n            ],\n            keywords=[],\n        )"
        ],
        [
            "LOAD_METHOD",
            "ast.copy_location"
        ],
        [
            "CALL_METHOD",
            "ast.copy_location(after_marker, node)"
        ],
        [
            "LOAD_METHOD",
            "ast.fix_missing_locations"
        ],
        [
            "CALL_METHOD",
            "ast.fix_missing_locations(after_marker)"
        ],
        [
            "LOAD_METHOD",
            "self._create_simple_marker_call"
        ],
        [
            "CALL_FUNCTION",
            "super(_NodeVisitor, self)"
        ],
        [
            "LOAD_METHOD",
            "super(_NodeVisitor, self).generic_visit"
        ],
        [
            "CALL_METHOD",
            "super(_NodeVisitor, self).generic_visit(node)"
        ],
        [
            "LOAD_ATTR",
            "TreeTracerBase._treetrace_hidden_with_stmt"
        ],
        [
            "CALL_METHOD",
            "self._create_simple_marker_call(\n            super(_NodeVisitor, self).generic_visit(node),\n            TreeTracerBase._treetrace_hidden_with_stmt)"
        ],
        [
            "LOAD_ATTR",
            "ast.With"
        ],
        [
            "LOAD_ATTR",
            "ast.withitem"
        ],
        [
            "CALL_FUNCTION_KW",
            "ast.withitem(context_expr=context_expr)"
        ],
        [
            "CALL_FUNCTION_KW",
            "ast.With(\n                items=[ast.withitem(context_expr=context_expr)],\n                body=[node],\n            )"
        ],
        [
            "LOAD_ATTR",
            "ast.With"
        ],
        [
            "CALL_FUNCTION_KW",
            "ast.With(\n                context_expr=context_expr,\n                body=[node],\n            )"
        ],
        [
            "LOAD_METHOD",
            "ast.copy_location"
        ],
        [
            "CALL_METHOD",
            "ast.copy_location(wrapped, node)"
        ],
        [
            "LOAD_METHOD",
            "ast.fix_missing_locations"
        ],
        [
            "CALL_METHOD",
            "ast.fix_missing_locations(wrapped)"
        ],
        [
            "LOAD_ATTR",
            "ast.Call"
        ],
        [
            "LOAD_ATTR",
            "ast.Name"
        ],
        [
            "LOAD_ATTR",
            "func.__name__"
        ],
        [
            "LOAD_METHOD",
            "ast.Load"
        ],
        [
            "CALL_METHOD",
            "ast.Load()"
        ],
        [
            "CALL_FUNCTION_KW",
            "ast.Name(id=func.__name__,\n                          ctx=ast.Load())"
        ],
        [
            "LOAD_METHOD",
            "ast.Num"
        ],
        [
            "LOAD_ATTR",
            "node._tree_index"
        ],
        [
            "CALL_METHOD",
            "ast.Num(node._tree_index)"
        ],
        [
            "CALL_FUNCTION_KW",
            "ast.Call(\n            func=ast.Name(id=func.__name__,\n                          ctx=ast.Load()),\n            args=[ast.Num(node._tree_index)],\n            keywords=[],\n        )"
        ],
        [
            "LOAD_ATTR",
            "self.tracer"
        ],
        [
            "LOAD_ATTR",
            "self.node"
        ],
        [
            "LOAD_ATTR",
            "self.frame"
        ],
        [
            "CALL_FUNCTION",
            "getattr(node, '_enter_call_node', False)"
        ],
        [
            "LOAD_METHOD",
            "tracer._enter_call"
        ],
        [
            "CALL_METHOD",
            "tracer._enter_call(node, frame)"
        ],
        [
            "LOAD_ATTR",
            "tracer.stack"
        ],
        [
            "BINARY_SUBSCR",
            "tracer.stack[frame]"
        ],
        [
            "LOAD_ATTR",
            "frame_info.statement_stack"
        ],
        [
            "LOAD_METHOD",
            "frame_info.statement_stack.append"
        ],
        [
            "CALL_METHOD",
            "frame_info.statement_stack.append(node)"
        ],
        [
            "LOAD_METHOD",
            "tracer.before_stmt"
        ],
        [
            "CALL_METHOD",
            "tracer.before_stmt(node, frame)"
        ],
        [
            "LOAD_ATTR",
            "self.node"
        ],
        [
            "LOAD_ATTR",
            "self.tracer"
        ],
        [
            "LOAD_ATTR",
            "self.frame"
        ],
        [
            "LOAD_ATTR",
            "tracer.stack"
        ],
        [
            "BINARY_SUBSCR",
            "tracer.stack[frame]"
        ],
        [
            "LOAD_ATTR",
            "frame_info.statement_stack"
        ],
        [
            "LOAD_METHOD",
            "frame_info.statement_stack.pop"
        ],
        [
            "CALL_METHOD",
            "frame_info.statement_stack.pop()"
        ],
        [
            "LOAD_ATTR",
            "frame_info.exc_value"
        ],
        [
            "IS_OP",
            "exc_val is not frame_info.exc_value"
        ],
        [
            "LOAD_ATTR",
            "frame_info.expression_stack"
        ],
        [
            "BINARY_SUBSCR",
            "expression_stack[-1]"
        ],
        [
            "LOAD_METHOD",
            "tracer._after_expr"
        ],
        [
            "CALL_METHOD",
            "tracer._after_expr(exc_node, frame, None, exc_val, exc_tb)"
        ],
        [
            "LOAD_METHOD",
            "tracer.after_stmt"
        ],
        [
            "CALL_METHOD",
            "tracer.after_stmt(node, frame, exc_val, exc_tb, exc_node)"
        ],
        [
            "LOAD_ATTR",
            "ast.Return"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node, ast.Return)"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_ATTR",
            "frame_info.return_node"
        ],
        [
            "LOAD_ATTR",
            "ast.FunctionDef"
        ],
        [
            "LOAD_ATTR",
            "ast.Module"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(parent, (ast.FunctionDef, ast.Module))"
        ],
        [
            "LOAD_ATTR",
            "parent.body"
        ],
        [
            "BINARY_SUBSCR",
            "parent.body[-1]"
        ],
        [
            "IS_OP",
            "node is parent.body[-1]"
        ],
        [
            "LOAD_METHOD",
            "tracer._get_caller_stuff"
        ],
        [
            "CALL_METHOD",
            "tracer._get_caller_stuff(frame)"
        ],
        [
            "LOAD_ATTR",
            "return_node.value"
        ],
        [
            "LOAD_ATTR",
            "frame_info.expression_values"
        ],
        [
            "LOAD_ATTR",
            "return_node.value"
        ],
        [
            "BINARY_SUBSCR",
            "frame_info.expression_values[return_node.value]"
        ],
        [
            "LOAD_METHOD",
            "tracer.exit_call"
        ],
        [
            "CALL_FUNCTION",
            "ExitCallInfo(call_node,\n                                          return_node,\n                                          caller_frame,\n                                          frame,\n                                          return_value,\n                                          exc_val,\n                                          exc_tb\n                                          )"
        ],
        [
            "CALL_METHOD",
            "tracer.exit_call(ExitCallInfo(call_node,\n                                          return_node,\n                                          caller_frame,\n                                          frame,\n                                          return_value,\n                                          exc_val,\n                                          exc_tb\n                                          ))"
        ],
        [
            "LOAD_ATTR",
            "tracer.stack"
        ],
        [
            "LOAD_ATTR",
            "self.tracer"
        ],
        [
            "LOAD_ATTR",
            "self.tracer.main_to_secondary_frames"
        ],
        [
            "LOAD_METHOD",
            "self.tracer.main_to_secondary_frames.pop"
        ],
        [
            "CALL_METHOD",
            "self.tracer.main_to_secondary_frames.pop(frame)"
        ],
        [
            "LOAD_ATTR",
            "self.tracer"
        ],
        [
            "LOAD_ATTR",
            "self.tracer.secondary_to_main_frames"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_ATTR",
            "ast.FunctionDef"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(parent, ast.FunctionDef)"
        ],
        [
            "LOAD_ATTR",
            "ast.For"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(parent, ast.For)"
        ],
        [
            "LOAD_ATTR",
            "parent.iter"
        ],
        [
            "IS_OP",
            "parent.iter is not node"
        ],
        [
            "LOAD_ATTR",
            "ast.While"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(parent, ast.While)"
        ],
        [
            "LOAD_ATTR",
            "parent.orelse"
        ],
        [
            "CONTAINS_OP",
            "node not in parent.orelse"
        ],
        [
            "LOAD_ATTR",
            "ast.comprehension"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(parent, ast.comprehension)"
        ],
        [
            "LOAD_ATTR",
            "parent.ifs"
        ],
        [
            "CONTAINS_OP",
            "node in parent.ifs"
        ],
        [
            "LOAD_METHOD",
            "result.append"
        ],
        [
            "CALL_METHOD",
            "result.append(parent)"
        ],
        [
            "LOAD_ATTR",
            "ast.ListComp"
        ],
        [
            "LOAD_ATTR",
            "ast.GeneratorExp"
        ],
        [
            "LOAD_ATTR",
            "ast.DictComp"
        ],
        [
            "LOAD_ATTR",
            "ast.SetComp"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(parent, (ast.ListComp,\n                                 ast.GeneratorExp,\n                                 ast.DictComp,\n                                 ast.SetComp))"
        ],
        [
            "LOAD_ATTR",
            "parent.generators"
        ],
        [
            "CONTAINS_OP",
            "node in generators"
        ],
        [
            "CALL_FUNCTION",
            "takewhile(lambda n: n != node, generators)"
        ],
        [
            "CALL_FUNCTION",
            "list(takewhile(lambda n: n != node, generators))"
        ],
        [
            "LOAD_METHOD",
            "result.extend"
        ],
        [
            "CALL_FUNCTION",
            "reversed(generators)"
        ],
        [
            "CALL_METHOD",
            "result.extend(reversed(generators))"
        ],
        [
            "LOAD_METHOD",
            "result.reverse"
        ],
        [
            "CALL_METHOD",
            "result.reverse()"
        ],
        [
            "CALL_FUNCTION",
            "tuple(result)"
        ],
        [
            "COMPARE_OP",
            "n != node"
        ]
    ],
    "tracer2.py": [
        [
            "LOAD_ATTR",
            "six.text_type"
        ],
        [
            "CALL_FUNCTION",
            "find_repr_function(six.text_type)"
        ],
        [
            "LOAD_ATTR",
            "six.binary_type"
        ],
        [
            "CALL_FUNCTION",
            "find_repr_function(six.binary_type)"
        ],
        [
            "CALL_FUNCTION",
            "find_repr_function(object)"
        ],
        [
            "CALL_FUNCTION",
            "find_repr_function(int)"
        ],
        [
            "LOAD_METHOD",
            "threading.local"
        ],
        [
            "CALL_METHOD",
            "threading.local()"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.dirname"
        ],
        [
            "LOAD_ATTR",
            "(lambda: 0).__code__"
        ],
        [
            "LOAD_ATTR",
            "(lambda: 0).__code__.co_filename"
        ],
        [
            "CALL_METHOD",
            "os.path.dirname((lambda: 0).__code__.co_filename)"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.dirname"
        ],
        [
            "LOAD_ATTR",
            "birdseye.__file__"
        ],
        [
            "CALL_METHOD",
            "os.path.dirname(birdseye.__file__)"
        ],
        [
            "LOAD_METHOD",
            "six.add_metaclass"
        ],
        [
            "CALL_METHOD",
            "six.add_metaclass(TracerMeta)"
        ],
        [
            "LOAD_ATTR",
            "frame.f_lineno"
        ],
        [
            "CALL_FUNCTION",
            "OrderedDict()"
        ],
        [
            "LOAD_METHOD",
            "Source.for_frame"
        ],
        [
            "CALL_METHOD",
            "Source.for_frame(frame)"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_flags"
        ],
        [
            "LOAD_ATTR",
            "inspect.CO_GENERATOR"
        ],
        [
            "BINARY_AND",
            "frame.f_code.co_flags & inspect.CO_GENERATOR"
        ],
        [
            "CALL_FUNCTION",
            "is_comprehension_frame(frame)"
        ],
        [
            "LOAD_METHOD",
            "re.match"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_name"
        ],
        [
            "CALL_METHOD",
            "re.match(r'<(\\w+)comp>', frame.f_code.co_name)"
        ],
        [
            "LOAD_METHOD",
            "re.match(r'<(\\w+)comp>', frame.f_code.co_name).group"
        ],
        [
            "CALL_METHOD",
            "re.match(r'<(\\w+)comp>', frame.f_code.co_name).group(1)"
        ],
        [
            "LOAD_METHOD",
            "re.match(r'<(\\w+)comp>', frame.f_code.co_name).group(1).title"
        ],
        [
            "CALL_METHOD",
            "re.match(r'<(\\w+)comp>', frame.f_code.co_name).group(1).title()"
        ],
        [
            "BINARY_ADD",
            "re.match(r'<(\\w+)comp>', frame.f_code.co_name).group(1).title()\n                    + u' comprehension'"
        ],
        [
            "LOAD_ATTR",
            "self.frame"
        ],
        [
            "LOAD_ATTR",
            "self.frame.f_lineno"
        ],
        [
            "LOAD_ATTR",
            "self.local_reprs"
        ],
        [
            "LOAD_METHOD",
            "self.get_local_reprs"
        ],
        [
            "CALL_METHOD",
            "self.get_local_reprs(watch, watch_extras)"
        ],
        [
            "CALL_FUNCTION",
            "OrderedDict(\n            (source, my_cheap_repr(value))\n            for source, value in\n            self.get_local_reprs(watch, watch_extras)\n        )"
        ],
        [
            "LOAD_ATTR",
            "self.comprehension_type"
        ],
        [
            "LOAD_ATTR",
            "self.local_reprs"
        ],
        [
            "LOAD_METHOD",
            "self.local_reprs.items"
        ],
        [
            "CALL_METHOD",
            "self.local_reprs.items()"
        ],
        [
            "LOAD_ATTR",
            "self.comprehension_variables"
        ],
        [
            "LOAD_METHOD",
            "self.comprehension_variables.setdefault"
        ],
        [
            "CALL_METHOD",
            "self.comprehension_variables.setdefault(name, [])"
        ],
        [
            "BINARY_SUBSCR",
            "values[-1]"
        ],
        [
            "COMPARE_OP",
            "values[-1] != value_repr"
        ],
        [
            "LOAD_METHOD",
            "values.append"
        ],
        [
            "CALL_METHOD",
            "values.append(value_repr)"
        ],
        [
            "CALL_FUNCTION",
            "truncate_list(values, 11)"
        ],
        [
            "CONTAINS_OP",
            "event in ('return', 'exception')"
        ],
        [
            "LOAD_ATTR",
            "self.comprehension_variables"
        ],
        [
            "LOAD_METHOD",
            "self.comprehension_variables.items"
        ],
        [
            "CALL_METHOD",
            "self.comprehension_variables.items()"
        ],
        [
            "LOAD_ATTR",
            "self.local_reprs"
        ],
        [
            "LOAD_METHOD",
            "self.local_reprs.items"
        ],
        [
            "CALL_METHOD",
            "self.local_reprs.items()"
        ],
        [
            "CONTAINS_OP",
            "name not in old_local_reprs"
        ],
        [
            "BINARY_SUBSCR",
            "old_local_reprs[name]"
        ],
        [
            "COMPARE_OP",
            "old_local_reprs[name] != value_repr"
        ],
        [
            "LOAD_METHOD",
            "variables.append"
        ],
        [
            "CALL_METHOD",
            "variables.append((name, value_repr))"
        ],
        [
            "CALL_FUNCTION",
            "my_cheap_repr(value)"
        ],
        [
            "LOAD_METHOD",
            "', '.join"
        ],
        [
            "CALL_METHOD",
            "', '.join(values)"
        ],
        [
            "LOAD_ATTR",
            "self.frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "code.co_varnames"
        ],
        [
            "LOAD_ATTR",
            "code.co_cellvars"
        ],
        [
            "BINARY_ADD",
            "code.co_varnames + code.co_cellvars"
        ],
        [
            "LOAD_ATTR",
            "code.co_freevars"
        ],
        [
            "BINARY_ADD",
            "code.co_varnames + code.co_cellvars + code.co_freevars"
        ],
        [
            "LOAD_ATTR",
            "frame.f_locals"
        ],
        [
            "LOAD_METHOD",
            "frame.f_locals.keys"
        ],
        [
            "CALL_METHOD",
            "frame.f_locals.keys()"
        ],
        [
            "CALL_FUNCTION",
            "tuple(frame.f_locals.keys())"
        ],
        [
            "BINARY_ADD",
            "code.co_varnames + code.co_cellvars + code.co_freevars + tuple(frame.f_locals.keys())"
        ],
        [
            "LOAD_ATTR",
            "frame.f_locals"
        ],
        [
            "LOAD_METHOD",
            "frame.f_locals.items"
        ],
        [
            "CALL_METHOD",
            "frame.f_locals.items()"
        ],
        [
            "CALL_FUNCTION_KW",
            "sorted(\n            frame.f_locals.items(),\n            key=lambda key_value: vars_order.index(key_value[0])\n        )"
        ],
        [
            "LOAD_METHOD",
            "variable.items"
        ],
        [
            "CALL_METHOD",
            "variable.items(frame)"
        ],
        [
            "CALL_FUNCTION",
            "sorted(variable.items(frame))"
        ],
        [
            "CALL_FUNCTION",
            "extra(source, value)"
        ],
        [
            "IS_OP",
            "pair is not None"
        ],
        [
            "CALL_FUNCTION",
            "len(pair)"
        ],
        [
            "COMPARE_OP",
            "len(pair) == 2"
        ],
        [
            "LOAD_METHOD",
            "vars_order.index"
        ],
        [
            "BINARY_SUBSCR",
            "key_value[0]"
        ],
        [
            "CALL_METHOD",
            "vars_order.index(key_value[0])"
        ],
        [
            "CALL_FUNCTION",
            "super(TracerMeta, mcs)"
        ],
        [
            "LOAD_ATTR",
            "super(TracerMeta, mcs).__new__"
        ],
        [
            "CALL_FUNCTION_EX",
            "super(TracerMeta, mcs).__new__(mcs, *args, **kwargs)"
        ],
        [
            "CALL_FUNCTION",
            "result()"
        ],
        [
            "CALL_FUNCTION",
            "no_args_decorator(args, kwargs)"
        ],
        [
            "LOAD_METHOD",
            "cls.default"
        ],
        [
            "BINARY_SUBSCR",
            "args[0]"
        ],
        [
            "CALL_METHOD",
            "cls.default(args[0])"
        ],
        [
            "CALL_FUNCTION",
            "super(TracerMeta, cls)"
        ],
        [
            "LOAD_ATTR",
            "super(TracerMeta, cls).__call__"
        ],
        [
            "CALL_FUNCTION_EX",
            "super(TracerMeta, cls).__call__(*args, **kwargs)"
        ],
        [
            "LOAD_ATTR",
            "self.default"
        ],
        [
            "LOAD_ATTR",
            "self.default.__enter__"
        ],
        [
            "CALL_FUNCTION_KW",
            "self.default.__enter__(context=1)"
        ],
        [
            "LOAD_ATTR",
            "self.default"
        ],
        [
            "LOAD_ATTR",
            "self.default.__exit__"
        ],
        [
            "CALL_FUNCTION_EX",
            "self.default.__exit__(*args, context=1)"
        ],
        [
            "CALL_FUNCTION",
            "ensure_tuple(watch)"
        ],
        [
            "CALL_FUNCTION",
            "ensure_tuple(watch_explode)"
        ],
        [
            "BINARY_ADD",
            "[\n            v if isinstance(v, BaseVariable) else CommonVariable(v)\n            for v in ensure_tuple(watch)\n        ] + [\n            v if isinstance(v, BaseVariable) else Exploding(v)\n            for v in ensure_tuple(watch_explode)\n        ]"
        ],
        [
            "CALL_FUNCTION",
            "ArgDefaultDict(FrameInfo)"
        ],
        [
            "LOAD_ATTR",
            "self.depth"
        ],
        [
            "COMPARE_OP",
            "self.depth >= 1"
        ],
        [
            "CALL_FUNCTION",
            "set()"
        ],
        [
            "CALL_FUNCTION",
            "set()"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(v, BaseVariable)"
        ],
        [
            "CALL_FUNCTION",
            "CommonVariable(v)"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(v, BaseVariable)"
        ],
        [
            "CALL_FUNCTION",
            "Exploding(v)"
        ],
        [
            "CALL_FUNCTION",
            "iscoroutinefunction(function)"
        ],
        [
            "CALL_FUNCTION",
            "NotImplementedError(\"coroutines are not supported, sorry!\")"
        ],
        [
            "LOAD_ATTR",
            "self.target_codes"
        ],
        [
            "LOAD_METHOD",
            "self.target_codes.add"
        ],
        [
            "LOAD_ATTR",
            "function.__code__"
        ],
        [
            "CALL_METHOD",
            "self.target_codes.add(function.__code__)"
        ],
        [
            "LOAD_METHOD",
            "functools.wraps"
        ],
        [
            "CALL_METHOD",
            "functools.wraps(function)"
        ],
        [
            "LOAD_METHOD",
            "functools.wraps"
        ],
        [
            "CALL_METHOD",
            "functools.wraps(function)"
        ],
        [
            "LOAD_METHOD",
            "inspect.isgeneratorfunction"
        ],
        [
            "CALL_METHOD",
            "inspect.isgeneratorfunction(function)"
        ],
        [
            "CALL_FUNCTION_EX",
            "function(*args, **kwargs)"
        ],
        [
            "CALL_FUNCTION_EX",
            "function(*args, **kwargs)"
        ],
        [
            "LOAD_ATTR",
            "gen.send"
        ],
        [
            "CALL_FUNCTION",
            "method(incoming)"
        ],
        [
            "LOAD_ATTR",
            "gen.send"
        ],
        [
            "LOAD_ATTR",
            "gen.throw"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.enabled"
        ],
        [
            "LOAD_METHOD",
            "sys._getframe"
        ],
        [
            "BINARY_ADD",
            "context + 1"
        ],
        [
            "CALL_METHOD",
            "sys._getframe(context + 1)"
        ],
        [
            "LOAD_METHOD",
            "self._is_internal_frame"
        ],
        [
            "CALL_METHOD",
            "self._is_internal_frame(calling_frame)"
        ],
        [
            "LOAD_ATTR",
            "self.trace"
        ],
        [
            "LOAD_ATTR",
            "self.target_frames"
        ],
        [
            "LOAD_METHOD",
            "self.target_frames.add"
        ],
        [
            "CALL_METHOD",
            "self.target_frames.add(calling_frame)"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_METHOD",
            "self.trace"
        ],
        [
            "CALL_METHOD",
            "self.trace(calling_frame, 'enter', None)"
        ],
        [
            "LOAD_ATTR",
            "thread_global.__dict__"
        ],
        [
            "LOAD_METHOD",
            "thread_global.__dict__.setdefault"
        ],
        [
            "CALL_METHOD",
            "thread_global.__dict__.setdefault('original_trace_functions', [])"
        ],
        [
            "LOAD_METHOD",
            "stack.append"
        ],
        [
            "LOAD_METHOD",
            "sys.gettrace"
        ],
        [
            "CALL_METHOD",
            "sys.gettrace()"
        ],
        [
            "CALL_METHOD",
            "stack.append(sys.gettrace())"
        ],
        [
            "LOAD_METHOD",
            "sys.settrace"
        ],
        [
            "LOAD_ATTR",
            "self.trace"
        ],
        [
            "CALL_METHOD",
            "sys.settrace(self.trace)"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.enabled"
        ],
        [
            "LOAD_ATTR",
            "thread_global.original_trace_functions"
        ],
        [
            "LOAD_METHOD",
            "sys.settrace"
        ],
        [
            "LOAD_METHOD",
            "stack.pop"
        ],
        [
            "CALL_METHOD",
            "stack.pop()"
        ],
        [
            "CALL_METHOD",
            "sys.settrace(stack.pop())"
        ],
        [
            "LOAD_METHOD",
            "sys._getframe"
        ],
        [
            "BINARY_ADD",
            "context + 1"
        ],
        [
            "CALL_METHOD",
            "sys._getframe(context + 1)"
        ],
        [
            "LOAD_METHOD",
            "self.trace"
        ],
        [
            "CALL_METHOD",
            "self.trace(calling_frame, 'exit', None)"
        ],
        [
            "LOAD_ATTR",
            "self.target_frames"
        ],
        [
            "LOAD_METHOD",
            "self.target_frames.discard"
        ],
        [
            "CALL_METHOD",
            "self.target_frames.discard(calling_frame)"
        ],
        [
            "LOAD_ATTR",
            "self.frame_infos"
        ],
        [
            "LOAD_METHOD",
            "self.frame_infos.pop"
        ],
        [
            "CALL_METHOD",
            "self.frame_infos.pop(calling_frame, None)"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_filename"
        ],
        [
            "LOAD_METHOD",
            "frame.f_code.co_filename.startswith"
        ],
        [
            "CALL_METHOD",
            "frame.f_code.co_filename.startswith(internal_directories)"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "self.target_codes"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code in self.target_codes"
        ],
        [
            "LOAD_ATTR",
            "self.target_frames"
        ],
        [
            "CONTAINS_OP",
            "frame in self.target_frames"
        ],
        [
            "LOAD_METHOD",
            "self._is_traced_frame"
        ],
        [
            "CALL_METHOD",
            "self._is_traced_frame(frame)"
        ],
        [
            "LOAD_ATTR",
            "self.depth"
        ],
        [
            "COMPARE_OP",
            "self.depth == 1"
        ],
        [
            "LOAD_METHOD",
            "self._is_internal_frame"
        ],
        [
            "CALL_METHOD",
            "self._is_internal_frame(frame)"
        ],
        [
            "CALL_FUNCTION",
            "is_comprehension_frame(frame)"
        ],
        [
            "CALL_FUNCTION",
            "is_comprehension_frame(candidate)"
        ],
        [
            "LOAD_ATTR",
            "candidate.f_back"
        ],
        [
            "LOAD_METHOD",
            "self._is_traced_frame"
        ],
        [
            "CALL_METHOD",
            "self._is_traced_frame(candidate)"
        ],
        [
            "LOAD_ATTR",
            "candidate.f_back"
        ],
        [
            "LOAD_ATTR",
            "self.depth"
        ],
        [
            "COMPARE_OP",
            "i >= self.depth"
        ],
        [
            "IS_OP",
            "candidate is None"
        ],
        [
            "LOAD_METHOD",
            "self._is_internal_frame"
        ],
        [
            "CALL_METHOD",
            "self._is_internal_frame(candidate)"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.thread_local"
        ],
        [
            "LOAD_ATTR",
            "thread_local.__dict__"
        ],
        [
            "LOAD_METHOD",
            "thread_local.__dict__.setdefault"
        ],
        [
            "CALL_METHOD",
            "thread_local.__dict__.setdefault('depth', -1)"
        ],
        [
            "LOAD_ATTR",
            "self.frame_infos"
        ],
        [
            "BINARY_SUBSCR",
            "self.frame_infos[frame]"
        ],
        [
            "CONTAINS_OP",
            "event in ('call', 'enter')"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.last_frame"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.last_frame"
        ],
        [
            "IS_OP",
            "self.config.last_frame is not frame"
        ],
        [
            "LOAD_ATTR",
            "frame_info.last_line_no"
        ],
        [
            "LOAD_ATTR",
            "thread_local.depth"
        ],
        [
            "CALL_FUNCTION_KW",
            "Event(frame_info, event, arg, thread_local.depth, line_no=line_no)"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.formatter"
        ],
        [
            "LOAD_METHOD",
            "self.config.formatter.format_line_only"
        ],
        [
            "CALL_METHOD",
            "self.config.formatter.format_line_only(trace_event)"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_METHOD",
            "self.config.write"
        ],
        [
            "CALL_METHOD",
            "self.config.write(line)"
        ],
        [
            "COMPARE_OP",
            "event == 'exception'"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "thread_local.depth"
        ],
        [
            "CALL_FUNCTION",
            "Event(frame_info, event, arg, thread_local.depth)"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_name"
        ],
        [
            "COMPARE_OP",
            "frame.f_code.co_name == '<genexpr>'"
        ],
        [
            "CONTAINS_OP",
            "event not in ('return', 'exception')"
        ],
        [
            "LOAD_METHOD",
            "frame_info.update_variables"
        ],
        [
            "LOAD_ATTR",
            "self.watch"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.watch_extras"
        ],
        [
            "CALL_METHOD",
            "frame_info.update_variables(\n                self.watch,\n                self.config.watch_extras,\n                event,\n            )"
        ],
        [
            "CONTAINS_OP",
            "event in ('return', 'exit')"
        ],
        [
            "LOAD_ATTR",
            "self.frame_infos"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.formatter"
        ],
        [
            "LOAD_METHOD",
            "self.config.formatter.format"
        ],
        [
            "CALL_METHOD",
            "self.config.formatter.format(trace_event)"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_METHOD",
            "self.config.write"
        ],
        [
            "CALL_METHOD",
            "self.config.write(formatted)"
        ],
        [
            "LOAD_ATTR",
            "self.trace"
        ],
        [
            "CALL_FUNCTION",
            "Exception(\"birdseye doesn't support this version of Python\")"
        ],
        [
            "CALL_FUNCTION",
            "Exception(\"You must install birdseye separately to use spy: pip install birdseye\")"
        ],
        [
            "CALL_FUNCTION",
            "no_args_decorator(args, kwargs)"
        ],
        [
            "LOAD_METHOD",
            "self._trace"
        ],
        [
            "BINARY_SUBSCR",
            "args[0]"
        ],
        [
            "CALL_METHOD",
            "self._trace(args[0])"
        ],
        [
            "LOAD_ATTR",
            "self._trace"
        ],
        [
            "CALL_FUNCTION_EX",
            "self._trace(func, *args, **kwargs)"
        ],
        [
            "CALL_FUNCTION",
            "eye(func)"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.snoop"
        ],
        [
            "CALL_FUNCTION_EX",
            "self.config.snoop(*args, **kwargs)"
        ],
        [
            "CALL_FUNCTION",
            "self.config.snoop(*args, **kwargs)(traced)"
        ],
        [
            "LOAD_METHOD",
            "functools.wraps"
        ],
        [
            "CALL_METHOD",
            "functools.wraps(func)"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.enabled"
        ],
        [
            "CALL_FUNCTION_EX",
            "final_func(*func_args, **func_kwargs)"
        ]
    ],
    "utils.py": [
        [
            "LOAD_METHOD",
            "standard_library.install_aliases"
        ],
        [
            "CALL_METHOD",
            "standard_library.install_aliases()"
        ],
        [
            "LOAD_ATTR",
            "version_info.major"
        ],
        [
            "COMPARE_OP",
            "version_info.major == 2"
        ],
        [
            "UNARY_NOT",
            "not PY2"
        ],
        [
            "CALL_FUNCTION",
            "TypeVar('T')"
        ],
        [
            "CALL_FUNCTION",
            "TypeVar('RT')"
        ],
        [
            "LOAD_ATTR",
            "json.JSONEncoder"
        ],
        [
            "LOAD_METHOD",
            "ntpath.split"
        ],
        [
            "CALL_METHOD",
            "ntpath.split(path)"
        ],
        [
            "LOAD_METHOD",
            "ntpath.basename"
        ],
        [
            "CALL_METHOD",
            "ntpath.basename(head)"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.commonprefix"
        ],
        [
            "CALL_METHOD",
            "os.path.commonprefix(paths)"
        ],
        [
            "LOAD_METHOD",
            "ntpath.split"
        ],
        [
            "CALL_METHOD",
            "ntpath.split(prefix)"
        ],
        [
            "BINARY_SUBSCR",
            "ntpath.split(prefix)[0]"
        ],
        [
            "BINARY_SUBSCR",
            "paths[0]"
        ],
        [
            "CALL_FUNCTION",
            "len(prefix)"
        ],
        [
            "BINARY_SUBSCR",
            "paths[0][len(prefix)]"
        ],
        [
            "CONTAINS_OP",
            "first_char_after in r'\\/'"
        ],
        [
            "COMPARE_OP",
            "path == IPYTHON_FILE_PATH"
        ],
        [
            "CALL_FUNCTION",
            "common_ancestor(all_paths)"
        ],
        [
            "CONTAINS_OP",
            "prefix in r'\\/'"
        ],
        [
            "CALL_FUNCTION",
            "strip_required_prefix(path, prefix)"
        ],
        [
            "CALL_FUNCTION",
            "path_leaf(path)"
        ],
        [
            "COMPARE_OP",
            "f != IPYTHON_FILE_PATH"
        ],
        [
            "COMPARE_OP",
            "path == IPYTHON_FILE_PATH"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_ATTR",
            "os.path.sep"
        ],
        [
            "COMPARE_OP",
            "os.path.sep == '/'"
        ],
        [
            "LOAD_METHOD",
            "path.startswith"
        ],
        [
            "CALL_METHOD",
            "path.startswith('/')"
        ],
        [
            "BINARY_ADD",
            "'/' + path"
        ],
        [
            "CALL_FUNCTION",
            "type(obj)"
        ],
        [
            "LOAD_ATTR",
            "types.InstanceType"
        ],
        [
            "IS_OP",
            "t is types.InstanceType"
        ],
        [
            "LOAD_ATTR",
            "obj.__class__"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(x, type_or_tuple)"
        ],
        [
            "CALL_FUNCTION",
            "next(it)"
        ],
        [
            "CALL_FUNCTION",
            "raise_from(RuntimeError, e)"
        ],
        [
            "CALL_FUNCTION",
            "hasattr(expression, 'one_or_none')"
        ],
        [
            "LOAD_METHOD",
            "expression.one_or_none"
        ],
        [
            "CALL_METHOD",
            "expression.one_or_none()"
        ],
        [
            "LOAD_METHOD",
            "expression.all"
        ],
        [
            "CALL_METHOD",
            "expression.all()"
        ],
        [
            "CALL_FUNCTION",
            "len(result)"
        ],
        [
            "COMPARE_OP",
            "len(result) == 0"
        ],
        [
            "CALL_FUNCTION",
            "len(result)"
        ],
        [
            "COMPARE_OP",
            "len(result) == 1"
        ],
        [
            "BINARY_SUBSCR",
            "result[0]"
        ],
        [
            "CALL_FUNCTION",
            "Exception(\"There is more than one item returned for the supplied filter\")"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(x, list)"
        ],
        [
            "LOAD_METHOD",
            "result.extend"
        ],
        [
            "CALL_FUNCTION",
            "flatten_list(x)"
        ],
        [
            "CALL_METHOD",
            "result.extend(flatten_list(x))"
        ],
        [
            "LOAD_METHOD",
            "result.append"
        ],
        [
            "CALL_METHOD",
            "result.append(x)"
        ],
        [
            "LOAD_ATTR",
            "f.__code__"
        ],
        [
            "LOAD_ATTR",
            "code.co_name"
        ],
        [
            "LOAD_ATTR",
            "(lambda: 0).__code__"
        ],
        [
            "LOAD_ATTR",
            "(lambda: 0).__code__.co_name"
        ],
        [
            "COMPARE_OP",
            "code.co_name == (lambda: 0).__code__.co_name"
        ],
        [
            "LOAD_ATTR",
            "o.as_json"
        ],
        [
            "CALL_FUNCTION",
            "super(ProtocolEncoder, self)"
        ],
        [
            "LOAD_METHOD",
            "super(ProtocolEncoder, self).default"
        ],
        [
            "CALL_METHOD",
            "super(ProtocolEncoder, self).default(o)"
        ],
        [
            "CALL_FUNCTION",
            "method()"
        ],
        [
            "LOAD_METHOD",
            "io.open"
        ],
        [
            "CALL_METHOD",
            "io.open(filename, 'rb')"
        ],
        [
            "LOAD_ATTR",
            "fp.readline"
        ],
        [
            "CALL_FUNCTION",
            "detect_encoding(fp.readline)"
        ],
        [
            "LOAD_METHOD",
            "fp.seek"
        ],
        [
            "CALL_METHOD",
            "fp.seek(0)"
        ],
        [
            "LOAD_ATTR",
            "io.TextIOWrapper"
        ],
        [
            "CALL_FUNCTION_KW",
            "io.TextIOWrapper(fp, encoding, line_buffering=True)"
        ],
        [
            "LOAD_METHOD",
            "fp.close"
        ],
        [
            "CALL_METHOD",
            "fp.close()"
        ],
        [
            "LOAD_METHOD",
            "filename.endswith"
        ],
        [
            "CALL_METHOD",
            "filename.endswith('.pyc')"
        ],
        [
            "BINARY_SUBSCR",
            "filename[:-1]"
        ],
        [
            "CALL_FUNCTION",
            "open_with_encoding_check(filename)"
        ],
        [
            "LOAD_METHOD",
            "''.join"
        ],
        [
            "CALL_FUNCTION",
            "enumerate(f)"
        ],
        [
            "CALL_METHOD",
            "''.join([\n            '\\n' if i < 2 and cookie_re.match(line)\n            else line\n            for i, line in enumerate(f)\n        ])"
        ],
        [
            "COMPARE_OP",
            "i < 2"
        ],
        [
            "LOAD_METHOD",
            "cookie_re.match"
        ],
        [
            "CALL_METHOD",
            "cookie_re.match(line)"
        ],
        [
            "LOAD_METHOD",
            "tokens.get_tokens"
        ],
        [
            "CALL_METHOD",
            "tokens.get_tokens(function_node)"
        ],
        [
            "CALL_FUNCTION",
            "safe_next(t for t in tokens.get_tokens(function_node)\n                          if t.string == 'def' and t.type == token.NAME)"
        ],
        [
            "LOAD_ATTR",
            "def_token.startpos"
        ],
        [
            "LOAD_ATTR",
            "tokens.text"
        ],
        [
            "LOAD_ATTR",
            "function_node.last_token"
        ],
        [
            "LOAD_ATTR",
            "function_node.last_token.endpos"
        ],
        [
            "BINARY_SUBSCR",
            "tokens.text[startpos:function_node.last_token.endpos]"
        ],
        [
            "LOAD_METHOD",
            "tokens.text[startpos:function_node.last_token.endpos].rstrip"
        ],
        [
            "CALL_METHOD",
            "tokens.text[startpos:function_node.last_token.endpos].rstrip()"
        ],
        [
            "LOAD_METHOD",
            "source.startswith"
        ],
        [
            "CALL_METHOD",
            "source.startswith('def')"
        ],
        [
            "LOAD_ATTR",
            "t.string"
        ],
        [
            "COMPARE_OP",
            "t.string == 'def'"
        ],
        [
            "LOAD_ATTR",
            "t.type"
        ],
        [
            "LOAD_ATTR",
            "token.NAME"
        ],
        [
            "COMPARE_OP",
            "t.type == token.NAME"
        ],
        [
            "CALL_FUNCTION",
            "print(arg)"
        ],
        [
            "CALL_FUNCTION",
            "len(args)"
        ],
        [
            "COMPARE_OP",
            "len(args) == 1"
        ],
        [
            "BINARY_SUBSCR",
            "args[0]"
        ],
        [
            "LOAD_METHOD",
            "filename.startswith"
        ],
        [
            "CALL_METHOD",
            "filename.startswith('<ipython-input-')"
        ],
        [
            "LOAD_ATTR",
            "ast.ImportFrom"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(node, ast.ImportFrom)"
        ],
        [
            "LOAD_ATTR",
            "node.module"
        ],
        [
            "COMPARE_OP",
            "node.module == \"__future__\""
        ],
        [
            "LOAD_METHOD",
            "real_datetime.now"
        ],
        [
            "CALL_METHOD",
            "real_datetime.now()"
        ]
    ],
    "utils2.py": [
        [
            "LOAD_ATTR",
            "sys.version"
        ],
        [
            "LOAD_METHOD",
            "sys.version.lower"
        ],
        [
            "CALL_METHOD",
            "sys.version.lower()"
        ],
        [
            "CONTAINS_OP",
            "'pypy' in sys.version.lower()"
        ],
        [
            "LOAD_ATTR",
            "sys.version_info"
        ],
        [
            "BINARY_SUBSCR",
            "sys.version_info[:2]"
        ],
        [
            "CONTAINS_OP",
            "sys.version_info[:2] in [(3, 4), (3, 8)]"
        ],
        [
            "LOAD_ATTR",
            "inspect.iscoroutinefunction"
        ],
        [
            "LOAD_ATTR",
            "ast.Try"
        ],
        [
            "LOAD_ATTR",
            "ast.TryExcept"
        ],
        [
            "CALL_FUNCTION",
            "__import__(\"__builtin__\")"
        ],
        [
            "CALL_FUNCTION",
            "__import__(\"builtins\")"
        ],
        [
            "LOAD_ATTR",
            "ast.FormattedValue"
        ],
        [
            "CALL_FUNCTION",
            "try_register_repr('pandas', 'Series')"
        ],
        [
            "LOAD_METHOD",
            "''.join"
        ],
        [
            "CALL_METHOD",
            "''.join(\n        (c if (0 < ord(c) < 256) else '?') for c in s\n    )"
        ],
        [
            "CALL_FUNCTION",
            "ord(c)"
        ],
        [
            "CALL_FUNCTION",
            "len(seq)"
        ],
        [
            "COMPARE_OP",
            "len(seq) > max_length"
        ],
        [
            "CALL_FUNCTION",
            "len(middle)"
        ],
        [
            "BINARY_SUBTRACT",
            "max_length - len(middle)"
        ],
        [
            "BINARY_FLOOR_DIVIDE",
            "(max_length - len(middle)) // 2"
        ],
        [
            "CALL_FUNCTION",
            "len(middle)"
        ],
        [
            "BINARY_SUBTRACT",
            "max_length - len(middle)"
        ],
        [
            "BINARY_SUBTRACT",
            "max_length - len(middle) - left"
        ],
        [
            "BINARY_SUBSCR",
            "seq[:left]"
        ],
        [
            "BINARY_ADD",
            "seq[:left] + middle"
        ],
        [
            "UNARY_NEGATIVE",
            "-right"
        ],
        [
            "BINARY_SUBSCR",
            "seq[-right:]"
        ],
        [
            "BINARY_ADD",
            "seq[:left] + middle + seq[-right:]"
        ],
        [
            "CALL_FUNCTION",
            "truncate(string, max_length, '...')"
        ],
        [
            "CALL_FUNCTION",
            "truncate(lst, max_length, ['...'])"
        ],
        [
            "LOAD_ATTR",
            "six.string_types"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(x, six.string_types)"
        ],
        [
            "LOAD_METHOD",
            "x.replace"
        ],
        [
            "CALL_METHOD",
            "x.replace(',', ' ')"
        ],
        [
            "LOAD_METHOD",
            "x.replace(',', ' ').split"
        ],
        [
            "CALL_METHOD",
            "x.replace(',', ' ').split()"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(x, (list, set, tuple))"
        ],
        [
            "CALL_FUNCTION",
            "tuple(x)"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.basename"
        ],
        [
            "LOAD_ATTR",
            "code.co_filename"
        ],
        [
            "CALL_METHOD",
            "os.path.basename(code.co_filename)"
        ],
        [
            "LOAD_METHOD",
            "result.endswith"
        ],
        [
            "CALL_METHOD",
            "result.endswith('.pyc')"
        ],
        [
            "BINARY_SUBSCR",
            "result[:-1]"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_name"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code.co_name in ('<listcomp>', '<dictcomp>', '<setcomp>')"
        ],
        [
            "CALL_FUNCTION",
            "code('{}.x')"
        ],
        [
            "CALL_FUNCTION",
            "code('({})')"
        ],
        [
            "CALL_FUNCTION",
            "code('({}).x')"
        ],
        [
            "COMPARE_OP",
            "without_parens != code('({}).x')"
        ],
        [
            "LOAD_METHOD",
            "s.format"
        ],
        [
            "CALL_METHOD",
            "s.format(source)"
        ],
        [
            "CALL_FUNCTION",
            "compile(s.format(source), '<variable>', 'eval')"
        ],
        [
            "LOAD_ATTR",
            "compile(s.format(source), '<variable>', 'eval').co_code"
        ],
        [
            "CALL_FUNCTION",
            "needs_parentheses(source)"
        ],
        [
            "LOAD_METHOD",
            "'({})'.format"
        ],
        [
            "CALL_METHOD",
            "'({})'.format(source)"
        ],
        [
            "CALL_FUNCTION_KW",
            "cheap_repr(x, target_length=REPR_TARGET_LENGTH)"
        ],
        [
            "CALL_FUNCTION",
            "super(ArgDefaultDict, self)"
        ],
        [
            "LOAD_METHOD",
            "super(ArgDefaultDict, self).__init__"
        ],
        [
            "CALL_METHOD",
            "super(ArgDefaultDict, self).__init__()"
        ],
        [
            "LOAD_METHOD",
            "self.factory"
        ],
        [
            "CALL_METHOD",
            "self.factory(key)"
        ],
        [
            "CALL_FUNCTION",
            "len(lst)"
        ],
        [
            "COMPARE_OP",
            "len(lst) == 1"
        ],
        [
            "BINARY_ADD",
            "i + 1"
        ],
        [
            "CALL_FUNCTION",
            "str(i + 1)"
        ],
        [
            "BINARY_ADD",
            "' ' + str(i + 1)"
        ],
        [
            "CALL_FUNCTION",
            "hasattr(os, 'PathLike')"
        ],
        [
            "LOAD_ATTR",
            "os.PathLike"
        ],
        [
            "CALL_FUNCTION",
            "isinstance(x, os.PathLike)"
        ],
        [
            "CALL_FUNCTION",
            "hasattr(x, '__fspath__')"
        ],
        [
            "CALL_FUNCTION",
            "hasattr(x, 'open')"
        ],
        [
            "LOAD_ATTR",
            "x.__class__"
        ],
        [
            "LOAD_ATTR",
            "x.__class__.__name__"
        ],
        [
            "LOAD_METHOD",
            "x.__class__.__name__.lower"
        ],
        [
            "CALL_METHOD",
            "x.__class__.__name__.lower()"
        ],
        [
            "CONTAINS_OP",
            "'path' in x.__class__.__name__.lower()"
        ],
        [
            "CALL_FUNCTION",
            "len(args)"
        ],
        [
            "COMPARE_OP",
            "len(args) == 1"
        ],
        [
            "LOAD_METHOD",
            "inspect.isfunction"
        ],
        [
            "BINARY_SUBSCR",
            "args[0]"
        ],
        [
            "CALL_METHOD",
            "inspect.isfunction(args[0])"
        ],
        [
            "UNARY_NOT",
            "not kwargs"
        ],
        [
            "BINARY_ADD",
            "max_length + 2"
        ],
        [
            "COMPARE_OP",
            "length <= max_length + 2"
        ],
        [
            "CALL_FUNCTION",
            "range(length)"
        ],
        [
            "BINARY_FLOOR_DIVIDE",
            "max_length // 2"
        ],
        [
            "CALL_FUNCTION",
            "range(max_length // 2)"
        ],
        [
            "BINARY_FLOOR_DIVIDE",
            "max_length // 2"
        ],
        [
            "BINARY_SUBTRACT",
            "length - max_length // 2"
        ],
        [
            "CALL_FUNCTION",
            "range(length - max_length // 2,\n                           length)"
        ],
        [
            "CALL_FUNCTION",
            "chain(range(max_length // 2),\n                     range(length - max_length // 2,\n                           length))"
        ],
        [
            "CALL_FUNCTION",
            "len(x)"
        ],
        [
            "COMPARE_OP",
            "n == 0"
        ],
        [
            "CALL_FUNCTION",
            "repr(x)"
        ],
        [
            "LOAD_ATTR",
            "helper.level"
        ],
        [
            "BINARY_SUBTRACT",
            "helper.level - 1"
        ],
        [
            "LOAD_ATTR",
            "_repr_series_one_line.maxparts"
        ],
        [
            "CALL_FUNCTION",
            "_sample_indices(n, maxparts)"
        ],
        [
            "LOAD_ATTR",
            "x.index"
        ],
        [
            "BINARY_ADD",
            "i + 1"
        ],
        [
            "BINARY_SUBSCR",
            "x.index[i:i + 1]"
        ],
        [
            "LOAD_ATTR",
            "x.index[i:i + 1].format"
        ],
        [
            "CALL_FUNCTION_KW",
            "x.index[i:i + 1].format(sparsify=False)"
        ],
        [
            "BINARY_SUBSCR",
            "x.index[i:i + 1].format(sparsify=False)[0]"
        ],
        [
            "LOAD_ATTR",
            "x.iloc"
        ],
        [
            "BINARY_SUBSCR",
            "x.iloc[i]"
        ],
        [
            "LOAD_METHOD",
            "pieces.append"
        ],
        [
            "CALL_FUNCTION",
            "cheap_repr(v, newlevel)"
        ],
        [
            "BINARY_MODULO",
            "'%s = %s' % (k, cheap_repr(v, newlevel))"
        ],
        [
            "CALL_METHOD",
            "pieces.append('%s = %s' % (k, cheap_repr(v, newlevel)))"
        ],
        [
            "BINARY_ADD",
            "maxparts + 2"
        ],
        [
            "COMPARE_OP",
            "n > maxparts + 2"
        ],
        [
            "LOAD_METHOD",
            "pieces.insert"
        ],
        [
            "BINARY_FLOOR_DIVIDE",
            "maxparts // 2"
        ],
        [
            "CALL_METHOD",
            "pieces.insert(maxparts // 2, '...')"
        ],
        [
            "LOAD_METHOD",
            "'; '.join"
        ],
        [
            "CALL_METHOD",
            "'; '.join(pieces)"
        ]
    ]
}