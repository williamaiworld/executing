{
    "_parser.py": [
        [
            "STORE_NAME",
            "from __future__ import annotations"
        ],
        [
            "STORE_NAME",
            "from collections.abc import Iterable"
        ],
        [
            "STORE_NAME",
            "import string"
        ],
        [
            "STORE_NAME",
            "from types import MappingProxyType"
        ],
        [
            "STORE_NAME",
            "from typing import Any, BinaryIO, NamedTuple"
        ],
        [
            "STORE_NAME",
            "from typing import Any, BinaryIO, NamedTuple"
        ],
        [
            "STORE_NAME",
            "from typing import Any, BinaryIO, NamedTuple"
        ],
        [
            "STORE_NAME",
            "from ._re import (\n    RE_DATETIME,\n    RE_LOCALTIME,\n    RE_NUMBER,\n    match_to_datetime,\n    match_to_localtime,\n    match_to_number,\n)"
        ],
        [
            "STORE_NAME",
            "from ._re import (\n    RE_DATETIME,\n    RE_LOCALTIME,\n    RE_NUMBER,\n    match_to_datetime,\n    match_to_localtime,\n    match_to_number,\n)"
        ],
        [
            "STORE_NAME",
            "from ._re import (\n    RE_DATETIME,\n    RE_LOCALTIME,\n    RE_NUMBER,\n    match_to_datetime,\n    match_to_localtime,\n    match_to_number,\n)"
        ],
        [
            "STORE_NAME",
            "from ._re import (\n    RE_DATETIME,\n    RE_LOCALTIME,\n    RE_NUMBER,\n    match_to_datetime,\n    match_to_localtime,\n    match_to_number,\n)"
        ],
        [
            "STORE_NAME",
            "from ._re import (\n    RE_DATETIME,\n    RE_LOCALTIME,\n    RE_NUMBER,\n    match_to_datetime,\n    match_to_localtime,\n    match_to_number,\n)"
        ],
        [
            "STORE_NAME",
            "from ._re import (\n    RE_DATETIME,\n    RE_LOCALTIME,\n    RE_NUMBER,\n    match_to_datetime,\n    match_to_localtime,\n    match_to_number,\n)"
        ],
        [
            "STORE_NAME",
            "from ._types import Key, ParseFloat, Pos"
        ],
        [
            "STORE_NAME",
            "from ._types import Key, ParseFloat, Pos"
        ],
        [
            "STORE_NAME",
            "from ._types import Key, ParseFloat, Pos"
        ],
        [
            "LOAD_NAME",
            "frozenset"
        ],
        [
            "LOAD_NAME",
            "range"
        ],
        [
            "CALL",
            "range(32)"
        ],
        [
            "CALL",
            "(chr(i) for i in range(32))"
        ],
        [
            "CALL",
            "frozenset(chr(i) for i in range(32))"
        ],
        [
            "LOAD_NAME",
            "frozenset"
        ],
        [
            "LOAD_NAME",
            "chr"
        ],
        [
            "CALL",
            "chr(127)"
        ],
        [
            "CALL",
            "frozenset(chr(127))"
        ],
        [
            "BINARY_OP",
            "frozenset(chr(i) for i in range(32)) | frozenset(chr(127))"
        ],
        [
            "STORE_NAME",
            "ASCII_CTRL"
        ],
        [
            "LOAD_NAME",
            "ASCII_CTRL"
        ],
        [
            "LOAD_NAME",
            "frozenset"
        ],
        [
            "CALL",
            "frozenset(\"\\t\")"
        ],
        [
            "BINARY_OP",
            "ASCII_CTRL - frozenset(\"\\t\")"
        ],
        [
            "STORE_NAME",
            "ILLEGAL_BASIC_STR_CHARS"
        ],
        [
            "LOAD_NAME",
            "ASCII_CTRL"
        ],
        [
            "LOAD_NAME",
            "frozenset"
        ],
        [
            "CALL",
            "frozenset(\"\\t\\n\")"
        ],
        [
            "BINARY_OP",
            "ASCII_CTRL - frozenset(\"\\t\\n\")"
        ],
        [
            "STORE_NAME",
            "ILLEGAL_MULTILINE_BASIC_STR_CHARS"
        ],
        [
            "LOAD_NAME",
            "ILLEGAL_BASIC_STR_CHARS"
        ],
        [
            "STORE_NAME",
            "ILLEGAL_LITERAL_STR_CHARS"
        ],
        [
            "LOAD_NAME",
            "ILLEGAL_MULTILINE_BASIC_STR_CHARS"
        ],
        [
            "STORE_NAME",
            "ILLEGAL_MULTILINE_LITERAL_STR_CHARS"
        ],
        [
            "LOAD_NAME",
            "ILLEGAL_BASIC_STR_CHARS"
        ],
        [
            "STORE_NAME",
            "ILLEGAL_COMMENT_CHARS"
        ],
        [
            "LOAD_NAME",
            "frozenset"
        ],
        [
            "CALL",
            "frozenset(\" \\t\")"
        ],
        [
            "STORE_NAME",
            "TOML_WS"
        ],
        [
            "LOAD_NAME",
            "TOML_WS"
        ],
        [
            "LOAD_NAME",
            "frozenset"
        ],
        [
            "CALL",
            "frozenset(\"\\n\")"
        ],
        [
            "BINARY_OP",
            "TOML_WS | frozenset(\"\\n\")"
        ],
        [
            "STORE_NAME",
            "TOML_WS_AND_NEWLINE"
        ],
        [
            "LOAD_NAME",
            "frozenset"
        ],
        [
            "LOAD_NAME",
            "string"
        ],
        [
            "LOAD_ATTR",
            "string.ascii_letters"
        ],
        [
            "LOAD_NAME",
            "string"
        ],
        [
            "LOAD_ATTR",
            "string.digits"
        ],
        [
            "BINARY_OP",
            "string.ascii_letters + string.digits"
        ],
        [
            "BINARY_OP",
            "string.ascii_letters + string.digits + \"-_\""
        ],
        [
            "CALL",
            "frozenset(string.ascii_letters + string.digits + \"-_\")"
        ],
        [
            "STORE_NAME",
            "BARE_KEY_CHARS"
        ],
        [
            "LOAD_NAME",
            "BARE_KEY_CHARS"
        ],
        [
            "LOAD_NAME",
            "frozenset"
        ],
        [
            "CALL",
            "frozenset(\"\\\"'\")"
        ],
        [
            "BINARY_OP",
            "BARE_KEY_CHARS | frozenset(\"\\\"'\")"
        ],
        [
            "STORE_NAME",
            "KEY_INITIAL_CHARS"
        ],
        [
            "LOAD_NAME",
            "frozenset"
        ],
        [
            "LOAD_NAME",
            "string"
        ],
        [
            "LOAD_ATTR",
            "string.hexdigits"
        ],
        [
            "CALL",
            "frozenset(string.hexdigits)"
        ],
        [
            "STORE_NAME",
            "HEXDIGIT_CHARS"
        ],
        [
            "LOAD_NAME",
            "MappingProxyType"
        ],
        [
            "CALL",
            "MappingProxyType(\n    {\n        \"\\\\b\": \"\\u0008\",  # backspace\n        \"\\\\t\": \"\\u0009\",  # tab\n        \"\\\\n\": \"\\u000A\",  # linefeed\n        \"\\\\f\": \"\\u000C\",  # form feed\n        \"\\\\r\": \"\\u000D\",  # carriage return\n        '\\\\\"': \"\\u0022\",  # quote\n        \"\\\\\\\\\": \"\\u005C\",  # backslash\n    }\n)"
        ],
        [
            "STORE_NAME",
            "BASIC_STR_ESCAPE_REPLACEMENTS"
        ],
        [
            "LOAD_NAME",
            "ValueError"
        ],
        [
            "CALL",
            "class TOMLDecodeError(ValueError):\n    \"\"\"An error raised if a document is not valid TOML.\"\"\""
        ],
        [
            "STORE_NAME",
            "class TOMLDecodeError(ValueError):\n    \"\"\"An error raised if a document is not valid TOML.\"\"\""
        ],
        [
            "LOAD_NAME",
            "float"
        ],
        [
            "STORE_NAME",
            "def load(fp: BinaryIO, /, *, parse_float: ParseFloat = float) -> dict[str, Any]:\n    \"\"\"Parse TOML from a binary file object.\"\"\"\n    b = fp.read()\n    try:\n        s = b.decode()\n    except AttributeError:\n        raise TypeError(\n            \"File must be opened in binary mode, e.g. use `open('foo.toml', 'rb')`\"\n        ) from None\n    return loads(s, parse_float=parse_float)"
        ],
        [
            "LOAD_NAME",
            "float"
        ],
        [
            "STORE_NAME",
            "def loads(s: str, /, *, parse_float: ParseFloat = float) -> dict[str, Any]:  # noqa: C901\n    \"\"\"Parse TOML from a string.\"\"\"\n\n    # The spec allows converting \"\\r\\n\" to \"\\n\", even in string\n    # literals. Let's do so to simplify parsing.\n    src = s.replace(\"\\r\\n\", \"\\n\")\n    pos = 0\n    out = Output(NestedDict(), Flags())\n    header: Key = ()\n    parse_float = make_safe_parse_float(parse_float)\n\n    # Parse one statement at a time\n    # (typically means one line in TOML source)\n    while True:\n        # 1. Skip line leading whitespace\n        pos = skip_chars(src, pos, TOML_WS)\n\n        # 2. Parse rules. Expect one of the following:\n        #    - end of file\n        #    - end of line\n        #    - comment\n        #    - key/value pair\n        #    - append dict to list (and move to its namespace)\n        #    - create dict (and move to its namespace)\n        # Skip trailing whitespace when applicable.\n        try:\n            char = src[pos]\n        except IndexError:\n            break\n        if char == \"\\n\":\n            pos += 1\n            continue\n        if char in KEY_INITIAL_CHARS:\n            pos = key_value_rule(src, pos, out, header, parse_float)\n            pos = skip_chars(src, pos, TOML_WS)\n        elif char == \"[\":\n            try:\n                second_char: str | None = src[pos + 1]\n            except IndexError:\n                second_char = None\n            out.flags.finalize_pending()\n            if second_char == \"[\":\n                pos, header = create_list_rule(src, pos, out)\n            else:\n                pos, header = create_dict_rule(src, pos, out)\n            pos = skip_chars(src, pos, TOML_WS)\n        elif char != \"#\":\n            raise suffixed_err(src, pos, \"Invalid statement\")\n\n        # 3. Skip comment\n        pos = skip_comment(src, pos)\n\n        # 4. Expect end of line or end of file\n        try:\n            char = src[pos]\n        except IndexError:\n            break\n        if char != \"\\n\":\n            raise suffixed_err(\n                src, pos, \"Expected newline or end of document after a statement\"\n            )\n        pos += 1\n\n    return out.data.dict"
        ],
        [
            "CALL",
            "class Flags:\n    \"\"\"Flags that map to parsed keys/namespaces.\"\"\"\n\n    # Marks an immutable namespace (inline array or inline table).\n    FROZEN = 0\n    # Marks a nest that has been explicitly created and can no longer\n    # be opened using the \"[table]\" syntax.\n    EXPLICIT_NEST = 1\n\n    def __init__(self) -> None:\n        self._flags: dict[str, dict] = {}\n        self._pending_flags: set[tuple[Key, int]] = set()\n\n    def add_pending(self, key: Key, flag: int) -> None:\n        self._pending_flags.add((key, flag))\n\n    def finalize_pending(self) -> None:\n        for key, flag in self._pending_flags:\n            self.set(key, flag, recursive=False)\n        self._pending_flags.clear()\n\n    def unset_all(self, key: Key) -> None:\n        cont = self._flags\n        for k in key[:-1]:\n            if k not in cont:\n                return\n            cont = cont[k][\"nested\"]\n        cont.pop(key[-1], None)\n\n    def set(self, key: Key, flag: int, *, recursive: bool) -> None:  # noqa: A003\n        cont = self._flags\n        key_parent, key_stem = key[:-1], key[-1]\n        for k in key_parent:\n            if k not in cont:\n                cont[k] = {\"flags\": set(), \"recursive_flags\": set(), \"nested\": {}}\n            cont = cont[k][\"nested\"]\n        if key_stem not in cont:\n            cont[key_stem] = {\"flags\": set(), \"recursive_flags\": set(), \"nested\": {}}\n        cont[key_stem][\"recursive_flags\" if recursive else \"flags\"].add(flag)\n\n    def is_(self, key: Key, flag: int) -> bool:\n        if not key:\n            return False  # document root has no flags\n        cont = self._flags\n        for k in key[:-1]:\n            if k not in cont:\n                return False\n            inner_cont = cont[k]\n            if flag in inner_cont[\"recursive_flags\"]:\n                return True\n            cont = inner_cont[\"nested\"]\n        key_stem = key[-1]\n        if key_stem in cont:\n            cont = cont[key_stem]\n            return flag in cont[\"flags\"] or flag in cont[\"recursive_flags\"]\n        return False"
        ],
        [
            "STORE_NAME",
            "class Flags:\n    \"\"\"Flags that map to parsed keys/namespaces.\"\"\"\n\n    # Marks an immutable namespace (inline array or inline table).\n    FROZEN = 0\n    # Marks a nest that has been explicitly created and can no longer\n    # be opened using the \"[table]\" syntax.\n    EXPLICIT_NEST = 1\n\n    def __init__(self) -> None:\n        self._flags: dict[str, dict] = {}\n        self._pending_flags: set[tuple[Key, int]] = set()\n\n    def add_pending(self, key: Key, flag: int) -> None:\n        self._pending_flags.add((key, flag))\n\n    def finalize_pending(self) -> None:\n        for key, flag in self._pending_flags:\n            self.set(key, flag, recursive=False)\n        self._pending_flags.clear()\n\n    def unset_all(self, key: Key) -> None:\n        cont = self._flags\n        for k in key[:-1]:\n            if k not in cont:\n                return\n            cont = cont[k][\"nested\"]\n        cont.pop(key[-1], None)\n\n    def set(self, key: Key, flag: int, *, recursive: bool) -> None:  # noqa: A003\n        cont = self._flags\n        key_parent, key_stem = key[:-1], key[-1]\n        for k in key_parent:\n            if k not in cont:\n                cont[k] = {\"flags\": set(), \"recursive_flags\": set(), \"nested\": {}}\n            cont = cont[k][\"nested\"]\n        if key_stem not in cont:\n            cont[key_stem] = {\"flags\": set(), \"recursive_flags\": set(), \"nested\": {}}\n        cont[key_stem][\"recursive_flags\" if recursive else \"flags\"].add(flag)\n\n    def is_(self, key: Key, flag: int) -> bool:\n        if not key:\n            return False  # document root has no flags\n        cont = self._flags\n        for k in key[:-1]:\n            if k not in cont:\n                return False\n            inner_cont = cont[k]\n            if flag in inner_cont[\"recursive_flags\"]:\n                return True\n            cont = inner_cont[\"nested\"]\n        key_stem = key[-1]\n        if key_stem in cont:\n            cont = cont[key_stem]\n            return flag in cont[\"flags\"] or flag in cont[\"recursive_flags\"]\n        return False"
        ],
        [
            "CALL",
            "class NestedDict:\n    def __init__(self) -> None:\n        # The parsed content of the TOML document\n        self.dict: dict[str, Any] = {}\n\n    def get_or_create_nest(\n        self,\n        key: Key,\n        *,\n        access_lists: bool = True,\n    ) -> dict:\n        cont: Any = self.dict\n        for k in key:\n            if k not in cont:\n                cont[k] = {}\n            cont = cont[k]\n            if access_lists and isinstance(cont, list):\n                cont = cont[-1]\n            if not isinstance(cont, dict):\n                raise KeyError(\"There is no nest behind this key\")\n        return cont\n\n    def append_nest_to_list(self, key: Key) -> None:\n        cont = self.get_or_create_nest(key[:-1])\n        last_key = key[-1]\n        if last_key in cont:\n            list_ = cont[last_key]\n            if not isinstance(list_, list):\n                raise KeyError(\"An object other than list found behind this key\")\n            list_.append({})\n        else:\n            cont[last_key] = [{}]"
        ],
        [
            "STORE_NAME",
            "class NestedDict:\n    def __init__(self) -> None:\n        # The parsed content of the TOML document\n        self.dict: dict[str, Any] = {}\n\n    def get_or_create_nest(\n        self,\n        key: Key,\n        *,\n        access_lists: bool = True,\n    ) -> dict:\n        cont: Any = self.dict\n        for k in key:\n            if k not in cont:\n                cont[k] = {}\n            cont = cont[k]\n            if access_lists and isinstance(cont, list):\n                cont = cont[-1]\n            if not isinstance(cont, dict):\n                raise KeyError(\"There is no nest behind this key\")\n        return cont\n\n    def append_nest_to_list(self, key: Key) -> None:\n        cont = self.get_or_create_nest(key[:-1])\n        last_key = key[-1]\n        if last_key in cont:\n            list_ = cont[last_key]\n            if not isinstance(list_, list):\n                raise KeyError(\"An object other than list found behind this key\")\n            list_.append({})\n        else:\n            cont[last_key] = [{}]"
        ],
        [
            "LOAD_NAME",
            "NamedTuple"
        ],
        [
            "CALL",
            "class Output(NamedTuple):\n    data: NestedDict\n    flags: Flags"
        ],
        [
            "STORE_NAME",
            "class Output(NamedTuple):\n    data: NestedDict\n    flags: Flags"
        ],
        [
            "STORE_NAME",
            "def skip_chars(src: str, pos: Pos, chars: Iterable[str]) -> Pos:\n    try:\n        while src[pos] in chars:\n            pos += 1\n    except IndexError:\n        pass\n    return pos"
        ],
        [
            "STORE_NAME",
            "def skip_until(\n    src: str,\n    pos: Pos,\n    expect: str,\n    *,\n    error_on: frozenset[str],\n    error_on_eof: bool,\n) -> Pos:\n    try:\n        new_pos = src.index(expect, pos)\n    except ValueError:\n        new_pos = len(src)\n        if error_on_eof:\n            raise suffixed_err(src, new_pos, f\"Expected {expect!r}\") from None\n\n    if not error_on.isdisjoint(src[pos:new_pos]):\n        while src[pos] not in error_on:\n            pos += 1\n        raise suffixed_err(src, pos, f\"Found invalid character {src[pos]!r}\")\n    return new_pos"
        ],
        [
            "STORE_NAME",
            "def skip_comment(src: str, pos: Pos) -> Pos:\n    try:\n        char: str | None = src[pos]\n    except IndexError:\n        char = None\n    if char == \"#\":\n        return skip_until(\n            src, pos + 1, \"\\n\", error_on=ILLEGAL_COMMENT_CHARS, error_on_eof=False\n        )\n    return pos"
        ],
        [
            "STORE_NAME",
            "def skip_comments_and_array_ws(src: str, pos: Pos) -> Pos:\n    while True:\n        pos_before_skip = pos\n        pos = skip_chars(src, pos, TOML_WS_AND_NEWLINE)\n        pos = skip_comment(src, pos)\n        if pos == pos_before_skip:\n            return pos"
        ],
        [
            "STORE_NAME",
            "def create_dict_rule(src: str, pos: Pos, out: Output) -> tuple[Pos, Key]:\n    pos += 1  # Skip \"[\"\n    pos = skip_chars(src, pos, TOML_WS)\n    pos, key = parse_key(src, pos)\n\n    if out.flags.is_(key, Flags.EXPLICIT_NEST) or out.flags.is_(key, Flags.FROZEN):\n        raise suffixed_err(src, pos, f\"Cannot declare {key} twice\")\n    out.flags.set(key, Flags.EXPLICIT_NEST, recursive=False)\n    try:\n        out.data.get_or_create_nest(key)\n    except KeyError:\n        raise suffixed_err(src, pos, \"Cannot overwrite a value\") from None\n\n    if not src.startswith(\"]\", pos):\n        raise suffixed_err(src, pos, \"Expected ']' at the end of a table declaration\")\n    return pos + 1, key"
        ],
        [
            "STORE_NAME",
            "def create_list_rule(src: str, pos: Pos, out: Output) -> tuple[Pos, Key]:\n    pos += 2  # Skip \"[[\"\n    pos = skip_chars(src, pos, TOML_WS)\n    pos, key = parse_key(src, pos)\n\n    if out.flags.is_(key, Flags.FROZEN):\n        raise suffixed_err(src, pos, f\"Cannot mutate immutable namespace {key}\")\n    # Free the namespace now that it points to another empty list item...\n    out.flags.unset_all(key)\n    # ...but this key precisely is still prohibited from table declaration\n    out.flags.set(key, Flags.EXPLICIT_NEST, recursive=False)\n    try:\n        out.data.append_nest_to_list(key)\n    except KeyError:\n        raise suffixed_err(src, pos, \"Cannot overwrite a value\") from None\n\n    if not src.startswith(\"]]\", pos):\n        raise suffixed_err(src, pos, \"Expected ']]' at the end of an array declaration\")\n    return pos + 2, key"
        ],
        [
            "STORE_NAME",
            "def key_value_rule(\n    src: str, pos: Pos, out: Output, header: Key, parse_float: ParseFloat\n) -> Pos:\n    pos, key, value = parse_key_value_pair(src, pos, parse_float)\n    key_parent, key_stem = key[:-1], key[-1]\n    abs_key_parent = header + key_parent\n\n    relative_path_cont_keys = (header + key[:i] for i in range(1, len(key)))\n    for cont_key in relative_path_cont_keys:\n        # Check that dotted key syntax does not redefine an existing table\n        if out.flags.is_(cont_key, Flags.EXPLICIT_NEST):\n            raise suffixed_err(src, pos, f\"Cannot redefine namespace {cont_key}\")\n        # Containers in the relative path can't be opened with the table syntax or\n        # dotted key/value syntax in following table sections.\n        out.flags.add_pending(cont_key, Flags.EXPLICIT_NEST)\n\n    if out.flags.is_(abs_key_parent, Flags.FROZEN):\n        raise suffixed_err(\n            src, pos, f\"Cannot mutate immutable namespace {abs_key_parent}\"\n        )\n\n    try:\n        nest = out.data.get_or_create_nest(abs_key_parent)\n    except KeyError:\n        raise suffixed_err(src, pos, \"Cannot overwrite a value\") from None\n    if key_stem in nest:\n        raise suffixed_err(src, pos, \"Cannot overwrite a value\")\n    # Mark inline table and array namespaces recursively immutable\n    if isinstance(value, (dict, list)):\n        out.flags.set(header + key, Flags.FROZEN, recursive=True)\n    nest[key_stem] = value\n    return pos"
        ],
        [
            "STORE_NAME",
            "def parse_key_value_pair(\n    src: str, pos: Pos, parse_float: ParseFloat\n) -> tuple[Pos, Key, Any]:\n    pos, key = parse_key(src, pos)\n    try:\n        char: str | None = src[pos]\n    except IndexError:\n        char = None\n    if char != \"=\":\n        raise suffixed_err(src, pos, \"Expected '=' after a key in a key/value pair\")\n    pos += 1\n    pos = skip_chars(src, pos, TOML_WS)\n    pos, value = parse_value(src, pos, parse_float)\n    return pos, key, value"
        ],
        [
            "STORE_NAME",
            "def parse_key(src: str, pos: Pos) -> tuple[Pos, Key]:\n    pos, key_part = parse_key_part(src, pos)\n    key: Key = (key_part,)\n    pos = skip_chars(src, pos, TOML_WS)\n    while True:\n        try:\n            char: str | None = src[pos]\n        except IndexError:\n            char = None\n        if char != \".\":\n            return pos, key\n        pos += 1\n        pos = skip_chars(src, pos, TOML_WS)\n        pos, key_part = parse_key_part(src, pos)\n        key += (key_part,)\n        pos = skip_chars(src, pos, TOML_WS)"
        ],
        [
            "STORE_NAME",
            "def parse_key_part(src: str, pos: Pos) -> tuple[Pos, str]:\n    try:\n        char: str | None = src[pos]\n    except IndexError:\n        char = None\n    if char in BARE_KEY_CHARS:\n        start_pos = pos\n        pos = skip_chars(src, pos, BARE_KEY_CHARS)\n        return pos, src[start_pos:pos]\n    if char == \"'\":\n        return parse_literal_str(src, pos)\n    if char == '\"':\n        return parse_one_line_basic_str(src, pos)\n    raise suffixed_err(src, pos, \"Invalid initial character for a key part\")"
        ],
        [
            "STORE_NAME",
            "def parse_one_line_basic_str(src: str, pos: Pos) -> tuple[Pos, str]:\n    pos += 1\n    return parse_basic_str(src, pos, multiline=False)"
        ],
        [
            "STORE_NAME",
            "def parse_array(src: str, pos: Pos, parse_float: ParseFloat) -> tuple[Pos, list]:\n    pos += 1\n    array: list = []\n\n    pos = skip_comments_and_array_ws(src, pos)\n    if src.startswith(\"]\", pos):\n        return pos + 1, array\n    while True:\n        pos, val = parse_value(src, pos, parse_float)\n        array.append(val)\n        pos = skip_comments_and_array_ws(src, pos)\n\n        c = src[pos : pos + 1]\n        if c == \"]\":\n            return pos + 1, array\n        if c != \",\":\n            raise suffixed_err(src, pos, \"Unclosed array\")\n        pos += 1\n\n        pos = skip_comments_and_array_ws(src, pos)\n        if src.startswith(\"]\", pos):\n            return pos + 1, array"
        ],
        [
            "STORE_NAME",
            "def parse_inline_table(src: str, pos: Pos, parse_float: ParseFloat) -> tuple[Pos, dict]:\n    pos += 1\n    nested_dict = NestedDict()\n    flags = Flags()\n\n    pos = skip_chars(src, pos, TOML_WS)\n    if src.startswith(\"}\", pos):\n        return pos + 1, nested_dict.dict\n    while True:\n        pos, key, value = parse_key_value_pair(src, pos, parse_float)\n        key_parent, key_stem = key[:-1], key[-1]\n        if flags.is_(key, Flags.FROZEN):\n            raise suffixed_err(src, pos, f\"Cannot mutate immutable namespace {key}\")\n        try:\n            nest = nested_dict.get_or_create_nest(key_parent, access_lists=False)\n        except KeyError:\n            raise suffixed_err(src, pos, \"Cannot overwrite a value\") from None\n        if key_stem in nest:\n            raise suffixed_err(src, pos, f\"Duplicate inline table key {key_stem!r}\")\n        nest[key_stem] = value\n        pos = skip_chars(src, pos, TOML_WS)\n        c = src[pos : pos + 1]\n        if c == \"}\":\n            return pos + 1, nested_dict.dict\n        if c != \",\":\n            raise suffixed_err(src, pos, \"Unclosed inline table\")\n        if isinstance(value, (dict, list)):\n            flags.set(key, Flags.FROZEN, recursive=True)\n        pos += 1\n        pos = skip_chars(src, pos, TOML_WS)"
        ],
        [
            "STORE_NAME",
            "def parse_basic_str_escape(\n    src: str, pos: Pos, *, multiline: bool = False\n) -> tuple[Pos, str]:\n    escape_id = src[pos : pos + 2]\n    pos += 2\n    if multiline and escape_id in {\"\\\\ \", \"\\\\\\t\", \"\\\\\\n\"}:\n        # Skip whitespace until next non-whitespace character or end of\n        # the doc. Error if non-whitespace is found before newline.\n        if escape_id != \"\\\\\\n\":\n            pos = skip_chars(src, pos, TOML_WS)\n            try:\n                char = src[pos]\n            except IndexError:\n                return pos, \"\"\n            if char != \"\\n\":\n                raise suffixed_err(src, pos, \"Unescaped '\\\\' in a string\")\n            pos += 1\n        pos = skip_chars(src, pos, TOML_WS_AND_NEWLINE)\n        return pos, \"\"\n    if escape_id == \"\\\\u\":\n        return parse_hex_char(src, pos, 4)\n    if escape_id == \"\\\\U\":\n        return parse_hex_char(src, pos, 8)\n    try:\n        return pos, BASIC_STR_ESCAPE_REPLACEMENTS[escape_id]\n    except KeyError:\n        raise suffixed_err(src, pos, \"Unescaped '\\\\' in a string\") from None"
        ],
        [
            "STORE_NAME",
            "def parse_basic_str_escape_multiline(src: str, pos: Pos) -> tuple[Pos, str]:\n    return parse_basic_str_escape(src, pos, multiline=True)"
        ],
        [
            "STORE_NAME",
            "def parse_hex_char(src: str, pos: Pos, hex_len: int) -> tuple[Pos, str]:\n    hex_str = src[pos : pos + hex_len]\n    if len(hex_str) != hex_len or not HEXDIGIT_CHARS.issuperset(hex_str):\n        raise suffixed_err(src, pos, \"Invalid hex value\")\n    pos += hex_len\n    hex_int = int(hex_str, 16)\n    if not is_unicode_scalar_value(hex_int):\n        raise suffixed_err(src, pos, \"Escaped character is not a Unicode scalar value\")\n    return pos, chr(hex_int)"
        ],
        [
            "STORE_NAME",
            "def parse_literal_str(src: str, pos: Pos) -> tuple[Pos, str]:\n    pos += 1  # Skip starting apostrophe\n    start_pos = pos\n    pos = skip_until(\n        src, pos, \"'\", error_on=ILLEGAL_LITERAL_STR_CHARS, error_on_eof=True\n    )\n    return pos + 1, src[start_pos:pos]"
        ],
        [
            "STORE_NAME",
            "def parse_multiline_str(src: str, pos: Pos, *, literal: bool) -> tuple[Pos, str]:\n    pos += 3\n    if src.startswith(\"\\n\", pos):\n        pos += 1\n\n    if literal:\n        delim = \"'\"\n        end_pos = skip_until(\n            src,\n            pos,\n            \"'''\",\n            error_on=ILLEGAL_MULTILINE_LITERAL_STR_CHARS,\n            error_on_eof=True,\n        )\n        result = src[pos:end_pos]\n        pos = end_pos + 3\n    else:\n        delim = '\"'\n        pos, result = parse_basic_str(src, pos, multiline=True)\n\n    # Add at maximum two extra apostrophes/quotes if the end sequence\n    # is 4 or 5 chars long instead of just 3.\n    if not src.startswith(delim, pos):\n        return pos, result\n    pos += 1\n    if not src.startswith(delim, pos):\n        return pos, result + delim\n    pos += 1\n    return pos, result + (delim * 2)"
        ],
        [
            "STORE_NAME",
            "def parse_basic_str(src: str, pos: Pos, *, multiline: bool) -> tuple[Pos, str]:\n    if multiline:\n        error_on = ILLEGAL_MULTILINE_BASIC_STR_CHARS\n        parse_escapes = parse_basic_str_escape_multiline\n    else:\n        error_on = ILLEGAL_BASIC_STR_CHARS\n        parse_escapes = parse_basic_str_escape\n    result = \"\"\n    start_pos = pos\n    while True:\n        try:\n            char = src[pos]\n        except IndexError:\n            raise suffixed_err(src, pos, \"Unterminated string\") from None\n        if char == '\"':\n            if not multiline:\n                return pos + 1, result + src[start_pos:pos]\n            if src.startswith('\"\"\"', pos):\n                return pos + 3, result + src[start_pos:pos]\n            pos += 1\n            continue\n        if char == \"\\\\\":\n            result += src[start_pos:pos]\n            pos, parsed_escape = parse_escapes(src, pos)\n            result += parsed_escape\n            start_pos = pos\n            continue\n        if char in error_on:\n            raise suffixed_err(src, pos, f\"Illegal character {char!r}\")\n        pos += 1"
        ],
        [
            "STORE_NAME",
            "def parse_value(  # noqa: C901\n    src: str, pos: Pos, parse_float: ParseFloat\n) -> tuple[Pos, Any]:\n    try:\n        char: str | None = src[pos]\n    except IndexError:\n        char = None\n\n    # IMPORTANT: order conditions based on speed of checking and likelihood\n\n    # Basic strings\n    if char == '\"':\n        if src.startswith('\"\"\"', pos):\n            return parse_multiline_str(src, pos, literal=False)\n        return parse_one_line_basic_str(src, pos)\n\n    # Literal strings\n    if char == \"'\":\n        if src.startswith(\"'''\", pos):\n            return parse_multiline_str(src, pos, literal=True)\n        return parse_literal_str(src, pos)\n\n    # Booleans\n    if char == \"t\":\n        if src.startswith(\"true\", pos):\n            return pos + 4, True\n    if char == \"f\":\n        if src.startswith(\"false\", pos):\n            return pos + 5, False\n\n    # Arrays\n    if char == \"[\":\n        return parse_array(src, pos, parse_float)\n\n    # Inline tables\n    if char == \"{\":\n        return parse_inline_table(src, pos, parse_float)\n\n    # Dates and times\n    datetime_match = RE_DATETIME.match(src, pos)\n    if datetime_match:\n        try:\n            datetime_obj = match_to_datetime(datetime_match)\n        except ValueError as e:\n            raise suffixed_err(src, pos, \"Invalid date or datetime\") from e\n        return datetime_match.end(), datetime_obj\n    localtime_match = RE_LOCALTIME.match(src, pos)\n    if localtime_match:\n        return localtime_match.end(), match_to_localtime(localtime_match)\n\n    # Integers and \"normal\" floats.\n    # The regex will greedily match any type starting with a decimal\n    # char, so needs to be located after handling of dates and times.\n    number_match = RE_NUMBER.match(src, pos)\n    if number_match:\n        return number_match.end(), match_to_number(number_match, parse_float)\n\n    # Special floats\n    first_three = src[pos : pos + 3]\n    if first_three in {\"inf\", \"nan\"}:\n        return pos + 3, parse_float(first_three)\n    first_four = src[pos : pos + 4]\n    if first_four in {\"-inf\", \"+inf\", \"-nan\", \"+nan\"}:\n        return pos + 4, parse_float(first_four)\n\n    raise suffixed_err(src, pos, \"Invalid value\")"
        ],
        [
            "STORE_NAME",
            "def suffixed_err(src: str, pos: Pos, msg: str) -> TOMLDecodeError:\n    \"\"\"Return a `TOMLDecodeError` where error message is suffixed with\n    coordinates in source.\"\"\"\n\n    def coord_repr(src: str, pos: Pos) -> str:\n        if pos >= len(src):\n            return \"end of document\"\n        line = src.count(\"\\n\", 0, pos) + 1\n        if line == 1:\n            column = pos + 1\n        else:\n            column = pos - src.rindex(\"\\n\", 0, pos)\n        return f\"line {line}, column {column}\"\n\n    return TOMLDecodeError(f\"{msg} (at {coord_repr(src, pos)})\")"
        ],
        [
            "STORE_NAME",
            "def is_unicode_scalar_value(codepoint: int) -> bool:\n    return (0 <= codepoint <= 55295) or (57344 <= codepoint <= 1114111)"
        ],
        [
            "STORE_NAME",
            "def make_safe_parse_float(parse_float: ParseFloat) -> ParseFloat:\n    \"\"\"A decorator to make `parse_float` safe.\n\n    `parse_float` must not return dicts or lists, because these types\n    would be mixed with parsed TOML tables and arrays, thus confusing\n    the parser. The returned decorated callable raises `ValueError`\n    instead of returning illegal types.\n    \"\"\"\n    # The default `float` callable never returns illegal types. Optimize it.\n    if parse_float is float:  # type: ignore[comparison-overlap]\n        return float\n\n    def safe_parse_float(float_str: str) -> Any:\n        float_value = parse_float(float_str)\n        if isinstance(float_value, (dict, list)):\n            raise ValueError(\"parse_float must not return dicts or lists\")\n        return float_value\n\n    return safe_parse_float"
        ],
        [
            "LOAD_FAST",
            "(chr(i) for i in range(32))"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "LOAD_GLOBAL",
            "chr"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "CALL",
            "chr(i)"
        ],
        [
            "STORE_NAME",
            "\"\"\"An error raised if a document is not valid TOML.\"\"\""
        ],
        [
            "LOAD_FAST",
            "fp"
        ],
        [
            "LOAD_METHOD",
            "fp.read"
        ],
        [
            "CALL",
            "fp.read()"
        ],
        [
            "STORE_FAST",
            "b"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "LOAD_METHOD",
            "b.decode"
        ],
        [
            "CALL",
            "b.decode()"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_GLOBAL",
            "AttributeError"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "CALL",
            "TypeError(\n            \"File must be opened in binary mode, e.g. use `open('foo.toml', 'rb')`\"\n        )"
        ],
        [
            "LOAD_GLOBAL",
            "loads"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "parse_float"
        ],
        [
            "CALL",
            "loads(s, parse_float=parse_float)"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_METHOD",
            "s.replace"
        ],
        [
            "CALL",
            "s.replace(\"\\r\\n\", \"\\n\")"
        ],
        [
            "STORE_FAST",
            "src"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "Output"
        ],
        [
            "LOAD_GLOBAL",
            "NestedDict"
        ],
        [
            "CALL",
            "NestedDict()"
        ],
        [
            "LOAD_GLOBAL",
            "Flags"
        ],
        [
            "CALL",
            "Flags()"
        ],
        [
            "CALL",
            "Output(NestedDict(), Flags())"
        ],
        [
            "STORE_FAST",
            "out"
        ],
        [
            "STORE_FAST",
            "header"
        ],
        [
            "LOAD_GLOBAL",
            "make_safe_parse_float"
        ],
        [
            "LOAD_FAST",
            "parse_float"
        ],
        [
            "CALL",
            "make_safe_parse_float(parse_float)"
        ],
        [
            "STORE_FAST",
            "parse_float"
        ],
        [
            "LOAD_GLOBAL",
            "skip_chars"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "TOML_WS"
        ],
        [
            "CALL",
            "skip_chars(src, pos, TOML_WS)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_SUBSCR",
            "src[pos]"
        ],
        [
            "STORE_FAST",
            "char"
        ],
        [
            "LOAD_GLOBAL",
            "IndexError"
        ],
        [
            "LOAD_FAST",
            "char"
        ],
        [
            "COMPARE_OP",
            "char == \"\\n\""
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos += 1"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "char"
        ],
        [
            "LOAD_GLOBAL",
            "KEY_INITIAL_CHARS"
        ],
        [
            "CONTAINS_OP",
            "char in KEY_INITIAL_CHARS"
        ],
        [
            "LOAD_GLOBAL",
            "key_value_rule"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "out"
        ],
        [
            "LOAD_FAST",
            "header"
        ],
        [
            "LOAD_FAST",
            "parse_float"
        ],
        [
            "CALL",
            "key_value_rule(src, pos, out, header, parse_float)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "skip_chars"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "TOML_WS"
        ],
        [
            "CALL",
            "skip_chars(src, pos, TOML_WS)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "char"
        ],
        [
            "COMPARE_OP",
            "char == \"[\""
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos + 1"
        ],
        [
            "BINARY_SUBSCR",
            "src[pos + 1]"
        ],
        [
            "STORE_FAST",
            "second_char"
        ],
        [
            "LOAD_GLOBAL",
            "IndexError"
        ],
        [
            "STORE_FAST",
            "second_char"
        ],
        [
            "LOAD_FAST",
            "out"
        ],
        [
            "LOAD_ATTR",
            "out.flags"
        ],
        [
            "LOAD_METHOD",
            "out.flags.finalize_pending"
        ],
        [
            "CALL",
            "out.flags.finalize_pending()"
        ],
        [
            "LOAD_FAST",
            "second_char"
        ],
        [
            "COMPARE_OP",
            "second_char == \"[\""
        ],
        [
            "LOAD_GLOBAL",
            "create_list_rule"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "out"
        ],
        [
            "CALL",
            "create_list_rule(src, pos, out)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "STORE_FAST",
            "header"
        ],
        [
            "LOAD_GLOBAL",
            "create_dict_rule"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "out"
        ],
        [
            "CALL",
            "create_dict_rule(src, pos, out)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "STORE_FAST",
            "header"
        ],
        [
            "LOAD_GLOBAL",
            "skip_chars"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "TOML_WS"
        ],
        [
            "CALL",
            "skip_chars(src, pos, TOML_WS)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "char"
        ],
        [
            "COMPARE_OP",
            "char != \"#\""
        ],
        [
            "LOAD_GLOBAL",
            "suffixed_err"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "suffixed_err(src, pos, \"Invalid statement\")"
        ],
        [
            "LOAD_GLOBAL",
            "skip_comment"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "skip_comment(src, pos)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_SUBSCR",
            "src[pos]"
        ],
        [
            "STORE_FAST",
            "char"
        ],
        [
            "LOAD_GLOBAL",
            "IndexError"
        ],
        [
            "LOAD_FAST",
            "char"
        ],
        [
            "COMPARE_OP",
            "char != \"\\n\""
        ],
        [
            "LOAD_GLOBAL",
            "suffixed_err"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "suffixed_err(\n                src, pos, \"Expected newline or end of document after a statement\"\n            )"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos += 1"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "out"
        ],
        [
            "LOAD_ATTR",
            "out.data"
        ],
        [
            "LOAD_ATTR",
            "out.data.dict"
        ],
        [
            "STORE_NAME",
            "\"\"\"Flags that map to parsed keys/namespaces.\"\"\""
        ],
        [
            "STORE_NAME",
            "FROZEN"
        ],
        [
            "STORE_NAME",
            "EXPLICIT_NEST"
        ],
        [
            "STORE_NAME",
            "    def __init__(self) -> None:\n        self._flags: dict[str, dict] = {}\n        self._pending_flags: set[tuple[Key, int]] = set()"
        ],
        [
            "STORE_NAME",
            "    def add_pending(self, key: Key, flag: int) -> None:\n        self._pending_flags.add((key, flag))"
        ],
        [
            "STORE_NAME",
            "    def finalize_pending(self) -> None:\n        for key, flag in self._pending_flags:\n            self.set(key, flag, recursive=False)\n        self._pending_flags.clear()"
        ],
        [
            "STORE_NAME",
            "    def unset_all(self, key: Key) -> None:\n        cont = self._flags\n        for k in key[:-1]:\n            if k not in cont:\n                return\n            cont = cont[k][\"nested\"]\n        cont.pop(key[-1], None)"
        ],
        [
            "STORE_NAME",
            "    def set(self, key: Key, flag: int, *, recursive: bool) -> None:  # noqa: A003\n        cont = self._flags\n        key_parent, key_stem = key[:-1], key[-1]\n        for k in key_parent:\n            if k not in cont:\n                cont[k] = {\"flags\": set(), \"recursive_flags\": set(), \"nested\": {}}\n            cont = cont[k][\"nested\"]\n        if key_stem not in cont:\n            cont[key_stem] = {\"flags\": set(), \"recursive_flags\": set(), \"nested\": {}}\n        cont[key_stem][\"recursive_flags\" if recursive else \"flags\"].add(flag)"
        ],
        [
            "STORE_NAME",
            "    def is_(self, key: Key, flag: int) -> bool:\n        if not key:\n            return False  # document root has no flags\n        cont = self._flags\n        for k in key[:-1]:\n            if k not in cont:\n                return False\n            inner_cont = cont[k]\n            if flag in inner_cont[\"recursive_flags\"]:\n                return True\n            cont = inner_cont[\"nested\"]\n        key_stem = key[-1]\n        if key_stem in cont:\n            cont = cont[key_stem]\n            return flag in cont[\"flags\"] or flag in cont[\"recursive_flags\"]\n        return False"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._flags"
        ],
        [
            "LOAD_GLOBAL",
            "set"
        ],
        [
            "CALL",
            "set()"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._pending_flags"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._pending_flags"
        ],
        [
            "LOAD_METHOD",
            "self._pending_flags.add"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "LOAD_FAST",
            "flag"
        ],
        [
            "CALL",
            "self._pending_flags.add((key, flag))"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._pending_flags"
        ],
        [
            "STORE_FAST",
            "key"
        ],
        [
            "STORE_FAST",
            "flag"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.set"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "LOAD_FAST",
            "flag"
        ],
        [
            "CALL",
            "self.set(key, flag, recursive=False)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._pending_flags"
        ],
        [
            "LOAD_METHOD",
            "self._pending_flags.clear"
        ],
        [
            "CALL",
            "self._pending_flags.clear()"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._flags"
        ],
        [
            "STORE_FAST",
            "cont"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "BINARY_SUBSCR",
            "key[:-1]"
        ],
        [
            "STORE_FAST",
            "k"
        ],
        [
            "LOAD_FAST",
            "k"
        ],
        [
            "LOAD_FAST",
            "cont"
        ],
        [
            "CONTAINS_OP",
            "k not in cont"
        ],
        [
            "LOAD_FAST",
            "cont"
        ],
        [
            "LOAD_FAST",
            "k"
        ],
        [
            "BINARY_SUBSCR",
            "cont[k]"
        ],
        [
            "BINARY_SUBSCR",
            "cont[k][\"nested\"]"
        ],
        [
            "STORE_FAST",
            "cont"
        ],
        [
            "LOAD_FAST",
            "cont"
        ],
        [
            "LOAD_METHOD",
            "cont.pop"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "BINARY_SUBSCR",
            "key[-1]"
        ],
        [
            "CALL",
            "cont.pop(key[-1], None)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._flags"
        ],
        [
            "STORE_FAST",
            "cont"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "BINARY_SUBSCR",
            "key[:-1]"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "BINARY_SUBSCR",
            "key[-1]"
        ],
        [
            "STORE_FAST",
            "key_stem"
        ],
        [
            "STORE_FAST",
            "key_parent"
        ],
        [
            "LOAD_FAST",
            "key_parent"
        ],
        [
            "STORE_FAST",
            "k"
        ],
        [
            "LOAD_FAST",
            "k"
        ],
        [
            "LOAD_FAST",
            "cont"
        ],
        [
            "CONTAINS_OP",
            "k not in cont"
        ],
        [
            "LOAD_GLOBAL",
            "set"
        ],
        [
            "CALL",
            "set()"
        ],
        [
            "LOAD_GLOBAL",
            "set"
        ],
        [
            "CALL",
            "set()"
        ],
        [
            "LOAD_FAST",
            "cont"
        ],
        [
            "LOAD_FAST",
            "k"
        ],
        [
            "STORE_SUBSCR",
            "cont[k]"
        ],
        [
            "LOAD_FAST",
            "cont"
        ],
        [
            "LOAD_FAST",
            "k"
        ],
        [
            "BINARY_SUBSCR",
            "cont[k]"
        ],
        [
            "BINARY_SUBSCR",
            "cont[k][\"nested\"]"
        ],
        [
            "STORE_FAST",
            "cont"
        ],
        [
            "LOAD_FAST",
            "key_stem"
        ],
        [
            "LOAD_FAST",
            "cont"
        ],
        [
            "CONTAINS_OP",
            "key_stem not in cont"
        ],
        [
            "LOAD_GLOBAL",
            "set"
        ],
        [
            "CALL",
            "set()"
        ],
        [
            "LOAD_GLOBAL",
            "set"
        ],
        [
            "CALL",
            "set()"
        ],
        [
            "LOAD_FAST",
            "cont"
        ],
        [
            "LOAD_FAST",
            "key_stem"
        ],
        [
            "STORE_SUBSCR",
            "cont[key_stem]"
        ],
        [
            "LOAD_FAST",
            "cont"
        ],
        [
            "LOAD_FAST",
            "key_stem"
        ],
        [
            "BINARY_SUBSCR",
            "cont[key_stem]"
        ],
        [
            "LOAD_FAST",
            "recursive"
        ],
        [
            "BINARY_SUBSCR",
            "cont[key_stem][\"recursive_flags\" if recursive else \"flags\"]"
        ],
        [
            "LOAD_METHOD",
            "cont[key_stem][\"recursive_flags\" if recursive else \"flags\"].add"
        ],
        [
            "LOAD_FAST",
            "flag"
        ],
        [
            "CALL",
            "cont[key_stem][\"recursive_flags\" if recursive else \"flags\"].add(flag)"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._flags"
        ],
        [
            "STORE_FAST",
            "cont"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "BINARY_SUBSCR",
            "key[:-1]"
        ],
        [
            "STORE_FAST",
            "k"
        ],
        [
            "LOAD_FAST",
            "k"
        ],
        [
            "LOAD_FAST",
            "cont"
        ],
        [
            "CONTAINS_OP",
            "k not in cont"
        ],
        [
            "LOAD_FAST",
            "cont"
        ],
        [
            "LOAD_FAST",
            "k"
        ],
        [
            "BINARY_SUBSCR",
            "cont[k]"
        ],
        [
            "STORE_FAST",
            "inner_cont"
        ],
        [
            "LOAD_FAST",
            "flag"
        ],
        [
            "LOAD_FAST",
            "inner_cont"
        ],
        [
            "BINARY_SUBSCR",
            "inner_cont[\"recursive_flags\"]"
        ],
        [
            "CONTAINS_OP",
            "flag in inner_cont[\"recursive_flags\"]"
        ],
        [
            "LOAD_FAST",
            "inner_cont"
        ],
        [
            "BINARY_SUBSCR",
            "inner_cont[\"nested\"]"
        ],
        [
            "STORE_FAST",
            "cont"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "BINARY_SUBSCR",
            "key[-1]"
        ],
        [
            "STORE_FAST",
            "key_stem"
        ],
        [
            "LOAD_FAST",
            "key_stem"
        ],
        [
            "LOAD_FAST",
            "cont"
        ],
        [
            "CONTAINS_OP",
            "key_stem in cont"
        ],
        [
            "LOAD_FAST",
            "cont"
        ],
        [
            "LOAD_FAST",
            "key_stem"
        ],
        [
            "BINARY_SUBSCR",
            "cont[key_stem]"
        ],
        [
            "STORE_FAST",
            "cont"
        ],
        [
            "LOAD_FAST",
            "flag"
        ],
        [
            "LOAD_FAST",
            "cont"
        ],
        [
            "BINARY_SUBSCR",
            "cont[\"flags\"]"
        ],
        [
            "CONTAINS_OP",
            "flag in cont[\"flags\"]"
        ],
        [
            "LOAD_FAST",
            "flag"
        ],
        [
            "LOAD_FAST",
            "cont"
        ],
        [
            "BINARY_SUBSCR",
            "cont[\"recursive_flags\"]"
        ],
        [
            "CONTAINS_OP",
            "flag in cont[\"recursive_flags\"]"
        ],
        [
            "STORE_NAME",
            "    def __init__(self) -> None:\n        # The parsed content of the TOML document\n        self.dict: dict[str, Any] = {}"
        ],
        [
            "STORE_NAME",
            "    def get_or_create_nest(\n        self,\n        key: Key,\n        *,\n        access_lists: bool = True,\n    ) -> dict:\n        cont: Any = self.dict\n        for k in key:\n            if k not in cont:\n                cont[k] = {}\n            cont = cont[k]\n            if access_lists and isinstance(cont, list):\n                cont = cont[-1]\n            if not isinstance(cont, dict):\n                raise KeyError(\"There is no nest behind this key\")\n        return cont"
        ],
        [
            "STORE_NAME",
            "    def append_nest_to_list(self, key: Key) -> None:\n        cont = self.get_or_create_nest(key[:-1])\n        last_key = key[-1]\n        if last_key in cont:\n            list_ = cont[last_key]\n            if not isinstance(list_, list):\n                raise KeyError(\"An object other than list found behind this key\")\n            list_.append({})\n        else:\n            cont[last_key] = [{}]"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.dict"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.dict"
        ],
        [
            "STORE_FAST",
            "cont"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "STORE_FAST",
            "k"
        ],
        [
            "LOAD_FAST",
            "k"
        ],
        [
            "LOAD_FAST",
            "cont"
        ],
        [
            "CONTAINS_OP",
            "k not in cont"
        ],
        [
            "LOAD_FAST",
            "cont"
        ],
        [
            "LOAD_FAST",
            "k"
        ],
        [
            "STORE_SUBSCR",
            "cont[k]"
        ],
        [
            "LOAD_FAST",
            "cont"
        ],
        [
            "LOAD_FAST",
            "k"
        ],
        [
            "BINARY_SUBSCR",
            "cont[k]"
        ],
        [
            "STORE_FAST",
            "cont"
        ],
        [
            "LOAD_FAST",
            "access_lists"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "cont"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "CALL",
            "isinstance(cont, list)"
        ],
        [
            "LOAD_FAST",
            "cont"
        ],
        [
            "BINARY_SUBSCR",
            "cont[-1]"
        ],
        [
            "STORE_FAST",
            "cont"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "cont"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "CALL",
            "isinstance(cont, dict)"
        ],
        [
            "LOAD_GLOBAL",
            "KeyError"
        ],
        [
            "CALL",
            "KeyError(\"There is no nest behind this key\")"
        ],
        [
            "LOAD_FAST",
            "cont"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.get_or_create_nest"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "BINARY_SUBSCR",
            "key[:-1]"
        ],
        [
            "CALL",
            "self.get_or_create_nest(key[:-1])"
        ],
        [
            "STORE_FAST",
            "cont"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "BINARY_SUBSCR",
            "key[-1]"
        ],
        [
            "STORE_FAST",
            "last_key"
        ],
        [
            "LOAD_FAST",
            "last_key"
        ],
        [
            "LOAD_FAST",
            "cont"
        ],
        [
            "CONTAINS_OP",
            "last_key in cont"
        ],
        [
            "LOAD_FAST",
            "cont"
        ],
        [
            "LOAD_FAST",
            "last_key"
        ],
        [
            "BINARY_SUBSCR",
            "cont[last_key]"
        ],
        [
            "STORE_FAST",
            "list_"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "list_"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "CALL",
            "isinstance(list_, list)"
        ],
        [
            "LOAD_GLOBAL",
            "KeyError"
        ],
        [
            "CALL",
            "KeyError(\"An object other than list found behind this key\")"
        ],
        [
            "LOAD_FAST",
            "list_"
        ],
        [
            "LOAD_METHOD",
            "list_.append"
        ],
        [
            "CALL",
            "list_.append({})"
        ],
        [
            "LOAD_FAST",
            "cont"
        ],
        [
            "LOAD_FAST",
            "last_key"
        ],
        [
            "STORE_SUBSCR",
            "cont[last_key]"
        ],
        [
            "LOAD_NAME",
            "data: NestedDict"
        ],
        [
            "STORE_SUBSCR",
            "data: NestedDict"
        ],
        [
            "LOAD_NAME",
            "flags: Flags"
        ],
        [
            "STORE_SUBSCR",
            "flags: Flags"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_SUBSCR",
            "src[pos]"
        ],
        [
            "LOAD_FAST",
            "chars"
        ],
        [
            "CONTAINS_OP",
            "src[pos] in chars"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos += 1"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_SUBSCR",
            "src[pos]"
        ],
        [
            "LOAD_FAST",
            "chars"
        ],
        [
            "CONTAINS_OP",
            "src[pos] in chars"
        ],
        [
            "LOAD_GLOBAL",
            "IndexError"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_METHOD",
            "src.index"
        ],
        [
            "LOAD_FAST",
            "expect"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "src.index(expect, pos)"
        ],
        [
            "STORE_FAST",
            "new_pos"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "CALL",
            "len(src)"
        ],
        [
            "STORE_FAST",
            "new_pos"
        ],
        [
            "LOAD_FAST",
            "error_on_eof"
        ],
        [
            "LOAD_GLOBAL",
            "suffixed_err"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "new_pos"
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "CALL",
            "suffixed_err(src, new_pos, f\"Expected {expect!r}\")"
        ],
        [
            "LOAD_FAST",
            "error_on"
        ],
        [
            "LOAD_METHOD",
            "error_on.isdisjoint"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "new_pos"
        ],
        [
            "BINARY_SUBSCR",
            "src[pos:new_pos]"
        ],
        [
            "CALL",
            "error_on.isdisjoint(src[pos:new_pos])"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_SUBSCR",
            "src[pos]"
        ],
        [
            "LOAD_FAST",
            "error_on"
        ],
        [
            "CONTAINS_OP",
            "src[pos] not in error_on"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos += 1"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_SUBSCR",
            "src[pos]"
        ],
        [
            "LOAD_FAST",
            "error_on"
        ],
        [
            "CONTAINS_OP",
            "src[pos] not in error_on"
        ],
        [
            "LOAD_GLOBAL",
            "suffixed_err"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "BINARY_SUBSCR",
            ""
        ],
        [
            "CALL",
            "suffixed_err(src, pos, f\"Found invalid character {src[pos]!r}\")"
        ],
        [
            "LOAD_FAST",
            "new_pos"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_SUBSCR",
            "src[pos]"
        ],
        [
            "STORE_FAST",
            "char"
        ],
        [
            "LOAD_GLOBAL",
            "IndexError"
        ],
        [
            "STORE_FAST",
            "char"
        ],
        [
            "LOAD_FAST",
            "char"
        ],
        [
            "COMPARE_OP",
            "char == \"#\""
        ],
        [
            "LOAD_GLOBAL",
            "skip_until"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos + 1"
        ],
        [
            "LOAD_GLOBAL",
            "ILLEGAL_COMMENT_CHARS"
        ],
        [
            "CALL",
            "skip_until(\n            src, pos + 1, \"\\n\", error_on=ILLEGAL_COMMENT_CHARS, error_on_eof=False\n        )"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "STORE_FAST",
            "pos_before_skip"
        ],
        [
            "LOAD_GLOBAL",
            "skip_chars"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "TOML_WS_AND_NEWLINE"
        ],
        [
            "CALL",
            "skip_chars(src, pos, TOML_WS_AND_NEWLINE)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "skip_comment"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "skip_comment(src, pos)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "pos_before_skip"
        ],
        [
            "COMPARE_OP",
            "pos == pos_before_skip"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos += 1"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "skip_chars"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "TOML_WS"
        ],
        [
            "CALL",
            "skip_chars(src, pos, TOML_WS)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "parse_key"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "parse_key(src, pos)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "STORE_FAST",
            "key"
        ],
        [
            "LOAD_FAST",
            "out"
        ],
        [
            "LOAD_ATTR",
            "out.flags"
        ],
        [
            "LOAD_METHOD",
            "out.flags.is_"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "LOAD_GLOBAL",
            "Flags"
        ],
        [
            "LOAD_ATTR",
            "Flags.EXPLICIT_NEST"
        ],
        [
            "CALL",
            "out.flags.is_(key, Flags.EXPLICIT_NEST)"
        ],
        [
            "LOAD_FAST",
            "out"
        ],
        [
            "LOAD_ATTR",
            "out.flags"
        ],
        [
            "LOAD_METHOD",
            "out.flags.is_"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "LOAD_GLOBAL",
            "Flags"
        ],
        [
            "LOAD_ATTR",
            "Flags.FROZEN"
        ],
        [
            "CALL",
            "out.flags.is_(key, Flags.FROZEN)"
        ],
        [
            "LOAD_GLOBAL",
            "suffixed_err"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "CALL",
            "suffixed_err(src, pos, f\"Cannot declare {key} twice\")"
        ],
        [
            "LOAD_FAST",
            "out"
        ],
        [
            "LOAD_ATTR",
            "out.flags"
        ],
        [
            "LOAD_METHOD",
            "out.flags.set"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "LOAD_GLOBAL",
            "Flags"
        ],
        [
            "LOAD_ATTR",
            "Flags.EXPLICIT_NEST"
        ],
        [
            "CALL",
            "out.flags.set(key, Flags.EXPLICIT_NEST, recursive=False)"
        ],
        [
            "LOAD_FAST",
            "out"
        ],
        [
            "LOAD_ATTR",
            "out.data"
        ],
        [
            "LOAD_METHOD",
            "out.data.get_or_create_nest"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "CALL",
            "out.data.get_or_create_nest(key)"
        ],
        [
            "LOAD_GLOBAL",
            "KeyError"
        ],
        [
            "LOAD_GLOBAL",
            "suffixed_err"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "suffixed_err(src, pos, \"Cannot overwrite a value\")"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_METHOD",
            "src.startswith"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "src.startswith(\"]\", pos)"
        ],
        [
            "LOAD_GLOBAL",
            "suffixed_err"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "suffixed_err(src, pos, \"Expected ']' at the end of a table declaration\")"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos + 1"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos += 2"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "skip_chars"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "TOML_WS"
        ],
        [
            "CALL",
            "skip_chars(src, pos, TOML_WS)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "parse_key"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "parse_key(src, pos)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "STORE_FAST",
            "key"
        ],
        [
            "LOAD_FAST",
            "out"
        ],
        [
            "LOAD_ATTR",
            "out.flags"
        ],
        [
            "LOAD_METHOD",
            "out.flags.is_"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "LOAD_GLOBAL",
            "Flags"
        ],
        [
            "LOAD_ATTR",
            "Flags.FROZEN"
        ],
        [
            "CALL",
            "out.flags.is_(key, Flags.FROZEN)"
        ],
        [
            "LOAD_GLOBAL",
            "suffixed_err"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "CALL",
            "suffixed_err(src, pos, f\"Cannot mutate immutable namespace {key}\")"
        ],
        [
            "LOAD_FAST",
            "out"
        ],
        [
            "LOAD_ATTR",
            "out.flags"
        ],
        [
            "LOAD_METHOD",
            "out.flags.unset_all"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "CALL",
            "out.flags.unset_all(key)"
        ],
        [
            "LOAD_FAST",
            "out"
        ],
        [
            "LOAD_ATTR",
            "out.flags"
        ],
        [
            "LOAD_METHOD",
            "out.flags.set"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "LOAD_GLOBAL",
            "Flags"
        ],
        [
            "LOAD_ATTR",
            "Flags.EXPLICIT_NEST"
        ],
        [
            "CALL",
            "out.flags.set(key, Flags.EXPLICIT_NEST, recursive=False)"
        ],
        [
            "LOAD_FAST",
            "out"
        ],
        [
            "LOAD_ATTR",
            "out.data"
        ],
        [
            "LOAD_METHOD",
            "out.data.append_nest_to_list"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "CALL",
            "out.data.append_nest_to_list(key)"
        ],
        [
            "LOAD_GLOBAL",
            "KeyError"
        ],
        [
            "LOAD_GLOBAL",
            "suffixed_err"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "suffixed_err(src, pos, \"Cannot overwrite a value\")"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_METHOD",
            "src.startswith"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "src.startswith(\"]]\", pos)"
        ],
        [
            "LOAD_GLOBAL",
            "suffixed_err"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "suffixed_err(src, pos, \"Expected ']]' at the end of an array declaration\")"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos + 2"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "LOAD_GLOBAL",
            "parse_key_value_pair"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "parse_float"
        ],
        [
            "CALL",
            "parse_key_value_pair(src, pos, parse_float)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "STORE_DEREF",
            "key"
        ],
        [
            "STORE_FAST",
            "value"
        ],
        [
            "LOAD_DEREF",
            "key"
        ],
        [
            "BINARY_SUBSCR",
            "key[:-1]"
        ],
        [
            "LOAD_DEREF",
            "key"
        ],
        [
            "BINARY_SUBSCR",
            "key[-1]"
        ],
        [
            "STORE_FAST",
            "key_stem"
        ],
        [
            "STORE_FAST",
            "key_parent"
        ],
        [
            "LOAD_DEREF",
            "header"
        ],
        [
            "LOAD_FAST",
            "key_parent"
        ],
        [
            "BINARY_OP",
            "header + key_parent"
        ],
        [
            "STORE_FAST",
            "abs_key_parent"
        ],
        [
            "LOAD_GLOBAL",
            "range"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_DEREF",
            "key"
        ],
        [
            "CALL",
            "len(key)"
        ],
        [
            "CALL",
            "range(1, len(key))"
        ],
        [
            "CALL",
            "(header + key[:i] for i in range(1, len(key)))"
        ],
        [
            "STORE_FAST",
            "relative_path_cont_keys"
        ],
        [
            "LOAD_FAST",
            "relative_path_cont_keys"
        ],
        [
            "STORE_FAST",
            "cont_key"
        ],
        [
            "LOAD_FAST",
            "out"
        ],
        [
            "LOAD_ATTR",
            "out.flags"
        ],
        [
            "LOAD_METHOD",
            "out.flags.is_"
        ],
        [
            "LOAD_FAST",
            "cont_key"
        ],
        [
            "LOAD_GLOBAL",
            "Flags"
        ],
        [
            "LOAD_ATTR",
            "Flags.EXPLICIT_NEST"
        ],
        [
            "CALL",
            "out.flags.is_(cont_key, Flags.EXPLICIT_NEST)"
        ],
        [
            "LOAD_GLOBAL",
            "suffixed_err"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "CALL",
            "suffixed_err(src, pos, f\"Cannot redefine namespace {cont_key}\")"
        ],
        [
            "LOAD_FAST",
            "out"
        ],
        [
            "LOAD_ATTR",
            "out.flags"
        ],
        [
            "LOAD_METHOD",
            "out.flags.add_pending"
        ],
        [
            "LOAD_FAST",
            "cont_key"
        ],
        [
            "LOAD_GLOBAL",
            "Flags"
        ],
        [
            "LOAD_ATTR",
            "Flags.EXPLICIT_NEST"
        ],
        [
            "CALL",
            "out.flags.add_pending(cont_key, Flags.EXPLICIT_NEST)"
        ],
        [
            "LOAD_FAST",
            "out"
        ],
        [
            "LOAD_ATTR",
            "out.flags"
        ],
        [
            "LOAD_METHOD",
            "out.flags.is_"
        ],
        [
            "LOAD_FAST",
            "abs_key_parent"
        ],
        [
            "LOAD_GLOBAL",
            "Flags"
        ],
        [
            "LOAD_ATTR",
            "Flags.FROZEN"
        ],
        [
            "CALL",
            "out.flags.is_(abs_key_parent, Flags.FROZEN)"
        ],
        [
            "LOAD_GLOBAL",
            "suffixed_err"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "CALL",
            "suffixed_err(\n            src, pos, f\"Cannot mutate immutable namespace {abs_key_parent}\"\n        )"
        ],
        [
            "LOAD_FAST",
            "out"
        ],
        [
            "LOAD_ATTR",
            "out.data"
        ],
        [
            "LOAD_METHOD",
            "out.data.get_or_create_nest"
        ],
        [
            "LOAD_FAST",
            "abs_key_parent"
        ],
        [
            "CALL",
            "out.data.get_or_create_nest(abs_key_parent)"
        ],
        [
            "STORE_FAST",
            "nest"
        ],
        [
            "LOAD_GLOBAL",
            "KeyError"
        ],
        [
            "LOAD_GLOBAL",
            "suffixed_err"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "suffixed_err(src, pos, \"Cannot overwrite a value\")"
        ],
        [
            "LOAD_FAST",
            "key_stem"
        ],
        [
            "LOAD_FAST",
            "nest"
        ],
        [
            "CONTAINS_OP",
            "key_stem in nest"
        ],
        [
            "LOAD_GLOBAL",
            "suffixed_err"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "suffixed_err(src, pos, \"Cannot overwrite a value\")"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "CALL",
            "isinstance(value, (dict, list))"
        ],
        [
            "LOAD_FAST",
            "out"
        ],
        [
            "LOAD_ATTR",
            "out.flags"
        ],
        [
            "LOAD_METHOD",
            "out.flags.set"
        ],
        [
            "LOAD_DEREF",
            "header"
        ],
        [
            "LOAD_DEREF",
            "key"
        ],
        [
            "BINARY_OP",
            "header + key"
        ],
        [
            "LOAD_GLOBAL",
            "Flags"
        ],
        [
            "LOAD_ATTR",
            "Flags.FROZEN"
        ],
        [
            "CALL",
            "out.flags.set(header + key, Flags.FROZEN, recursive=True)"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "nest"
        ],
        [
            "LOAD_FAST",
            "key_stem"
        ],
        [
            "STORE_SUBSCR",
            "nest[key_stem]"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "(header + key[:i] for i in range(1, len(key)))"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "LOAD_DEREF",
            "header"
        ],
        [
            "LOAD_DEREF",
            "key"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_SUBSCR",
            "key[:i]"
        ],
        [
            "BINARY_OP",
            "header + key[:i]"
        ],
        [
            "LOAD_GLOBAL",
            "parse_key"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "parse_key(src, pos)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "STORE_FAST",
            "key"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_SUBSCR",
            "src[pos]"
        ],
        [
            "STORE_FAST",
            "char"
        ],
        [
            "LOAD_GLOBAL",
            "IndexError"
        ],
        [
            "STORE_FAST",
            "char"
        ],
        [
            "LOAD_FAST",
            "char"
        ],
        [
            "COMPARE_OP",
            "char != \"=\""
        ],
        [
            "LOAD_GLOBAL",
            "suffixed_err"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "suffixed_err(src, pos, \"Expected '=' after a key in a key/value pair\")"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos += 1"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "skip_chars"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "TOML_WS"
        ],
        [
            "CALL",
            "skip_chars(src, pos, TOML_WS)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "parse_value"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "parse_float"
        ],
        [
            "CALL",
            "parse_value(src, pos, parse_float)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "STORE_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_GLOBAL",
            "parse_key_part"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "parse_key_part(src, pos)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "STORE_FAST",
            "key_part"
        ],
        [
            "LOAD_FAST",
            "key_part"
        ],
        [
            "STORE_FAST",
            "key"
        ],
        [
            "LOAD_GLOBAL",
            "skip_chars"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "TOML_WS"
        ],
        [
            "CALL",
            "skip_chars(src, pos, TOML_WS)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_SUBSCR",
            "src[pos]"
        ],
        [
            "STORE_FAST",
            "char"
        ],
        [
            "LOAD_GLOBAL",
            "IndexError"
        ],
        [
            "STORE_FAST",
            "char"
        ],
        [
            "LOAD_FAST",
            "char"
        ],
        [
            "COMPARE_OP",
            "char != \".\""
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos += 1"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "skip_chars"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "TOML_WS"
        ],
        [
            "CALL",
            "skip_chars(src, pos, TOML_WS)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "parse_key_part"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "parse_key_part(src, pos)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "STORE_FAST",
            "key_part"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "LOAD_FAST",
            "key_part"
        ],
        [
            "BINARY_OP",
            "key += (key_part,)"
        ],
        [
            "STORE_FAST",
            "key"
        ],
        [
            "LOAD_GLOBAL",
            "skip_chars"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "TOML_WS"
        ],
        [
            "CALL",
            "skip_chars(src, pos, TOML_WS)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_SUBSCR",
            "src[pos]"
        ],
        [
            "STORE_FAST",
            "char"
        ],
        [
            "LOAD_GLOBAL",
            "IndexError"
        ],
        [
            "STORE_FAST",
            "char"
        ],
        [
            "LOAD_FAST",
            "char"
        ],
        [
            "LOAD_GLOBAL",
            "BARE_KEY_CHARS"
        ],
        [
            "CONTAINS_OP",
            "char in BARE_KEY_CHARS"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "STORE_FAST",
            "start_pos"
        ],
        [
            "LOAD_GLOBAL",
            "skip_chars"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "BARE_KEY_CHARS"
        ],
        [
            "CALL",
            "skip_chars(src, pos, BARE_KEY_CHARS)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "start_pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_SUBSCR",
            "src[start_pos:pos]"
        ],
        [
            "LOAD_FAST",
            "char"
        ],
        [
            "COMPARE_OP",
            "char == \"'\""
        ],
        [
            "LOAD_GLOBAL",
            "parse_literal_str"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "parse_literal_str(src, pos)"
        ],
        [
            "LOAD_FAST",
            "char"
        ],
        [
            "COMPARE_OP",
            "char == '\"'"
        ],
        [
            "LOAD_GLOBAL",
            "parse_one_line_basic_str"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "parse_one_line_basic_str(src, pos)"
        ],
        [
            "LOAD_GLOBAL",
            "suffixed_err"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "suffixed_err(src, pos, \"Invalid initial character for a key part\")"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos += 1"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "parse_basic_str"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "parse_basic_str(src, pos, multiline=False)"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos += 1"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "STORE_FAST",
            "array"
        ],
        [
            "LOAD_GLOBAL",
            "skip_comments_and_array_ws"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "skip_comments_and_array_ws(src, pos)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_METHOD",
            "src.startswith"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "src.startswith(\"]\", pos)"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos + 1"
        ],
        [
            "LOAD_FAST",
            "array"
        ],
        [
            "LOAD_GLOBAL",
            "parse_value"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "parse_float"
        ],
        [
            "CALL",
            "parse_value(src, pos, parse_float)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "STORE_FAST",
            "val"
        ],
        [
            "LOAD_FAST",
            "array"
        ],
        [
            "LOAD_METHOD",
            "array.append"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "CALL",
            "array.append(val)"
        ],
        [
            "LOAD_GLOBAL",
            "skip_comments_and_array_ws"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "skip_comments_and_array_ws(src, pos)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos + 1"
        ],
        [
            "BINARY_SUBSCR",
            "src[pos : pos + 1]"
        ],
        [
            "STORE_FAST",
            "c"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "COMPARE_OP",
            "c == \"]\""
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos + 1"
        ],
        [
            "LOAD_FAST",
            "array"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "COMPARE_OP",
            "c != \",\""
        ],
        [
            "LOAD_GLOBAL",
            "suffixed_err"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "suffixed_err(src, pos, \"Unclosed array\")"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos += 1"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "skip_comments_and_array_ws"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "skip_comments_and_array_ws(src, pos)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_METHOD",
            "src.startswith"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "src.startswith(\"]\", pos)"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos + 1"
        ],
        [
            "LOAD_FAST",
            "array"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos += 1"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "NestedDict"
        ],
        [
            "CALL",
            "NestedDict()"
        ],
        [
            "STORE_FAST",
            "nested_dict"
        ],
        [
            "LOAD_GLOBAL",
            "Flags"
        ],
        [
            "CALL",
            "Flags()"
        ],
        [
            "STORE_FAST",
            "flags"
        ],
        [
            "LOAD_GLOBAL",
            "skip_chars"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "TOML_WS"
        ],
        [
            "CALL",
            "skip_chars(src, pos, TOML_WS)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_METHOD",
            "src.startswith"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "src.startswith(\"}\", pos)"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos + 1"
        ],
        [
            "LOAD_FAST",
            "nested_dict"
        ],
        [
            "LOAD_ATTR",
            "nested_dict.dict"
        ],
        [
            "LOAD_GLOBAL",
            "parse_key_value_pair"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "parse_float"
        ],
        [
            "CALL",
            "parse_key_value_pair(src, pos, parse_float)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "STORE_FAST",
            "key"
        ],
        [
            "STORE_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "BINARY_SUBSCR",
            "key[:-1]"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "BINARY_SUBSCR",
            "key[-1]"
        ],
        [
            "STORE_FAST",
            "key_stem"
        ],
        [
            "STORE_FAST",
            "key_parent"
        ],
        [
            "LOAD_FAST",
            "flags"
        ],
        [
            "LOAD_METHOD",
            "flags.is_"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "LOAD_GLOBAL",
            "Flags"
        ],
        [
            "LOAD_ATTR",
            "Flags.FROZEN"
        ],
        [
            "CALL",
            "flags.is_(key, Flags.FROZEN)"
        ],
        [
            "LOAD_GLOBAL",
            "suffixed_err"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "CALL",
            "suffixed_err(src, pos, f\"Cannot mutate immutable namespace {key}\")"
        ],
        [
            "LOAD_FAST",
            "nested_dict"
        ],
        [
            "LOAD_METHOD",
            "nested_dict.get_or_create_nest"
        ],
        [
            "LOAD_FAST",
            "key_parent"
        ],
        [
            "CALL",
            "nested_dict.get_or_create_nest(key_parent, access_lists=False)"
        ],
        [
            "STORE_FAST",
            "nest"
        ],
        [
            "LOAD_GLOBAL",
            "KeyError"
        ],
        [
            "LOAD_GLOBAL",
            "suffixed_err"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "suffixed_err(src, pos, \"Cannot overwrite a value\")"
        ],
        [
            "LOAD_FAST",
            "key_stem"
        ],
        [
            "LOAD_FAST",
            "nest"
        ],
        [
            "CONTAINS_OP",
            "key_stem in nest"
        ],
        [
            "LOAD_GLOBAL",
            "suffixed_err"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "CALL",
            "suffixed_err(src, pos, f\"Duplicate inline table key {key_stem!r}\")"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "nest"
        ],
        [
            "LOAD_FAST",
            "key_stem"
        ],
        [
            "STORE_SUBSCR",
            "nest[key_stem]"
        ],
        [
            "LOAD_GLOBAL",
            "skip_chars"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "TOML_WS"
        ],
        [
            "CALL",
            "skip_chars(src, pos, TOML_WS)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos + 1"
        ],
        [
            "BINARY_SUBSCR",
            "src[pos : pos + 1]"
        ],
        [
            "STORE_FAST",
            "c"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "COMPARE_OP",
            "c == \"}\""
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos + 1"
        ],
        [
            "LOAD_FAST",
            "nested_dict"
        ],
        [
            "LOAD_ATTR",
            "nested_dict.dict"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "COMPARE_OP",
            "c != \",\""
        ],
        [
            "LOAD_GLOBAL",
            "suffixed_err"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "suffixed_err(src, pos, \"Unclosed inline table\")"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "CALL",
            "isinstance(value, (dict, list))"
        ],
        [
            "LOAD_FAST",
            "flags"
        ],
        [
            "LOAD_METHOD",
            "flags.set"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "LOAD_GLOBAL",
            "Flags"
        ],
        [
            "LOAD_ATTR",
            "Flags.FROZEN"
        ],
        [
            "CALL",
            "flags.set(key, Flags.FROZEN, recursive=True)"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos += 1"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "skip_chars"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "TOML_WS"
        ],
        [
            "CALL",
            "skip_chars(src, pos, TOML_WS)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos + 2"
        ],
        [
            "BINARY_SUBSCR",
            "src[pos : pos + 2]"
        ],
        [
            "STORE_FAST",
            "escape_id"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos += 2"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "multiline"
        ],
        [
            "LOAD_FAST",
            "escape_id"
        ],
        [
            "CONTAINS_OP",
            "escape_id in {\"\\\\ \", \"\\\\\\t\", \"\\\\\\n\"}"
        ],
        [
            "LOAD_FAST",
            "escape_id"
        ],
        [
            "COMPARE_OP",
            "escape_id != \"\\\\\\n\""
        ],
        [
            "LOAD_GLOBAL",
            "skip_chars"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "TOML_WS"
        ],
        [
            "CALL",
            "skip_chars(src, pos, TOML_WS)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_SUBSCR",
            "src[pos]"
        ],
        [
            "STORE_FAST",
            "char"
        ],
        [
            "LOAD_GLOBAL",
            "IndexError"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "char"
        ],
        [
            "COMPARE_OP",
            "char != \"\\n\""
        ],
        [
            "LOAD_GLOBAL",
            "suffixed_err"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "suffixed_err(src, pos, \"Unescaped '\\\\' in a string\")"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos += 1"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "skip_chars"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "TOML_WS_AND_NEWLINE"
        ],
        [
            "CALL",
            "skip_chars(src, pos, TOML_WS_AND_NEWLINE)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "escape_id"
        ],
        [
            "COMPARE_OP",
            "escape_id == \"\\\\u\""
        ],
        [
            "LOAD_GLOBAL",
            "parse_hex_char"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "parse_hex_char(src, pos, 4)"
        ],
        [
            "LOAD_FAST",
            "escape_id"
        ],
        [
            "COMPARE_OP",
            "escape_id == \"\\\\U\""
        ],
        [
            "LOAD_GLOBAL",
            "parse_hex_char"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "parse_hex_char(src, pos, 8)"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "BASIC_STR_ESCAPE_REPLACEMENTS"
        ],
        [
            "LOAD_FAST",
            "escape_id"
        ],
        [
            "BINARY_SUBSCR",
            "BASIC_STR_ESCAPE_REPLACEMENTS[escape_id]"
        ],
        [
            "LOAD_GLOBAL",
            "KeyError"
        ],
        [
            "LOAD_GLOBAL",
            "suffixed_err"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "suffixed_err(src, pos, \"Unescaped '\\\\' in a string\")"
        ],
        [
            "LOAD_GLOBAL",
            "parse_basic_str_escape"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "parse_basic_str_escape(src, pos, multiline=True)"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "hex_len"
        ],
        [
            "BINARY_OP",
            "pos + hex_len"
        ],
        [
            "BINARY_SUBSCR",
            "src[pos : pos + hex_len]"
        ],
        [
            "STORE_FAST",
            "hex_str"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "hex_str"
        ],
        [
            "CALL",
            "len(hex_str)"
        ],
        [
            "LOAD_FAST",
            "hex_len"
        ],
        [
            "COMPARE_OP",
            "len(hex_str) != hex_len"
        ],
        [
            "LOAD_GLOBAL",
            "HEXDIGIT_CHARS"
        ],
        [
            "LOAD_METHOD",
            "HEXDIGIT_CHARS.issuperset"
        ],
        [
            "LOAD_FAST",
            "hex_str"
        ],
        [
            "CALL",
            "HEXDIGIT_CHARS.issuperset(hex_str)"
        ],
        [
            "LOAD_GLOBAL",
            "suffixed_err"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "suffixed_err(src, pos, \"Invalid hex value\")"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "hex_len"
        ],
        [
            "BINARY_OP",
            "pos += hex_len"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "LOAD_FAST",
            "hex_str"
        ],
        [
            "CALL",
            "int(hex_str, 16)"
        ],
        [
            "STORE_FAST",
            "hex_int"
        ],
        [
            "LOAD_GLOBAL",
            "is_unicode_scalar_value"
        ],
        [
            "LOAD_FAST",
            "hex_int"
        ],
        [
            "CALL",
            "is_unicode_scalar_value(hex_int)"
        ],
        [
            "LOAD_GLOBAL",
            "suffixed_err"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "suffixed_err(src, pos, \"Escaped character is not a Unicode scalar value\")"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "chr"
        ],
        [
            "LOAD_FAST",
            "hex_int"
        ],
        [
            "CALL",
            "chr(hex_int)"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos += 1"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "STORE_FAST",
            "start_pos"
        ],
        [
            "LOAD_GLOBAL",
            "skip_until"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "ILLEGAL_LITERAL_STR_CHARS"
        ],
        [
            "CALL",
            "skip_until(\n        src, pos, \"'\", error_on=ILLEGAL_LITERAL_STR_CHARS, error_on_eof=True\n    )"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos + 1"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "start_pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_SUBSCR",
            "src[start_pos:pos]"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos += 3"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_METHOD",
            "src.startswith"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "src.startswith(\"\\n\", pos)"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos += 1"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "literal"
        ],
        [
            "STORE_FAST",
            "delim"
        ],
        [
            "LOAD_GLOBAL",
            "skip_until"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "ILLEGAL_MULTILINE_LITERAL_STR_CHARS"
        ],
        [
            "CALL",
            "skip_until(\n            src,\n            pos,\n            \"'''\",\n            error_on=ILLEGAL_MULTILINE_LITERAL_STR_CHARS,\n            error_on_eof=True,\n        )"
        ],
        [
            "STORE_FAST",
            "end_pos"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "end_pos"
        ],
        [
            "BINARY_SUBSCR",
            "src[pos:end_pos]"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "end_pos"
        ],
        [
            "BINARY_OP",
            "end_pos + 3"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "STORE_FAST",
            "delim"
        ],
        [
            "LOAD_GLOBAL",
            "parse_basic_str"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "parse_basic_str(src, pos, multiline=True)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_METHOD",
            "src.startswith"
        ],
        [
            "LOAD_FAST",
            "delim"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "src.startswith(delim, pos)"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos += 1"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_METHOD",
            "src.startswith"
        ],
        [
            "LOAD_FAST",
            "delim"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "src.startswith(delim, pos)"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "delim"
        ],
        [
            "BINARY_OP",
            "result + delim"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos += 1"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "delim"
        ],
        [
            "BINARY_OP",
            "delim * 2"
        ],
        [
            "BINARY_OP",
            "result + (delim * 2)"
        ],
        [
            "LOAD_FAST",
            "multiline"
        ],
        [
            "LOAD_GLOBAL",
            "ILLEGAL_MULTILINE_BASIC_STR_CHARS"
        ],
        [
            "STORE_FAST",
            "error_on"
        ],
        [
            "LOAD_GLOBAL",
            "parse_basic_str_escape_multiline"
        ],
        [
            "STORE_FAST",
            "parse_escapes"
        ],
        [
            "LOAD_GLOBAL",
            "ILLEGAL_BASIC_STR_CHARS"
        ],
        [
            "STORE_FAST",
            "error_on"
        ],
        [
            "LOAD_GLOBAL",
            "parse_basic_str_escape"
        ],
        [
            "STORE_FAST",
            "parse_escapes"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "STORE_FAST",
            "start_pos"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_SUBSCR",
            "src[pos]"
        ],
        [
            "STORE_FAST",
            "char"
        ],
        [
            "LOAD_GLOBAL",
            "IndexError"
        ],
        [
            "LOAD_GLOBAL",
            "suffixed_err"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "suffixed_err(src, pos, \"Unterminated string\")"
        ],
        [
            "LOAD_FAST",
            "char"
        ],
        [
            "COMPARE_OP",
            "char == '\"'"
        ],
        [
            "LOAD_FAST",
            "multiline"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos + 1"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "start_pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_SUBSCR",
            "src[start_pos:pos]"
        ],
        [
            "BINARY_OP",
            "result + src[start_pos:pos]"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_METHOD",
            "src.startswith"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "src.startswith('\"\"\"', pos)"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos + 3"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "start_pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_SUBSCR",
            "src[start_pos:pos]"
        ],
        [
            "BINARY_OP",
            "result + src[start_pos:pos]"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos += 1"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "char"
        ],
        [
            "COMPARE_OP",
            "char == \"\\\\\""
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "start_pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_SUBSCR",
            "src[start_pos:pos]"
        ],
        [
            "BINARY_OP",
            "result += src[start_pos:pos]"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "parse_escapes"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "parse_escapes(src, pos)"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "STORE_FAST",
            "parsed_escape"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "parsed_escape"
        ],
        [
            "BINARY_OP",
            "result += parsed_escape"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "STORE_FAST",
            "start_pos"
        ],
        [
            "LOAD_FAST",
            "char"
        ],
        [
            "LOAD_FAST",
            "error_on"
        ],
        [
            "CONTAINS_OP",
            "char in error_on"
        ],
        [
            "LOAD_GLOBAL",
            "suffixed_err"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "CALL",
            "suffixed_err(src, pos, f\"Illegal character {char!r}\")"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos += 1"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_SUBSCR",
            "src[pos]"
        ],
        [
            "STORE_FAST",
            "char"
        ],
        [
            "LOAD_GLOBAL",
            "IndexError"
        ],
        [
            "STORE_FAST",
            "char"
        ],
        [
            "LOAD_FAST",
            "char"
        ],
        [
            "COMPARE_OP",
            "char == '\"'"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_METHOD",
            "src.startswith"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "src.startswith('\"\"\"', pos)"
        ],
        [
            "LOAD_GLOBAL",
            "parse_multiline_str"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "parse_multiline_str(src, pos, literal=False)"
        ],
        [
            "LOAD_GLOBAL",
            "parse_one_line_basic_str"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "parse_one_line_basic_str(src, pos)"
        ],
        [
            "LOAD_FAST",
            "char"
        ],
        [
            "COMPARE_OP",
            "char == \"'\""
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_METHOD",
            "src.startswith"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "src.startswith(\"'''\", pos)"
        ],
        [
            "LOAD_GLOBAL",
            "parse_multiline_str"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "parse_multiline_str(src, pos, literal=True)"
        ],
        [
            "LOAD_GLOBAL",
            "parse_literal_str"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "parse_literal_str(src, pos)"
        ],
        [
            "LOAD_FAST",
            "char"
        ],
        [
            "COMPARE_OP",
            "char == \"t\""
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_METHOD",
            "src.startswith"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "src.startswith(\"true\", pos)"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos + 4"
        ],
        [
            "LOAD_FAST",
            "char"
        ],
        [
            "COMPARE_OP",
            "char == \"f\""
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_METHOD",
            "src.startswith"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "src.startswith(\"false\", pos)"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos + 5"
        ],
        [
            "LOAD_FAST",
            "char"
        ],
        [
            "COMPARE_OP",
            "char == \"[\""
        ],
        [
            "LOAD_GLOBAL",
            "parse_array"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "parse_float"
        ],
        [
            "CALL",
            "parse_array(src, pos, parse_float)"
        ],
        [
            "LOAD_FAST",
            "char"
        ],
        [
            "COMPARE_OP",
            "char == \"{\""
        ],
        [
            "LOAD_GLOBAL",
            "parse_inline_table"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "parse_float"
        ],
        [
            "CALL",
            "parse_inline_table(src, pos, parse_float)"
        ],
        [
            "LOAD_GLOBAL",
            "RE_DATETIME"
        ],
        [
            "LOAD_ATTR",
            "RE_DATETIME.match"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "RE_DATETIME.match(src, pos)"
        ],
        [
            "STORE_FAST",
            "datetime_match"
        ],
        [
            "LOAD_FAST",
            "datetime_match"
        ],
        [
            "LOAD_GLOBAL",
            "match_to_datetime"
        ],
        [
            "LOAD_FAST",
            "datetime_match"
        ],
        [
            "CALL",
            "match_to_datetime(datetime_match)"
        ],
        [
            "STORE_FAST",
            "datetime_obj"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "STORE_FAST",
            "        except ValueError as e:\n            raise suffixed_err(src, pos, \"Invalid date or datetime\") from e"
        ],
        [
            "LOAD_GLOBAL",
            "suffixed_err"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "suffixed_err(src, pos, \"Invalid date or datetime\")"
        ],
        [
            "LOAD_FAST",
            "e"
        ],
        [
            "LOAD_FAST",
            "datetime_match"
        ],
        [
            "LOAD_METHOD",
            "datetime_match.end"
        ],
        [
            "CALL",
            "datetime_match.end()"
        ],
        [
            "LOAD_FAST",
            "datetime_obj"
        ],
        [
            "LOAD_GLOBAL",
            "RE_LOCALTIME"
        ],
        [
            "LOAD_ATTR",
            "RE_LOCALTIME.match"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "RE_LOCALTIME.match(src, pos)"
        ],
        [
            "STORE_FAST",
            "localtime_match"
        ],
        [
            "LOAD_FAST",
            "localtime_match"
        ],
        [
            "LOAD_FAST",
            "localtime_match"
        ],
        [
            "LOAD_METHOD",
            "localtime_match.end"
        ],
        [
            "CALL",
            "localtime_match.end()"
        ],
        [
            "LOAD_GLOBAL",
            "match_to_localtime"
        ],
        [
            "LOAD_FAST",
            "localtime_match"
        ],
        [
            "CALL",
            "match_to_localtime(localtime_match)"
        ],
        [
            "LOAD_GLOBAL",
            "RE_NUMBER"
        ],
        [
            "LOAD_ATTR",
            "RE_NUMBER.match"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "RE_NUMBER.match(src, pos)"
        ],
        [
            "STORE_FAST",
            "number_match"
        ],
        [
            "LOAD_FAST",
            "number_match"
        ],
        [
            "LOAD_FAST",
            "number_match"
        ],
        [
            "LOAD_METHOD",
            "number_match.end"
        ],
        [
            "CALL",
            "number_match.end()"
        ],
        [
            "LOAD_GLOBAL",
            "match_to_number"
        ],
        [
            "LOAD_FAST",
            "number_match"
        ],
        [
            "LOAD_FAST",
            "parse_float"
        ],
        [
            "CALL",
            "match_to_number(number_match, parse_float)"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos + 3"
        ],
        [
            "BINARY_SUBSCR",
            "src[pos : pos + 3]"
        ],
        [
            "STORE_FAST",
            "first_three"
        ],
        [
            "LOAD_FAST",
            "first_three"
        ],
        [
            "CONTAINS_OP",
            "first_three in {\"inf\", \"nan\"}"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos + 3"
        ],
        [
            "LOAD_FAST",
            "parse_float"
        ],
        [
            "LOAD_FAST",
            "first_three"
        ],
        [
            "CALL",
            "parse_float(first_three)"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos + 4"
        ],
        [
            "BINARY_SUBSCR",
            "src[pos : pos + 4]"
        ],
        [
            "STORE_FAST",
            "first_four"
        ],
        [
            "LOAD_FAST",
            "first_four"
        ],
        [
            "CONTAINS_OP",
            "first_four in {\"-inf\", \"+inf\", \"-nan\", \"+nan\"}"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos + 4"
        ],
        [
            "LOAD_FAST",
            "parse_float"
        ],
        [
            "LOAD_FAST",
            "first_four"
        ],
        [
            "CALL",
            "parse_float(first_four)"
        ],
        [
            "LOAD_GLOBAL",
            "suffixed_err"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "suffixed_err(src, pos, \"Invalid value\")"
        ],
        [
            "STORE_FAST",
            "    def coord_repr(src: str, pos: Pos) -> str:\n        if pos >= len(src):\n            return \"end of document\"\n        line = src.count(\"\\n\", 0, pos) + 1\n        if line == 1:\n            column = pos + 1\n        else:\n            column = pos - src.rindex(\"\\n\", 0, pos)\n        return f\"line {line}, column {column}\""
        ],
        [
            "LOAD_GLOBAL",
            "TOMLDecodeError"
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "CALL",
            ""
        ],
        [
            "CALL",
            "TOMLDecodeError(f\"{msg} (at {coord_repr(src, pos)})\")"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "CALL",
            "len(src)"
        ],
        [
            "COMPARE_OP",
            "pos >= len(src)"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_METHOD",
            "src.count"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "src.count(\"\\n\", 0, pos)"
        ],
        [
            "BINARY_OP",
            "src.count(\"\\n\", 0, pos) + 1"
        ],
        [
            "STORE_FAST",
            "line"
        ],
        [
            "LOAD_FAST",
            "line"
        ],
        [
            "COMPARE_OP",
            "line == 1"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos + 1"
        ],
        [
            "STORE_FAST",
            "column"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "src"
        ],
        [
            "LOAD_METHOD",
            "src.rindex"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "CALL",
            "src.rindex(\"\\n\", 0, pos)"
        ],
        [
            "BINARY_OP",
            "pos - src.rindex(\"\\n\", 0, pos)"
        ],
        [
            "STORE_FAST",
            "column"
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "LOAD_FAST",
            "codepoint"
        ],
        [
            "COMPARE_OP",
            "0 <= codepoint <= 55295"
        ],
        [
            "COMPARE_OP",
            "0 <= codepoint <= 55295"
        ],
        [
            "LOAD_FAST",
            "codepoint"
        ],
        [
            "COMPARE_OP",
            "57344 <= codepoint <= 1114111"
        ],
        [
            "COMPARE_OP",
            "57344 <= codepoint <= 1114111"
        ],
        [
            "LOAD_DEREF",
            "parse_float"
        ],
        [
            "LOAD_GLOBAL",
            "float"
        ],
        [
            "IS_OP",
            "parse_float is float"
        ],
        [
            "LOAD_GLOBAL",
            "float"
        ],
        [
            "STORE_FAST",
            "    def safe_parse_float(float_str: str) -> Any:\n        float_value = parse_float(float_str)\n        if isinstance(float_value, (dict, list)):\n            raise ValueError(\"parse_float must not return dicts or lists\")\n        return float_value"
        ],
        [
            "LOAD_FAST",
            "safe_parse_float"
        ],
        [
            "LOAD_DEREF",
            "parse_float"
        ],
        [
            "LOAD_FAST",
            "float_str"
        ],
        [
            "CALL",
            "parse_float(float_str)"
        ],
        [
            "STORE_FAST",
            "float_value"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "float_value"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "CALL",
            "isinstance(float_value, (dict, list))"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError(\"parse_float must not return dicts or lists\")"
        ],
        [
            "LOAD_FAST",
            "float_value"
        ]
    ],
    "bird.py": [
        [
            "STORE_NAME",
            "from __future__ import absolute_import, division, print_function"
        ],
        [
            "STORE_NAME",
            "from __future__ import absolute_import, division, print_function"
        ],
        [
            "STORE_NAME",
            "from __future__ import absolute_import, division, print_function"
        ],
        [
            "STORE_NAME",
            "from future import standard_library"
        ],
        [
            "LOAD_NAME",
            "standard_library"
        ],
        [
            "LOAD_ATTR",
            "standard_library.install_aliases"
        ],
        [
            "CALL",
            "standard_library.install_aliases()"
        ],
        [
            "STORE_NAME",
            "from future.utils import iteritems"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
        ],
        [
            "STORE_NAME",
            "from types import FrameType, TracebackType, CodeType, FunctionType, ModuleType"
        ],
        [
            "STORE_NAME",
            "from types import FrameType, TracebackType, CodeType, FunctionType, ModuleType"
        ],
        [
            "STORE_NAME",
            "from types import FrameType, TracebackType, CodeType, FunctionType, ModuleType"
        ],
        [
            "STORE_NAME",
            "from types import FrameType, TracebackType, CodeType, FunctionType, ModuleType"
        ],
        [
            "STORE_NAME",
            "from types import FrameType, TracebackType, CodeType, FunctionType, ModuleType"
        ],
        [
            "STORE_NAME",
            "import typing"
        ],
        [
            "STORE_NAME",
            "import ast"
        ],
        [
            "STORE_NAME",
            "import html"
        ],
        [
            "STORE_NAME",
            "import inspect"
        ],
        [
            "STORE_NAME",
            "import json"
        ],
        [
            "STORE_NAME",
            "import os"
        ],
        [
            "STORE_NAME",
            "import traceback"
        ],
        [
            "STORE_NAME",
            "from collections import defaultdict, Sequence, Set, Mapping, deque, namedtuple, Counter"
        ],
        [
            "STORE_NAME",
            "from collections import defaultdict, Sequence, Set, Mapping, deque, namedtuple, Counter"
        ],
        [
            "STORE_NAME",
            "from collections import defaultdict, Sequence, Set, Mapping, deque, namedtuple, Counter"
        ],
        [
            "STORE_NAME",
            "from collections import defaultdict, Sequence, Set, Mapping, deque, namedtuple, Counter"
        ],
        [
            "STORE_NAME",
            "from collections import defaultdict, Sequence, Set, Mapping, deque, namedtuple, Counter"
        ],
        [
            "STORE_NAME",
            "from collections import defaultdict, Sequence, Set, Mapping, deque, namedtuple, Counter"
        ],
        [
            "STORE_NAME",
            "from collections import defaultdict, Sequence, Set, Mapping, deque, namedtuple, Counter"
        ],
        [
            "STORE_NAME",
            "from functools import partial"
        ],
        [
            "STORE_NAME",
            "from itertools import chain, islice"
        ],
        [
            "STORE_NAME",
            "from itertools import chain, islice"
        ],
        [
            "STORE_NAME",
            "from threading import Lock"
        ],
        [
            "STORE_NAME",
            "from uuid import uuid4"
        ],
        [
            "STORE_NAME",
            "import hashlib"
        ],
        [
            "STORE_NAME",
            "import sys"
        ],
        [
            "STORE_NAME",
            "from asttokens import ASTTokens"
        ],
        [
            "STORE_NAME",
            "from littleutils import group_by_key_func, only"
        ],
        [
            "STORE_NAME",
            "from littleutils import group_by_key_func, only"
        ],
        [
            "STORE_NAME",
            "from outdated import warn_if_outdated"
        ],
        [
            "STORE_NAME",
            "from cached_property import cached_property"
        ],
        [
            "STORE_NAME",
            "from cheap_repr import cheap_repr, try_register_repr"
        ],
        [
            "STORE_NAME",
            "from cheap_repr import cheap_repr, try_register_repr"
        ],
        [
            "STORE_NAME",
            "from cheap_repr.utils import safe_qualname, exception_string"
        ],
        [
            "STORE_NAME",
            "from cheap_repr.utils import safe_qualname, exception_string"
        ],
        [
            "STORE_NAME",
            "from birdseye.db import Database, retry_db"
        ],
        [
            "STORE_NAME",
            "from birdseye.db import Database, retry_db"
        ],
        [
            "STORE_NAME",
            "from birdseye.tracer import TreeTracerBase, TracedFile, EnterCallInfo, ExitCallInfo, FrameInfo, ChangeValue, Loop"
        ],
        [
            "STORE_NAME",
            "from birdseye.tracer import TreeTracerBase, TracedFile, EnterCallInfo, ExitCallInfo, FrameInfo, ChangeValue, Loop"
        ],
        [
            "STORE_NAME",
            "from birdseye.tracer import TreeTracerBase, TracedFile, EnterCallInfo, ExitCallInfo, FrameInfo, ChangeValue, Loop"
        ],
        [
            "STORE_NAME",
            "from birdseye.tracer import TreeTracerBase, TracedFile, EnterCallInfo, ExitCallInfo, FrameInfo, ChangeValue, Loop"
        ],
        [
            "STORE_NAME",
            "from birdseye.tracer import TreeTracerBase, TracedFile, EnterCallInfo, ExitCallInfo, FrameInfo, ChangeValue, Loop"
        ],
        [
            "STORE_NAME",
            "from birdseye.tracer import TreeTracerBase, TracedFile, EnterCallInfo, ExitCallInfo, FrameInfo, ChangeValue, Loop"
        ],
        [
            "STORE_NAME",
            "from birdseye.tracer import TreeTracerBase, TracedFile, EnterCallInfo, ExitCallInfo, FrameInfo, ChangeValue, Loop"
        ],
        [
            "STORE_NAME",
            "from birdseye import tracer"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye import __version__"
        ],
        [
            "STORE_NAME",
            "from numpy import ndarray"
        ],
        [
            "LOAD_NAME",
            "ImportError"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "    class ndarray(object):\n        pass"
        ],
        [
            "STORE_NAME",
            "    class ndarray(object):\n        pass"
        ],
        [
            "STORE_NAME",
            "from pandas import DataFrame, Series"
        ],
        [
            "STORE_NAME",
            "from pandas import DataFrame, Series"
        ],
        [
            "LOAD_NAME",
            "ImportError"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "    class DataFrame(object):\n        pass"
        ],
        [
            "STORE_NAME",
            "    class DataFrame(object):\n        pass"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "    class Series(object):\n        pass"
        ],
        [
            "STORE_NAME",
            "    class Series(object):\n        pass"
        ],
        [
            "STORE_NAME",
            "from django.db.models import QuerySet"
        ],
        [
            "LOAD_NAME",
            "ImportError"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "    class QuerySet(object):\n        pass"
        ],
        [
            "STORE_NAME",
            "    class QuerySet(object):\n        pass"
        ],
        [
            "LOAD_NAME",
            "warn_if_outdated"
        ],
        [
            "LOAD_NAME",
            "__version__"
        ],
        [
            "CALL",
            "warn_if_outdated('birdseye', __version__)"
        ],
        [
            "LOAD_NAME",
            "namedtuple"
        ],
        [
            "CALL",
            "namedtuple('CodeInfo', 'db_func traced_file arg_names')"
        ],
        [
            "STORE_NAME",
            "CodeInfo"
        ],
        [
            "LOAD_NAME",
            "TreeTracerBase"
        ],
        [
            "CALL",
            "class BirdsEye(TreeTracerBase):\n    \"\"\"\n    Decorate functions with an instance of this class to debug them,\n    or just use the existing instance `eye`.\n    \"\"\"\n\n    def __init__(self, db_uri=None, num_samples=None):\n        \"\"\"\n        Set db_uri to specify where the database lives, as an alternative to\n        the environment variable BIRDSEYE_DB.\n        \"\"\"\n        super(BirdsEye, self).__init__()\n        self._db_uri = db_uri\n        self._code_infos = {}  # type: Dict[CodeType, CodeInfo]\n        self._last_call_id = None\n        self._ipython_cell_value = None\n        self.num_samples = num_samples or dict(\n            big=dict(\n                attributes=50,\n                dict=50,\n                list=30,\n                set=30,\n                pandas_rows=20,\n                pandas_cols=100,\n            ),\n            small=dict(\n                attributes=50,\n                dict=10,\n                list=6,\n                set=6,\n                pandas_rows=6,\n                pandas_cols=10,\n            ),\n        )\n\n    @cached_property\n    def db(self):\n        return Database(self._db_uri)\n\n    def parse_extra(self, root, source, filename):\n        # type: (ast.Module, str, str) -> None\n        for node in ast.walk(root):  # type: ast.AST\n            node._loops = tracer.loops(node)\n            if isinstance(node, ast.expr):\n                node._is_interesting_expression = is_interesting_expression(node)\n\n    @lru_cache()\n    def compile(self, source, filename, flags=0):\n        traced_file = super(BirdsEye, self).compile(source, filename, flags)\n        traced_file.tokens = ASTTokens(source, tree=traced_file.root)\n        return traced_file\n\n    def before_stmt(self, node, frame):\n        # type: (ast.stmt, FrameType) -> None\n        if frame.f_code not in self._code_infos:\n            return\n        if isinstance(node.parent, ast.For) and node is node.parent.body[0]:\n            self._add_iteration(node._loops, frame)\n\n    def before_expr(self, node, frame):\n        if isinstance(node.parent, ast.While) and node is node.parent.test:\n            self._add_iteration(node._loops, frame)\n\n    def _add_iteration(self, loops, frame):\n        # type: (typing.Sequence[Loop], FrameType) -> None\n        \"\"\"\n        Given one or more nested loops, add an iteration for the innermost\n        loop (the last in the sequence).\n        \"\"\"\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for i, loop_node in enumerate(loops):\n            loop = iteration.loops[loop_node._tree_index]\n            if i == len(loops) - 1:\n                loop.append(Iteration())\n            else:\n                iteration = loop.last()\n\n    def after_expr(self, node, frame, value, exc_value, exc_tb):\n        # type: (ast.expr, FrameType, Any, Optional[BaseException], Optional[TracebackType]) -> Optional[ChangeValue]\n\n        if _tracing_recursively(frame):\n            return None\n\n        if frame.f_code not in self._code_infos:\n            return None\n\n        if node._is_interesting_expression:\n            # If this is an expression statement and the last statement\n            # in the body, the value is returned from the cell magic\n            # to be displayed as usual\n            if (self._code_infos[frame.f_code].traced_file.is_ipython_cell\n                    and isinstance(node.parent, ast.Expr)\n                    and node.parent is node.parent.parent.body[-1]):\n                self._ipython_cell_value = value\n\n            if is_obvious_builtin(node, self.stack[frame].expression_values[node]):\n                return None\n\n            frame_info = self.stack[frame]\n            if exc_value:\n                node_value = self._exception_value(node, frame, exc_value)\n            else:\n                node_value = NodeValue.expression(\n                    self.num_samples,\n                    value,\n                    level=max(1, 3 - len(node._loops) * (not self._is_first_loop_iteration(node, frame))),\n                )\n                self._set_node_value(node, frame, node_value)\n            self._check_inner_call(frame_info, node, node_value)\n\n        # i.e. is `node` the `y` in `[f(x) for x in y]`, making `node.parent` the `for x in y`\n        is_special_comprehension_iter = (\n                isinstance(node.parent, ast.comprehension) and\n                node is node.parent.iter and\n\n                # Generators execute in their own time and aren't directly attached to the parent frame\n                not isinstance(node.parent.parent, ast.GeneratorExp))\n\n        if not is_special_comprehension_iter:\n            return None\n\n        # Mark `for x in y` as a bit that executed, so it doesn't show as grey\n        self._set_node_value(node.parent, frame, NodeValue.covered())\n\n        if exc_value:\n            return None\n\n        # Track each iteration over `y` so that the 'loop' can be stepped through\n        loops = node._loops + (node.parent,)  # type: Tuple[Loop, ...]\n\n        def comprehension_iter_proxy():\n            for item in value:\n                self._add_iteration(loops, frame)\n                yield item\n\n        # This effectively changes to code to `for x in comprehension_iter_proxy()`\n        return ChangeValue(comprehension_iter_proxy())\n\n    def _check_inner_call(self, frame_info, node, node_value):\n        # type: (FrameInfo, Union[ast.stmt, ast.expr], NodeValue) -> None\n        inner_calls = frame_info.inner_calls.pop(node, None)\n        if inner_calls:\n            node_value.set_meta('inner_calls', inner_calls)\n\n    def _is_first_loop_iteration(self, node, frame):\n        # type: (ast.AST, FrameType) -> bool\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for loop_node in node._loops:  # type: ast.AST\n            loop = iteration.loops[loop_node._tree_index]\n            iteration = loop.last()\n            if iteration.index > 0:\n                return False\n        return True\n\n    def _set_node_value(self, node, frame, value):\n        # type: (ast.AST, FrameType, NodeValue) -> None\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for loop_node in node._loops:  # type: ast.AST\n            loop = iteration.loops[loop_node._tree_index]\n            loop.recorded_node(node)\n            iteration = loop.last()\n        iteration.vals[node._tree_index] = value\n\n    def _exception_value(self, node, frame, exc_value):\n        # type: (Union[ast.expr, ast.stmt], FrameType, BaseException) -> NodeValue\n        value = NodeValue.exception(exc_value)\n        self._set_node_value(node, frame, value)\n        return value\n\n    def after_stmt(self, node, frame, exc_value, exc_traceback, exc_node):\n        # type: (ast.stmt, FrameType, Optional[BaseException], Optional[TracebackType], Optional[ast.AST]) -> Optional[bool]\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return None\n        if exc_value and node is exc_node:\n            value = self._exception_value(node, frame, exc_value)\n        else:\n            value = NodeValue.covered()\n            self._set_node_value(node, frame, value)\n        self._check_inner_call(self.stack[frame], node, value)\n        return None\n\n    def enter_call(self, enter_info):\n        # type: (EnterCallInfo) -> None\n        frame = enter_info.current_frame  # type: FrameType\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return\n        frame_info = self.stack[frame]\n        frame_info.start_time = get_unfrozen_datetime()\n        frame_info.iteration = Iteration()\n\n        code_info = self._code_infos[frame.f_code]\n        if isinstance(enter_info.enter_node.parent, ast.Module):\n            arguments = []\n        else:\n            f_locals = frame.f_locals.copy()  # type: Dict[str, Any]\n            arguments = [(name, f_locals.pop(name))\n                         for name in code_info.arg_names\n                         if name] + [\n\n                            # Local variables other than actual arguments. These are variables from\n                            # the enclosing scope. It's handy to treat them like arguments in the UI\n                            it for it in f_locals.items()\n                            if it[0][0] != '.'  # Appears when using nested tuple arguments\n                        ]\n        frame_info.arguments = json.dumps([[k, cheap_repr(v)] for k, v in arguments])\n        frame_info.call_id = self._call_id()\n        frame_info.inner_calls = defaultdict(list)\n        prev = self.stack.get(enter_info.caller_frame)\n        if prev:\n            inner_calls = getattr(prev, 'inner_calls', None)\n            if inner_calls is not None:\n                inner_calls[enter_info.call_node].append(frame_info.call_id)\n\n    def _call_id(self):\n        # type: () -> Text\n        return uuid4().hex\n\n    def exit_call(self, exit_info):\n        # type: (ExitCallInfo) -> None\n        \"\"\"\n        This is where all the data collected during the call is gathered up\n        and sent to the database.\n        \"\"\"\n        frame = exit_info.current_frame  # type: FrameType\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return\n        frame_info = self.stack[frame]\n\n        top_iteration = frame_info.iteration  # type: Iteration\n        node_values = _deep_dict()\n        self._extract_node_values(top_iteration, (), node_values)\n\n        db_func = self._code_infos[frame.f_code].db_func\n        exc = exit_info.exc_value  # type: Optional[Exception]\n        if exc:\n            traceback_str = ''.join(traceback.format_exception(type(exc), exc, exit_info.exc_tb))\n            exception = exception_string(exc)\n        else:\n            traceback_str = exception = None\n\n        @retry_db\n        def add_call():\n            Call = self.db.Call\n            call = Call(id=frame_info.call_id,\n                        function_id=db_func,\n                        arguments=frame_info.arguments,\n                        return_value=cheap_repr(exit_info.return_value),\n                        exception=exception,\n                        traceback=traceback_str,\n                        data=json.dumps(\n                            dict(\n                                node_values=node_values,\n                                loop_iterations=top_iteration.extract_iterations()['loops'],\n                                type_names=type_registry.names(),\n                                num_special_types=type_registry.num_special_types,\n                            ),\n                            cls=ProtocolEncoder,\n                            separators=(',', ':')\n                        ),\n                        start_time=frame_info.start_time)\n            with self.db.session_scope() as session:\n                session.add(call)\n\n        add_call()\n\n        self._last_call_id = frame_info.call_id\n\n    def _extract_node_values(self, iteration, path, node_values):\n        # type: (Iteration, Tuple[int, ...], dict) -> None\n        \"\"\"\n        Populates node_values with values inside iteration.\n        \"\"\"\n        # Each element of `path` is an index of a loop iteration\n        # e.g. given the nested loops:\n        #\n        # for i in [0, 1, 2]:\n        #     for j in [0, 1, 2, 3]:\n        #\n        # path may be (i, j) for each of the iterations\n        for tree_index, node_value in iteration.vals.items():\n\n            # So this `full_path` is a tuple of ints, but the first\n            # int has a different meaning from the others\n            full_path = (tree_index,) + path\n\n            # Given a path (a, b, c) we're making node_values 'contain'\n            # this structure:\n            # {a: {b: {c: node_value}}}\n            d = node_values\n            for path_k in full_path[:-1]:\n                d = d[path_k]\n            d[full_path[-1]] = node_value\n\n        for loop in iteration.loops.values():\n            for i, iteration in enumerate(loop):\n                self._extract_node_values(iteration, path + (i,), node_values)\n\n    def trace_function(self, func):\n        # type: (FunctionType) -> FunctionType\n        new_func = super(BirdsEye, self).trace_function(func)\n        code_info = self._code_infos.get(new_func.__code__)\n        if code_info:\n            return new_func\n\n        lines, start_lineno = inspect.getsourcelines(func)  # type: List[Text], int\n        end_lineno = start_lineno + len(lines)\n        name = safe_qualname(func)\n        source_file = inspect.getsourcefile(func)\n        if source_file.startswith('<ipython-input'):\n            filename = IPYTHON_FILE_PATH\n        else:\n            filename = os.path.abspath(source_file)\n        traced_file = new_func.traced_file\n\n        arg_info = inspect.getargs(new_func.__code__)\n        arg_names = list(chain(flatten_list(arg_info[0]), arg_info[1:]))  # type: List[str]\n        self._trace(name, filename, traced_file, new_func.__code__, typ='function',\n                    start_lineno=start_lineno, end_lineno=end_lineno,\n                    arg_names=arg_names)\n\n        return new_func\n\n    def exec_ipython_cell(self, source, callback):\n        from IPython import get_ipython\n        shell = get_ipython()\n        filename = name = shell.compile.cache(source)\n        flags = shell.compile.flags\n\n        traced_file = self.compile(source, filename, flags)\n        traced_file.is_ipython_cell = True\n\n        for node in traced_file.root.body:\n            if is_future_import(node):\n                raise ValueError('from __future__ import ... statements '\n                                 'are not allowed in cells traced with %%eye')\n\n        shell.user_global_ns.update(self._trace_methods_dict(traced_file))\n\n        self._trace(name, filename, traced_file, traced_file.code, 'module', source)\n\n        try:\n            shell.ex(traced_file.code)\n            return self._ipython_cell_value\n        finally:\n            callback(self._last_call_id)\n            self._ipython_cell_value = None\n\n    def trace_this_module(self, context=0, deep=False):\n        frame = inspect.currentframe()\n\n        filename = None\n        while context >= 0:\n            frame = frame.f_back\n            filename = inspect.getsourcefile(frame)\n            if filename is not None:\n                context -= 1\n        filename = os.path.abspath(filename)\n\n        if frame.f_globals.get('__name__') != '__main__':\n            if PY3 and self._treetrace_hidden_with_stmt.__name__ not in frame.f_globals:\n                raise RuntimeError(\n                    'To trace an imported module, you must import birdseye before '\n                    'importing that module.')\n            return\n\n        lines = read_source_file(filename).splitlines()\n        lines[:frame.f_lineno] = [''] * frame.f_lineno\n        source = '\\n'.join(lines)\n        self.exec_string(source, filename, frame.f_globals, frame.f_locals, deep)\n        sys.exit(0)\n\n    def exec_string(self, source, filename, globs=None, locs=None, deep=False):\n        globs = globs or {}\n        locs = locs or {}\n\n        traced_file = self.compile(source, filename)\n\n        globs.update(self._trace_methods_dict(traced_file))\n\n        self._trace(FILE_SENTINEL_NAME, filename, traced_file, traced_file.code, 'module', source)\n\n        if deep:\n            nodes_by_lineno = {\n                node.lineno: node\n                for node in traced_file.nodes\n                if isinstance(node, ast.FunctionDef)\n            }\n\n            def find_code(root_code):\n                # type: (CodeType) -> None\n                for code in root_code.co_consts:  # type: CodeType\n                    if not inspect.iscode(code) or code.co_name.startswith('<'):\n                        continue\n\n                    find_code(code)\n\n                    lineno = code.co_firstlineno\n                    node = nodes_by_lineno.get(lineno)\n                    if not node:\n                        continue\n\n                    self._trace(\n                        code.co_name, filename, traced_file, code,\n                        typ='function',\n                        source=source,\n                        start_lineno=lineno,\n                        end_lineno=node.last_token.end[0] + 1,\n                    )\n\n            find_code(traced_file.code)\n\n        exec(traced_file.code, globs, locs)\n\n    def _trace(\n            self,\n            name,\n            filename,\n            traced_file,\n            code,\n            typ,\n            source='',\n            start_lineno=1,\n            end_lineno=None,\n            arg_names=(),\n    ):\n        if not end_lineno:\n            end_lineno = start_lineno + len(source.splitlines())\n        nodes = list(self._nodes_of_interest(traced_file, start_lineno, end_lineno))\n        html_body = self._nodes_html(nodes, start_lineno, end_lineno, traced_file)\n\n        data_dict = dict(\n            # This maps each node to the loops enclosing that node\n            node_loops={\n                node._tree_index: [n._tree_index for n in node._loops]\n                for node, _ in nodes\n                if node._loops\n            },\n        )\n        if typ == 'function':\n            tokens = traced_file.tokens\n            func_node = only(node\n                             for node, _ in nodes\n                             if isinstance(node, ast.FunctionDef)\n                             and node.first_token.start[0] == start_lineno)\n            func_startpos, source = source_without_decorators(tokens, func_node)\n            # These are for the PyCharm plugin\n            data_dict.update(\n                node_ranges=list(self._node_ranges(nodes, tokens, func_startpos)),\n                loop_ranges=list(self._loop_ranges(nodes, tokens, func_startpos)),\n            )\n\n        data = json.dumps(data_dict, sort_keys=True)\n        db_func = self._db_func(data, filename, html_body, name, start_lineno, source, typ)\n        self._code_infos[code] = CodeInfo(db_func, traced_file, arg_names)\n\n    def _loop_ranges(self, nodes, tokens, func_start):\n        # For a for loop, e.g.\n        #\n        #     for x in y:\n        #\n        # this yields the range of the target 'x'.\n        #\n        # For a while loop, e.g.\n        #\n        #     while x < 10:\n        #\n        # this yields the range of the condition 'x < 10'.\n        for node, (classes, _, __) in nodes:\n            if 'loop' not in classes:\n                continue\n\n            try:\n                target = node.target  # for loop\n            except AttributeError:\n                target = node.test  # while loop\n\n            start, end = tokens.get_text_range(target)\n            start -= func_start\n            end -= func_start\n\n            yield dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end\n            )\n\n    def _node_ranges(self, nodes, tokens, func_start):\n        for node, (classes, _, __) in nodes:\n            start, end = tokens.get_text_range(node)\n            start -= func_start\n            end -= func_start\n\n            if start < 0:\n                assert (end < 0  # nodes before the def, i.e. decorators\n                        or isinstance(node, ast.FunctionDef))\n                continue\n\n            yield dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end,\n                depth=node._depth,\n                classes=classes,\n            )\n\n    @retry_db\n    def _db_func(self, data, filename, html_body, name, start_lineno, source, typ):\n        \"\"\"\n        Retrieve the Function object from the database if one exists, or create one.\n        \"\"\"\n\n        def h(s):\n            return hashlib.sha256(s.encode('utf8')).hexdigest()\n\n        function_hash = h(filename + name + html_body + data + str(start_lineno))\n\n        Function = self.db.Function\n\n        with self.db.session_scope() as session:\n            db_func = one_or_none(session.query(Function).filter_by(hash=function_hash))  # type: Optional[Function]\n            if not db_func:\n                db_func = Function(file=filename,\n                                   name=name,\n                                   type=typ,\n                                   html_body=html_body,\n                                   lineno=start_lineno,\n                                   data=data,\n                                   body_hash=h(source),\n                                   hash=function_hash)\n                session.add(db_func)\n                session.commit()  # ensure .id exists\n            assert isinstance(db_func.id, int)\n            return db_func.id\n\n    def _nodes_of_interest(self, traced_file, start_lineno, end_lineno):\n        # type: (TracedFile, int, int) -> Iterator[Tuple[ast.AST, Tuple]]\n        \"\"\"\n        Nodes that may have a value, show up as a box in the UI, and lie within the\n        given line range.\n        \"\"\"\n        for node in traced_file.nodes:\n            classes = []\n\n            if (isinstance(node, (ast.While, ast.For, ast.comprehension)) and\n                    not isinstance(node.parent, ast.GeneratorExp)):\n                classes.append('loop')\n            if isinstance(node, ast.stmt):\n                classes.append('stmt')\n\n            if isinstance(node, ast.expr):\n                if not node._is_interesting_expression:\n                    continue\n            elif not classes:\n                continue\n\n            assert isinstance(node, ast.AST)\n\n            # In particular FormattedValue is missing this\n            if not hasattr(node, 'first_token'):\n                continue\n\n            if not start_lineno <= node.first_token.start[0] <= end_lineno:\n                continue\n\n            start, end = traced_file.tokens.get_text_range(node)  # type: int, int\n            if start == end == 0:\n                continue\n\n            yield node, (classes, start, end)\n\n    def _nodes_html(self, nodes, start_lineno, end_lineno, traced_file):\n        # type: (list, int, int, TracedFile) -> str\n        \"\"\"\n        The algorithm for generating the HTML works as follows. We generate a list\n        of HTMLPositions, which are essentially places to insert HTML into the source plus some\n        metadata. The order of the fields of HTMLPosition ensure that when the list is sorted,\n        the resulting HTML is valid and correct. Specifically, the fields are:\n        \n          1. index: the index in the source string where the HTML would be inserted\n          2. is_start: Indicates if this piece of HTML is the start of a tag, rather than the end.\n             Ends should appear first, so that the resulting HTML looks like:\n                <span> ... </span><span> ... </span>\n             rather than:\n                <span> ... <span></span> ... </span>\n             (I think this might actually be unnecessary, since I can't think of any cases of two\n              expressions right next to each other with nothing in between)\n          3. depth: the depth of the corresponding node in the AST. We want the start of a tag from\n             a node to appear before the start of a tag nested within, e.g. `foo()` should become:\n                <span [for foo()]><span [for foo]>foo</span>()</span>\n             rather than:   \n                <span [for foo]><span [for foo()]>foo</span>()</span>\n          4. html: the actual HTML to insert. Not important for ordering.\n          \n        Mostly the list contains pairs of HTMLPositions corresponding to AST nodes, one for the\n        start and one for the end.\n        \n        After the list is sorted, the HTML generated is essentially:\n        \n        source[0:positions[0].index] + positions[0].html + source[positions[0].index:positions[1].index] + positions[1].html + ...\n        \"\"\"\n\n        traced_file.root._depth = 0\n        for node in ast.walk(traced_file.root):  # type: ast.AST\n            for child in ast.iter_child_nodes(node):\n                child._depth = node._depth + 1\n\n        positions = []  # type: List[HTMLPosition]\n\n        for node, (classes, start, end) in nodes:\n            # noinspection PyArgumentList\n            positions.extend(map(\n                HTMLPosition,\n                [start, end],\n                [True, False],  # is_start\n                [node._depth, node._depth],\n                ['<span data-index=\"%s\" class=\"%s\">' % (node._tree_index, ' '.join(classes)),\n                 '</span>']))\n\n        end_lineno = self._separate_comprehensions(\n            [n[0] for n in nodes],\n            end_lineno, positions, traced_file)\n\n        # This just makes the loop below simpler\n        positions.append(HTMLPosition(len(traced_file.source), False, 0, ''))\n\n        positions.sort()\n\n        html_parts = []\n        start = 0\n        for position in positions:\n            html_parts.append(html.escape(traced_file.source[start:position.index]))\n            html_parts.append(position.html)\n            start = position.index\n        html_body = ''.join(html_parts)\n        html_body = '\\n'.join(html_body.split('\\n')[start_lineno - 1:end_lineno - 1])\n\n        return html_body.strip('\\n')\n\n    def _separate_comprehensions(self, nodes, end_lineno, positions, traced_file):\n        # type: (list, int, List[HTMLPosition], TracedFile) -> int\n        \"\"\"\n        Comprehensions (e.g. list comprehensions) are troublesome because they can\n        be navigated like loops, and the buttons for these need to be on separate lines.\n        This function inserts newlines to turn:\n\n        [x + y for x in range(3) for y in range(5)] and\n        [[x + y for x in range(3)] for y in range(5)]\n\n        into\n\n        [x + y for x in range(3)\n         for y in range(5)] and\n        [[x + y for x in range(3)]\n         for y in range(5)]\n        \"\"\"\n\n        comprehensions = group_by_key_func(of_type((ast.comprehension, ast.While, ast.For), nodes),\n                                           lambda c: c.first_token.start[0]\n                                           )  # type: Dict[Any, Iterable[ast.comprehension]]\n\n        def get_start(n):\n            # type: (ast.AST) -> int\n            return traced_file.tokens.get_text_range(n)[0]\n\n        for comp_list in comprehensions.values():\n            prev_start = None  # type: Optional[int]\n            for comp in sorted(comp_list, key=lambda c: c.first_token.startpos):\n                if isinstance(comp, ast.comprehension) and comp is comp.parent.generators[0]:\n                    start = get_start(comp.parent)\n                    if prev_start is not None and start < prev_start:\n                        start = get_start(comp)\n                else:\n                    start = get_start(comp)\n                if prev_start is not None:\n                    positions.append(HTMLPosition(start, True, 0, '\\n '))\n                    end_lineno += 1\n                prev_start = start\n\n        return end_lineno"
        ],
        [
            "STORE_NAME",
            "class BirdsEye(TreeTracerBase):\n    \"\"\"\n    Decorate functions with an instance of this class to debug them,\n    or just use the existing instance `eye`.\n    \"\"\"\n\n    def __init__(self, db_uri=None, num_samples=None):\n        \"\"\"\n        Set db_uri to specify where the database lives, as an alternative to\n        the environment variable BIRDSEYE_DB.\n        \"\"\"\n        super(BirdsEye, self).__init__()\n        self._db_uri = db_uri\n        self._code_infos = {}  # type: Dict[CodeType, CodeInfo]\n        self._last_call_id = None\n        self._ipython_cell_value = None\n        self.num_samples = num_samples or dict(\n            big=dict(\n                attributes=50,\n                dict=50,\n                list=30,\n                set=30,\n                pandas_rows=20,\n                pandas_cols=100,\n            ),\n            small=dict(\n                attributes=50,\n                dict=10,\n                list=6,\n                set=6,\n                pandas_rows=6,\n                pandas_cols=10,\n            ),\n        )\n\n    @cached_property\n    def db(self):\n        return Database(self._db_uri)\n\n    def parse_extra(self, root, source, filename):\n        # type: (ast.Module, str, str) -> None\n        for node in ast.walk(root):  # type: ast.AST\n            node._loops = tracer.loops(node)\n            if isinstance(node, ast.expr):\n                node._is_interesting_expression = is_interesting_expression(node)\n\n    @lru_cache()\n    def compile(self, source, filename, flags=0):\n        traced_file = super(BirdsEye, self).compile(source, filename, flags)\n        traced_file.tokens = ASTTokens(source, tree=traced_file.root)\n        return traced_file\n\n    def before_stmt(self, node, frame):\n        # type: (ast.stmt, FrameType) -> None\n        if frame.f_code not in self._code_infos:\n            return\n        if isinstance(node.parent, ast.For) and node is node.parent.body[0]:\n            self._add_iteration(node._loops, frame)\n\n    def before_expr(self, node, frame):\n        if isinstance(node.parent, ast.While) and node is node.parent.test:\n            self._add_iteration(node._loops, frame)\n\n    def _add_iteration(self, loops, frame):\n        # type: (typing.Sequence[Loop], FrameType) -> None\n        \"\"\"\n        Given one or more nested loops, add an iteration for the innermost\n        loop (the last in the sequence).\n        \"\"\"\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for i, loop_node in enumerate(loops):\n            loop = iteration.loops[loop_node._tree_index]\n            if i == len(loops) - 1:\n                loop.append(Iteration())\n            else:\n                iteration = loop.last()\n\n    def after_expr(self, node, frame, value, exc_value, exc_tb):\n        # type: (ast.expr, FrameType, Any, Optional[BaseException], Optional[TracebackType]) -> Optional[ChangeValue]\n\n        if _tracing_recursively(frame):\n            return None\n\n        if frame.f_code not in self._code_infos:\n            return None\n\n        if node._is_interesting_expression:\n            # If this is an expression statement and the last statement\n            # in the body, the value is returned from the cell magic\n            # to be displayed as usual\n            if (self._code_infos[frame.f_code].traced_file.is_ipython_cell\n                    and isinstance(node.parent, ast.Expr)\n                    and node.parent is node.parent.parent.body[-1]):\n                self._ipython_cell_value = value\n\n            if is_obvious_builtin(node, self.stack[frame].expression_values[node]):\n                return None\n\n            frame_info = self.stack[frame]\n            if exc_value:\n                node_value = self._exception_value(node, frame, exc_value)\n            else:\n                node_value = NodeValue.expression(\n                    self.num_samples,\n                    value,\n                    level=max(1, 3 - len(node._loops) * (not self._is_first_loop_iteration(node, frame))),\n                )\n                self._set_node_value(node, frame, node_value)\n            self._check_inner_call(frame_info, node, node_value)\n\n        # i.e. is `node` the `y` in `[f(x) for x in y]`, making `node.parent` the `for x in y`\n        is_special_comprehension_iter = (\n                isinstance(node.parent, ast.comprehension) and\n                node is node.parent.iter and\n\n                # Generators execute in their own time and aren't directly attached to the parent frame\n                not isinstance(node.parent.parent, ast.GeneratorExp))\n\n        if not is_special_comprehension_iter:\n            return None\n\n        # Mark `for x in y` as a bit that executed, so it doesn't show as grey\n        self._set_node_value(node.parent, frame, NodeValue.covered())\n\n        if exc_value:\n            return None\n\n        # Track each iteration over `y` so that the 'loop' can be stepped through\n        loops = node._loops + (node.parent,)  # type: Tuple[Loop, ...]\n\n        def comprehension_iter_proxy():\n            for item in value:\n                self._add_iteration(loops, frame)\n                yield item\n\n        # This effectively changes to code to `for x in comprehension_iter_proxy()`\n        return ChangeValue(comprehension_iter_proxy())\n\n    def _check_inner_call(self, frame_info, node, node_value):\n        # type: (FrameInfo, Union[ast.stmt, ast.expr], NodeValue) -> None\n        inner_calls = frame_info.inner_calls.pop(node, None)\n        if inner_calls:\n            node_value.set_meta('inner_calls', inner_calls)\n\n    def _is_first_loop_iteration(self, node, frame):\n        # type: (ast.AST, FrameType) -> bool\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for loop_node in node._loops:  # type: ast.AST\n            loop = iteration.loops[loop_node._tree_index]\n            iteration = loop.last()\n            if iteration.index > 0:\n                return False\n        return True\n\n    def _set_node_value(self, node, frame, value):\n        # type: (ast.AST, FrameType, NodeValue) -> None\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for loop_node in node._loops:  # type: ast.AST\n            loop = iteration.loops[loop_node._tree_index]\n            loop.recorded_node(node)\n            iteration = loop.last()\n        iteration.vals[node._tree_index] = value\n\n    def _exception_value(self, node, frame, exc_value):\n        # type: (Union[ast.expr, ast.stmt], FrameType, BaseException) -> NodeValue\n        value = NodeValue.exception(exc_value)\n        self._set_node_value(node, frame, value)\n        return value\n\n    def after_stmt(self, node, frame, exc_value, exc_traceback, exc_node):\n        # type: (ast.stmt, FrameType, Optional[BaseException], Optional[TracebackType], Optional[ast.AST]) -> Optional[bool]\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return None\n        if exc_value and node is exc_node:\n            value = self._exception_value(node, frame, exc_value)\n        else:\n            value = NodeValue.covered()\n            self._set_node_value(node, frame, value)\n        self._check_inner_call(self.stack[frame], node, value)\n        return None\n\n    def enter_call(self, enter_info):\n        # type: (EnterCallInfo) -> None\n        frame = enter_info.current_frame  # type: FrameType\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return\n        frame_info = self.stack[frame]\n        frame_info.start_time = get_unfrozen_datetime()\n        frame_info.iteration = Iteration()\n\n        code_info = self._code_infos[frame.f_code]\n        if isinstance(enter_info.enter_node.parent, ast.Module):\n            arguments = []\n        else:\n            f_locals = frame.f_locals.copy()  # type: Dict[str, Any]\n            arguments = [(name, f_locals.pop(name))\n                         for name in code_info.arg_names\n                         if name] + [\n\n                            # Local variables other than actual arguments. These are variables from\n                            # the enclosing scope. It's handy to treat them like arguments in the UI\n                            it for it in f_locals.items()\n                            if it[0][0] != '.'  # Appears when using nested tuple arguments\n                        ]\n        frame_info.arguments = json.dumps([[k, cheap_repr(v)] for k, v in arguments])\n        frame_info.call_id = self._call_id()\n        frame_info.inner_calls = defaultdict(list)\n        prev = self.stack.get(enter_info.caller_frame)\n        if prev:\n            inner_calls = getattr(prev, 'inner_calls', None)\n            if inner_calls is not None:\n                inner_calls[enter_info.call_node].append(frame_info.call_id)\n\n    def _call_id(self):\n        # type: () -> Text\n        return uuid4().hex\n\n    def exit_call(self, exit_info):\n        # type: (ExitCallInfo) -> None\n        \"\"\"\n        This is where all the data collected during the call is gathered up\n        and sent to the database.\n        \"\"\"\n        frame = exit_info.current_frame  # type: FrameType\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return\n        frame_info = self.stack[frame]\n\n        top_iteration = frame_info.iteration  # type: Iteration\n        node_values = _deep_dict()\n        self._extract_node_values(top_iteration, (), node_values)\n\n        db_func = self._code_infos[frame.f_code].db_func\n        exc = exit_info.exc_value  # type: Optional[Exception]\n        if exc:\n            traceback_str = ''.join(traceback.format_exception(type(exc), exc, exit_info.exc_tb))\n            exception = exception_string(exc)\n        else:\n            traceback_str = exception = None\n\n        @retry_db\n        def add_call():\n            Call = self.db.Call\n            call = Call(id=frame_info.call_id,\n                        function_id=db_func,\n                        arguments=frame_info.arguments,\n                        return_value=cheap_repr(exit_info.return_value),\n                        exception=exception,\n                        traceback=traceback_str,\n                        data=json.dumps(\n                            dict(\n                                node_values=node_values,\n                                loop_iterations=top_iteration.extract_iterations()['loops'],\n                                type_names=type_registry.names(),\n                                num_special_types=type_registry.num_special_types,\n                            ),\n                            cls=ProtocolEncoder,\n                            separators=(',', ':')\n                        ),\n                        start_time=frame_info.start_time)\n            with self.db.session_scope() as session:\n                session.add(call)\n\n        add_call()\n\n        self._last_call_id = frame_info.call_id\n\n    def _extract_node_values(self, iteration, path, node_values):\n        # type: (Iteration, Tuple[int, ...], dict) -> None\n        \"\"\"\n        Populates node_values with values inside iteration.\n        \"\"\"\n        # Each element of `path` is an index of a loop iteration\n        # e.g. given the nested loops:\n        #\n        # for i in [0, 1, 2]:\n        #     for j in [0, 1, 2, 3]:\n        #\n        # path may be (i, j) for each of the iterations\n        for tree_index, node_value in iteration.vals.items():\n\n            # So this `full_path` is a tuple of ints, but the first\n            # int has a different meaning from the others\n            full_path = (tree_index,) + path\n\n            # Given a path (a, b, c) we're making node_values 'contain'\n            # this structure:\n            # {a: {b: {c: node_value}}}\n            d = node_values\n            for path_k in full_path[:-1]:\n                d = d[path_k]\n            d[full_path[-1]] = node_value\n\n        for loop in iteration.loops.values():\n            for i, iteration in enumerate(loop):\n                self._extract_node_values(iteration, path + (i,), node_values)\n\n    def trace_function(self, func):\n        # type: (FunctionType) -> FunctionType\n        new_func = super(BirdsEye, self).trace_function(func)\n        code_info = self._code_infos.get(new_func.__code__)\n        if code_info:\n            return new_func\n\n        lines, start_lineno = inspect.getsourcelines(func)  # type: List[Text], int\n        end_lineno = start_lineno + len(lines)\n        name = safe_qualname(func)\n        source_file = inspect.getsourcefile(func)\n        if source_file.startswith('<ipython-input'):\n            filename = IPYTHON_FILE_PATH\n        else:\n            filename = os.path.abspath(source_file)\n        traced_file = new_func.traced_file\n\n        arg_info = inspect.getargs(new_func.__code__)\n        arg_names = list(chain(flatten_list(arg_info[0]), arg_info[1:]))  # type: List[str]\n        self._trace(name, filename, traced_file, new_func.__code__, typ='function',\n                    start_lineno=start_lineno, end_lineno=end_lineno,\n                    arg_names=arg_names)\n\n        return new_func\n\n    def exec_ipython_cell(self, source, callback):\n        from IPython import get_ipython\n        shell = get_ipython()\n        filename = name = shell.compile.cache(source)\n        flags = shell.compile.flags\n\n        traced_file = self.compile(source, filename, flags)\n        traced_file.is_ipython_cell = True\n\n        for node in traced_file.root.body:\n            if is_future_import(node):\n                raise ValueError('from __future__ import ... statements '\n                                 'are not allowed in cells traced with %%eye')\n\n        shell.user_global_ns.update(self._trace_methods_dict(traced_file))\n\n        self._trace(name, filename, traced_file, traced_file.code, 'module', source)\n\n        try:\n            shell.ex(traced_file.code)\n            return self._ipython_cell_value\n        finally:\n            callback(self._last_call_id)\n            self._ipython_cell_value = None\n\n    def trace_this_module(self, context=0, deep=False):\n        frame = inspect.currentframe()\n\n        filename = None\n        while context >= 0:\n            frame = frame.f_back\n            filename = inspect.getsourcefile(frame)\n            if filename is not None:\n                context -= 1\n        filename = os.path.abspath(filename)\n\n        if frame.f_globals.get('__name__') != '__main__':\n            if PY3 and self._treetrace_hidden_with_stmt.__name__ not in frame.f_globals:\n                raise RuntimeError(\n                    'To trace an imported module, you must import birdseye before '\n                    'importing that module.')\n            return\n\n        lines = read_source_file(filename).splitlines()\n        lines[:frame.f_lineno] = [''] * frame.f_lineno\n        source = '\\n'.join(lines)\n        self.exec_string(source, filename, frame.f_globals, frame.f_locals, deep)\n        sys.exit(0)\n\n    def exec_string(self, source, filename, globs=None, locs=None, deep=False):\n        globs = globs or {}\n        locs = locs or {}\n\n        traced_file = self.compile(source, filename)\n\n        globs.update(self._trace_methods_dict(traced_file))\n\n        self._trace(FILE_SENTINEL_NAME, filename, traced_file, traced_file.code, 'module', source)\n\n        if deep:\n            nodes_by_lineno = {\n                node.lineno: node\n                for node in traced_file.nodes\n                if isinstance(node, ast.FunctionDef)\n            }\n\n            def find_code(root_code):\n                # type: (CodeType) -> None\n                for code in root_code.co_consts:  # type: CodeType\n                    if not inspect.iscode(code) or code.co_name.startswith('<'):\n                        continue\n\n                    find_code(code)\n\n                    lineno = code.co_firstlineno\n                    node = nodes_by_lineno.get(lineno)\n                    if not node:\n                        continue\n\n                    self._trace(\n                        code.co_name, filename, traced_file, code,\n                        typ='function',\n                        source=source,\n                        start_lineno=lineno,\n                        end_lineno=node.last_token.end[0] + 1,\n                    )\n\n            find_code(traced_file.code)\n\n        exec(traced_file.code, globs, locs)\n\n    def _trace(\n            self,\n            name,\n            filename,\n            traced_file,\n            code,\n            typ,\n            source='',\n            start_lineno=1,\n            end_lineno=None,\n            arg_names=(),\n    ):\n        if not end_lineno:\n            end_lineno = start_lineno + len(source.splitlines())\n        nodes = list(self._nodes_of_interest(traced_file, start_lineno, end_lineno))\n        html_body = self._nodes_html(nodes, start_lineno, end_lineno, traced_file)\n\n        data_dict = dict(\n            # This maps each node to the loops enclosing that node\n            node_loops={\n                node._tree_index: [n._tree_index for n in node._loops]\n                for node, _ in nodes\n                if node._loops\n            },\n        )\n        if typ == 'function':\n            tokens = traced_file.tokens\n            func_node = only(node\n                             for node, _ in nodes\n                             if isinstance(node, ast.FunctionDef)\n                             and node.first_token.start[0] == start_lineno)\n            func_startpos, source = source_without_decorators(tokens, func_node)\n            # These are for the PyCharm plugin\n            data_dict.update(\n                node_ranges=list(self._node_ranges(nodes, tokens, func_startpos)),\n                loop_ranges=list(self._loop_ranges(nodes, tokens, func_startpos)),\n            )\n\n        data = json.dumps(data_dict, sort_keys=True)\n        db_func = self._db_func(data, filename, html_body, name, start_lineno, source, typ)\n        self._code_infos[code] = CodeInfo(db_func, traced_file, arg_names)\n\n    def _loop_ranges(self, nodes, tokens, func_start):\n        # For a for loop, e.g.\n        #\n        #     for x in y:\n        #\n        # this yields the range of the target 'x'.\n        #\n        # For a while loop, e.g.\n        #\n        #     while x < 10:\n        #\n        # this yields the range of the condition 'x < 10'.\n        for node, (classes, _, __) in nodes:\n            if 'loop' not in classes:\n                continue\n\n            try:\n                target = node.target  # for loop\n            except AttributeError:\n                target = node.test  # while loop\n\n            start, end = tokens.get_text_range(target)\n            start -= func_start\n            end -= func_start\n\n            yield dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end\n            )\n\n    def _node_ranges(self, nodes, tokens, func_start):\n        for node, (classes, _, __) in nodes:\n            start, end = tokens.get_text_range(node)\n            start -= func_start\n            end -= func_start\n\n            if start < 0:\n                assert (end < 0  # nodes before the def, i.e. decorators\n                        or isinstance(node, ast.FunctionDef))\n                continue\n\n            yield dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end,\n                depth=node._depth,\n                classes=classes,\n            )\n\n    @retry_db\n    def _db_func(self, data, filename, html_body, name, start_lineno, source, typ):\n        \"\"\"\n        Retrieve the Function object from the database if one exists, or create one.\n        \"\"\"\n\n        def h(s):\n            return hashlib.sha256(s.encode('utf8')).hexdigest()\n\n        function_hash = h(filename + name + html_body + data + str(start_lineno))\n\n        Function = self.db.Function\n\n        with self.db.session_scope() as session:\n            db_func = one_or_none(session.query(Function).filter_by(hash=function_hash))  # type: Optional[Function]\n            if not db_func:\n                db_func = Function(file=filename,\n                                   name=name,\n                                   type=typ,\n                                   html_body=html_body,\n                                   lineno=start_lineno,\n                                   data=data,\n                                   body_hash=h(source),\n                                   hash=function_hash)\n                session.add(db_func)\n                session.commit()  # ensure .id exists\n            assert isinstance(db_func.id, int)\n            return db_func.id\n\n    def _nodes_of_interest(self, traced_file, start_lineno, end_lineno):\n        # type: (TracedFile, int, int) -> Iterator[Tuple[ast.AST, Tuple]]\n        \"\"\"\n        Nodes that may have a value, show up as a box in the UI, and lie within the\n        given line range.\n        \"\"\"\n        for node in traced_file.nodes:\n            classes = []\n\n            if (isinstance(node, (ast.While, ast.For, ast.comprehension)) and\n                    not isinstance(node.parent, ast.GeneratorExp)):\n                classes.append('loop')\n            if isinstance(node, ast.stmt):\n                classes.append('stmt')\n\n            if isinstance(node, ast.expr):\n                if not node._is_interesting_expression:\n                    continue\n            elif not classes:\n                continue\n\n            assert isinstance(node, ast.AST)\n\n            # In particular FormattedValue is missing this\n            if not hasattr(node, 'first_token'):\n                continue\n\n            if not start_lineno <= node.first_token.start[0] <= end_lineno:\n                continue\n\n            start, end = traced_file.tokens.get_text_range(node)  # type: int, int\n            if start == end == 0:\n                continue\n\n            yield node, (classes, start, end)\n\n    def _nodes_html(self, nodes, start_lineno, end_lineno, traced_file):\n        # type: (list, int, int, TracedFile) -> str\n        \"\"\"\n        The algorithm for generating the HTML works as follows. We generate a list\n        of HTMLPositions, which are essentially places to insert HTML into the source plus some\n        metadata. The order of the fields of HTMLPosition ensure that when the list is sorted,\n        the resulting HTML is valid and correct. Specifically, the fields are:\n        \n          1. index: the index in the source string where the HTML would be inserted\n          2. is_start: Indicates if this piece of HTML is the start of a tag, rather than the end.\n             Ends should appear first, so that the resulting HTML looks like:\n                <span> ... </span><span> ... </span>\n             rather than:\n                <span> ... <span></span> ... </span>\n             (I think this might actually be unnecessary, since I can't think of any cases of two\n              expressions right next to each other with nothing in between)\n          3. depth: the depth of the corresponding node in the AST. We want the start of a tag from\n             a node to appear before the start of a tag nested within, e.g. `foo()` should become:\n                <span [for foo()]><span [for foo]>foo</span>()</span>\n             rather than:   \n                <span [for foo]><span [for foo()]>foo</span>()</span>\n          4. html: the actual HTML to insert. Not important for ordering.\n          \n        Mostly the list contains pairs of HTMLPositions corresponding to AST nodes, one for the\n        start and one for the end.\n        \n        After the list is sorted, the HTML generated is essentially:\n        \n        source[0:positions[0].index] + positions[0].html + source[positions[0].index:positions[1].index] + positions[1].html + ...\n        \"\"\"\n\n        traced_file.root._depth = 0\n        for node in ast.walk(traced_file.root):  # type: ast.AST\n            for child in ast.iter_child_nodes(node):\n                child._depth = node._depth + 1\n\n        positions = []  # type: List[HTMLPosition]\n\n        for node, (classes, start, end) in nodes:\n            # noinspection PyArgumentList\n            positions.extend(map(\n                HTMLPosition,\n                [start, end],\n                [True, False],  # is_start\n                [node._depth, node._depth],\n                ['<span data-index=\"%s\" class=\"%s\">' % (node._tree_index, ' '.join(classes)),\n                 '</span>']))\n\n        end_lineno = self._separate_comprehensions(\n            [n[0] for n in nodes],\n            end_lineno, positions, traced_file)\n\n        # This just makes the loop below simpler\n        positions.append(HTMLPosition(len(traced_file.source), False, 0, ''))\n\n        positions.sort()\n\n        html_parts = []\n        start = 0\n        for position in positions:\n            html_parts.append(html.escape(traced_file.source[start:position.index]))\n            html_parts.append(position.html)\n            start = position.index\n        html_body = ''.join(html_parts)\n        html_body = '\\n'.join(html_body.split('\\n')[start_lineno - 1:end_lineno - 1])\n\n        return html_body.strip('\\n')\n\n    def _separate_comprehensions(self, nodes, end_lineno, positions, traced_file):\n        # type: (list, int, List[HTMLPosition], TracedFile) -> int\n        \"\"\"\n        Comprehensions (e.g. list comprehensions) are troublesome because they can\n        be navigated like loops, and the buttons for these need to be on separate lines.\n        This function inserts newlines to turn:\n\n        [x + y for x in range(3) for y in range(5)] and\n        [[x + y for x in range(3)] for y in range(5)]\n\n        into\n\n        [x + y for x in range(3)\n         for y in range(5)] and\n        [[x + y for x in range(3)]\n         for y in range(5)]\n        \"\"\"\n\n        comprehensions = group_by_key_func(of_type((ast.comprehension, ast.While, ast.For), nodes),\n                                           lambda c: c.first_token.start[0]\n                                           )  # type: Dict[Any, Iterable[ast.comprehension]]\n\n        def get_start(n):\n            # type: (ast.AST) -> int\n            return traced_file.tokens.get_text_range(n)[0]\n\n        for comp_list in comprehensions.values():\n            prev_start = None  # type: Optional[int]\n            for comp in sorted(comp_list, key=lambda c: c.first_token.startpos):\n                if isinstance(comp, ast.comprehension) and comp is comp.parent.generators[0]:\n                    start = get_start(comp.parent)\n                    if prev_start is not None and start < prev_start:\n                        start = get_start(comp)\n                else:\n                    start = get_start(comp)\n                if prev_start is not None:\n                    positions.append(HTMLPosition(start, True, 0, '\\n '))\n                    end_lineno += 1\n                prev_start = start\n\n        return end_lineno"
        ],
        [
            "LOAD_NAME",
            "BirdsEye"
        ],
        [
            "CALL",
            "BirdsEye()"
        ],
        [
            "STORE_NAME",
            "eye"
        ],
        [
            "LOAD_NAME",
            "NamedTuple"
        ],
        [
            "LOAD_NAME",
            "int"
        ],
        [
            "LOAD_NAME",
            "bool"
        ],
        [
            "LOAD_NAME",
            "int"
        ],
        [
            "LOAD_NAME",
            "str"
        ],
        [
            "CALL",
            "NamedTuple('HTMLPosition', [\n    ('index', int),\n    ('is_start', bool),\n    ('depth', int),\n    ('html', str),\n])"
        ],
        [
            "STORE_NAME",
            "HTMLPosition"
        ],
        [
            "STORE_NAME",
            "def _deep_dict():\n    return defaultdict(_deep_dict)"
        ],
        [
            "LOAD_NAME",
            "eye"
        ],
        [
            "LOAD_ATTR",
            "eye.enter_call"
        ],
        [
            "LOAD_ATTR",
            "eye.enter_call.__code__"
        ],
        [
            "LOAD_NAME",
            "eye"
        ],
        [
            "LOAD_ATTR",
            "eye.exit_call"
        ],
        [
            "LOAD_ATTR",
            "eye.exit_call.__code__"
        ],
        [
            "LOAD_NAME",
            "eye"
        ],
        [
            "LOAD_ATTR",
            "eye.after_expr"
        ],
        [
            "LOAD_ATTR",
            "eye.after_expr.__code__"
        ],
        [
            "LOAD_NAME",
            "eye"
        ],
        [
            "LOAD_ATTR",
            "eye.after_stmt"
        ],
        [
            "LOAD_ATTR",
            "eye.after_stmt.__code__"
        ],
        [
            "STORE_NAME",
            "_bad_codes"
        ],
        [
            "STORE_NAME",
            "def _tracing_recursively(frame):\n    while frame:\n        if frame.f_code in _bad_codes:\n            return True\n        frame = frame.f_back"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class Iteration(object):\n    \"\"\"\n    Corresponds to an iteration of a loop during a call, OR\n    the call itself (FrameInfo.iteration).\n    \"\"\"\n\n    def __init__(self):\n        # Mapping of nodes (via node._tree_index) to the value of that\n        # node in this iteration. Only contains nodes within the corresponding\n        # loop or at the top of the function, but not in loops further within\n        # (those will be somewhere within self.loops)\n        # Therefore those nodes have at most one value.\n        self.vals = {}  # type: Dict[int, NodeValue]\n\n        # Mapping of loop nodes (via node._tree_index) to IterationLists\n        # for loops that happened during this iteration\n        self.loops = defaultdict(IterationList)  # type: Dict[int, IterationList]\n\n        # 0-based index of this iteration\n        self.index = None  # type: int\n        self.keep = False\n\n    def extract_iterations(self):\n        # type: () -> Dict[str, Union[int, Dict]]\n        return {\n            'index': self.index,\n            'loops': {\n                tree_index: [iteration.extract_iterations()\n                             for iteration in iteration_list]\n                for tree_index, iteration_list in self.loops.items()\n            }\n        }"
        ],
        [
            "STORE_NAME",
            "class Iteration(object):\n    \"\"\"\n    Corresponds to an iteration of a loop during a call, OR\n    the call itself (FrameInfo.iteration).\n    \"\"\"\n\n    def __init__(self):\n        # Mapping of nodes (via node._tree_index) to the value of that\n        # node in this iteration. Only contains nodes within the corresponding\n        # loop or at the top of the function, but not in loops further within\n        # (those will be somewhere within self.loops)\n        # Therefore those nodes have at most one value.\n        self.vals = {}  # type: Dict[int, NodeValue]\n\n        # Mapping of loop nodes (via node._tree_index) to IterationLists\n        # for loops that happened during this iteration\n        self.loops = defaultdict(IterationList)  # type: Dict[int, IterationList]\n\n        # 0-based index of this iteration\n        self.index = None  # type: int\n        self.keep = False\n\n    def extract_iterations(self):\n        # type: () -> Dict[str, Union[int, Dict]]\n        return {\n            'index': self.index,\n            'loops': {\n                tree_index: [iteration.extract_iterations()\n                             for iteration in iteration_list]\n                for tree_index, iteration_list in self.loops.items()\n            }\n        }"
        ],
        [
            "LOAD_NAME",
            "Iterable"
        ],
        [
            "LOAD_NAME",
            "Iteration"
        ],
        [
            "BINARY_SUBSCR",
            "Iterable[Iteration]"
        ],
        [
            "CALL",
            "class IterationList(Iterable[Iteration]):\n    \"\"\"\n    A list of Iterations, corresponding to a run of a loop.\n    If the loop has many iterations, only contains the first and last few\n    and any in the middle where unique nodes had values, so that\n    any node which appeared during this loop exists in at least some iterations.\n    \"\"\"\n    side_len = 3\n\n    def __init__(self):\n        # Contains the first few iterations\n        # and any after that have unique nodes in them\n        self.start = []  # type: List[Iteration]\n\n        # Contains the last few iterations\n        self.end = deque(maxlen=self.side_len)  # type: Deque[Iteration]\n\n        # Total number of iterations in the loop, not all of which\n        # are kept\n        self.length = 0  # type: int\n\n        # Number of times each node has been recorded in this loop\n        self.recorded = Counter()\n\n    def append(self, iteration):\n        # type: (Iteration) -> None\n        if self.length < self.side_len:\n            self.start.append(iteration)\n        else:\n            # If self.end is too long, the first element self.end[0]\n            # is about to be dropped by the deque. If that iteration\n            # should be kept because of some node that was recorded,\n            # add it to self.start\n            if len(self.end) >= self.side_len and self.end[0].keep:\n                self.start.append(self.end[0])\n\n            self.end.append(iteration)\n        iteration.index = self.length\n        self.length += 1\n\n    def __iter__(self):\n        # type: () -> Iterator[Iteration]\n        return chain(self.start, self.end)\n\n    def last(self):\n        # type: () -> Iteration\n        if self.end:\n            return self.end[-1]\n        else:\n            return self.start[-1]\n\n    def recorded_node(self, node):\n        # type: (ast.AST) -> None\n        if self.recorded[node] >= 2:\n            # We've already seen this node enough\n            return\n\n        # This node is new(ish), make sure we keep this iteration\n        self.last().keep = True\n        self.recorded[node] += 1"
        ],
        [
            "STORE_NAME",
            "class IterationList(Iterable[Iteration]):\n    \"\"\"\n    A list of Iterations, corresponding to a run of a loop.\n    If the loop has many iterations, only contains the first and last few\n    and any in the middle where unique nodes had values, so that\n    any node which appeared during this loop exists in at least some iterations.\n    \"\"\"\n    side_len = 3\n\n    def __init__(self):\n        # Contains the first few iterations\n        # and any after that have unique nodes in them\n        self.start = []  # type: List[Iteration]\n\n        # Contains the last few iterations\n        self.end = deque(maxlen=self.side_len)  # type: Deque[Iteration]\n\n        # Total number of iterations in the loop, not all of which\n        # are kept\n        self.length = 0  # type: int\n\n        # Number of times each node has been recorded in this loop\n        self.recorded = Counter()\n\n    def append(self, iteration):\n        # type: (Iteration) -> None\n        if self.length < self.side_len:\n            self.start.append(iteration)\n        else:\n            # If self.end is too long, the first element self.end[0]\n            # is about to be dropped by the deque. If that iteration\n            # should be kept because of some node that was recorded,\n            # add it to self.start\n            if len(self.end) >= self.side_len and self.end[0].keep:\n                self.start.append(self.end[0])\n\n            self.end.append(iteration)\n        iteration.index = self.length\n        self.length += 1\n\n    def __iter__(self):\n        # type: () -> Iterator[Iteration]\n        return chain(self.start, self.end)\n\n    def last(self):\n        # type: () -> Iteration\n        if self.end:\n            return self.end[-1]\n        else:\n            return self.start[-1]\n\n    def recorded_node(self, node):\n        # type: (ast.AST) -> None\n        if self.recorded[node] >= 2:\n            # We've already seen this node enough\n            return\n\n        # This node is new(ish), make sure we keep this iteration\n        self.last().keep = True\n        self.recorded[node] += 1"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class TypeRegistry(object):\n    basic_types = (type(None), bool, int, float, complex)\n    if PY2:\n        basic_types += (long,)\n    special_types = basic_types + (list, dict, tuple, set, frozenset, str)\n    if PY2:\n        special_types += (unicode if PY2 else bytes,)\n\n    num_special_types = len(special_types)\n\n    def __init__(self):\n        self.lock = Lock()\n        self.data = defaultdict(lambda: len(self.data))  # type: Dict[type, int]\n\n        for t in self.special_types:\n            _ = self.data[t]\n\n    def __getitem__(self, item):\n        t = correct_type(item)\n        with self.lock:\n            return self.data[t]\n\n    def names(self):\n        # type: () -> List[str]\n        rev = dict((v, k) for k, v in self.data.items())\n        return [safe_qualname(rev[i]) for i in range(len(rev))]"
        ],
        [
            "STORE_NAME",
            "class TypeRegistry(object):\n    basic_types = (type(None), bool, int, float, complex)\n    if PY2:\n        basic_types += (long,)\n    special_types = basic_types + (list, dict, tuple, set, frozenset, str)\n    if PY2:\n        special_types += (unicode if PY2 else bytes,)\n\n    num_special_types = len(special_types)\n\n    def __init__(self):\n        self.lock = Lock()\n        self.data = defaultdict(lambda: len(self.data))  # type: Dict[type, int]\n\n        for t in self.special_types:\n            _ = self.data[t]\n\n    def __getitem__(self, item):\n        t = correct_type(item)\n        with self.lock:\n            return self.data[t]\n\n    def names(self):\n        # type: () -> List[str]\n        rev = dict((v, k) for k, v in self.data.items())\n        return [safe_qualname(rev[i]) for i in range(len(rev))]"
        ],
        [
            "LOAD_NAME",
            "TypeRegistry"
        ],
        [
            "CALL",
            "TypeRegistry()"
        ],
        [
            "STORE_NAME",
            "type_registry"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class NodeValue(object):\n    \"\"\"\n    The 'value' of a node during a particular iteration.\n    This can mean different things, see the classmethods.\n    Can also contain some metadata, including links to other calls.\n    \"\"\"\n    __slots__ = ('val_repr', 'type_index', 'meta', 'children')\n\n    def __init__(self, val_repr, type_index):\n        self.val_repr = val_repr  # type: str\n        self.type_index = type_index  # type: int\n        self.meta = None  # type: Optional[Dict[str, Any]]\n        self.children = None  # type: Optional[List[Tuple[str, NodeValue]]]\n\n    def set_meta(self, key, value):\n        # type: (str, Any) -> None\n        self.meta = self.meta or {}\n        self.meta[key] = value\n\n    def add_child(self, samples, level, key, value):\n        # type: (dict, int, str, Any) -> None\n        self.children = self.children or []\n        self.children.append((key, NodeValue.expression(samples, value, level)))\n\n    def as_json(self):\n        result = [self.val_repr, self.type_index, self.meta or {}]  # type: list\n        if self.children:\n            result.extend(self.children)\n        return result\n\n    @classmethod\n    def covered(cls):\n        \"\"\"\n        Represents a bit of code, usually a statement, that executed successfully but\n        doesn't have an actual value.\n        \"\"\"\n        return cls('', -2)\n\n    @classmethod\n    def exception(cls, exc_value):\n        \"\"\"\n        Means that exc_value was raised by a node when executing, and not any inner node.\n        \"\"\"\n        return cls(exception_string(exc_value), -1)\n\n    @classmethod\n    def expression(cls, samples, val, level):\n        # type: (dict, Any, int) -> NodeValue\n        \"\"\"\n        The value of an expression or one of its children, with attributes,\n        dictionary items, etc as children. Has a max depth of `level` levels.\n        \"\"\"\n        result = cls(cheap_repr(val), type_registry[val])\n        if isinstance(val, (TypeRegistry.basic_types, BirdsEye)):\n            return result\n\n        length = None\n        if not isinstance(val, QuerySet):  # len triggers a database query\n            try:\n                length = len(val)\n            except:\n                pass\n            else:\n                result.set_meta('len', length)\n\n        if isinstance(val, ModuleType):\n            level = min(level, 2)\n\n        add_child = partial(result.add_child, samples, level - 1)\n\n        if isinstance(val, (Series, ndarray)):\n            attrs = ['dtype']\n            if isinstance(val, ndarray):\n                attrs.append('shape')\n            for name in attrs:\n                try:\n                    attr = getattr(val, name)\n                except AttributeError:\n                    pass\n                else:\n                    add_child(name, attr)\n\n        if level >= 3 or level >= 2 and isinstance(val, Series):\n            sample_type = 'big'\n        else:\n            sample_type = 'small'\n\n        samples = samples[sample_type]\n\n        # Always expand DataFrames and Series regardless of level to\n        # make the table view of DataFrames work\n\n        if isinstance(val, DataFrame):\n            meta = {}\n            result.set_meta('dataframe', meta)\n\n            max_rows = samples['pandas_rows']\n            max_cols = samples['pandas_cols']\n\n            if length > max_rows + 2:\n                meta['row_break'] = max_rows // 2\n\n            columns = val.columns\n            num_cols = len(columns)\n            if num_cols > max_cols + 2:\n                meta['col_break'] = max_cols // 2\n\n            indices = set(_sample_indices(num_cols, max_cols))\n            for i, (formatted_name, label) in enumerate(zip(val.columns.format(sparsify=False),\n                                                            val.columns)):\n                if i in indices:\n                    add_child(formatted_name, val[label])\n\n            return result\n\n        if isinstance(val, Series):\n            for i in _sample_indices(length, samples['pandas_rows']):\n                try:\n                    k = val.index[i:i + 1].format(sparsify=False)[0]\n                    v = val.iloc[i]\n                except:\n                    pass\n                else:\n                    add_child(k, v)\n            return result\n\n        if (level <= 0 or\n                isinstance(val,\n                           (str, bytes, range)\n                           if PY3 else\n                           (str, unicode, xrange))):\n            return result\n\n        if isinstance(val, (Sequence, ndarray)) and length is not None:\n            for i in _sample_indices(length, samples['list']):\n                try:\n                    v = val[i]\n                except:\n                    pass\n                else:\n                    add_child(str(i), v)\n\n        if isinstance(val, Mapping):\n            for k, v in islice(_safe_iter(val, iteritems), samples['dict']):\n                add_child(cheap_repr(k), v)\n\n        if isinstance(val, Set):\n            vals = _safe_iter(val)\n            num_items = samples['set']\n            if length is None or length > num_items + 2:\n                vals = islice(vals, num_items)\n            for i, v in enumerate(vals):\n                add_child('<%s>' % i, v)\n\n        d = getattr(val, '__dict__', None)\n        if d:\n            for k in sorted(islice(_safe_iter(d),\n                                   samples['attributes']),\n                            key=str):\n                v = d[k]\n                if isinstance(v, TracedFile):\n                    continue\n                add_child(str(k), v)\n        else:\n            for s in sorted(getattr(type(val), '__slots__', None) or ()):\n                try:\n                    attr = getattr(val, s)\n                except AttributeError:\n                    pass\n                else:\n                    add_child(str(s), attr)\n        return result"
        ],
        [
            "STORE_NAME",
            "class NodeValue(object):\n    \"\"\"\n    The 'value' of a node during a particular iteration.\n    This can mean different things, see the classmethods.\n    Can also contain some metadata, including links to other calls.\n    \"\"\"\n    __slots__ = ('val_repr', 'type_index', 'meta', 'children')\n\n    def __init__(self, val_repr, type_index):\n        self.val_repr = val_repr  # type: str\n        self.type_index = type_index  # type: int\n        self.meta = None  # type: Optional[Dict[str, Any]]\n        self.children = None  # type: Optional[List[Tuple[str, NodeValue]]]\n\n    def set_meta(self, key, value):\n        # type: (str, Any) -> None\n        self.meta = self.meta or {}\n        self.meta[key] = value\n\n    def add_child(self, samples, level, key, value):\n        # type: (dict, int, str, Any) -> None\n        self.children = self.children or []\n        self.children.append((key, NodeValue.expression(samples, value, level)))\n\n    def as_json(self):\n        result = [self.val_repr, self.type_index, self.meta or {}]  # type: list\n        if self.children:\n            result.extend(self.children)\n        return result\n\n    @classmethod\n    def covered(cls):\n        \"\"\"\n        Represents a bit of code, usually a statement, that executed successfully but\n        doesn't have an actual value.\n        \"\"\"\n        return cls('', -2)\n\n    @classmethod\n    def exception(cls, exc_value):\n        \"\"\"\n        Means that exc_value was raised by a node when executing, and not any inner node.\n        \"\"\"\n        return cls(exception_string(exc_value), -1)\n\n    @classmethod\n    def expression(cls, samples, val, level):\n        # type: (dict, Any, int) -> NodeValue\n        \"\"\"\n        The value of an expression or one of its children, with attributes,\n        dictionary items, etc as children. Has a max depth of `level` levels.\n        \"\"\"\n        result = cls(cheap_repr(val), type_registry[val])\n        if isinstance(val, (TypeRegistry.basic_types, BirdsEye)):\n            return result\n\n        length = None\n        if not isinstance(val, QuerySet):  # len triggers a database query\n            try:\n                length = len(val)\n            except:\n                pass\n            else:\n                result.set_meta('len', length)\n\n        if isinstance(val, ModuleType):\n            level = min(level, 2)\n\n        add_child = partial(result.add_child, samples, level - 1)\n\n        if isinstance(val, (Series, ndarray)):\n            attrs = ['dtype']\n            if isinstance(val, ndarray):\n                attrs.append('shape')\n            for name in attrs:\n                try:\n                    attr = getattr(val, name)\n                except AttributeError:\n                    pass\n                else:\n                    add_child(name, attr)\n\n        if level >= 3 or level >= 2 and isinstance(val, Series):\n            sample_type = 'big'\n        else:\n            sample_type = 'small'\n\n        samples = samples[sample_type]\n\n        # Always expand DataFrames and Series regardless of level to\n        # make the table view of DataFrames work\n\n        if isinstance(val, DataFrame):\n            meta = {}\n            result.set_meta('dataframe', meta)\n\n            max_rows = samples['pandas_rows']\n            max_cols = samples['pandas_cols']\n\n            if length > max_rows + 2:\n                meta['row_break'] = max_rows // 2\n\n            columns = val.columns\n            num_cols = len(columns)\n            if num_cols > max_cols + 2:\n                meta['col_break'] = max_cols // 2\n\n            indices = set(_sample_indices(num_cols, max_cols))\n            for i, (formatted_name, label) in enumerate(zip(val.columns.format(sparsify=False),\n                                                            val.columns)):\n                if i in indices:\n                    add_child(formatted_name, val[label])\n\n            return result\n\n        if isinstance(val, Series):\n            for i in _sample_indices(length, samples['pandas_rows']):\n                try:\n                    k = val.index[i:i + 1].format(sparsify=False)[0]\n                    v = val.iloc[i]\n                except:\n                    pass\n                else:\n                    add_child(k, v)\n            return result\n\n        if (level <= 0 or\n                isinstance(val,\n                           (str, bytes, range)\n                           if PY3 else\n                           (str, unicode, xrange))):\n            return result\n\n        if isinstance(val, (Sequence, ndarray)) and length is not None:\n            for i in _sample_indices(length, samples['list']):\n                try:\n                    v = val[i]\n                except:\n                    pass\n                else:\n                    add_child(str(i), v)\n\n        if isinstance(val, Mapping):\n            for k, v in islice(_safe_iter(val, iteritems), samples['dict']):\n                add_child(cheap_repr(k), v)\n\n        if isinstance(val, Set):\n            vals = _safe_iter(val)\n            num_items = samples['set']\n            if length is None or length > num_items + 2:\n                vals = islice(vals, num_items)\n            for i, v in enumerate(vals):\n                add_child('<%s>' % i, v)\n\n        d = getattr(val, '__dict__', None)\n        if d:\n            for k in sorted(islice(_safe_iter(d),\n                                   samples['attributes']),\n                            key=str):\n                v = d[k]\n                if isinstance(v, TracedFile):\n                    continue\n                add_child(str(k), v)\n        else:\n            for s in sorted(getattr(type(val), '__slots__', None) or ()):\n                try:\n                    attr = getattr(val, s)\n                except AttributeError:\n                    pass\n                else:\n                    add_child(str(s), attr)\n        return result"
        ],
        [
            "STORE_NAME",
            "def _safe_iter(val, f=lambda x: x):\n    try:\n        for x in f(val):\n            yield x\n    except:\n        pass"
        ],
        [
            "STORE_NAME",
            "def _sample_indices(length, max_length):\n    if length <= max_length + 2:\n        return range(length)\n    else:\n        return chain(range(max_length // 2),\n                     range(length - max_length // 2,\n                           length))"
        ],
        [
            "LOAD_NAME",
            "try_register_repr"
        ],
        [
            "CALL",
            "try_register_repr('pandas', 'Series')"
        ],
        [
            "CALL",
            "try_register_repr('pandas', 'Series')"
        ],
        [
            "STORE_NAME",
            "@try_register_repr('pandas', 'Series')\ndef _repr_series_one_line(x, helper):\n    n = len(x)\n    if n == 0:\n        return repr(x)\n    newlevel = helper.level - 1\n    pieces = []\n    maxparts = _repr_series_one_line.maxparts\n    for i in _sample_indices(n, maxparts):\n        k = x.index[i:i + 1].format(sparsify=False)[0]\n        v = x.iloc[i]\n        pieces.append('%s = %s' % (k, cheap_repr(v, newlevel)))\n    if n > maxparts + 2:\n        pieces.insert(maxparts // 2, '...')\n    return '; '.join(pieces)"
        ],
        [
            "STORE_NAME",
            "def is_interesting_expression(node):\n    # type: (ast.AST) -> bool\n    \"\"\"\n    If this expression has a value that may not be exactly what it looks like,\n    return True. Put differently, return False if this is just a literal.\n    \"\"\"\n    return (isinstance(node, ast.expr) and\n            not (isinstance(node, (ast.Num, ast.Str, getattr(ast, 'NameConstant', ()))) or\n                 isinstance(getattr(node, 'ctx', None),\n                            (ast.Store, ast.Del)) or\n                 (isinstance(node, ast.UnaryOp) and\n                  isinstance(node.op, (ast.UAdd, ast.USub)) and\n                  isinstance(node.operand, ast.Num)) or\n                 (isinstance(node, (ast.List, ast.Tuple, ast.Dict)) and\n                  not any(is_interesting_expression(n) for n in ast.iter_child_nodes(node)))))"
        ],
        [
            "STORE_NAME",
            "def is_obvious_builtin(node, value):\n    # type: (ast.expr, Any) -> bool\n    \"\"\"\n    Return True if this node looks like a builtin and it really is\n    (i.e. hasn't been shadowed).\n    \"\"\"\n    # noinspection PyUnresolvedReferences\n    builtins = cast(dict, __builtins__)\n    return ((isinstance(node, ast.Name) and\n             node.id in builtins and\n             builtins[node.id] is value) or\n            isinstance(node, getattr(ast, 'NameConstant', ())))"
        ],
        [
            "STORE_NAME",
            "\"\"\"\n    Decorate functions with an instance of this class to debug them,\n    or just use the existing instance `eye`.\n    \"\"\""
        ],
        [
            "STORE_NAME",
            "    def __init__(self, db_uri=None, num_samples=None):\n        \"\"\"\n        Set db_uri to specify where the database lives, as an alternative to\n        the environment variable BIRDSEYE_DB.\n        \"\"\"\n        super(BirdsEye, self).__init__()\n        self._db_uri = db_uri\n        self._code_infos = {}  # type: Dict[CodeType, CodeInfo]\n        self._last_call_id = None\n        self._ipython_cell_value = None\n        self.num_samples = num_samples or dict(\n            big=dict(\n                attributes=50,\n                dict=50,\n                list=30,\n                set=30,\n                pandas_rows=20,\n                pandas_cols=100,\n            ),\n            small=dict(\n                attributes=50,\n                dict=10,\n                list=6,\n                set=6,\n                pandas_rows=6,\n                pandas_cols=10,\n            ),\n        )"
        ],
        [
            "LOAD_NAME",
            "cached_property"
        ],
        [
            "CALL",
            "cached_property"
        ],
        [
            "STORE_NAME",
            "    @cached_property\n    def db(self):\n        return Database(self._db_uri)"
        ],
        [
            "STORE_NAME",
            "    def parse_extra(self, root, source, filename):\n        # type: (ast.Module, str, str) -> None\n        for node in ast.walk(root):  # type: ast.AST\n            node._loops = tracer.loops(node)\n            if isinstance(node, ast.expr):\n                node._is_interesting_expression = is_interesting_expression(node)"
        ],
        [
            "LOAD_NAME",
            "lru_cache"
        ],
        [
            "CALL",
            "lru_cache()"
        ],
        [
            "CALL",
            "lru_cache()"
        ],
        [
            "STORE_NAME",
            "    @lru_cache()\n    def compile(self, source, filename, flags=0):\n        traced_file = super(BirdsEye, self).compile(source, filename, flags)\n        traced_file.tokens = ASTTokens(source, tree=traced_file.root)\n        return traced_file"
        ],
        [
            "STORE_NAME",
            "    def before_stmt(self, node, frame):\n        # type: (ast.stmt, FrameType) -> None\n        if frame.f_code not in self._code_infos:\n            return\n        if isinstance(node.parent, ast.For) and node is node.parent.body[0]:\n            self._add_iteration(node._loops, frame)"
        ],
        [
            "STORE_NAME",
            "    def before_expr(self, node, frame):\n        if isinstance(node.parent, ast.While) and node is node.parent.test:\n            self._add_iteration(node._loops, frame)"
        ],
        [
            "STORE_NAME",
            "    def _add_iteration(self, loops, frame):\n        # type: (typing.Sequence[Loop], FrameType) -> None\n        \"\"\"\n        Given one or more nested loops, add an iteration for the innermost\n        loop (the last in the sequence).\n        \"\"\"\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for i, loop_node in enumerate(loops):\n            loop = iteration.loops[loop_node._tree_index]\n            if i == len(loops) - 1:\n                loop.append(Iteration())\n            else:\n                iteration = loop.last()"
        ],
        [
            "STORE_NAME",
            "    def after_expr(self, node, frame, value, exc_value, exc_tb):\n        # type: (ast.expr, FrameType, Any, Optional[BaseException], Optional[TracebackType]) -> Optional[ChangeValue]\n\n        if _tracing_recursively(frame):\n            return None\n\n        if frame.f_code not in self._code_infos:\n            return None\n\n        if node._is_interesting_expression:\n            # If this is an expression statement and the last statement\n            # in the body, the value is returned from the cell magic\n            # to be displayed as usual\n            if (self._code_infos[frame.f_code].traced_file.is_ipython_cell\n                    and isinstance(node.parent, ast.Expr)\n                    and node.parent is node.parent.parent.body[-1]):\n                self._ipython_cell_value = value\n\n            if is_obvious_builtin(node, self.stack[frame].expression_values[node]):\n                return None\n\n            frame_info = self.stack[frame]\n            if exc_value:\n                node_value = self._exception_value(node, frame, exc_value)\n            else:\n                node_value = NodeValue.expression(\n                    self.num_samples,\n                    value,\n                    level=max(1, 3 - len(node._loops) * (not self._is_first_loop_iteration(node, frame))),\n                )\n                self._set_node_value(node, frame, node_value)\n            self._check_inner_call(frame_info, node, node_value)\n\n        # i.e. is `node` the `y` in `[f(x) for x in y]`, making `node.parent` the `for x in y`\n        is_special_comprehension_iter = (\n                isinstance(node.parent, ast.comprehension) and\n                node is node.parent.iter and\n\n                # Generators execute in their own time and aren't directly attached to the parent frame\n                not isinstance(node.parent.parent, ast.GeneratorExp))\n\n        if not is_special_comprehension_iter:\n            return None\n\n        # Mark `for x in y` as a bit that executed, so it doesn't show as grey\n        self._set_node_value(node.parent, frame, NodeValue.covered())\n\n        if exc_value:\n            return None\n\n        # Track each iteration over `y` so that the 'loop' can be stepped through\n        loops = node._loops + (node.parent,)  # type: Tuple[Loop, ...]\n\n        def comprehension_iter_proxy():\n            for item in value:\n                self._add_iteration(loops, frame)\n                yield item\n\n        # This effectively changes to code to `for x in comprehension_iter_proxy()`\n        return ChangeValue(comprehension_iter_proxy())"
        ],
        [
            "STORE_NAME",
            "    def _check_inner_call(self, frame_info, node, node_value):\n        # type: (FrameInfo, Union[ast.stmt, ast.expr], NodeValue) -> None\n        inner_calls = frame_info.inner_calls.pop(node, None)\n        if inner_calls:\n            node_value.set_meta('inner_calls', inner_calls)"
        ],
        [
            "STORE_NAME",
            "    def _is_first_loop_iteration(self, node, frame):\n        # type: (ast.AST, FrameType) -> bool\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for loop_node in node._loops:  # type: ast.AST\n            loop = iteration.loops[loop_node._tree_index]\n            iteration = loop.last()\n            if iteration.index > 0:\n                return False\n        return True"
        ],
        [
            "STORE_NAME",
            "    def _set_node_value(self, node, frame, value):\n        # type: (ast.AST, FrameType, NodeValue) -> None\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for loop_node in node._loops:  # type: ast.AST\n            loop = iteration.loops[loop_node._tree_index]\n            loop.recorded_node(node)\n            iteration = loop.last()\n        iteration.vals[node._tree_index] = value"
        ],
        [
            "STORE_NAME",
            "    def _exception_value(self, node, frame, exc_value):\n        # type: (Union[ast.expr, ast.stmt], FrameType, BaseException) -> NodeValue\n        value = NodeValue.exception(exc_value)\n        self._set_node_value(node, frame, value)\n        return value"
        ],
        [
            "STORE_NAME",
            "    def after_stmt(self, node, frame, exc_value, exc_traceback, exc_node):\n        # type: (ast.stmt, FrameType, Optional[BaseException], Optional[TracebackType], Optional[ast.AST]) -> Optional[bool]\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return None\n        if exc_value and node is exc_node:\n            value = self._exception_value(node, frame, exc_value)\n        else:\n            value = NodeValue.covered()\n            self._set_node_value(node, frame, value)\n        self._check_inner_call(self.stack[frame], node, value)\n        return None"
        ],
        [
            "STORE_NAME",
            "    def enter_call(self, enter_info):\n        # type: (EnterCallInfo) -> None\n        frame = enter_info.current_frame  # type: FrameType\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return\n        frame_info = self.stack[frame]\n        frame_info.start_time = get_unfrozen_datetime()\n        frame_info.iteration = Iteration()\n\n        code_info = self._code_infos[frame.f_code]\n        if isinstance(enter_info.enter_node.parent, ast.Module):\n            arguments = []\n        else:\n            f_locals = frame.f_locals.copy()  # type: Dict[str, Any]\n            arguments = [(name, f_locals.pop(name))\n                         for name in code_info.arg_names\n                         if name] + [\n\n                            # Local variables other than actual arguments. These are variables from\n                            # the enclosing scope. It's handy to treat them like arguments in the UI\n                            it for it in f_locals.items()\n                            if it[0][0] != '.'  # Appears when using nested tuple arguments\n                        ]\n        frame_info.arguments = json.dumps([[k, cheap_repr(v)] for k, v in arguments])\n        frame_info.call_id = self._call_id()\n        frame_info.inner_calls = defaultdict(list)\n        prev = self.stack.get(enter_info.caller_frame)\n        if prev:\n            inner_calls = getattr(prev, 'inner_calls', None)\n            if inner_calls is not None:\n                inner_calls[enter_info.call_node].append(frame_info.call_id)"
        ],
        [
            "STORE_NAME",
            "    def _call_id(self):\n        # type: () -> Text\n        return uuid4().hex"
        ],
        [
            "STORE_NAME",
            "    def exit_call(self, exit_info):\n        # type: (ExitCallInfo) -> None\n        \"\"\"\n        This is where all the data collected during the call is gathered up\n        and sent to the database.\n        \"\"\"\n        frame = exit_info.current_frame  # type: FrameType\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return\n        frame_info = self.stack[frame]\n\n        top_iteration = frame_info.iteration  # type: Iteration\n        node_values = _deep_dict()\n        self._extract_node_values(top_iteration, (), node_values)\n\n        db_func = self._code_infos[frame.f_code].db_func\n        exc = exit_info.exc_value  # type: Optional[Exception]\n        if exc:\n            traceback_str = ''.join(traceback.format_exception(type(exc), exc, exit_info.exc_tb))\n            exception = exception_string(exc)\n        else:\n            traceback_str = exception = None\n\n        @retry_db\n        def add_call():\n            Call = self.db.Call\n            call = Call(id=frame_info.call_id,\n                        function_id=db_func,\n                        arguments=frame_info.arguments,\n                        return_value=cheap_repr(exit_info.return_value),\n                        exception=exception,\n                        traceback=traceback_str,\n                        data=json.dumps(\n                            dict(\n                                node_values=node_values,\n                                loop_iterations=top_iteration.extract_iterations()['loops'],\n                                type_names=type_registry.names(),\n                                num_special_types=type_registry.num_special_types,\n                            ),\n                            cls=ProtocolEncoder,\n                            separators=(',', ':')\n                        ),\n                        start_time=frame_info.start_time)\n            with self.db.session_scope() as session:\n                session.add(call)\n\n        add_call()\n\n        self._last_call_id = frame_info.call_id"
        ],
        [
            "STORE_NAME",
            "    def _extract_node_values(self, iteration, path, node_values):\n        # type: (Iteration, Tuple[int, ...], dict) -> None\n        \"\"\"\n        Populates node_values with values inside iteration.\n        \"\"\"\n        # Each element of `path` is an index of a loop iteration\n        # e.g. given the nested loops:\n        #\n        # for i in [0, 1, 2]:\n        #     for j in [0, 1, 2, 3]:\n        #\n        # path may be (i, j) for each of the iterations\n        for tree_index, node_value in iteration.vals.items():\n\n            # So this `full_path` is a tuple of ints, but the first\n            # int has a different meaning from the others\n            full_path = (tree_index,) + path\n\n            # Given a path (a, b, c) we're making node_values 'contain'\n            # this structure:\n            # {a: {b: {c: node_value}}}\n            d = node_values\n            for path_k in full_path[:-1]:\n                d = d[path_k]\n            d[full_path[-1]] = node_value\n\n        for loop in iteration.loops.values():\n            for i, iteration in enumerate(loop):\n                self._extract_node_values(iteration, path + (i,), node_values)"
        ],
        [
            "STORE_NAME",
            "    def trace_function(self, func):\n        # type: (FunctionType) -> FunctionType\n        new_func = super(BirdsEye, self).trace_function(func)\n        code_info = self._code_infos.get(new_func.__code__)\n        if code_info:\n            return new_func\n\n        lines, start_lineno = inspect.getsourcelines(func)  # type: List[Text], int\n        end_lineno = start_lineno + len(lines)\n        name = safe_qualname(func)\n        source_file = inspect.getsourcefile(func)\n        if source_file.startswith('<ipython-input'):\n            filename = IPYTHON_FILE_PATH\n        else:\n            filename = os.path.abspath(source_file)\n        traced_file = new_func.traced_file\n\n        arg_info = inspect.getargs(new_func.__code__)\n        arg_names = list(chain(flatten_list(arg_info[0]), arg_info[1:]))  # type: List[str]\n        self._trace(name, filename, traced_file, new_func.__code__, typ='function',\n                    start_lineno=start_lineno, end_lineno=end_lineno,\n                    arg_names=arg_names)\n\n        return new_func"
        ],
        [
            "STORE_NAME",
            "    def exec_ipython_cell(self, source, callback):\n        from IPython import get_ipython\n        shell = get_ipython()\n        filename = name = shell.compile.cache(source)\n        flags = shell.compile.flags\n\n        traced_file = self.compile(source, filename, flags)\n        traced_file.is_ipython_cell = True\n\n        for node in traced_file.root.body:\n            if is_future_import(node):\n                raise ValueError('from __future__ import ... statements '\n                                 'are not allowed in cells traced with %%eye')\n\n        shell.user_global_ns.update(self._trace_methods_dict(traced_file))\n\n        self._trace(name, filename, traced_file, traced_file.code, 'module', source)\n\n        try:\n            shell.ex(traced_file.code)\n            return self._ipython_cell_value\n        finally:\n            callback(self._last_call_id)\n            self._ipython_cell_value = None"
        ],
        [
            "STORE_NAME",
            "    def trace_this_module(self, context=0, deep=False):\n        frame = inspect.currentframe()\n\n        filename = None\n        while context >= 0:\n            frame = frame.f_back\n            filename = inspect.getsourcefile(frame)\n            if filename is not None:\n                context -= 1\n        filename = os.path.abspath(filename)\n\n        if frame.f_globals.get('__name__') != '__main__':\n            if PY3 and self._treetrace_hidden_with_stmt.__name__ not in frame.f_globals:\n                raise RuntimeError(\n                    'To trace an imported module, you must import birdseye before '\n                    'importing that module.')\n            return\n\n        lines = read_source_file(filename).splitlines()\n        lines[:frame.f_lineno] = [''] * frame.f_lineno\n        source = '\\n'.join(lines)\n        self.exec_string(source, filename, frame.f_globals, frame.f_locals, deep)\n        sys.exit(0)"
        ],
        [
            "STORE_NAME",
            "    def exec_string(self, source, filename, globs=None, locs=None, deep=False):\n        globs = globs or {}\n        locs = locs or {}\n\n        traced_file = self.compile(source, filename)\n\n        globs.update(self._trace_methods_dict(traced_file))\n\n        self._trace(FILE_SENTINEL_NAME, filename, traced_file, traced_file.code, 'module', source)\n\n        if deep:\n            nodes_by_lineno = {\n                node.lineno: node\n                for node in traced_file.nodes\n                if isinstance(node, ast.FunctionDef)\n            }\n\n            def find_code(root_code):\n                # type: (CodeType) -> None\n                for code in root_code.co_consts:  # type: CodeType\n                    if not inspect.iscode(code) or code.co_name.startswith('<'):\n                        continue\n\n                    find_code(code)\n\n                    lineno = code.co_firstlineno\n                    node = nodes_by_lineno.get(lineno)\n                    if not node:\n                        continue\n\n                    self._trace(\n                        code.co_name, filename, traced_file, code,\n                        typ='function',\n                        source=source,\n                        start_lineno=lineno,\n                        end_lineno=node.last_token.end[0] + 1,\n                    )\n\n            find_code(traced_file.code)\n\n        exec(traced_file.code, globs, locs)"
        ],
        [
            "STORE_NAME",
            "    def _trace(\n            self,\n            name,\n            filename,\n            traced_file,\n            code,\n            typ,\n            source='',\n            start_lineno=1,\n            end_lineno=None,\n            arg_names=(),\n    ):\n        if not end_lineno:\n            end_lineno = start_lineno + len(source.splitlines())\n        nodes = list(self._nodes_of_interest(traced_file, start_lineno, end_lineno))\n        html_body = self._nodes_html(nodes, start_lineno, end_lineno, traced_file)\n\n        data_dict = dict(\n            # This maps each node to the loops enclosing that node\n            node_loops={\n                node._tree_index: [n._tree_index for n in node._loops]\n                for node, _ in nodes\n                if node._loops\n            },\n        )\n        if typ == 'function':\n            tokens = traced_file.tokens\n            func_node = only(node\n                             for node, _ in nodes\n                             if isinstance(node, ast.FunctionDef)\n                             and node.first_token.start[0] == start_lineno)\n            func_startpos, source = source_without_decorators(tokens, func_node)\n            # These are for the PyCharm plugin\n            data_dict.update(\n                node_ranges=list(self._node_ranges(nodes, tokens, func_startpos)),\n                loop_ranges=list(self._loop_ranges(nodes, tokens, func_startpos)),\n            )\n\n        data = json.dumps(data_dict, sort_keys=True)\n        db_func = self._db_func(data, filename, html_body, name, start_lineno, source, typ)\n        self._code_infos[code] = CodeInfo(db_func, traced_file, arg_names)"
        ],
        [
            "STORE_NAME",
            "    def _loop_ranges(self, nodes, tokens, func_start):\n        # For a for loop, e.g.\n        #\n        #     for x in y:\n        #\n        # this yields the range of the target 'x'.\n        #\n        # For a while loop, e.g.\n        #\n        #     while x < 10:\n        #\n        # this yields the range of the condition 'x < 10'.\n        for node, (classes, _, __) in nodes:\n            if 'loop' not in classes:\n                continue\n\n            try:\n                target = node.target  # for loop\n            except AttributeError:\n                target = node.test  # while loop\n\n            start, end = tokens.get_text_range(target)\n            start -= func_start\n            end -= func_start\n\n            yield dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end\n            )"
        ],
        [
            "STORE_NAME",
            "    def _node_ranges(self, nodes, tokens, func_start):\n        for node, (classes, _, __) in nodes:\n            start, end = tokens.get_text_range(node)\n            start -= func_start\n            end -= func_start\n\n            if start < 0:\n                assert (end < 0  # nodes before the def, i.e. decorators\n                        or isinstance(node, ast.FunctionDef))\n                continue\n\n            yield dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end,\n                depth=node._depth,\n                classes=classes,\n            )"
        ],
        [
            "LOAD_NAME",
            "retry_db"
        ],
        [
            "CALL",
            "retry_db"
        ],
        [
            "STORE_NAME",
            "    @retry_db\n    def _db_func(self, data, filename, html_body, name, start_lineno, source, typ):\n        \"\"\"\n        Retrieve the Function object from the database if one exists, or create one.\n        \"\"\"\n\n        def h(s):\n            return hashlib.sha256(s.encode('utf8')).hexdigest()\n\n        function_hash = h(filename + name + html_body + data + str(start_lineno))\n\n        Function = self.db.Function\n\n        with self.db.session_scope() as session:\n            db_func = one_or_none(session.query(Function).filter_by(hash=function_hash))  # type: Optional[Function]\n            if not db_func:\n                db_func = Function(file=filename,\n                                   name=name,\n                                   type=typ,\n                                   html_body=html_body,\n                                   lineno=start_lineno,\n                                   data=data,\n                                   body_hash=h(source),\n                                   hash=function_hash)\n                session.add(db_func)\n                session.commit()  # ensure .id exists\n            assert isinstance(db_func.id, int)\n            return db_func.id"
        ],
        [
            "STORE_NAME",
            "    def _nodes_of_interest(self, traced_file, start_lineno, end_lineno):\n        # type: (TracedFile, int, int) -> Iterator[Tuple[ast.AST, Tuple]]\n        \"\"\"\n        Nodes that may have a value, show up as a box in the UI, and lie within the\n        given line range.\n        \"\"\"\n        for node in traced_file.nodes:\n            classes = []\n\n            if (isinstance(node, (ast.While, ast.For, ast.comprehension)) and\n                    not isinstance(node.parent, ast.GeneratorExp)):\n                classes.append('loop')\n            if isinstance(node, ast.stmt):\n                classes.append('stmt')\n\n            if isinstance(node, ast.expr):\n                if not node._is_interesting_expression:\n                    continue\n            elif not classes:\n                continue\n\n            assert isinstance(node, ast.AST)\n\n            # In particular FormattedValue is missing this\n            if not hasattr(node, 'first_token'):\n                continue\n\n            if not start_lineno <= node.first_token.start[0] <= end_lineno:\n                continue\n\n            start, end = traced_file.tokens.get_text_range(node)  # type: int, int\n            if start == end == 0:\n                continue\n\n            yield node, (classes, start, end)"
        ],
        [
            "STORE_NAME",
            "    def _nodes_html(self, nodes, start_lineno, end_lineno, traced_file):\n        # type: (list, int, int, TracedFile) -> str\n        \"\"\"\n        The algorithm for generating the HTML works as follows. We generate a list\n        of HTMLPositions, which are essentially places to insert HTML into the source plus some\n        metadata. The order of the fields of HTMLPosition ensure that when the list is sorted,\n        the resulting HTML is valid and correct. Specifically, the fields are:\n        \n          1. index: the index in the source string where the HTML would be inserted\n          2. is_start: Indicates if this piece of HTML is the start of a tag, rather than the end.\n             Ends should appear first, so that the resulting HTML looks like:\n                <span> ... </span><span> ... </span>\n             rather than:\n                <span> ... <span></span> ... </span>\n             (I think this might actually be unnecessary, since I can't think of any cases of two\n              expressions right next to each other with nothing in between)\n          3. depth: the depth of the corresponding node in the AST. We want the start of a tag from\n             a node to appear before the start of a tag nested within, e.g. `foo()` should become:\n                <span [for foo()]><span [for foo]>foo</span>()</span>\n             rather than:   \n                <span [for foo]><span [for foo()]>foo</span>()</span>\n          4. html: the actual HTML to insert. Not important for ordering.\n          \n        Mostly the list contains pairs of HTMLPositions corresponding to AST nodes, one for the\n        start and one for the end.\n        \n        After the list is sorted, the HTML generated is essentially:\n        \n        source[0:positions[0].index] + positions[0].html + source[positions[0].index:positions[1].index] + positions[1].html + ...\n        \"\"\"\n\n        traced_file.root._depth = 0\n        for node in ast.walk(traced_file.root):  # type: ast.AST\n            for child in ast.iter_child_nodes(node):\n                child._depth = node._depth + 1\n\n        positions = []  # type: List[HTMLPosition]\n\n        for node, (classes, start, end) in nodes:\n            # noinspection PyArgumentList\n            positions.extend(map(\n                HTMLPosition,\n                [start, end],\n                [True, False],  # is_start\n                [node._depth, node._depth],\n                ['<span data-index=\"%s\" class=\"%s\">' % (node._tree_index, ' '.join(classes)),\n                 '</span>']))\n\n        end_lineno = self._separate_comprehensions(\n            [n[0] for n in nodes],\n            end_lineno, positions, traced_file)\n\n        # This just makes the loop below simpler\n        positions.append(HTMLPosition(len(traced_file.source), False, 0, ''))\n\n        positions.sort()\n\n        html_parts = []\n        start = 0\n        for position in positions:\n            html_parts.append(html.escape(traced_file.source[start:position.index]))\n            html_parts.append(position.html)\n            start = position.index\n        html_body = ''.join(html_parts)\n        html_body = '\\n'.join(html_body.split('\\n')[start_lineno - 1:end_lineno - 1])\n\n        return html_body.strip('\\n')"
        ],
        [
            "STORE_NAME",
            "    def _separate_comprehensions(self, nodes, end_lineno, positions, traced_file):\n        # type: (list, int, List[HTMLPosition], TracedFile) -> int\n        \"\"\"\n        Comprehensions (e.g. list comprehensions) are troublesome because they can\n        be navigated like loops, and the buttons for these need to be on separate lines.\n        This function inserts newlines to turn:\n\n        [x + y for x in range(3) for y in range(5)] and\n        [[x + y for x in range(3)] for y in range(5)]\n\n        into\n\n        [x + y for x in range(3)\n         for y in range(5)] and\n        [[x + y for x in range(3)]\n         for y in range(5)]\n        \"\"\"\n\n        comprehensions = group_by_key_func(of_type((ast.comprehension, ast.While, ast.For), nodes),\n                                           lambda c: c.first_token.start[0]\n                                           )  # type: Dict[Any, Iterable[ast.comprehension]]\n\n        def get_start(n):\n            # type: (ast.AST) -> int\n            return traced_file.tokens.get_text_range(n)[0]\n\n        for comp_list in comprehensions.values():\n            prev_start = None  # type: Optional[int]\n            for comp in sorted(comp_list, key=lambda c: c.first_token.startpos):\n                if isinstance(comp, ast.comprehension) and comp is comp.parent.generators[0]:\n                    start = get_start(comp.parent)\n                    if prev_start is not None and start < prev_start:\n                        start = get_start(comp)\n                else:\n                    start = get_start(comp)\n                if prev_start is not None:\n                    positions.append(HTMLPosition(start, True, 0, '\\n '))\n                    end_lineno += 1\n                prev_start = start\n\n        return end_lineno"
        ],
        [
            "STORE_NAME",
            "    def _separate_comprehensions(self, nodes, end_lineno, positions, traced_file):\n        # type: (list, int, List[HTMLPosition], TracedFile) -> int\n        \"\"\"\n        Comprehensions (e.g. list comprehensions) are troublesome because they can\n        be navigated like loops, and the buttons for these need to be on separate lines.\n        This function inserts newlines to turn:\n\n        [x + y for x in range(3) for y in range(5)] and\n        [[x + y for x in range(3)] for y in range(5)]\n\n        into\n\n        [x + y for x in range(3)\n         for y in range(5)] and\n        [[x + y for x in range(3)]\n         for y in range(5)]\n        \"\"\"\n\n        comprehensions = group_by_key_func(of_type((ast.comprehension, ast.While, ast.For), nodes),\n                                           lambda c: c.first_token.start[0]\n                                           )  # type: Dict[Any, Iterable[ast.comprehension]]\n\n        def get_start(n):\n            # type: (ast.AST) -> int\n            return traced_file.tokens.get_text_range(n)[0]\n\n        for comp_list in comprehensions.values():\n            prev_start = None  # type: Optional[int]\n            for comp in sorted(comp_list, key=lambda c: c.first_token.startpos):\n                if isinstance(comp, ast.comprehension) and comp is comp.parent.generators[0]:\n                    start = get_start(comp.parent)\n                    if prev_start is not None and start < prev_start:\n                        start = get_start(comp)\n                else:\n                    start = get_start(comp)\n                if prev_start is not None:\n                    positions.append(HTMLPosition(start, True, 0, '\\n '))\n                    end_lineno += 1\n                prev_start = start\n\n        return end_lineno"
        ],
        [
            "LOAD_GLOBAL",
            "super"
        ],
        [
            "LOAD_GLOBAL",
            "BirdsEye"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "super(BirdsEye, self)"
        ],
        [
            "LOAD_METHOD",
            "super(BirdsEye, self).__init__"
        ],
        [
            "CALL",
            "super(BirdsEye, self).__init__()"
        ],
        [
            "LOAD_FAST",
            "db_uri"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._db_uri"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._code_infos"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._last_call_id"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._ipython_cell_value"
        ],
        [
            "LOAD_FAST",
            "num_samples"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "CALL",
            "dict(\n                attributes=50,\n                dict=50,\n                list=30,\n                set=30,\n                pandas_rows=20,\n                pandas_cols=100,\n            )"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "CALL",
            "dict(\n                attributes=50,\n                dict=10,\n                list=6,\n                set=6,\n                pandas_rows=6,\n                pandas_cols=10,\n            )"
        ],
        [
            "CALL",
            "dict(\n            big=dict(\n                attributes=50,\n                dict=50,\n                list=30,\n                set=30,\n                pandas_rows=20,\n                pandas_cols=100,\n            ),\n            small=dict(\n                attributes=50,\n                dict=10,\n                list=6,\n                set=6,\n                pandas_rows=6,\n                pandas_cols=10,\n            ),\n        )"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.num_samples"
        ],
        [
            "LOAD_GLOBAL",
            "Database"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._db_uri"
        ],
        [
            "CALL",
            "Database(self._db_uri)"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.walk"
        ],
        [
            "LOAD_FAST",
            "root"
        ],
        [
            "CALL",
            "ast.walk(root)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "tracer"
        ],
        [
            "LOAD_ATTR",
            "tracer.loops"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "tracer.loops(node)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "STORE_ATTR",
            "node._loops"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.expr"
        ],
        [
            "CALL",
            "isinstance(node, ast.expr)"
        ],
        [
            "LOAD_GLOBAL",
            "is_interesting_expression"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "is_interesting_expression(node)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "STORE_ATTR",
            "node._is_interesting_expression"
        ],
        [
            "LOAD_GLOBAL",
            "super"
        ],
        [
            "LOAD_GLOBAL",
            "BirdsEye"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "super(BirdsEye, self)"
        ],
        [
            "LOAD_METHOD",
            "super(BirdsEye, self).compile"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "flags"
        ],
        [
            "CALL",
            "super(BirdsEye, self).compile(source, filename, flags)"
        ],
        [
            "STORE_FAST",
            "traced_file"
        ],
        [
            "LOAD_GLOBAL",
            "ASTTokens"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.root"
        ],
        [
            "CALL",
            "ASTTokens(source, tree=traced_file.root)"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "STORE_ATTR",
            "traced_file.tokens"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code not in self._code_infos"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.For"
        ],
        [
            "CALL",
            "isinstance(node.parent, ast.For)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_ATTR",
            "node.parent.body"
        ],
        [
            "BINARY_SUBSCR",
            "node.parent.body[0]"
        ],
        [
            "IS_OP",
            "node is node.parent.body[0]"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._add_iteration"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._loops"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "self._add_iteration(node._loops, frame)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.While"
        ],
        [
            "CALL",
            "isinstance(node.parent, ast.While)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_ATTR",
            "node.parent.test"
        ],
        [
            "IS_OP",
            "node is node.parent.test"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._add_iteration"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._loops"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "self._add_iteration(node._loops, frame)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "LOAD_ATTR",
            "self.stack[frame].iteration"
        ],
        [
            "STORE_FAST",
            "iteration"
        ],
        [
            "LOAD_GLOBAL",
            "enumerate"
        ],
        [
            "LOAD_FAST",
            "loops"
        ],
        [
            "CALL",
            "enumerate(loops)"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "STORE_FAST",
            "loop_node"
        ],
        [
            "LOAD_FAST",
            "iteration"
        ],
        [
            "LOAD_ATTR",
            "iteration.loops"
        ],
        [
            "LOAD_FAST",
            "loop_node"
        ],
        [
            "LOAD_ATTR",
            "loop_node._tree_index"
        ],
        [
            "BINARY_SUBSCR",
            "iteration.loops[loop_node._tree_index]"
        ],
        [
            "STORE_FAST",
            "loop"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "loops"
        ],
        [
            "CALL",
            "len(loops)"
        ],
        [
            "BINARY_OP",
            "len(loops) - 1"
        ],
        [
            "COMPARE_OP",
            "i == len(loops) - 1"
        ],
        [
            "LOAD_FAST",
            "loop"
        ],
        [
            "LOAD_METHOD",
            "loop.append"
        ],
        [
            "LOAD_GLOBAL",
            "Iteration"
        ],
        [
            "CALL",
            "Iteration()"
        ],
        [
            "CALL",
            "loop.append(Iteration())"
        ],
        [
            "LOAD_FAST",
            "loop"
        ],
        [
            "LOAD_METHOD",
            "loop.last"
        ],
        [
            "CALL",
            "loop.last()"
        ],
        [
            "STORE_FAST",
            "iteration"
        ],
        [
            "LOAD_GLOBAL",
            "_tracing_recursively"
        ],
        [
            "LOAD_DEREF",
            "frame"
        ],
        [
            "CALL",
            "_tracing_recursively(frame)"
        ],
        [
            "LOAD_DEREF",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code not in self._code_infos"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._is_interesting_expression"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "LOAD_DEREF",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "BINARY_SUBSCR",
            "self._code_infos[frame.f_code]"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos[frame.f_code].traced_file"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos[frame.f_code].traced_file.is_ipython_cell"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Expr"
        ],
        [
            "CALL",
            "isinstance(node.parent, ast.Expr)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_ATTR",
            "node.parent.parent"
        ],
        [
            "LOAD_ATTR",
            "node.parent.parent.body"
        ],
        [
            "BINARY_SUBSCR",
            "node.parent.parent.body[-1]"
        ],
        [
            "IS_OP",
            "node.parent is node.parent.parent.body[-1]"
        ],
        [
            "LOAD_DEREF",
            "value"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._ipython_cell_value"
        ],
        [
            "LOAD_GLOBAL",
            "is_obvious_builtin"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_DEREF",
            "frame"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "LOAD_ATTR",
            "self.stack[frame].expression_values"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame].expression_values[node]"
        ],
        [
            "CALL",
            "is_obvious_builtin(node, self.stack[frame].expression_values[node])"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_DEREF",
            "frame"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "STORE_FAST",
            "frame_info"
        ],
        [
            "LOAD_FAST",
            "exc_value"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._exception_value"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_DEREF",
            "frame"
        ],
        [
            "LOAD_FAST",
            "exc_value"
        ],
        [
            "CALL",
            "self._exception_value(node, frame, exc_value)"
        ],
        [
            "STORE_FAST",
            "node_value"
        ],
        [
            "LOAD_GLOBAL",
            "NodeValue"
        ],
        [
            "LOAD_METHOD",
            "NodeValue.expression"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.num_samples"
        ],
        [
            "LOAD_DEREF",
            "value"
        ],
        [
            "LOAD_GLOBAL",
            "max"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._loops"
        ],
        [
            "CALL",
            "len(node._loops)"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._is_first_loop_iteration"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_DEREF",
            "frame"
        ],
        [
            "CALL",
            "self._is_first_loop_iteration(node, frame)"
        ],
        [
            "UNARY_NOT",
            "not self._is_first_loop_iteration(node, frame)"
        ],
        [
            "BINARY_OP",
            "len(node._loops) * (not self._is_first_loop_iteration(node, frame))"
        ],
        [
            "BINARY_OP",
            "3 - len(node._loops) * (not self._is_first_loop_iteration(node, frame))"
        ],
        [
            "CALL",
            "max(1, 3 - len(node._loops) * (not self._is_first_loop_iteration(node, frame)))"
        ],
        [
            "CALL",
            "NodeValue.expression(\n                    self.num_samples,\n                    value,\n                    level=max(1, 3 - len(node._loops) * (not self._is_first_loop_iteration(node, frame))),\n                )"
        ],
        [
            "STORE_FAST",
            "node_value"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._set_node_value"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_DEREF",
            "frame"
        ],
        [
            "LOAD_FAST",
            "node_value"
        ],
        [
            "CALL",
            "self._set_node_value(node, frame, node_value)"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._check_inner_call"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "node_value"
        ],
        [
            "CALL",
            "self._check_inner_call(frame_info, node, node_value)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.comprehension"
        ],
        [
            "CALL",
            "isinstance(node.parent, ast.comprehension)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_ATTR",
            "node.parent.iter"
        ],
        [
            "IS_OP",
            "node is node.parent.iter"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_ATTR",
            "node.parent.parent"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.GeneratorExp"
        ],
        [
            "CALL",
            "isinstance(node.parent.parent, ast.GeneratorExp)"
        ],
        [
            "UNARY_NOT",
            "not isinstance(node.parent.parent, ast.GeneratorExp)"
        ],
        [
            "STORE_FAST",
            "is_special_comprehension_iter"
        ],
        [
            "LOAD_FAST",
            "is_special_comprehension_iter"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._set_node_value"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_DEREF",
            "frame"
        ],
        [
            "LOAD_GLOBAL",
            "NodeValue"
        ],
        [
            "LOAD_METHOD",
            "NodeValue.covered"
        ],
        [
            "CALL",
            "NodeValue.covered()"
        ],
        [
            "CALL",
            "self._set_node_value(node.parent, frame, NodeValue.covered())"
        ],
        [
            "LOAD_FAST",
            "exc_value"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._loops"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "BINARY_OP",
            "node._loops + (node.parent,)"
        ],
        [
            "STORE_DEREF",
            "loops"
        ],
        [
            "STORE_FAST",
            "        def comprehension_iter_proxy():\n            for item in value:\n                self._add_iteration(loops, frame)\n                yield item"
        ],
        [
            "LOAD_GLOBAL",
            "ChangeValue"
        ],
        [
            "LOAD_FAST",
            "comprehension_iter_proxy"
        ],
        [
            "CALL",
            "comprehension_iter_proxy()"
        ],
        [
            "CALL",
            "ChangeValue(comprehension_iter_proxy())"
        ],
        [
            "LOAD_DEREF",
            "value"
        ],
        [
            "STORE_FAST",
            "item"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._add_iteration"
        ],
        [
            "LOAD_DEREF",
            "loops"
        ],
        [
            "LOAD_DEREF",
            "frame"
        ],
        [
            "CALL",
            "self._add_iteration(loops, frame)"
        ],
        [
            "LOAD_FAST",
            "item"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.inner_calls"
        ],
        [
            "LOAD_METHOD",
            "frame_info.inner_calls.pop"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "frame_info.inner_calls.pop(node, None)"
        ],
        [
            "STORE_FAST",
            "inner_calls"
        ],
        [
            "LOAD_FAST",
            "inner_calls"
        ],
        [
            "LOAD_FAST",
            "node_value"
        ],
        [
            "LOAD_METHOD",
            "node_value.set_meta"
        ],
        [
            "LOAD_FAST",
            "inner_calls"
        ],
        [
            "CALL",
            "node_value.set_meta('inner_calls', inner_calls)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "LOAD_ATTR",
            "self.stack[frame].iteration"
        ],
        [
            "STORE_FAST",
            "iteration"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._loops"
        ],
        [
            "STORE_FAST",
            "loop_node"
        ],
        [
            "LOAD_FAST",
            "iteration"
        ],
        [
            "LOAD_ATTR",
            "iteration.loops"
        ],
        [
            "LOAD_FAST",
            "loop_node"
        ],
        [
            "LOAD_ATTR",
            "loop_node._tree_index"
        ],
        [
            "BINARY_SUBSCR",
            "iteration.loops[loop_node._tree_index]"
        ],
        [
            "STORE_FAST",
            "loop"
        ],
        [
            "LOAD_FAST",
            "loop"
        ],
        [
            "LOAD_METHOD",
            "loop.last"
        ],
        [
            "CALL",
            "loop.last()"
        ],
        [
            "STORE_FAST",
            "iteration"
        ],
        [
            "LOAD_FAST",
            "iteration"
        ],
        [
            "LOAD_ATTR",
            "iteration.index"
        ],
        [
            "COMPARE_OP",
            "iteration.index > 0"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "LOAD_ATTR",
            "self.stack[frame].iteration"
        ],
        [
            "STORE_FAST",
            "iteration"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._loops"
        ],
        [
            "STORE_FAST",
            "loop_node"
        ],
        [
            "LOAD_FAST",
            "iteration"
        ],
        [
            "LOAD_ATTR",
            "iteration.loops"
        ],
        [
            "LOAD_FAST",
            "loop_node"
        ],
        [
            "LOAD_ATTR",
            "loop_node._tree_index"
        ],
        [
            "BINARY_SUBSCR",
            "iteration.loops[loop_node._tree_index]"
        ],
        [
            "STORE_FAST",
            "loop"
        ],
        [
            "LOAD_FAST",
            "loop"
        ],
        [
            "LOAD_METHOD",
            "loop.recorded_node"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "loop.recorded_node(node)"
        ],
        [
            "LOAD_FAST",
            "loop"
        ],
        [
            "LOAD_METHOD",
            "loop.last"
        ],
        [
            "CALL",
            "loop.last()"
        ],
        [
            "STORE_FAST",
            "iteration"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "iteration"
        ],
        [
            "LOAD_ATTR",
            "iteration.vals"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._tree_index"
        ],
        [
            "STORE_SUBSCR",
            "iteration.vals[node._tree_index]"
        ],
        [
            "LOAD_GLOBAL",
            "NodeValue"
        ],
        [
            "LOAD_METHOD",
            "NodeValue.exception"
        ],
        [
            "LOAD_FAST",
            "exc_value"
        ],
        [
            "CALL",
            "NodeValue.exception(exc_value)"
        ],
        [
            "STORE_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._set_node_value"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "CALL",
            "self._set_node_value(node, frame, value)"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code not in self._code_infos"
        ],
        [
            "LOAD_GLOBAL",
            "_tracing_recursively"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "_tracing_recursively(frame)"
        ],
        [
            "LOAD_FAST",
            "exc_value"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "exc_node"
        ],
        [
            "IS_OP",
            "node is exc_node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._exception_value"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "exc_value"
        ],
        [
            "CALL",
            "self._exception_value(node, frame, exc_value)"
        ],
        [
            "STORE_FAST",
            "value"
        ],
        [
            "LOAD_GLOBAL",
            "NodeValue"
        ],
        [
            "LOAD_METHOD",
            "NodeValue.covered"
        ],
        [
            "CALL",
            "NodeValue.covered()"
        ],
        [
            "STORE_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._set_node_value"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "CALL",
            "self._set_node_value(node, frame, value)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._check_inner_call"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "CALL",
            "self._check_inner_call(self.stack[frame], node, value)"
        ],
        [
            "LOAD_FAST",
            "enter_info"
        ],
        [
            "LOAD_ATTR",
            "enter_info.current_frame"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code not in self._code_infos"
        ],
        [
            "LOAD_GLOBAL",
            "_tracing_recursively"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "_tracing_recursively(frame)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "STORE_FAST",
            "frame_info"
        ],
        [
            "LOAD_GLOBAL",
            "get_unfrozen_datetime"
        ],
        [
            "CALL",
            "get_unfrozen_datetime()"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "STORE_ATTR",
            "frame_info.start_time"
        ],
        [
            "LOAD_GLOBAL",
            "Iteration"
        ],
        [
            "CALL",
            "Iteration()"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "STORE_ATTR",
            "frame_info.iteration"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "BINARY_SUBSCR",
            "self._code_infos[frame.f_code]"
        ],
        [
            "STORE_FAST",
            "code_info"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "enter_info"
        ],
        [
            "LOAD_ATTR",
            "enter_info.enter_node"
        ],
        [
            "LOAD_ATTR",
            "enter_info.enter_node.parent"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Module"
        ],
        [
            "CALL",
            "isinstance(enter_info.enter_node.parent, ast.Module)"
        ],
        [
            "STORE_FAST",
            "arguments"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_locals"
        ],
        [
            "LOAD_METHOD",
            "frame.f_locals.copy"
        ],
        [
            "CALL",
            "frame.f_locals.copy()"
        ],
        [
            "STORE_DEREF",
            "f_locals"
        ],
        [
            "LOAD_FAST",
            "code_info"
        ],
        [
            "LOAD_ATTR",
            "code_info.arg_names"
        ],
        [
            "CALL",
            "[(name, f_locals.pop(name))\n                         for name in code_info.arg_names\n                         if name]"
        ],
        [
            "LOAD_DEREF",
            "f_locals"
        ],
        [
            "LOAD_METHOD",
            "f_locals.items"
        ],
        [
            "CALL",
            "f_locals.items()"
        ],
        [
            "CALL",
            "[\n\n                            # Local variables other than actual arguments. These are variables from\n                            # the enclosing scope. It's handy to treat them like arguments in the UI\n                            it for it in f_locals.items()\n                            if it[0][0] != '.'  # Appears when using nested tuple arguments\n                        ]"
        ],
        [
            "BINARY_OP",
            "[(name, f_locals.pop(name))\n                         for name in code_info.arg_names\n                         if name] + [\n\n                            # Local variables other than actual arguments. These are variables from\n                            # the enclosing scope. It's handy to treat them like arguments in the UI\n                            it for it in f_locals.items()\n                            if it[0][0] != '.'  # Appears when using nested tuple arguments\n                        ]"
        ],
        [
            "STORE_FAST",
            "arguments"
        ],
        [
            "LOAD_GLOBAL",
            "json"
        ],
        [
            "LOAD_ATTR",
            "json.dumps"
        ],
        [
            "LOAD_FAST",
            "arguments"
        ],
        [
            "CALL",
            "[[k, cheap_repr(v)] for k, v in arguments]"
        ],
        [
            "CALL",
            "json.dumps([[k, cheap_repr(v)] for k, v in arguments])"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "STORE_ATTR",
            "frame_info.arguments"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._call_id"
        ],
        [
            "CALL",
            "self._call_id()"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "STORE_ATTR",
            "frame_info.call_id"
        ],
        [
            "LOAD_GLOBAL",
            "defaultdict"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "CALL",
            "defaultdict(list)"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "STORE_ATTR",
            "frame_info.inner_calls"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_METHOD",
            "self.stack.get"
        ],
        [
            "LOAD_FAST",
            "enter_info"
        ],
        [
            "LOAD_ATTR",
            "enter_info.caller_frame"
        ],
        [
            "CALL",
            "self.stack.get(enter_info.caller_frame)"
        ],
        [
            "STORE_FAST",
            "prev"
        ],
        [
            "LOAD_FAST",
            "prev"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_FAST",
            "prev"
        ],
        [
            "CALL",
            "getattr(prev, 'inner_calls', None)"
        ],
        [
            "STORE_FAST",
            "inner_calls"
        ],
        [
            "LOAD_FAST",
            "inner_calls"
        ],
        [
            "LOAD_FAST",
            "inner_calls"
        ],
        [
            "LOAD_FAST",
            "enter_info"
        ],
        [
            "LOAD_ATTR",
            "enter_info.call_node"
        ],
        [
            "BINARY_SUBSCR",
            "inner_calls[enter_info.call_node]"
        ],
        [
            "LOAD_METHOD",
            "inner_calls[enter_info.call_node].append"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.call_id"
        ],
        [
            "CALL",
            "inner_calls[enter_info.call_node].append(frame_info.call_id)"
        ],
        [
            "LOAD_FAST",
            "[(name, f_locals.pop(name))\n                         for name in code_info.arg_names\n                         if name]"
        ],
        [
            "STORE_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_DEREF",
            "f_locals"
        ],
        [
            "LOAD_METHOD",
            "f_locals.pop"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "CALL",
            "f_locals.pop(name)"
        ],
        [
            "LOAD_FAST",
            "[\n\n                            # Local variables other than actual arguments. These are variables from\n                            # the enclosing scope. It's handy to treat them like arguments in the UI\n                            it for it in f_locals.items()\n                            if it[0][0] != '.'  # Appears when using nested tuple arguments\n                        ]"
        ],
        [
            "STORE_FAST",
            "it"
        ],
        [
            "LOAD_FAST",
            "it"
        ],
        [
            "BINARY_SUBSCR",
            "it[0]"
        ],
        [
            "BINARY_SUBSCR",
            "it[0][0]"
        ],
        [
            "COMPARE_OP",
            "it[0][0] != '.'"
        ],
        [
            "LOAD_FAST",
            "it"
        ],
        [
            "LOAD_FAST",
            "[[k, cheap_repr(v)] for k, v in arguments]"
        ],
        [
            "STORE_FAST",
            "k"
        ],
        [
            "STORE_FAST",
            "v"
        ],
        [
            "LOAD_FAST",
            "k"
        ],
        [
            "LOAD_GLOBAL",
            "cheap_repr"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "CALL",
            "cheap_repr(v)"
        ],
        [
            "LOAD_GLOBAL",
            "uuid4"
        ],
        [
            "CALL",
            "uuid4()"
        ],
        [
            "LOAD_ATTR",
            "uuid4().hex"
        ],
        [
            "LOAD_DEREF",
            "exit_info"
        ],
        [
            "LOAD_ATTR",
            "exit_info.current_frame"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code not in self._code_infos"
        ],
        [
            "LOAD_GLOBAL",
            "_tracing_recursively"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "_tracing_recursively(frame)"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "STORE_DEREF",
            "frame_info"
        ],
        [
            "LOAD_DEREF",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.iteration"
        ],
        [
            "STORE_DEREF",
            "top_iteration"
        ],
        [
            "LOAD_GLOBAL",
            "_deep_dict"
        ],
        [
            "CALL",
            "_deep_dict()"
        ],
        [
            "STORE_DEREF",
            "node_values"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._extract_node_values"
        ],
        [
            "LOAD_DEREF",
            "top_iteration"
        ],
        [
            "LOAD_DEREF",
            "node_values"
        ],
        [
            "CALL",
            "self._extract_node_values(top_iteration, (), node_values)"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "BINARY_SUBSCR",
            "self._code_infos[frame.f_code]"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos[frame.f_code].db_func"
        ],
        [
            "STORE_DEREF",
            "db_func"
        ],
        [
            "LOAD_DEREF",
            "exit_info"
        ],
        [
            "LOAD_ATTR",
            "exit_info.exc_value"
        ],
        [
            "STORE_FAST",
            "exc"
        ],
        [
            "LOAD_FAST",
            "exc"
        ],
        [
            "LOAD_METHOD",
            "''.join"
        ],
        [
            "LOAD_GLOBAL",
            "traceback"
        ],
        [
            "LOAD_ATTR",
            "traceback.format_exception"
        ],
        [
            "LOAD_GLOBAL",
            "type"
        ],
        [
            "LOAD_FAST",
            "exc"
        ],
        [
            "CALL",
            "type(exc)"
        ],
        [
            "LOAD_FAST",
            "exc"
        ],
        [
            "LOAD_DEREF",
            "exit_info"
        ],
        [
            "LOAD_ATTR",
            "exit_info.exc_tb"
        ],
        [
            "CALL",
            "traceback.format_exception(type(exc), exc, exit_info.exc_tb)"
        ],
        [
            "CALL",
            "''.join(traceback.format_exception(type(exc), exc, exit_info.exc_tb))"
        ],
        [
            "STORE_DEREF",
            "traceback_str"
        ],
        [
            "LOAD_GLOBAL",
            "exception_string"
        ],
        [
            "LOAD_FAST",
            "exc"
        ],
        [
            "CALL",
            "exception_string(exc)"
        ],
        [
            "STORE_DEREF",
            "exception"
        ],
        [
            "STORE_DEREF",
            "traceback_str"
        ],
        [
            "STORE_DEREF",
            "exception"
        ],
        [
            "LOAD_GLOBAL",
            "retry_db"
        ],
        [
            "CALL",
            "retry_db"
        ],
        [
            "STORE_FAST",
            "        @retry_db\n        def add_call():\n            Call = self.db.Call\n            call = Call(id=frame_info.call_id,\n                        function_id=db_func,\n                        arguments=frame_info.arguments,\n                        return_value=cheap_repr(exit_info.return_value),\n                        exception=exception,\n                        traceback=traceback_str,\n                        data=json.dumps(\n                            dict(\n                                node_values=node_values,\n                                loop_iterations=top_iteration.extract_iterations()['loops'],\n                                type_names=type_registry.names(),\n                                num_special_types=type_registry.num_special_types,\n                            ),\n                            cls=ProtocolEncoder,\n                            separators=(',', ':')\n                        ),\n                        start_time=frame_info.start_time)\n            with self.db.session_scope() as session:\n                session.add(call)"
        ],
        [
            "LOAD_FAST",
            "add_call"
        ],
        [
            "CALL",
            "add_call()"
        ],
        [
            "LOAD_DEREF",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.call_id"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._last_call_id"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.db"
        ],
        [
            "LOAD_ATTR",
            "self.db.Call"
        ],
        [
            "STORE_FAST",
            "Call"
        ],
        [
            "LOAD_FAST",
            "Call"
        ],
        [
            "LOAD_DEREF",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.call_id"
        ],
        [
            "LOAD_DEREF",
            "db_func"
        ],
        [
            "LOAD_DEREF",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.arguments"
        ],
        [
            "LOAD_GLOBAL",
            "cheap_repr"
        ],
        [
            "LOAD_DEREF",
            "exit_info"
        ],
        [
            "LOAD_ATTR",
            "exit_info.return_value"
        ],
        [
            "CALL",
            "cheap_repr(exit_info.return_value)"
        ],
        [
            "LOAD_DEREF",
            "exception"
        ],
        [
            "LOAD_DEREF",
            "traceback_str"
        ],
        [
            "LOAD_GLOBAL",
            "json"
        ],
        [
            "LOAD_ATTR",
            "json.dumps"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_DEREF",
            "node_values"
        ],
        [
            "LOAD_DEREF",
            "top_iteration"
        ],
        [
            "LOAD_METHOD",
            "top_iteration.extract_iterations"
        ],
        [
            "CALL",
            "top_iteration.extract_iterations()"
        ],
        [
            "BINARY_SUBSCR",
            "top_iteration.extract_iterations()['loops']"
        ],
        [
            "LOAD_GLOBAL",
            "type_registry"
        ],
        [
            "LOAD_METHOD",
            "type_registry.names"
        ],
        [
            "CALL",
            "type_registry.names()"
        ],
        [
            "LOAD_GLOBAL",
            "type_registry"
        ],
        [
            "LOAD_ATTR",
            "type_registry.num_special_types"
        ],
        [
            "CALL",
            "dict(\n                                node_values=node_values,\n                                loop_iterations=top_iteration.extract_iterations()['loops'],\n                                type_names=type_registry.names(),\n                                num_special_types=type_registry.num_special_types,\n                            )"
        ],
        [
            "LOAD_GLOBAL",
            "ProtocolEncoder"
        ],
        [
            "CALL",
            "json.dumps(\n                            dict(\n                                node_values=node_values,\n                                loop_iterations=top_iteration.extract_iterations()['loops'],\n                                type_names=type_registry.names(),\n                                num_special_types=type_registry.num_special_types,\n                            ),\n                            cls=ProtocolEncoder,\n                            separators=(',', ':')\n                        )"
        ],
        [
            "LOAD_DEREF",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.start_time"
        ],
        [
            "CALL",
            "Call(id=frame_info.call_id,\n                        function_id=db_func,\n                        arguments=frame_info.arguments,\n                        return_value=cheap_repr(exit_info.return_value),\n                        exception=exception,\n                        traceback=traceback_str,\n                        data=json.dumps(\n                            dict(\n                                node_values=node_values,\n                                loop_iterations=top_iteration.extract_iterations()['loops'],\n                                type_names=type_registry.names(),\n                                num_special_types=type_registry.num_special_types,\n                            ),\n                            cls=ProtocolEncoder,\n                            separators=(',', ':')\n                        ),\n                        start_time=frame_info.start_time)"
        ],
        [
            "STORE_FAST",
            "call"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.db"
        ],
        [
            "LOAD_METHOD",
            "self.db.session_scope"
        ],
        [
            "CALL",
            "self.db.session_scope()"
        ],
        [
            "STORE_FAST",
            "session"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.add"
        ],
        [
            "LOAD_FAST",
            "call"
        ],
        [
            "CALL",
            "session.add(call)"
        ],
        [
            "CALL",
            "            with self.db.session_scope() as session:\n                session.add(call)"
        ],
        [
            "LOAD_FAST",
            "iteration"
        ],
        [
            "LOAD_ATTR",
            "iteration.vals"
        ],
        [
            "LOAD_METHOD",
            "iteration.vals.items"
        ],
        [
            "CALL",
            "iteration.vals.items()"
        ],
        [
            "STORE_FAST",
            "tree_index"
        ],
        [
            "STORE_FAST",
            "node_value"
        ],
        [
            "LOAD_FAST",
            "tree_index"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "BINARY_OP",
            "(tree_index,) + path"
        ],
        [
            "STORE_FAST",
            "full_path"
        ],
        [
            "LOAD_FAST",
            "node_values"
        ],
        [
            "STORE_FAST",
            "d"
        ],
        [
            "LOAD_FAST",
            "full_path"
        ],
        [
            "BINARY_SUBSCR",
            "full_path[:-1]"
        ],
        [
            "STORE_FAST",
            "path_k"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "LOAD_FAST",
            "path_k"
        ],
        [
            "BINARY_SUBSCR",
            "d[path_k]"
        ],
        [
            "STORE_FAST",
            "d"
        ],
        [
            "LOAD_FAST",
            "node_value"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "LOAD_FAST",
            "full_path"
        ],
        [
            "BINARY_SUBSCR",
            "full_path[-1]"
        ],
        [
            "STORE_SUBSCR",
            "d[full_path[-1]]"
        ],
        [
            "LOAD_FAST",
            "iteration"
        ],
        [
            "LOAD_ATTR",
            "iteration.loops"
        ],
        [
            "LOAD_METHOD",
            "iteration.loops.values"
        ],
        [
            "CALL",
            "iteration.loops.values()"
        ],
        [
            "STORE_FAST",
            "loop"
        ],
        [
            "LOAD_GLOBAL",
            "enumerate"
        ],
        [
            "LOAD_FAST",
            "loop"
        ],
        [
            "CALL",
            "enumerate(loop)"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "STORE_FAST",
            "iteration"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._extract_node_values"
        ],
        [
            "LOAD_FAST",
            "iteration"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_OP",
            "path + (i,)"
        ],
        [
            "LOAD_FAST",
            "node_values"
        ],
        [
            "CALL",
            "self._extract_node_values(iteration, path + (i,), node_values)"
        ],
        [
            "LOAD_GLOBAL",
            "super"
        ],
        [
            "LOAD_GLOBAL",
            "BirdsEye"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "super(BirdsEye, self)"
        ],
        [
            "LOAD_METHOD",
            "super(BirdsEye, self).trace_function"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "CALL",
            "super(BirdsEye, self).trace_function(func)"
        ],
        [
            "STORE_FAST",
            "new_func"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "LOAD_METHOD",
            "self._code_infos.get"
        ],
        [
            "LOAD_FAST",
            "new_func"
        ],
        [
            "LOAD_ATTR",
            "new_func.__code__"
        ],
        [
            "CALL",
            "self._code_infos.get(new_func.__code__)"
        ],
        [
            "STORE_FAST",
            "code_info"
        ],
        [
            "LOAD_FAST",
            "code_info"
        ],
        [
            "LOAD_FAST",
            "new_func"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.getsourcelines"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "CALL",
            "inspect.getsourcelines(func)"
        ],
        [
            "STORE_FAST",
            "lines"
        ],
        [
            "STORE_FAST",
            "start_lineno"
        ],
        [
            "LOAD_FAST",
            "start_lineno"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "lines"
        ],
        [
            "CALL",
            "len(lines)"
        ],
        [
            "BINARY_OP",
            "start_lineno + len(lines)"
        ],
        [
            "STORE_FAST",
            "end_lineno"
        ],
        [
            "LOAD_GLOBAL",
            "safe_qualname"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "CALL",
            "safe_qualname(func)"
        ],
        [
            "STORE_FAST",
            "name"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.getsourcefile"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "CALL",
            "inspect.getsourcefile(func)"
        ],
        [
            "STORE_FAST",
            "source_file"
        ],
        [
            "LOAD_FAST",
            "source_file"
        ],
        [
            "LOAD_METHOD",
            "source_file.startswith"
        ],
        [
            "CALL",
            "source_file.startswith('<ipython-input')"
        ],
        [
            "LOAD_GLOBAL",
            "IPYTHON_FILE_PATH"
        ],
        [
            "STORE_FAST",
            "filename"
        ],
        [
            "LOAD_GLOBAL",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.abspath"
        ],
        [
            "LOAD_FAST",
            "source_file"
        ],
        [
            "CALL",
            "os.path.abspath(source_file)"
        ],
        [
            "STORE_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "new_func"
        ],
        [
            "LOAD_ATTR",
            "new_func.traced_file"
        ],
        [
            "STORE_FAST",
            "traced_file"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.getargs"
        ],
        [
            "LOAD_FAST",
            "new_func"
        ],
        [
            "LOAD_ATTR",
            "new_func.__code__"
        ],
        [
            "CALL",
            "inspect.getargs(new_func.__code__)"
        ],
        [
            "STORE_FAST",
            "arg_info"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_GLOBAL",
            "chain"
        ],
        [
            "LOAD_GLOBAL",
            "flatten_list"
        ],
        [
            "LOAD_FAST",
            "arg_info"
        ],
        [
            "BINARY_SUBSCR",
            "arg_info[0]"
        ],
        [
            "CALL",
            "flatten_list(arg_info[0])"
        ],
        [
            "LOAD_FAST",
            "arg_info"
        ],
        [
            "BINARY_SUBSCR",
            "arg_info[1:]"
        ],
        [
            "CALL",
            "chain(flatten_list(arg_info[0]), arg_info[1:])"
        ],
        [
            "CALL",
            "list(chain(flatten_list(arg_info[0]), arg_info[1:]))"
        ],
        [
            "STORE_FAST",
            "arg_names"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._trace"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_FAST",
            "new_func"
        ],
        [
            "LOAD_ATTR",
            "new_func.__code__"
        ],
        [
            "LOAD_FAST",
            "start_lineno"
        ],
        [
            "LOAD_FAST",
            "end_lineno"
        ],
        [
            "LOAD_FAST",
            "arg_names"
        ],
        [
            "CALL",
            "self._trace(name, filename, traced_file, new_func.__code__, typ='function',\n                    start_lineno=start_lineno, end_lineno=end_lineno,\n                    arg_names=arg_names)"
        ],
        [
            "LOAD_FAST",
            "new_func"
        ],
        [
            "STORE_FAST",
            "from IPython import get_ipython"
        ],
        [
            "LOAD_FAST",
            "get_ipython"
        ],
        [
            "CALL",
            "get_ipython()"
        ],
        [
            "STORE_FAST",
            "shell"
        ],
        [
            "LOAD_FAST",
            "shell"
        ],
        [
            "LOAD_ATTR",
            "shell.compile"
        ],
        [
            "LOAD_METHOD",
            "shell.compile.cache"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CALL",
            "shell.compile.cache(source)"
        ],
        [
            "STORE_FAST",
            "filename"
        ],
        [
            "STORE_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "shell"
        ],
        [
            "LOAD_ATTR",
            "shell.compile"
        ],
        [
            "LOAD_ATTR",
            "shell.compile.flags"
        ],
        [
            "STORE_FAST",
            "flags"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.compile"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "flags"
        ],
        [
            "CALL",
            "self.compile(source, filename, flags)"
        ],
        [
            "STORE_FAST",
            "traced_file"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "STORE_ATTR",
            "traced_file.is_ipython_cell"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.root"
        ],
        [
            "LOAD_ATTR",
            "traced_file.root.body"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "is_future_import"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "is_future_import(node)"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError('from __future__ import ... statements '\n                                 'are not allowed in cells traced with %%eye')"
        ],
        [
            "LOAD_FAST",
            "shell"
        ],
        [
            "LOAD_ATTR",
            "shell.user_global_ns"
        ],
        [
            "LOAD_METHOD",
            "shell.user_global_ns.update"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._trace_methods_dict"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "CALL",
            "self._trace_methods_dict(traced_file)"
        ],
        [
            "CALL",
            "shell.user_global_ns.update(self._trace_methods_dict(traced_file))"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._trace"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.code"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CALL",
            "self._trace(name, filename, traced_file, traced_file.code, 'module', source)"
        ],
        [
            "LOAD_FAST",
            "shell"
        ],
        [
            "LOAD_METHOD",
            "shell.ex"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.code"
        ],
        [
            "CALL",
            "shell.ex(traced_file.code)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._ipython_cell_value"
        ],
        [
            "LOAD_FAST",
            "callback"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._last_call_id"
        ],
        [
            "CALL",
            "callback(self._last_call_id)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._ipython_cell_value"
        ],
        [
            "LOAD_FAST",
            "callback"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._last_call_id"
        ],
        [
            "CALL",
            "callback(self._last_call_id)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._ipython_cell_value"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.currentframe"
        ],
        [
            "CALL",
            "inspect.currentframe()"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "STORE_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "context"
        ],
        [
            "COMPARE_OP",
            "context >= 0"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_back"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.getsourcefile"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "inspect.getsourcefile(frame)"
        ],
        [
            "STORE_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "context"
        ],
        [
            "BINARY_OP",
            "context -= 1"
        ],
        [
            "STORE_FAST",
            "context"
        ],
        [
            "LOAD_FAST",
            "context"
        ],
        [
            "COMPARE_OP",
            "context >= 0"
        ],
        [
            "LOAD_GLOBAL",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.abspath"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "CALL",
            "os.path.abspath(filename)"
        ],
        [
            "STORE_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_globals"
        ],
        [
            "LOAD_METHOD",
            "frame.f_globals.get"
        ],
        [
            "CALL",
            "frame.f_globals.get('__name__')"
        ],
        [
            "COMPARE_OP",
            "frame.f_globals.get('__name__') != '__main__'"
        ],
        [
            "LOAD_GLOBAL",
            "PY3"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._treetrace_hidden_with_stmt"
        ],
        [
            "LOAD_ATTR",
            "self._treetrace_hidden_with_stmt.__name__"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_globals"
        ],
        [
            "CONTAINS_OP",
            "self._treetrace_hidden_with_stmt.__name__ not in frame.f_globals"
        ],
        [
            "LOAD_GLOBAL",
            "RuntimeError"
        ],
        [
            "CALL",
            "RuntimeError(\n                    'To trace an imported module, you must import birdseye before '\n                    'importing that module.')"
        ],
        [
            "LOAD_GLOBAL",
            "read_source_file"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "CALL",
            "read_source_file(filename)"
        ],
        [
            "LOAD_METHOD",
            "read_source_file(filename).splitlines"
        ],
        [
            "CALL",
            "read_source_file(filename).splitlines()"
        ],
        [
            "STORE_FAST",
            "lines"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_lineno"
        ],
        [
            "BINARY_OP",
            "[''] * frame.f_lineno"
        ],
        [
            "LOAD_FAST",
            "lines"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_lineno"
        ],
        [
            "STORE_SUBSCR",
            "lines[:frame.f_lineno]"
        ],
        [
            "LOAD_METHOD",
            "'\\n'.join"
        ],
        [
            "LOAD_FAST",
            "lines"
        ],
        [
            "CALL",
            "'\\n'.join(lines)"
        ],
        [
            "STORE_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.exec_string"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_globals"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_locals"
        ],
        [
            "LOAD_FAST",
            "deep"
        ],
        [
            "CALL",
            "self.exec_string(source, filename, frame.f_globals, frame.f_locals, deep)"
        ],
        [
            "LOAD_GLOBAL",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.exit"
        ],
        [
            "CALL",
            "sys.exit(0)"
        ],
        [
            "LOAD_FAST",
            "globs"
        ],
        [
            "STORE_FAST",
            "globs"
        ],
        [
            "LOAD_FAST",
            "locs"
        ],
        [
            "STORE_FAST",
            "locs"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.compile"
        ],
        [
            "LOAD_DEREF",
            "source"
        ],
        [
            "LOAD_DEREF",
            "filename"
        ],
        [
            "CALL",
            "self.compile(source, filename)"
        ],
        [
            "STORE_DEREF",
            "traced_file"
        ],
        [
            "LOAD_FAST",
            "globs"
        ],
        [
            "LOAD_METHOD",
            "globs.update"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._trace_methods_dict"
        ],
        [
            "LOAD_DEREF",
            "traced_file"
        ],
        [
            "CALL",
            "self._trace_methods_dict(traced_file)"
        ],
        [
            "CALL",
            "globs.update(self._trace_methods_dict(traced_file))"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._trace"
        ],
        [
            "LOAD_GLOBAL",
            "FILE_SENTINEL_NAME"
        ],
        [
            "LOAD_DEREF",
            "filename"
        ],
        [
            "LOAD_DEREF",
            "traced_file"
        ],
        [
            "LOAD_DEREF",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.code"
        ],
        [
            "LOAD_DEREF",
            "source"
        ],
        [
            "CALL",
            "self._trace(FILE_SENTINEL_NAME, filename, traced_file, traced_file.code, 'module', source)"
        ],
        [
            "LOAD_FAST",
            "deep"
        ],
        [
            "LOAD_DEREF",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.nodes"
        ],
        [
            "CALL",
            "{\n                node.lineno: node\n                for node in traced_file.nodes\n                if isinstance(node, ast.FunctionDef)\n            }"
        ],
        [
            "STORE_DEREF",
            "nodes_by_lineno"
        ],
        [
            "STORE_DEREF",
            "            def find_code(root_code):\n                # type: (CodeType) -> None\n                for code in root_code.co_consts:  # type: CodeType\n                    if not inspect.iscode(code) or code.co_name.startswith('<'):\n                        continue\n\n                    find_code(code)\n\n                    lineno = code.co_firstlineno\n                    node = nodes_by_lineno.get(lineno)\n                    if not node:\n                        continue\n\n                    self._trace(\n                        code.co_name, filename, traced_file, code,\n                        typ='function',\n                        source=source,\n                        start_lineno=lineno,\n                        end_lineno=node.last_token.end[0] + 1,\n                    )"
        ],
        [
            "LOAD_DEREF",
            "find_code"
        ],
        [
            "LOAD_DEREF",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.code"
        ],
        [
            "CALL",
            "find_code(traced_file.code)"
        ],
        [
            "LOAD_GLOBAL",
            "exec"
        ],
        [
            "LOAD_DEREF",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.code"
        ],
        [
            "LOAD_FAST",
            "globs"
        ],
        [
            "LOAD_FAST",
            "locs"
        ],
        [
            "CALL",
            "exec(traced_file.code, globs, locs)"
        ],
        [
            "LOAD_FAST",
            "{\n                node.lineno: node\n                for node in traced_file.nodes\n                if isinstance(node, ast.FunctionDef)\n            }"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.FunctionDef"
        ],
        [
            "CALL",
            "isinstance(node, ast.FunctionDef)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.lineno"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "root_code"
        ],
        [
            "LOAD_ATTR",
            "root_code.co_consts"
        ],
        [
            "STORE_FAST",
            "code"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.iscode"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "CALL",
            "inspect.iscode(code)"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_name"
        ],
        [
            "LOAD_METHOD",
            "code.co_name.startswith"
        ],
        [
            "CALL",
            "code.co_name.startswith('<')"
        ],
        [
            "LOAD_DEREF",
            "find_code"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "CALL",
            "find_code(code)"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_firstlineno"
        ],
        [
            "STORE_FAST",
            "lineno"
        ],
        [
            "LOAD_DEREF",
            "nodes_by_lineno"
        ],
        [
            "LOAD_METHOD",
            "nodes_by_lineno.get"
        ],
        [
            "LOAD_FAST",
            "lineno"
        ],
        [
            "CALL",
            "nodes_by_lineno.get(lineno)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._trace"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_name"
        ],
        [
            "LOAD_DEREF",
            "filename"
        ],
        [
            "LOAD_DEREF",
            "traced_file"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_DEREF",
            "source"
        ],
        [
            "LOAD_FAST",
            "lineno"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.last_token"
        ],
        [
            "LOAD_ATTR",
            "node.last_token.end"
        ],
        [
            "BINARY_SUBSCR",
            "node.last_token.end[0]"
        ],
        [
            "BINARY_OP",
            "node.last_token.end[0] + 1"
        ],
        [
            "CALL",
            "self._trace(\n                        code.co_name, filename, traced_file, code,\n                        typ='function',\n                        source=source,\n                        start_lineno=lineno,\n                        end_lineno=node.last_token.end[0] + 1,\n                    )"
        ],
        [
            "LOAD_FAST",
            "end_lineno"
        ],
        [
            "LOAD_DEREF",
            "start_lineno"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_METHOD",
            "source.splitlines"
        ],
        [
            "CALL",
            "source.splitlines()"
        ],
        [
            "CALL",
            "len(source.splitlines())"
        ],
        [
            "BINARY_OP",
            "start_lineno + len(source.splitlines())"
        ],
        [
            "STORE_FAST",
            "end_lineno"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._nodes_of_interest"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_DEREF",
            "start_lineno"
        ],
        [
            "LOAD_FAST",
            "end_lineno"
        ],
        [
            "CALL",
            "self._nodes_of_interest(traced_file, start_lineno, end_lineno)"
        ],
        [
            "CALL",
            "list(self._nodes_of_interest(traced_file, start_lineno, end_lineno))"
        ],
        [
            "STORE_FAST",
            "nodes"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._nodes_html"
        ],
        [
            "LOAD_FAST",
            "nodes"
        ],
        [
            "LOAD_DEREF",
            "start_lineno"
        ],
        [
            "LOAD_FAST",
            "end_lineno"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "CALL",
            "self._nodes_html(nodes, start_lineno, end_lineno, traced_file)"
        ],
        [
            "STORE_FAST",
            "html_body"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_FAST",
            "nodes"
        ],
        [
            "CALL",
            "{\n                node._tree_index: [n._tree_index for n in node._loops]\n                for node, _ in nodes\n                if node._loops\n            }"
        ],
        [
            "CALL",
            "dict(\n            # This maps each node to the loops enclosing that node\n            node_loops={\n                node._tree_index: [n._tree_index for n in node._loops]\n                for node, _ in nodes\n                if node._loops\n            },\n        )"
        ],
        [
            "STORE_FAST",
            "data_dict"
        ],
        [
            "LOAD_FAST",
            "typ"
        ],
        [
            "COMPARE_OP",
            "typ == 'function'"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.tokens"
        ],
        [
            "STORE_FAST",
            "tokens"
        ],
        [
            "LOAD_GLOBAL",
            "only"
        ],
        [
            "LOAD_FAST",
            "nodes"
        ],
        [
            "CALL",
            "(node\n                             for node, _ in nodes\n                             if isinstance(node, ast.FunctionDef)\n                             and node.first_token.start[0] == start_lineno)"
        ],
        [
            "CALL",
            "only(node\n                             for node, _ in nodes\n                             if isinstance(node, ast.FunctionDef)\n                             and node.first_token.start[0] == start_lineno)"
        ],
        [
            "STORE_FAST",
            "func_node"
        ],
        [
            "LOAD_GLOBAL",
            "source_without_decorators"
        ],
        [
            "LOAD_FAST",
            "tokens"
        ],
        [
            "LOAD_FAST",
            "func_node"
        ],
        [
            "CALL",
            "source_without_decorators(tokens, func_node)"
        ],
        [
            "STORE_FAST",
            "func_startpos"
        ],
        [
            "STORE_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "data_dict"
        ],
        [
            "LOAD_METHOD",
            "data_dict.update"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._node_ranges"
        ],
        [
            "LOAD_FAST",
            "nodes"
        ],
        [
            "LOAD_FAST",
            "tokens"
        ],
        [
            "LOAD_FAST",
            "func_startpos"
        ],
        [
            "CALL",
            "self._node_ranges(nodes, tokens, func_startpos)"
        ],
        [
            "CALL",
            "list(self._node_ranges(nodes, tokens, func_startpos))"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._loop_ranges"
        ],
        [
            "LOAD_FAST",
            "nodes"
        ],
        [
            "LOAD_FAST",
            "tokens"
        ],
        [
            "LOAD_FAST",
            "func_startpos"
        ],
        [
            "CALL",
            "self._loop_ranges(nodes, tokens, func_startpos)"
        ],
        [
            "CALL",
            "list(self._loop_ranges(nodes, tokens, func_startpos))"
        ],
        [
            "CALL",
            "data_dict.update(\n                node_ranges=list(self._node_ranges(nodes, tokens, func_startpos)),\n                loop_ranges=list(self._loop_ranges(nodes, tokens, func_startpos)),\n            )"
        ],
        [
            "LOAD_GLOBAL",
            "json"
        ],
        [
            "LOAD_ATTR",
            "json.dumps"
        ],
        [
            "LOAD_FAST",
            "data_dict"
        ],
        [
            "CALL",
            "json.dumps(data_dict, sort_keys=True)"
        ],
        [
            "STORE_FAST",
            "data"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._db_func"
        ],
        [
            "LOAD_FAST",
            "data"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "html_body"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_DEREF",
            "start_lineno"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "typ"
        ],
        [
            "CALL",
            "self._db_func(data, filename, html_body, name, start_lineno, source, typ)"
        ],
        [
            "STORE_FAST",
            "db_func"
        ],
        [
            "LOAD_GLOBAL",
            "CodeInfo"
        ],
        [
            "LOAD_FAST",
            "db_func"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_FAST",
            "arg_names"
        ],
        [
            "CALL",
            "CodeInfo(db_func, traced_file, arg_names)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "STORE_SUBSCR",
            "self._code_infos[code]"
        ],
        [
            "LOAD_FAST",
            "{\n                node._tree_index: [n._tree_index for n in node._loops]\n                for node, _ in nodes\n                if node._loops\n            }"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "STORE_FAST",
            "_"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._loops"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._tree_index"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._loops"
        ],
        [
            "CALL",
            "[n._tree_index for n in node._loops]"
        ],
        [
            "LOAD_FAST",
            "[n._tree_index for n in node._loops]"
        ],
        [
            "STORE_FAST",
            "n"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "LOAD_ATTR",
            "n._tree_index"
        ],
        [
            "LOAD_FAST",
            "(node\n                             for node, _ in nodes\n                             if isinstance(node, ast.FunctionDef)\n                             and node.first_token.start[0] == start_lineno)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "STORE_FAST",
            "_"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.FunctionDef"
        ],
        [
            "CALL",
            "isinstance(node, ast.FunctionDef)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.first_token"
        ],
        [
            "LOAD_ATTR",
            "node.first_token.start"
        ],
        [
            "BINARY_SUBSCR",
            "node.first_token.start[0]"
        ],
        [
            "LOAD_DEREF",
            "start_lineno"
        ],
        [
            "COMPARE_OP",
            "node.first_token.start[0] == start_lineno"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "nodes"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "STORE_FAST",
            "classes"
        ],
        [
            "STORE_FAST",
            "_"
        ],
        [
            "STORE_FAST",
            "__"
        ],
        [
            "LOAD_FAST",
            "classes"
        ],
        [
            "CONTAINS_OP",
            "'loop' not in classes"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.target"
        ],
        [
            "STORE_FAST",
            "target"
        ],
        [
            "LOAD_GLOBAL",
            "AttributeError"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.test"
        ],
        [
            "STORE_FAST",
            "target"
        ],
        [
            "LOAD_FAST",
            "tokens"
        ],
        [
            "LOAD_METHOD",
            "tokens.get_text_range"
        ],
        [
            "LOAD_FAST",
            "target"
        ],
        [
            "CALL",
            "tokens.get_text_range(target)"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "STORE_FAST",
            "end"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "func_start"
        ],
        [
            "BINARY_OP",
            "start -= func_start"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "end"
        ],
        [
            "LOAD_FAST",
            "func_start"
        ],
        [
            "BINARY_OP",
            "end -= func_start"
        ],
        [
            "STORE_FAST",
            "end"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._tree_index"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "end"
        ],
        [
            "CALL",
            "dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end\n            )"
        ],
        [
            "LOAD_FAST",
            "nodes"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "STORE_FAST",
            "classes"
        ],
        [
            "STORE_FAST",
            "_"
        ],
        [
            "STORE_FAST",
            "__"
        ],
        [
            "LOAD_FAST",
            "tokens"
        ],
        [
            "LOAD_METHOD",
            "tokens.get_text_range"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "tokens.get_text_range(node)"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "STORE_FAST",
            "end"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "func_start"
        ],
        [
            "BINARY_OP",
            "start -= func_start"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "end"
        ],
        [
            "LOAD_FAST",
            "func_start"
        ],
        [
            "BINARY_OP",
            "end -= func_start"
        ],
        [
            "STORE_FAST",
            "end"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "COMPARE_OP",
            "start < 0"
        ],
        [
            "LOAD_FAST",
            "end"
        ],
        [
            "COMPARE_OP",
            "end < 0"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.FunctionDef"
        ],
        [
            "CALL",
            "isinstance(node, ast.FunctionDef)"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._tree_index"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "end"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._depth"
        ],
        [
            "LOAD_FAST",
            "classes"
        ],
        [
            "CALL",
            "dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end,\n                depth=node._depth,\n                classes=classes,\n            )"
        ],
        [
            "STORE_FAST",
            "        def h(s):\n            return hashlib.sha256(s.encode('utf8')).hexdigest()"
        ],
        [
            "LOAD_FAST",
            "h"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "BINARY_OP",
            "filename + name"
        ],
        [
            "LOAD_FAST",
            "html_body"
        ],
        [
            "BINARY_OP",
            "filename + name + html_body"
        ],
        [
            "LOAD_FAST",
            "data"
        ],
        [
            "BINARY_OP",
            "filename + name + html_body + data"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_FAST",
            "start_lineno"
        ],
        [
            "CALL",
            "str(start_lineno)"
        ],
        [
            "BINARY_OP",
            "filename + name + html_body + data + str(start_lineno)"
        ],
        [
            "CALL",
            "h(filename + name + html_body + data + str(start_lineno))"
        ],
        [
            "STORE_FAST",
            "function_hash"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.db"
        ],
        [
            "LOAD_ATTR",
            "self.db.Function"
        ],
        [
            "STORE_FAST",
            "Function"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.db"
        ],
        [
            "LOAD_METHOD",
            "self.db.session_scope"
        ],
        [
            "CALL",
            "self.db.session_scope()"
        ],
        [
            "STORE_FAST",
            "session"
        ],
        [
            "LOAD_GLOBAL",
            "one_or_none"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "LOAD_FAST",
            "Function"
        ],
        [
            "CALL",
            "session.query(Function)"
        ],
        [
            "LOAD_METHOD",
            "session.query(Function).filter_by"
        ],
        [
            "LOAD_FAST",
            "function_hash"
        ],
        [
            "CALL",
            "session.query(Function).filter_by(hash=function_hash)"
        ],
        [
            "CALL",
            "one_or_none(session.query(Function).filter_by(hash=function_hash))"
        ],
        [
            "STORE_FAST",
            "db_func"
        ],
        [
            "LOAD_FAST",
            "db_func"
        ],
        [
            "LOAD_FAST",
            "Function"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "typ"
        ],
        [
            "LOAD_FAST",
            "html_body"
        ],
        [
            "LOAD_FAST",
            "start_lineno"
        ],
        [
            "LOAD_FAST",
            "data"
        ],
        [
            "LOAD_FAST",
            "h"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CALL",
            "h(source)"
        ],
        [
            "LOAD_FAST",
            "function_hash"
        ],
        [
            "CALL",
            "Function(file=filename,\n                                   name=name,\n                                   type=typ,\n                                   html_body=html_body,\n                                   lineno=start_lineno,\n                                   data=data,\n                                   body_hash=h(source),\n                                   hash=function_hash)"
        ],
        [
            "STORE_FAST",
            "db_func"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.add"
        ],
        [
            "LOAD_FAST",
            "db_func"
        ],
        [
            "CALL",
            "session.add(db_func)"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.commit"
        ],
        [
            "CALL",
            "session.commit()"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "db_func"
        ],
        [
            "LOAD_ATTR",
            "db_func.id"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "CALL",
            "isinstance(db_func.id, int)"
        ],
        [
            "LOAD_FAST",
            "db_func"
        ],
        [
            "LOAD_ATTR",
            "db_func.id"
        ],
        [
            "CALL",
            "        with self.db.session_scope() as session:\n            db_func = one_or_none(session.query(Function).filter_by(hash=function_hash))  # type: Optional[Function]\n            if not db_func:\n                db_func = Function(file=filename,\n                                   name=name,\n                                   type=typ,\n                                   html_body=html_body,\n                                   lineno=start_lineno,\n                                   data=data,\n                                   body_hash=h(source),\n                                   hash=function_hash)\n                session.add(db_func)\n                session.commit()  # ensure .id exists\n            assert isinstance(db_func.id, int)\n            return db_func.id"
        ],
        [
            "LOAD_GLOBAL",
            "hashlib"
        ],
        [
            "LOAD_ATTR",
            "hashlib.sha256"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_METHOD",
            "s.encode"
        ],
        [
            "CALL",
            "s.encode('utf8')"
        ],
        [
            "CALL",
            "hashlib.sha256(s.encode('utf8'))"
        ],
        [
            "LOAD_METHOD",
            "hashlib.sha256(s.encode('utf8')).hexdigest"
        ],
        [
            "CALL",
            "hashlib.sha256(s.encode('utf8')).hexdigest()"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.nodes"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "STORE_FAST",
            "classes"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.While"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.For"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.comprehension"
        ],
        [
            "CALL",
            "isinstance(node, (ast.While, ast.For, ast.comprehension))"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.GeneratorExp"
        ],
        [
            "CALL",
            "isinstance(node.parent, ast.GeneratorExp)"
        ],
        [
            "LOAD_FAST",
            "classes"
        ],
        [
            "LOAD_METHOD",
            "classes.append"
        ],
        [
            "CALL",
            "classes.append('loop')"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.stmt"
        ],
        [
            "CALL",
            "isinstance(node, ast.stmt)"
        ],
        [
            "LOAD_FAST",
            "classes"
        ],
        [
            "LOAD_METHOD",
            "classes.append"
        ],
        [
            "CALL",
            "classes.append('stmt')"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.expr"
        ],
        [
            "CALL",
            "isinstance(node, ast.expr)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._is_interesting_expression"
        ],
        [
            "LOAD_FAST",
            "classes"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.AST"
        ],
        [
            "CALL",
            "isinstance(node, ast.AST)"
        ],
        [
            "LOAD_GLOBAL",
            "hasattr"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "hasattr(node, 'first_token')"
        ],
        [
            "LOAD_FAST",
            "start_lineno"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.first_token"
        ],
        [
            "LOAD_ATTR",
            "node.first_token.start"
        ],
        [
            "BINARY_SUBSCR",
            "node.first_token.start[0]"
        ],
        [
            "COMPARE_OP",
            "start_lineno <= node.first_token.start[0] <= end_lineno"
        ],
        [
            "LOAD_FAST",
            "end_lineno"
        ],
        [
            "COMPARE_OP",
            "start_lineno <= node.first_token.start[0] <= end_lineno"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.tokens"
        ],
        [
            "LOAD_METHOD",
            "traced_file.tokens.get_text_range"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "traced_file.tokens.get_text_range(node)"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "STORE_FAST",
            "end"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "end"
        ],
        [
            "COMPARE_OP",
            "start == end == 0"
        ],
        [
            "COMPARE_OP",
            "start == end == 0"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "classes"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "end"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.root"
        ],
        [
            "STORE_ATTR",
            "traced_file.root._depth"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.walk"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.root"
        ],
        [
            "CALL",
            "ast.walk(traced_file.root)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.iter_child_nodes"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "ast.iter_child_nodes(node)"
        ],
        [
            "STORE_FAST",
            "child"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._depth"
        ],
        [
            "BINARY_OP",
            "node._depth + 1"
        ],
        [
            "LOAD_FAST",
            "child"
        ],
        [
            "STORE_ATTR",
            "child._depth"
        ],
        [
            "STORE_FAST",
            "positions"
        ],
        [
            "LOAD_FAST",
            "nodes"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "STORE_FAST",
            "classes"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "STORE_FAST",
            "end"
        ],
        [
            "LOAD_FAST",
            "positions"
        ],
        [
            "LOAD_METHOD",
            "positions.extend"
        ],
        [
            "LOAD_GLOBAL",
            "map"
        ],
        [
            "LOAD_GLOBAL",
            "HTMLPosition"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "end"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._depth"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._depth"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._tree_index"
        ],
        [
            "LOAD_METHOD",
            "' '.join"
        ],
        [
            "LOAD_FAST",
            "classes"
        ],
        [
            "CALL",
            "' '.join(classes)"
        ],
        [
            "BUILD_STRING",
            "'<span data-index=\"%s\" class=\"%s\">' % (node._tree_index, ' '.join(classes))"
        ],
        [
            "CALL",
            "map(\n                HTMLPosition,\n                [start, end],\n                [True, False],  # is_start\n                [node._depth, node._depth],\n                ['<span data-index=\"%s\" class=\"%s\">' % (node._tree_index, ' '.join(classes)),\n                 '</span>'])"
        ],
        [
            "CALL",
            "positions.extend(map(\n                HTMLPosition,\n                [start, end],\n                [True, False],  # is_start\n                [node._depth, node._depth],\n                ['<span data-index=\"%s\" class=\"%s\">' % (node._tree_index, ' '.join(classes)),\n                 '</span>']))"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._separate_comprehensions"
        ],
        [
            "LOAD_FAST",
            "nodes"
        ],
        [
            "CALL",
            "[n[0] for n in nodes]"
        ],
        [
            "LOAD_FAST",
            "end_lineno"
        ],
        [
            "LOAD_FAST",
            "positions"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "CALL",
            "self._separate_comprehensions(\n            [n[0] for n in nodes],\n            end_lineno, positions, traced_file)"
        ],
        [
            "STORE_FAST",
            "end_lineno"
        ],
        [
            "LOAD_FAST",
            "positions"
        ],
        [
            "LOAD_METHOD",
            "positions.append"
        ],
        [
            "LOAD_GLOBAL",
            "HTMLPosition"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.source"
        ],
        [
            "CALL",
            "len(traced_file.source)"
        ],
        [
            "CALL",
            "HTMLPosition(len(traced_file.source), False, 0, '')"
        ],
        [
            "CALL",
            "positions.append(HTMLPosition(len(traced_file.source), False, 0, ''))"
        ],
        [
            "LOAD_FAST",
            "positions"
        ],
        [
            "LOAD_METHOD",
            "positions.sort"
        ],
        [
            "CALL",
            "positions.sort()"
        ],
        [
            "STORE_FAST",
            "html_parts"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "positions"
        ],
        [
            "STORE_FAST",
            "position"
        ],
        [
            "LOAD_FAST",
            "html_parts"
        ],
        [
            "LOAD_METHOD",
            "html_parts.append"
        ],
        [
            "LOAD_GLOBAL",
            "html"
        ],
        [
            "LOAD_ATTR",
            "html.escape"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.source"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "position"
        ],
        [
            "LOAD_ATTR",
            "position.index"
        ],
        [
            "BINARY_SUBSCR",
            "traced_file.source[start:position.index]"
        ],
        [
            "CALL",
            "html.escape(traced_file.source[start:position.index])"
        ],
        [
            "CALL",
            "html_parts.append(html.escape(traced_file.source[start:position.index]))"
        ],
        [
            "LOAD_FAST",
            "html_parts"
        ],
        [
            "LOAD_METHOD",
            "html_parts.append"
        ],
        [
            "LOAD_FAST",
            "position"
        ],
        [
            "LOAD_ATTR",
            "position.html"
        ],
        [
            "CALL",
            "html_parts.append(position.html)"
        ],
        [
            "LOAD_FAST",
            "position"
        ],
        [
            "LOAD_ATTR",
            "position.index"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "LOAD_METHOD",
            "''.join"
        ],
        [
            "LOAD_FAST",
            "html_parts"
        ],
        [
            "CALL",
            "''.join(html_parts)"
        ],
        [
            "STORE_FAST",
            "html_body"
        ],
        [
            "LOAD_METHOD",
            "'\\n'.join"
        ],
        [
            "LOAD_FAST",
            "html_body"
        ],
        [
            "LOAD_METHOD",
            "html_body.split"
        ],
        [
            "CALL",
            "html_body.split('\\n')"
        ],
        [
            "LOAD_FAST",
            "start_lineno"
        ],
        [
            "BINARY_OP",
            "start_lineno - 1"
        ],
        [
            "LOAD_FAST",
            "end_lineno"
        ],
        [
            "BINARY_OP",
            "end_lineno - 1"
        ],
        [
            "BINARY_SUBSCR",
            "html_body.split('\\n')[start_lineno - 1:end_lineno - 1]"
        ],
        [
            "CALL",
            "'\\n'.join(html_body.split('\\n')[start_lineno - 1:end_lineno - 1])"
        ],
        [
            "STORE_FAST",
            "html_body"
        ],
        [
            "LOAD_FAST",
            "html_body"
        ],
        [
            "LOAD_METHOD",
            "html_body.strip"
        ],
        [
            "CALL",
            "html_body.strip('\\n')"
        ],
        [
            "LOAD_FAST",
            "[n[0] for n in nodes]"
        ],
        [
            "STORE_FAST",
            "n"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "BINARY_SUBSCR",
            "n[0]"
        ],
        [
            "LOAD_GLOBAL",
            "group_by_key_func"
        ],
        [
            "LOAD_GLOBAL",
            "of_type"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.comprehension"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.While"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.For"
        ],
        [
            "LOAD_FAST",
            "nodes"
        ],
        [
            "CALL",
            "of_type((ast.comprehension, ast.While, ast.For), nodes)"
        ],
        [
            "CALL",
            "group_by_key_func(of_type((ast.comprehension, ast.While, ast.For), nodes),\n                                           lambda c: c.first_token.start[0]\n                                           )"
        ],
        [
            "STORE_FAST",
            "comprehensions"
        ],
        [
            "STORE_FAST",
            "        def get_start(n):\n            # type: (ast.AST) -> int\n            return traced_file.tokens.get_text_range(n)[0]"
        ],
        [
            "LOAD_FAST",
            "comprehensions"
        ],
        [
            "LOAD_METHOD",
            "comprehensions.values"
        ],
        [
            "CALL",
            "comprehensions.values()"
        ],
        [
            "STORE_FAST",
            "comp_list"
        ],
        [
            "STORE_FAST",
            "prev_start"
        ],
        [
            "LOAD_GLOBAL",
            "sorted"
        ],
        [
            "LOAD_FAST",
            "comp_list"
        ],
        [
            "CALL",
            "sorted(comp_list, key=lambda c: c.first_token.startpos)"
        ],
        [
            "STORE_FAST",
            "comp"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "comp"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.comprehension"
        ],
        [
            "CALL",
            "isinstance(comp, ast.comprehension)"
        ],
        [
            "LOAD_FAST",
            "comp"
        ],
        [
            "LOAD_FAST",
            "comp"
        ],
        [
            "LOAD_ATTR",
            "comp.parent"
        ],
        [
            "LOAD_ATTR",
            "comp.parent.generators"
        ],
        [
            "BINARY_SUBSCR",
            "comp.parent.generators[0]"
        ],
        [
            "IS_OP",
            "comp is comp.parent.generators[0]"
        ],
        [
            "LOAD_FAST",
            "get_start"
        ],
        [
            "LOAD_FAST",
            "comp"
        ],
        [
            "LOAD_ATTR",
            "comp.parent"
        ],
        [
            "CALL",
            "get_start(comp.parent)"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "prev_start"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "prev_start"
        ],
        [
            "COMPARE_OP",
            "start < prev_start"
        ],
        [
            "LOAD_FAST",
            "get_start"
        ],
        [
            "LOAD_FAST",
            "comp"
        ],
        [
            "CALL",
            "get_start(comp)"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "get_start"
        ],
        [
            "LOAD_FAST",
            "comp"
        ],
        [
            "CALL",
            "get_start(comp)"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "prev_start"
        ],
        [
            "LOAD_FAST",
            "positions"
        ],
        [
            "LOAD_METHOD",
            "positions.append"
        ],
        [
            "LOAD_GLOBAL",
            "HTMLPosition"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "CALL",
            "HTMLPosition(start, True, 0, '\\n ')"
        ],
        [
            "CALL",
            "positions.append(HTMLPosition(start, True, 0, '\\n '))"
        ],
        [
            "LOAD_FAST",
            "end_lineno"
        ],
        [
            "BINARY_OP",
            "end_lineno += 1"
        ],
        [
            "STORE_FAST",
            "end_lineno"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "STORE_FAST",
            "prev_start"
        ],
        [
            "LOAD_FAST",
            "end_lineno"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_ATTR",
            "c.first_token"
        ],
        [
            "LOAD_ATTR",
            "c.first_token.start"
        ],
        [
            "BINARY_SUBSCR",
            "c.first_token.start[0]"
        ],
        [
            "LOAD_DEREF",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.tokens"
        ],
        [
            "LOAD_METHOD",
            "traced_file.tokens.get_text_range"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "CALL",
            "traced_file.tokens.get_text_range(n)"
        ],
        [
            "BINARY_SUBSCR",
            "traced_file.tokens.get_text_range(n)[0]"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_ATTR",
            "c.first_token"
        ],
        [
            "LOAD_ATTR",
            "c.first_token.startpos"
        ],
        [
            "LOAD_GLOBAL",
            "defaultdict"
        ],
        [
            "LOAD_GLOBAL",
            "_deep_dict"
        ],
        [
            "CALL",
            "defaultdict(_deep_dict)"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_GLOBAL",
            "_bad_codes"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code in _bad_codes"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_back"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "STORE_NAME",
            "\"\"\"\n    Corresponds to an iteration of a loop during a call, OR\n    the call itself (FrameInfo.iteration).\n    \"\"\""
        ],
        [
            "STORE_NAME",
            "    def __init__(self):\n        # Mapping of nodes (via node._tree_index) to the value of that\n        # node in this iteration. Only contains nodes within the corresponding\n        # loop or at the top of the function, but not in loops further within\n        # (those will be somewhere within self.loops)\n        # Therefore those nodes have at most one value.\n        self.vals = {}  # type: Dict[int, NodeValue]\n\n        # Mapping of loop nodes (via node._tree_index) to IterationLists\n        # for loops that happened during this iteration\n        self.loops = defaultdict(IterationList)  # type: Dict[int, IterationList]\n\n        # 0-based index of this iteration\n        self.index = None  # type: int\n        self.keep = False"
        ],
        [
            "STORE_NAME",
            "    def extract_iterations(self):\n        # type: () -> Dict[str, Union[int, Dict]]\n        return {\n            'index': self.index,\n            'loops': {\n                tree_index: [iteration.extract_iterations()\n                             for iteration in iteration_list]\n                for tree_index, iteration_list in self.loops.items()\n            }\n        }"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.vals"
        ],
        [
            "LOAD_GLOBAL",
            "defaultdict"
        ],
        [
            "LOAD_GLOBAL",
            "IterationList"
        ],
        [
            "CALL",
            "defaultdict(IterationList)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.loops"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.index"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.keep"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.index"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.loops"
        ],
        [
            "LOAD_METHOD",
            "self.loops.items"
        ],
        [
            "CALL",
            "self.loops.items()"
        ],
        [
            "CALL",
            "{\n                tree_index: [iteration.extract_iterations()\n                             for iteration in iteration_list]\n                for tree_index, iteration_list in self.loops.items()\n            }"
        ],
        [
            "LOAD_FAST",
            "{\n                tree_index: [iteration.extract_iterations()\n                             for iteration in iteration_list]\n                for tree_index, iteration_list in self.loops.items()\n            }"
        ],
        [
            "STORE_FAST",
            "tree_index"
        ],
        [
            "STORE_FAST",
            "iteration_list"
        ],
        [
            "LOAD_FAST",
            "tree_index"
        ],
        [
            "LOAD_FAST",
            "iteration_list"
        ],
        [
            "CALL",
            "[iteration.extract_iterations()\n                             for iteration in iteration_list]"
        ],
        [
            "LOAD_FAST",
            "[iteration.extract_iterations()\n                             for iteration in iteration_list]"
        ],
        [
            "STORE_FAST",
            "iteration"
        ],
        [
            "LOAD_FAST",
            "iteration"
        ],
        [
            "LOAD_METHOD",
            "iteration.extract_iterations"
        ],
        [
            "CALL",
            "iteration.extract_iterations()"
        ],
        [
            "STORE_NAME",
            "\"\"\"\n    A list of Iterations, corresponding to a run of a loop.\n    If the loop has many iterations, only contains the first and last few\n    and any in the middle where unique nodes had values, so that\n    any node which appeared during this loop exists in at least some iterations.\n    \"\"\""
        ],
        [
            "STORE_NAME",
            "side_len"
        ],
        [
            "STORE_NAME",
            "    def __init__(self):\n        # Contains the first few iterations\n        # and any after that have unique nodes in them\n        self.start = []  # type: List[Iteration]\n\n        # Contains the last few iterations\n        self.end = deque(maxlen=self.side_len)  # type: Deque[Iteration]\n\n        # Total number of iterations in the loop, not all of which\n        # are kept\n        self.length = 0  # type: int\n\n        # Number of times each node has been recorded in this loop\n        self.recorded = Counter()"
        ],
        [
            "STORE_NAME",
            "    def append(self, iteration):\n        # type: (Iteration) -> None\n        if self.length < self.side_len:\n            self.start.append(iteration)\n        else:\n            # If self.end is too long, the first element self.end[0]\n            # is about to be dropped by the deque. If that iteration\n            # should be kept because of some node that was recorded,\n            # add it to self.start\n            if len(self.end) >= self.side_len and self.end[0].keep:\n                self.start.append(self.end[0])\n\n            self.end.append(iteration)\n        iteration.index = self.length\n        self.length += 1"
        ],
        [
            "STORE_NAME",
            "    def __iter__(self):\n        # type: () -> Iterator[Iteration]\n        return chain(self.start, self.end)"
        ],
        [
            "STORE_NAME",
            "    def last(self):\n        # type: () -> Iteration\n        if self.end:\n            return self.end[-1]\n        else:\n            return self.start[-1]"
        ],
        [
            "STORE_NAME",
            "    def recorded_node(self, node):\n        # type: (ast.AST) -> None\n        if self.recorded[node] >= 2:\n            # We've already seen this node enough\n            return\n\n        # This node is new(ish), make sure we keep this iteration\n        self.last().keep = True\n        self.recorded[node] += 1"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.start"
        ],
        [
            "LOAD_GLOBAL",
            "deque"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.side_len"
        ],
        [
            "CALL",
            "deque(maxlen=self.side_len)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.end"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.length"
        ],
        [
            "LOAD_GLOBAL",
            "Counter"
        ],
        [
            "CALL",
            "Counter()"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.recorded"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.length"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.side_len"
        ],
        [
            "COMPARE_OP",
            "self.length < self.side_len"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.start"
        ],
        [
            "LOAD_METHOD",
            "self.start.append"
        ],
        [
            "LOAD_FAST",
            "iteration"
        ],
        [
            "CALL",
            "self.start.append(iteration)"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.end"
        ],
        [
            "CALL",
            "len(self.end)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.side_len"
        ],
        [
            "COMPARE_OP",
            "len(self.end) >= self.side_len"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.end"
        ],
        [
            "BINARY_SUBSCR",
            "self.end[0]"
        ],
        [
            "LOAD_ATTR",
            "self.end[0].keep"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.start"
        ],
        [
            "LOAD_METHOD",
            "self.start.append"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.end"
        ],
        [
            "BINARY_SUBSCR",
            "self.end[0]"
        ],
        [
            "CALL",
            "self.start.append(self.end[0])"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.end"
        ],
        [
            "LOAD_METHOD",
            "self.end.append"
        ],
        [
            "LOAD_FAST",
            "iteration"
        ],
        [
            "CALL",
            "self.end.append(iteration)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.length"
        ],
        [
            "LOAD_FAST",
            "iteration"
        ],
        [
            "STORE_ATTR",
            "iteration.index"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.length"
        ],
        [
            "BINARY_OP",
            "self.length += 1"
        ],
        [
            "STORE_ATTR",
            "self.length"
        ],
        [
            "LOAD_GLOBAL",
            "chain"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.start"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.end"
        ],
        [
            "CALL",
            "chain(self.start, self.end)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.end"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.end"
        ],
        [
            "BINARY_SUBSCR",
            "self.end[-1]"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.start"
        ],
        [
            "BINARY_SUBSCR",
            "self.start[-1]"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.recorded"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "BINARY_SUBSCR",
            "self.recorded[node]"
        ],
        [
            "COMPARE_OP",
            "self.recorded[node] >= 2"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.last"
        ],
        [
            "CALL",
            "self.last()"
        ],
        [
            "STORE_ATTR",
            "self.last().keep"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.recorded"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "BINARY_SUBSCR",
            "self.recorded[node]"
        ],
        [
            "BINARY_OP",
            "self.recorded[node] += 1"
        ],
        [
            "STORE_SUBSCR",
            "self.recorded[node]"
        ],
        [
            "LOAD_NAME",
            "type"
        ],
        [
            "CALL",
            "type(None)"
        ],
        [
            "LOAD_NAME",
            "bool"
        ],
        [
            "LOAD_NAME",
            "int"
        ],
        [
            "LOAD_NAME",
            "float"
        ],
        [
            "LOAD_NAME",
            "complex"
        ],
        [
            "STORE_NAME",
            "basic_types"
        ],
        [
            "LOAD_NAME",
            "PY2"
        ],
        [
            "LOAD_NAME",
            "basic_types"
        ],
        [
            "LOAD_NAME",
            "long"
        ],
        [
            "BINARY_OP",
            "basic_types += (long,)"
        ],
        [
            "STORE_NAME",
            "basic_types"
        ],
        [
            "LOAD_NAME",
            "basic_types"
        ],
        [
            "LOAD_NAME",
            "list"
        ],
        [
            "LOAD_NAME",
            "dict"
        ],
        [
            "LOAD_NAME",
            "tuple"
        ],
        [
            "LOAD_NAME",
            "set"
        ],
        [
            "LOAD_NAME",
            "frozenset"
        ],
        [
            "LOAD_NAME",
            "str"
        ],
        [
            "BINARY_OP",
            "basic_types + (list, dict, tuple, set, frozenset, str)"
        ],
        [
            "STORE_NAME",
            "special_types"
        ],
        [
            "LOAD_NAME",
            "PY2"
        ],
        [
            "LOAD_NAME",
            "special_types"
        ],
        [
            "LOAD_NAME",
            "PY2"
        ],
        [
            "LOAD_NAME",
            "unicode"
        ],
        [
            "LOAD_NAME",
            "bytes"
        ],
        [
            "BINARY_OP",
            "special_types += (unicode if PY2 else bytes,)"
        ],
        [
            "STORE_NAME",
            "special_types"
        ],
        [
            "LOAD_NAME",
            "len"
        ],
        [
            "LOAD_NAME",
            "special_types"
        ],
        [
            "CALL",
            "len(special_types)"
        ],
        [
            "STORE_NAME",
            "num_special_types"
        ],
        [
            "STORE_NAME",
            "    def __init__(self):\n        self.lock = Lock()\n        self.data = defaultdict(lambda: len(self.data))  # type: Dict[type, int]\n\n        for t in self.special_types:\n            _ = self.data[t]"
        ],
        [
            "STORE_NAME",
            "    def __getitem__(self, item):\n        t = correct_type(item)\n        with self.lock:\n            return self.data[t]"
        ],
        [
            "STORE_NAME",
            "    def names(self):\n        # type: () -> List[str]\n        rev = dict((v, k) for k, v in self.data.items())\n        return [safe_qualname(rev[i]) for i in range(len(rev))]"
        ],
        [
            "LOAD_GLOBAL",
            "Lock"
        ],
        [
            "CALL",
            "Lock()"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.lock"
        ],
        [
            "LOAD_GLOBAL",
            "defaultdict"
        ],
        [
            "CALL",
            "defaultdict(lambda: len(self.data))"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.data"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.special_types"
        ],
        [
            "STORE_FAST",
            "t"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.data"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "BINARY_SUBSCR",
            "self.data[t]"
        ],
        [
            "STORE_FAST",
            "_"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.data"
        ],
        [
            "CALL",
            "len(self.data)"
        ],
        [
            "LOAD_GLOBAL",
            "correct_type"
        ],
        [
            "LOAD_FAST",
            "item"
        ],
        [
            "CALL",
            "correct_type(item)"
        ],
        [
            "STORE_FAST",
            "t"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.lock"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.data"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "BINARY_SUBSCR",
            "self.data[t]"
        ],
        [
            "CALL",
            "        with self.lock:\n            return self.data[t]"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.data"
        ],
        [
            "LOAD_METHOD",
            "self.data.items"
        ],
        [
            "CALL",
            "self.data.items()"
        ],
        [
            "CALL",
            "((v, k) for k, v in self.data.items())"
        ],
        [
            "CALL",
            "dict((v, k) for k, v in self.data.items())"
        ],
        [
            "STORE_DEREF",
            "rev"
        ],
        [
            "LOAD_GLOBAL",
            "range"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_DEREF",
            "rev"
        ],
        [
            "CALL",
            "len(rev)"
        ],
        [
            "CALL",
            "range(len(rev))"
        ],
        [
            "CALL",
            "[safe_qualname(rev[i]) for i in range(len(rev))]"
        ],
        [
            "LOAD_FAST",
            "((v, k) for k, v in self.data.items())"
        ],
        [
            "STORE_FAST",
            "k"
        ],
        [
            "STORE_FAST",
            "v"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "LOAD_FAST",
            "k"
        ],
        [
            "LOAD_FAST",
            "[safe_qualname(rev[i]) for i in range(len(rev))]"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "LOAD_GLOBAL",
            "safe_qualname"
        ],
        [
            "LOAD_DEREF",
            "rev"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_SUBSCR",
            "rev[i]"
        ],
        [
            "CALL",
            "safe_qualname(rev[i])"
        ],
        [
            "STORE_NAME",
            "\"\"\"\n    The 'value' of a node during a particular iteration.\n    This can mean different things, see the classmethods.\n    Can also contain some metadata, including links to other calls.\n    \"\"\""
        ],
        [
            "STORE_NAME",
            "__slots__"
        ],
        [
            "STORE_NAME",
            "    def __init__(self, val_repr, type_index):\n        self.val_repr = val_repr  # type: str\n        self.type_index = type_index  # type: int\n        self.meta = None  # type: Optional[Dict[str, Any]]\n        self.children = None"
        ],
        [
            "STORE_NAME",
            "    def set_meta(self, key, value):\n        # type: (str, Any) -> None\n        self.meta = self.meta or {}\n        self.meta[key] = value"
        ],
        [
            "STORE_NAME",
            "    def add_child(self, samples, level, key, value):\n        # type: (dict, int, str, Any) -> None\n        self.children = self.children or []\n        self.children.append((key, NodeValue.expression(samples, value, level)))"
        ],
        [
            "STORE_NAME",
            "    def as_json(self):\n        result = [self.val_repr, self.type_index, self.meta or {}]  # type: list\n        if self.children:\n            result.extend(self.children)\n        return result"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def covered(cls):\n        \"\"\"\n        Represents a bit of code, usually a statement, that executed successfully but\n        doesn't have an actual value.\n        \"\"\"\n        return cls('', -2)"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def exception(cls, exc_value):\n        \"\"\"\n        Means that exc_value was raised by a node when executing, and not any inner node.\n        \"\"\"\n        return cls(exception_string(exc_value), -1)"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def expression(cls, samples, val, level):\n        # type: (dict, Any, int) -> NodeValue\n        \"\"\"\n        The value of an expression or one of its children, with attributes,\n        dictionary items, etc as children. Has a max depth of `level` levels.\n        \"\"\"\n        result = cls(cheap_repr(val), type_registry[val])\n        if isinstance(val, (TypeRegistry.basic_types, BirdsEye)):\n            return result\n\n        length = None\n        if not isinstance(val, QuerySet):  # len triggers a database query\n            try:\n                length = len(val)\n            except:\n                pass\n            else:\n                result.set_meta('len', length)\n\n        if isinstance(val, ModuleType):\n            level = min(level, 2)\n\n        add_child = partial(result.add_child, samples, level - 1)\n\n        if isinstance(val, (Series, ndarray)):\n            attrs = ['dtype']\n            if isinstance(val, ndarray):\n                attrs.append('shape')\n            for name in attrs:\n                try:\n                    attr = getattr(val, name)\n                except AttributeError:\n                    pass\n                else:\n                    add_child(name, attr)\n\n        if level >= 3 or level >= 2 and isinstance(val, Series):\n            sample_type = 'big'\n        else:\n            sample_type = 'small'\n\n        samples = samples[sample_type]\n\n        # Always expand DataFrames and Series regardless of level to\n        # make the table view of DataFrames work\n\n        if isinstance(val, DataFrame):\n            meta = {}\n            result.set_meta('dataframe', meta)\n\n            max_rows = samples['pandas_rows']\n            max_cols = samples['pandas_cols']\n\n            if length > max_rows + 2:\n                meta['row_break'] = max_rows // 2\n\n            columns = val.columns\n            num_cols = len(columns)\n            if num_cols > max_cols + 2:\n                meta['col_break'] = max_cols // 2\n\n            indices = set(_sample_indices(num_cols, max_cols))\n            for i, (formatted_name, label) in enumerate(zip(val.columns.format(sparsify=False),\n                                                            val.columns)):\n                if i in indices:\n                    add_child(formatted_name, val[label])\n\n            return result\n\n        if isinstance(val, Series):\n            for i in _sample_indices(length, samples['pandas_rows']):\n                try:\n                    k = val.index[i:i + 1].format(sparsify=False)[0]\n                    v = val.iloc[i]\n                except:\n                    pass\n                else:\n                    add_child(k, v)\n            return result\n\n        if (level <= 0 or\n                isinstance(val,\n                           (str, bytes, range)\n                           if PY3 else\n                           (str, unicode, xrange))):\n            return result\n\n        if isinstance(val, (Sequence, ndarray)) and length is not None:\n            for i in _sample_indices(length, samples['list']):\n                try:\n                    v = val[i]\n                except:\n                    pass\n                else:\n                    add_child(str(i), v)\n\n        if isinstance(val, Mapping):\n            for k, v in islice(_safe_iter(val, iteritems), samples['dict']):\n                add_child(cheap_repr(k), v)\n\n        if isinstance(val, Set):\n            vals = _safe_iter(val)\n            num_items = samples['set']\n            if length is None or length > num_items + 2:\n                vals = islice(vals, num_items)\n            for i, v in enumerate(vals):\n                add_child('<%s>' % i, v)\n\n        d = getattr(val, '__dict__', None)\n        if d:\n            for k in sorted(islice(_safe_iter(d),\n                                   samples['attributes']),\n                            key=str):\n                v = d[k]\n                if isinstance(v, TracedFile):\n                    continue\n                add_child(str(k), v)\n        else:\n            for s in sorted(getattr(type(val), '__slots__', None) or ()):\n                try:\n                    attr = getattr(val, s)\n                except AttributeError:\n                    pass\n                else:\n                    add_child(str(s), attr)\n        return result"
        ],
        [
            "LOAD_FAST",
            "val_repr"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.val_repr"
        ],
        [
            "LOAD_FAST",
            "type_index"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.type_index"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.meta"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.children"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.meta"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.meta"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.meta"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "STORE_SUBSCR",
            "self.meta[key]"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.children"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.children"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.children"
        ],
        [
            "LOAD_METHOD",
            "self.children.append"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "LOAD_GLOBAL",
            "NodeValue"
        ],
        [
            "LOAD_METHOD",
            "NodeValue.expression"
        ],
        [
            "LOAD_FAST",
            "samples"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "level"
        ],
        [
            "CALL",
            "NodeValue.expression(samples, value, level)"
        ],
        [
            "CALL",
            "self.children.append((key, NodeValue.expression(samples, value, level)))"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.val_repr"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.type_index"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.meta"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.children"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_METHOD",
            "result.extend"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.children"
        ],
        [
            "CALL",
            "result.extend(self.children)"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "CALL",
            "cls('', -2)"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_GLOBAL",
            "exception_string"
        ],
        [
            "LOAD_FAST",
            "exc_value"
        ],
        [
            "CALL",
            "exception_string(exc_value)"
        ],
        [
            "CALL",
            "cls(exception_string(exc_value), -1)"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_GLOBAL",
            "cheap_repr"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "CALL",
            "cheap_repr(val)"
        ],
        [
            "LOAD_GLOBAL",
            "type_registry"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "BINARY_SUBSCR",
            "type_registry[val]"
        ],
        [
            "CALL",
            "cls(cheap_repr(val), type_registry[val])"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_GLOBAL",
            "TypeRegistry"
        ],
        [
            "LOAD_ATTR",
            "TypeRegistry.basic_types"
        ],
        [
            "LOAD_GLOBAL",
            "BirdsEye"
        ],
        [
            "CALL",
            "isinstance(val, (TypeRegistry.basic_types, BirdsEye))"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "STORE_FAST",
            "length"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_GLOBAL",
            "QuerySet"
        ],
        [
            "CALL",
            "isinstance(val, QuerySet)"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "CALL",
            "len(val)"
        ],
        [
            "STORE_FAST",
            "length"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_METHOD",
            "result.set_meta"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "CALL",
            "result.set_meta('len', length)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_GLOBAL",
            "ModuleType"
        ],
        [
            "CALL",
            "isinstance(val, ModuleType)"
        ],
        [
            "LOAD_GLOBAL",
            "min"
        ],
        [
            "LOAD_FAST",
            "level"
        ],
        [
            "CALL",
            "min(level, 2)"
        ],
        [
            "STORE_FAST",
            "level"
        ],
        [
            "LOAD_GLOBAL",
            "partial"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_ATTR",
            "result.add_child"
        ],
        [
            "LOAD_FAST",
            "samples"
        ],
        [
            "LOAD_FAST",
            "level"
        ],
        [
            "BINARY_OP",
            "level - 1"
        ],
        [
            "CALL",
            "partial(result.add_child, samples, level - 1)"
        ],
        [
            "STORE_FAST",
            "add_child"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_GLOBAL",
            "Series"
        ],
        [
            "LOAD_GLOBAL",
            "ndarray"
        ],
        [
            "CALL",
            "isinstance(val, (Series, ndarray))"
        ],
        [
            "STORE_FAST",
            "attrs"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_GLOBAL",
            "ndarray"
        ],
        [
            "CALL",
            "isinstance(val, ndarray)"
        ],
        [
            "LOAD_FAST",
            "attrs"
        ],
        [
            "LOAD_METHOD",
            "attrs.append"
        ],
        [
            "CALL",
            "attrs.append('shape')"
        ],
        [
            "LOAD_FAST",
            "attrs"
        ],
        [
            "STORE_FAST",
            "name"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "CALL",
            "getattr(val, name)"
        ],
        [
            "STORE_FAST",
            "attr"
        ],
        [
            "LOAD_FAST",
            "add_child"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "attr"
        ],
        [
            "CALL",
            "add_child(name, attr)"
        ],
        [
            "LOAD_GLOBAL",
            "AttributeError"
        ],
        [
            "LOAD_FAST",
            "level"
        ],
        [
            "COMPARE_OP",
            "level >= 3"
        ],
        [
            "LOAD_FAST",
            "level"
        ],
        [
            "COMPARE_OP",
            "level >= 2"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_GLOBAL",
            "Series"
        ],
        [
            "CALL",
            "isinstance(val, Series)"
        ],
        [
            "STORE_FAST",
            "sample_type"
        ],
        [
            "STORE_FAST",
            "sample_type"
        ],
        [
            "LOAD_FAST",
            "samples"
        ],
        [
            "LOAD_FAST",
            "sample_type"
        ],
        [
            "BINARY_SUBSCR",
            "samples[sample_type]"
        ],
        [
            "STORE_FAST",
            "samples"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_GLOBAL",
            "DataFrame"
        ],
        [
            "CALL",
            "isinstance(val, DataFrame)"
        ],
        [
            "STORE_FAST",
            "meta"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_METHOD",
            "result.set_meta"
        ],
        [
            "LOAD_FAST",
            "meta"
        ],
        [
            "CALL",
            "result.set_meta('dataframe', meta)"
        ],
        [
            "LOAD_FAST",
            "samples"
        ],
        [
            "BINARY_SUBSCR",
            "samples['pandas_rows']"
        ],
        [
            "STORE_FAST",
            "max_rows"
        ],
        [
            "LOAD_FAST",
            "samples"
        ],
        [
            "BINARY_SUBSCR",
            "samples['pandas_cols']"
        ],
        [
            "STORE_FAST",
            "max_cols"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "LOAD_FAST",
            "max_rows"
        ],
        [
            "BINARY_OP",
            "max_rows + 2"
        ],
        [
            "COMPARE_OP",
            "length > max_rows + 2"
        ],
        [
            "LOAD_FAST",
            "max_rows"
        ],
        [
            "BINARY_OP",
            "max_rows // 2"
        ],
        [
            "LOAD_FAST",
            "meta"
        ],
        [
            "STORE_SUBSCR",
            "meta['row_break']"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_ATTR",
            "val.columns"
        ],
        [
            "STORE_FAST",
            "columns"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "columns"
        ],
        [
            "CALL",
            "len(columns)"
        ],
        [
            "STORE_FAST",
            "num_cols"
        ],
        [
            "LOAD_FAST",
            "num_cols"
        ],
        [
            "LOAD_FAST",
            "max_cols"
        ],
        [
            "BINARY_OP",
            "max_cols + 2"
        ],
        [
            "COMPARE_OP",
            "num_cols > max_cols + 2"
        ],
        [
            "LOAD_FAST",
            "max_cols"
        ],
        [
            "BINARY_OP",
            "max_cols // 2"
        ],
        [
            "LOAD_FAST",
            "meta"
        ],
        [
            "STORE_SUBSCR",
            "meta['col_break']"
        ],
        [
            "LOAD_GLOBAL",
            "set"
        ],
        [
            "LOAD_GLOBAL",
            "_sample_indices"
        ],
        [
            "LOAD_FAST",
            "num_cols"
        ],
        [
            "LOAD_FAST",
            "max_cols"
        ],
        [
            "CALL",
            "_sample_indices(num_cols, max_cols)"
        ],
        [
            "CALL",
            "set(_sample_indices(num_cols, max_cols))"
        ],
        [
            "STORE_FAST",
            "indices"
        ],
        [
            "LOAD_GLOBAL",
            "enumerate"
        ],
        [
            "LOAD_GLOBAL",
            "zip"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_ATTR",
            "val.columns"
        ],
        [
            "LOAD_METHOD",
            "val.columns.format"
        ],
        [
            "CALL",
            "val.columns.format(sparsify=False)"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_ATTR",
            "val.columns"
        ],
        [
            "CALL",
            "zip(val.columns.format(sparsify=False),\n                                                            val.columns)"
        ],
        [
            "CALL",
            "enumerate(zip(val.columns.format(sparsify=False),\n                                                            val.columns))"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "STORE_FAST",
            "formatted_name"
        ],
        [
            "STORE_FAST",
            "label"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "indices"
        ],
        [
            "CONTAINS_OP",
            "i in indices"
        ],
        [
            "LOAD_FAST",
            "add_child"
        ],
        [
            "LOAD_FAST",
            "formatted_name"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_FAST",
            "label"
        ],
        [
            "BINARY_SUBSCR",
            "val[label]"
        ],
        [
            "CALL",
            "add_child(formatted_name, val[label])"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_GLOBAL",
            "Series"
        ],
        [
            "CALL",
            "isinstance(val, Series)"
        ],
        [
            "LOAD_GLOBAL",
            "_sample_indices"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "LOAD_FAST",
            "samples"
        ],
        [
            "BINARY_SUBSCR",
            "samples['pandas_rows']"
        ],
        [
            "CALL",
            "_sample_indices(length, samples['pandas_rows'])"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_ATTR",
            "val.index"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_OP",
            "i + 1"
        ],
        [
            "BINARY_SUBSCR",
            "val.index[i:i + 1]"
        ],
        [
            "LOAD_METHOD",
            "val.index[i:i + 1].format"
        ],
        [
            "CALL",
            "val.index[i:i + 1].format(sparsify=False)"
        ],
        [
            "BINARY_SUBSCR",
            "val.index[i:i + 1].format(sparsify=False)[0]"
        ],
        [
            "STORE_FAST",
            "k"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_ATTR",
            "val.iloc"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_SUBSCR",
            "val.iloc[i]"
        ],
        [
            "STORE_FAST",
            "v"
        ],
        [
            "LOAD_FAST",
            "add_child"
        ],
        [
            "LOAD_FAST",
            "k"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "CALL",
            "add_child(k, v)"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "level"
        ],
        [
            "COMPARE_OP",
            "level <= 0"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_GLOBAL",
            "PY3"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_GLOBAL",
            "bytes"
        ],
        [
            "LOAD_GLOBAL",
            "range"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_GLOBAL",
            "unicode"
        ],
        [
            "LOAD_GLOBAL",
            "xrange"
        ],
        [
            "CALL",
            "isinstance(val,\n                           (str, bytes, range)\n                           if PY3 else\n                           (str, unicode, xrange))"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_GLOBAL",
            "Sequence"
        ],
        [
            "LOAD_GLOBAL",
            "ndarray"
        ],
        [
            "CALL",
            "isinstance(val, (Sequence, ndarray))"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "LOAD_GLOBAL",
            "_sample_indices"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "LOAD_FAST",
            "samples"
        ],
        [
            "BINARY_SUBSCR",
            "samples['list']"
        ],
        [
            "CALL",
            "_sample_indices(length, samples['list'])"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_SUBSCR",
            "val[i]"
        ],
        [
            "STORE_FAST",
            "v"
        ],
        [
            "LOAD_FAST",
            "add_child"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "CALL",
            "str(i)"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "CALL",
            "add_child(str(i), v)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_GLOBAL",
            "Mapping"
        ],
        [
            "CALL",
            "isinstance(val, Mapping)"
        ],
        [
            "LOAD_GLOBAL",
            "islice"
        ],
        [
            "LOAD_GLOBAL",
            "_safe_iter"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_GLOBAL",
            "iteritems"
        ],
        [
            "CALL",
            "_safe_iter(val, iteritems)"
        ],
        [
            "LOAD_FAST",
            "samples"
        ],
        [
            "BINARY_SUBSCR",
            "samples['dict']"
        ],
        [
            "CALL",
            "islice(_safe_iter(val, iteritems), samples['dict'])"
        ],
        [
            "STORE_FAST",
            "k"
        ],
        [
            "STORE_FAST",
            "v"
        ],
        [
            "LOAD_FAST",
            "add_child"
        ],
        [
            "LOAD_GLOBAL",
            "cheap_repr"
        ],
        [
            "LOAD_FAST",
            "k"
        ],
        [
            "CALL",
            "cheap_repr(k)"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "CALL",
            "add_child(cheap_repr(k), v)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_GLOBAL",
            "Set"
        ],
        [
            "CALL",
            "isinstance(val, Set)"
        ],
        [
            "LOAD_GLOBAL",
            "_safe_iter"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "CALL",
            "_safe_iter(val)"
        ],
        [
            "STORE_FAST",
            "vals"
        ],
        [
            "LOAD_FAST",
            "samples"
        ],
        [
            "BINARY_SUBSCR",
            "samples['set']"
        ],
        [
            "STORE_FAST",
            "num_items"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "LOAD_FAST",
            "num_items"
        ],
        [
            "BINARY_OP",
            "num_items + 2"
        ],
        [
            "COMPARE_OP",
            "length > num_items + 2"
        ],
        [
            "LOAD_GLOBAL",
            "islice"
        ],
        [
            "LOAD_FAST",
            "vals"
        ],
        [
            "LOAD_FAST",
            "num_items"
        ],
        [
            "CALL",
            "islice(vals, num_items)"
        ],
        [
            "STORE_FAST",
            "vals"
        ],
        [
            "LOAD_GLOBAL",
            "enumerate"
        ],
        [
            "LOAD_FAST",
            "vals"
        ],
        [
            "CALL",
            "enumerate(vals)"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "STORE_FAST",
            "v"
        ],
        [
            "LOAD_FAST",
            "add_child"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_OP",
            "'<%s>' % i"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "CALL",
            "add_child('<%s>' % i, v)"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "CALL",
            "getattr(val, '__dict__', None)"
        ],
        [
            "STORE_FAST",
            "d"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "LOAD_GLOBAL",
            "sorted"
        ],
        [
            "LOAD_GLOBAL",
            "islice"
        ],
        [
            "LOAD_GLOBAL",
            "_safe_iter"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "CALL",
            "_safe_iter(d)"
        ],
        [
            "LOAD_FAST",
            "samples"
        ],
        [
            "BINARY_SUBSCR",
            "samples['attributes']"
        ],
        [
            "CALL",
            "islice(_safe_iter(d),\n                                   samples['attributes'])"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "CALL",
            "sorted(islice(_safe_iter(d),\n                                   samples['attributes']),\n                            key=str)"
        ],
        [
            "STORE_FAST",
            "k"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "LOAD_FAST",
            "k"
        ],
        [
            "BINARY_SUBSCR",
            "d[k]"
        ],
        [
            "STORE_FAST",
            "v"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "LOAD_GLOBAL",
            "TracedFile"
        ],
        [
            "CALL",
            "isinstance(v, TracedFile)"
        ],
        [
            "LOAD_FAST",
            "add_child"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_FAST",
            "k"
        ],
        [
            "CALL",
            "str(k)"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "CALL",
            "add_child(str(k), v)"
        ],
        [
            "LOAD_GLOBAL",
            "sorted"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_GLOBAL",
            "type"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "CALL",
            "type(val)"
        ],
        [
            "CALL",
            "getattr(type(val), '__slots__', None)"
        ],
        [
            "CALL",
            "sorted(getattr(type(val), '__slots__', None) or ())"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "CALL",
            "getattr(val, s)"
        ],
        [
            "STORE_FAST",
            "attr"
        ],
        [
            "LOAD_FAST",
            "add_child"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "CALL",
            "str(s)"
        ],
        [
            "LOAD_FAST",
            "attr"
        ],
        [
            "CALL",
            "add_child(str(s), attr)"
        ],
        [
            "LOAD_GLOBAL",
            "AttributeError"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_FAST",
            "f"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "CALL",
            "f(val)"
        ],
        [
            "STORE_FAST",
            "x"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "LOAD_FAST",
            "max_length"
        ],
        [
            "BINARY_OP",
            "max_length + 2"
        ],
        [
            "COMPARE_OP",
            "length <= max_length + 2"
        ],
        [
            "LOAD_GLOBAL",
            "range"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "CALL",
            "range(length)"
        ],
        [
            "LOAD_GLOBAL",
            "chain"
        ],
        [
            "LOAD_GLOBAL",
            "range"
        ],
        [
            "LOAD_FAST",
            "max_length"
        ],
        [
            "BINARY_OP",
            "max_length // 2"
        ],
        [
            "CALL",
            "range(max_length // 2)"
        ],
        [
            "LOAD_GLOBAL",
            "range"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "LOAD_FAST",
            "max_length"
        ],
        [
            "BINARY_OP",
            "max_length // 2"
        ],
        [
            "BINARY_OP",
            "length - max_length // 2"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "CALL",
            "range(length - max_length // 2,\n                           length)"
        ],
        [
            "CALL",
            "chain(range(max_length // 2),\n                     range(length - max_length // 2,\n                           length))"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "len(x)"
        ],
        [
            "STORE_FAST",
            "n"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "COMPARE_OP",
            "n == 0"
        ],
        [
            "LOAD_GLOBAL",
            "repr"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "repr(x)"
        ],
        [
            "LOAD_FAST",
            "helper"
        ],
        [
            "LOAD_ATTR",
            "helper.level"
        ],
        [
            "BINARY_OP",
            "helper.level - 1"
        ],
        [
            "STORE_FAST",
            "newlevel"
        ],
        [
            "STORE_FAST",
            "pieces"
        ],
        [
            "LOAD_GLOBAL",
            "_repr_series_one_line"
        ],
        [
            "LOAD_ATTR",
            "_repr_series_one_line.maxparts"
        ],
        [
            "STORE_FAST",
            "maxparts"
        ],
        [
            "LOAD_GLOBAL",
            "_sample_indices"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "LOAD_FAST",
            "maxparts"
        ],
        [
            "CALL",
            "_sample_indices(n, maxparts)"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_ATTR",
            "x.index"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_OP",
            "i + 1"
        ],
        [
            "BINARY_SUBSCR",
            "x.index[i:i + 1]"
        ],
        [
            "LOAD_METHOD",
            "x.index[i:i + 1].format"
        ],
        [
            "CALL",
            "x.index[i:i + 1].format(sparsify=False)"
        ],
        [
            "BINARY_SUBSCR",
            "x.index[i:i + 1].format(sparsify=False)[0]"
        ],
        [
            "STORE_FAST",
            "k"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_ATTR",
            "x.iloc"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_SUBSCR",
            "x.iloc[i]"
        ],
        [
            "STORE_FAST",
            "v"
        ],
        [
            "LOAD_FAST",
            "pieces"
        ],
        [
            "LOAD_METHOD",
            "pieces.append"
        ],
        [
            "LOAD_FAST",
            "k"
        ],
        [
            "LOAD_GLOBAL",
            "cheap_repr"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "LOAD_FAST",
            "newlevel"
        ],
        [
            "CALL",
            "cheap_repr(v, newlevel)"
        ],
        [
            "BUILD_STRING",
            "'%s = %s' % (k, cheap_repr(v, newlevel))"
        ],
        [
            "CALL",
            "pieces.append('%s = %s' % (k, cheap_repr(v, newlevel)))"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "LOAD_FAST",
            "maxparts"
        ],
        [
            "BINARY_OP",
            "maxparts + 2"
        ],
        [
            "COMPARE_OP",
            "n > maxparts + 2"
        ],
        [
            "LOAD_FAST",
            "pieces"
        ],
        [
            "LOAD_METHOD",
            "pieces.insert"
        ],
        [
            "LOAD_FAST",
            "maxparts"
        ],
        [
            "BINARY_OP",
            "maxparts // 2"
        ],
        [
            "CALL",
            "pieces.insert(maxparts // 2, '...')"
        ],
        [
            "LOAD_METHOD",
            "'; '.join"
        ],
        [
            "LOAD_FAST",
            "pieces"
        ],
        [
            "CALL",
            "'; '.join(pieces)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.expr"
        ],
        [
            "CALL",
            "isinstance(node, ast.expr)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Num"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Str"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "CALL",
            "getattr(ast, 'NameConstant', ())"
        ],
        [
            "CALL",
            "isinstance(node, (ast.Num, ast.Str, getattr(ast, 'NameConstant', ())))"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "getattr(node, 'ctx', None)"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Store"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Del"
        ],
        [
            "CALL",
            "isinstance(getattr(node, 'ctx', None),\n                            (ast.Store, ast.Del))"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.UnaryOp"
        ],
        [
            "CALL",
            "isinstance(node, ast.UnaryOp)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.op"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.UAdd"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.USub"
        ],
        [
            "CALL",
            "isinstance(node.op, (ast.UAdd, ast.USub))"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.operand"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Num"
        ],
        [
            "CALL",
            "isinstance(node.operand, ast.Num)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.List"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Tuple"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Dict"
        ],
        [
            "CALL",
            "isinstance(node, (ast.List, ast.Tuple, ast.Dict))"
        ],
        [
            "LOAD_GLOBAL",
            "any"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.iter_child_nodes"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "ast.iter_child_nodes(node)"
        ],
        [
            "CALL",
            "(is_interesting_expression(n) for n in ast.iter_child_nodes(node))"
        ],
        [
            "CALL",
            "any(is_interesting_expression(n) for n in ast.iter_child_nodes(node))"
        ],
        [
            "UNARY_NOT",
            "not any(is_interesting_expression(n) for n in ast.iter_child_nodes(node))"
        ],
        [
            "UNARY_NOT",
            "not (isinstance(node, (ast.Num, ast.Str, getattr(ast, 'NameConstant', ()))) or\n                 isinstance(getattr(node, 'ctx', None),\n                            (ast.Store, ast.Del)) or\n                 (isinstance(node, ast.UnaryOp) and\n                  isinstance(node.op, (ast.UAdd, ast.USub)) and\n                  isinstance(node.operand, ast.Num)) or\n                 (isinstance(node, (ast.List, ast.Tuple, ast.Dict)) and\n                  not any(is_interesting_expression(n) for n in ast.iter_child_nodes(node))))"
        ],
        [
            "LOAD_FAST",
            "(is_interesting_expression(n) for n in ast.iter_child_nodes(node))"
        ],
        [
            "STORE_FAST",
            "n"
        ],
        [
            "LOAD_GLOBAL",
            "is_interesting_expression"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "CALL",
            "is_interesting_expression(n)"
        ],
        [
            "LOAD_GLOBAL",
            "cast"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_GLOBAL",
            "__builtins__"
        ],
        [
            "CALL",
            "cast(dict, __builtins__)"
        ],
        [
            "STORE_FAST",
            "builtins"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Name"
        ],
        [
            "CALL",
            "isinstance(node, ast.Name)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.id"
        ],
        [
            "LOAD_FAST",
            "builtins"
        ],
        [
            "CONTAINS_OP",
            "node.id in builtins"
        ],
        [
            "LOAD_FAST",
            "builtins"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.id"
        ],
        [
            "BINARY_SUBSCR",
            "builtins[node.id]"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "IS_OP",
            "builtins[node.id] is value"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "CALL",
            "getattr(ast, 'NameConstant', ())"
        ],
        [
            "CALL",
            "isinstance(node, getattr(ast, 'NameConstant', ()))"
        ]
    ],
    "configuration.py": [
        [
            "STORE_NAME",
            "import inspect"
        ],
        [
            "STORE_NAME",
            "import os"
        ],
        [
            "STORE_NAME",
            "import sys"
        ],
        [
            "STORE_NAME",
            "import threading"
        ],
        [
            "STORE_NAME",
            "from collections import Set, Mapping, Sequence"
        ],
        [
            "STORE_NAME",
            "from collections import Set, Mapping, Sequence"
        ],
        [
            "STORE_NAME",
            "from collections import Set, Mapping, Sequence"
        ],
        [
            "STORE_NAME",
            "from io import open"
        ],
        [
            "STORE_NAME",
            "import six"
        ],
        [
            "STORE_NAME",
            "import snoop as package"
        ],
        [
            "STORE_NAME",
            "from snoop.formatting import DefaultFormatter"
        ],
        [
            "STORE_NAME",
            "from snoop.pp_module import PP"
        ],
        [
            "STORE_NAME",
            "from snoop.tracer import Spy, Tracer"
        ],
        [
            "STORE_NAME",
            "from snoop.tracer import Spy, Tracer"
        ],
        [
            "STORE_NAME",
            "from snoop.utils import builtins as builtins_module, is_pathlike, shitcode, ensure_tuple, QuerySet"
        ],
        [
            "STORE_NAME",
            "from snoop.utils import builtins as builtins_module, is_pathlike, shitcode, ensure_tuple, QuerySet"
        ],
        [
            "STORE_NAME",
            "from snoop.utils import builtins as builtins_module, is_pathlike, shitcode, ensure_tuple, QuerySet"
        ],
        [
            "STORE_NAME",
            "from snoop.utils import builtins as builtins_module, is_pathlike, shitcode, ensure_tuple, QuerySet"
        ],
        [
            "STORE_NAME",
            "from snoop.utils import builtins as builtins_module, is_pathlike, shitcode, ensure_tuple, QuerySet"
        ],
        [
            "STORE_NAME",
            "import ctypes"
        ],
        [
            "LOAD_NAME",
            "ctypes"
        ],
        [
            "LOAD_ATTR",
            "ctypes.windll"
        ],
        [
            "LOAD_ATTR",
            "ctypes.windll.kernel32"
        ],
        [
            "STORE_NAME",
            "kernel32"
        ],
        [
            "LOAD_NAME",
            "kernel32"
        ],
        [
            "LOAD_METHOD",
            "kernel32.SetConsoleMode"
        ],
        [
            "LOAD_NAME",
            "kernel32"
        ],
        [
            "LOAD_METHOD",
            "kernel32.GetStdHandle"
        ],
        [
            "CALL",
            "kernel32.GetStdHandle(-11)"
        ],
        [
            "CALL",
            "kernel32.SetConsoleMode(kernel32.GetStdHandle(-11), 7)"
        ],
        [
            "STORE_NAME",
            "can_color"
        ],
        [
            "LOAD_NAME",
            "Exception"
        ],
        [
            "LOAD_NAME",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.name"
        ],
        [
            "COMPARE_OP",
            "os.name != 'nt'"
        ],
        [
            "STORE_NAME",
            "can_color"
        ],
        [
            "LOAD_NAME",
            "DefaultFormatter"
        ],
        [
            "STORE_NAME",
            "def install(\n        builtins=True,\n        snoop=\"snoop\",\n        pp=\"pp\",\n        spy=\"spy\",\n        out=None,\n        prefix='',\n        columns='time',\n        overwrite=False,\n        color=None,\n        enabled=True,\n        watch_extras=(),\n        replace_watch_extras=None,\n        formatter_class=DefaultFormatter,\n):\n    \"\"\"\n    Configure output, enable or disable, and add names to builtins. Parameters:\n    \n    - builtins: set to False to not add any names to builtins,\n        so importing will still be required.\n    - snoop, pp, and spy: set to other strings \n        to choose the names of these functions in builtins\n    - `out`: determines the output destination. By default this is stderr. You can also pass:\n        - A string or a `Path` object to write to a file at that location. By default this always will append to the file. Pass `overwrite=True` to clear the file initially.\n        - Anything with a `write` method, e.g. `sys.stdout` or a file object.\n        - Any callable with a single string argument, e.g. `logger.info`.\n    - `color`: determines whether the output includes escape characters to display colored text in the console. If you see weird characters in your output, your console doesn't support colors, so pass `color=False`.\n        - Code is syntax highlighted using [Pygments](http://pygments.org/), and this argument is passed as the style. You can choose a different color scheme by passing a string naming a style (see [this gallery](https://help.farbox.com/pygments.html)) or a style class. The default style is monokai.   \n        - By default this parameter is set to `out.isatty()`, which is usually true for stdout and stderr but will be false if they are redirected or piped. Pass `True` or a style if you want to force coloring.\n        - To see colors in the PyCharm Run window, edit the Run Configuration and tick \"Emulate terminal in output console\".\n    - `prefix`: Pass a string to start all snoop lines with that string so you can grep for them easily.\n    - `columns`: This specifies the columns at the start of each output line. You can pass a string with the names of built in columns separated by spaces or commas. These are the available columns:\n        - `time`: The current time. This is the only column by default.\n        - `thread`: The name of the current thread.  \n        - `thread_ident`: The [identifier](https://docs.python.org/3/library/threading.html#threading.Thread.ident) of the current thread, in case thread names are not unique.\n        - `file`: The filename (not the full path) of the current function.\n        - `full_file`: The full path to the file (also shown anyway when the function is called).\n        - `function`: The name of the current function.\n        - `function_qualname`: The qualified name of the current function.\n        \n        If you want a custom column, please open an issue to tell me what you're interested in! In the meantime, you can pass a list, where the elements are either strings or callables. The callables should take one argument, which will be an `Event` object. It has attributes `frame`, `event`, and `arg`, as specified in [`sys.settrace()`](https://docs.python.org/3/library/sys.html#sys.settrace), and other attributes which may change. \n    \"\"\"\n    \n    if builtins:\n        setattr(builtins_module, snoop, package.snoop)\n        setattr(builtins_module, pp, package.pp)\n        setattr(builtins_module, spy, package.spy)\n    config = Config(\n        out=out,\n        prefix=prefix,\n        columns=columns,\n        overwrite=overwrite,\n        color=color,\n        enabled=enabled,\n        watch_extras=watch_extras,\n        replace_watch_extras=replace_watch_extras,\n        formatter_class=formatter_class,\n    )\n    package.snoop.config = config\n    package.pp.config = config\n    package.spy.config = config"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class Config(object):\n    \"\"\"\"\n    If you need more control than the global `install` function, e.g. if you want to write to several different files in one process, you can create a `Config` object, e.g: `config = snoop.Config(out=filename)`. Then `config.snoop`, `config.pp` and `config.spy` will use that configuration rather than the global one.\n    \n    The arguments are the same as the arguments of `install()` relating to output configuration and `enabled`.\n    \"\"\"\n    \n    def __init__(\n            self,\n            out=None,\n            prefix='',\n            columns='time',\n            overwrite=False,\n            color=None,\n            enabled=True,\n            watch_extras=(),\n            replace_watch_extras=None,\n            formatter_class=DefaultFormatter,\n    ):\n        if can_color:\n            if color is None:\n                isatty = getattr(out or sys.stderr, 'isatty', lambda: False)\n                color = bool(isatty())\n        else:\n            color = False\n\n        self.write = get_write_function(out, overwrite)\n        self.formatter = formatter_class(prefix, columns, color)\n        self.enabled = enabled\n        self.pp = PP(self)\n\n        class ConfiguredTracer(Tracer):\n            config = self\n\n        self.snoop = ConfiguredTracer\n        self.spy = Spy(self)\n\n        self.last_frame = None\n        self.thread_local = threading.local()\n\n        if replace_watch_extras is not None:\n            self.watch_extras = ensure_tuple(replace_watch_extras)\n        else:\n            self.watch_extras = (len_shape_watch, dtype_watch) + ensure_tuple(watch_extras)"
        ],
        [
            "STORE_NAME",
            "class Config(object):\n    \"\"\"\"\n    If you need more control than the global `install` function, e.g. if you want to write to several different files in one process, you can create a `Config` object, e.g: `config = snoop.Config(out=filename)`. Then `config.snoop`, `config.pp` and `config.spy` will use that configuration rather than the global one.\n    \n    The arguments are the same as the arguments of `install()` relating to output configuration and `enabled`.\n    \"\"\"\n    \n    def __init__(\n            self,\n            out=None,\n            prefix='',\n            columns='time',\n            overwrite=False,\n            color=None,\n            enabled=True,\n            watch_extras=(),\n            replace_watch_extras=None,\n            formatter_class=DefaultFormatter,\n    ):\n        if can_color:\n            if color is None:\n                isatty = getattr(out or sys.stderr, 'isatty', lambda: False)\n                color = bool(isatty())\n        else:\n            color = False\n\n        self.write = get_write_function(out, overwrite)\n        self.formatter = formatter_class(prefix, columns, color)\n        self.enabled = enabled\n        self.pp = PP(self)\n\n        class ConfiguredTracer(Tracer):\n            config = self\n\n        self.snoop = ConfiguredTracer\n        self.spy = Spy(self)\n\n        self.last_frame = None\n        self.thread_local = threading.local()\n\n        if replace_watch_extras is not None:\n            self.watch_extras = ensure_tuple(replace_watch_extras)\n        else:\n            self.watch_extras = (len_shape_watch, dtype_watch) + ensure_tuple(watch_extras)"
        ],
        [
            "STORE_NAME",
            "def len_shape_watch(source, value):\n    try:\n        shape = value.shape\n    except Exception:\n        pass\n    else:\n        if not inspect.ismethod(shape):\n            return '{}.shape'.format(source), shape\n\n    if isinstance(value, QuerySet):\n        # Getting the length of a Django queryset evaluates it\n        return None\n\n    length = len(value)\n    if (\n            (isinstance(value, six.string_types)\n             and length < 50) or\n            (isinstance(value, (Mapping, Set, Sequence))\n             and length == 0)\n    ):\n        return None\n\n    return 'len({})'.format(source), length"
        ],
        [
            "STORE_NAME",
            "def dtype_watch(source, value):\n    dtype = value.dtype\n    if not inspect.ismethod(dtype):\n        return '{}.dtype'.format(source), dtype"
        ],
        [
            "STORE_NAME",
            "def get_write_function(output, overwrite):\n    is_path = (\n        isinstance(output, six.string_types)\n        or is_pathlike(output)\n    )\n    if is_path:\n        return FileWriter(output, overwrite).write\n    elif callable(output):\n        write = output\n    else:\n        def write(s):\n            stream = output\n\n            if stream is None:\n                stream = sys.stderr\n\n            try:\n                stream.write(s)\n            except UnicodeEncodeError:\n                # God damn Python 2\n                stream.write(shitcode(s))\n    return write"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class FileWriter(object):\n    def __init__(self, path, overwrite):\n        self.path = six.text_type(path)\n        self.overwrite = overwrite\n\n    def write(self, s):\n        with open(self.path, 'w' if self.overwrite else 'a', encoding='utf-8') as f:\n            f.write(s)\n        self.overwrite = False"
        ],
        [
            "STORE_NAME",
            "class FileWriter(object):\n    def __init__(self, path, overwrite):\n        self.path = six.text_type(path)\n        self.overwrite = overwrite\n\n    def write(self, s):\n        with open(self.path, 'w' if self.overwrite else 'a', encoding='utf-8') as f:\n            f.write(s)\n        self.overwrite = False"
        ],
        [
            "LOAD_FAST",
            "builtins"
        ],
        [
            "LOAD_GLOBAL",
            "setattr"
        ],
        [
            "LOAD_GLOBAL",
            "builtins_module"
        ],
        [
            "LOAD_FAST",
            "snoop"
        ],
        [
            "LOAD_GLOBAL",
            "package"
        ],
        [
            "LOAD_ATTR",
            "package.snoop"
        ],
        [
            "CALL",
            "setattr(builtins_module, snoop, package.snoop)"
        ],
        [
            "LOAD_GLOBAL",
            "setattr"
        ],
        [
            "LOAD_GLOBAL",
            "builtins_module"
        ],
        [
            "LOAD_FAST",
            "pp"
        ],
        [
            "LOAD_GLOBAL",
            "package"
        ],
        [
            "LOAD_ATTR",
            "package.pp"
        ],
        [
            "CALL",
            "setattr(builtins_module, pp, package.pp)"
        ],
        [
            "LOAD_GLOBAL",
            "setattr"
        ],
        [
            "LOAD_GLOBAL",
            "builtins_module"
        ],
        [
            "LOAD_FAST",
            "spy"
        ],
        [
            "LOAD_GLOBAL",
            "package"
        ],
        [
            "LOAD_ATTR",
            "package.spy"
        ],
        [
            "CALL",
            "setattr(builtins_module, spy, package.spy)"
        ],
        [
            "LOAD_GLOBAL",
            "Config"
        ],
        [
            "LOAD_FAST",
            "out"
        ],
        [
            "LOAD_FAST",
            "prefix"
        ],
        [
            "LOAD_FAST",
            "columns"
        ],
        [
            "LOAD_FAST",
            "overwrite"
        ],
        [
            "LOAD_FAST",
            "color"
        ],
        [
            "LOAD_FAST",
            "enabled"
        ],
        [
            "LOAD_FAST",
            "watch_extras"
        ],
        [
            "LOAD_FAST",
            "replace_watch_extras"
        ],
        [
            "LOAD_FAST",
            "formatter_class"
        ],
        [
            "CALL",
            "Config(\n        out=out,\n        prefix=prefix,\n        columns=columns,\n        overwrite=overwrite,\n        color=color,\n        enabled=enabled,\n        watch_extras=watch_extras,\n        replace_watch_extras=replace_watch_extras,\n        formatter_class=formatter_class,\n    )"
        ],
        [
            "STORE_FAST",
            "config"
        ],
        [
            "LOAD_FAST",
            "config"
        ],
        [
            "LOAD_GLOBAL",
            "package"
        ],
        [
            "LOAD_ATTR",
            "package.snoop"
        ],
        [
            "STORE_ATTR",
            "package.snoop.config"
        ],
        [
            "LOAD_FAST",
            "config"
        ],
        [
            "LOAD_GLOBAL",
            "package"
        ],
        [
            "LOAD_ATTR",
            "package.pp"
        ],
        [
            "STORE_ATTR",
            "package.pp.config"
        ],
        [
            "LOAD_FAST",
            "config"
        ],
        [
            "LOAD_GLOBAL",
            "package"
        ],
        [
            "LOAD_ATTR",
            "package.spy"
        ],
        [
            "STORE_ATTR",
            "package.spy.config"
        ],
        [
            "STORE_NAME",
            "\"\"\"\"\n    If you need more control than the global `install` function, e.g. if you want to write to several different files in one process, you can create a `Config` object, e.g: `config = snoop.Config(out=filename)`. Then `config.snoop`, `config.pp` and `config.spy` will use that configuration rather than the global one.\n    \n    The arguments are the same as the arguments of `install()` relating to output configuration and `enabled`.\n    \"\"\""
        ],
        [
            "LOAD_NAME",
            "DefaultFormatter"
        ],
        [
            "STORE_NAME",
            "    def __init__(\n            self,\n            out=None,\n            prefix='',\n            columns='time',\n            overwrite=False,\n            color=None,\n            enabled=True,\n            watch_extras=(),\n            replace_watch_extras=None,\n            formatter_class=DefaultFormatter,\n    ):\n        if can_color:\n            if color is None:\n                isatty = getattr(out or sys.stderr, 'isatty', lambda: False)\n                color = bool(isatty())\n        else:\n            color = False\n\n        self.write = get_write_function(out, overwrite)\n        self.formatter = formatter_class(prefix, columns, color)\n        self.enabled = enabled\n        self.pp = PP(self)\n\n        class ConfiguredTracer(Tracer):\n            config = self\n\n        self.snoop = ConfiguredTracer\n        self.spy = Spy(self)\n\n        self.last_frame = None\n        self.thread_local = threading.local()\n\n        if replace_watch_extras is not None:\n            self.watch_extras = ensure_tuple(replace_watch_extras)\n        else:\n            self.watch_extras = (len_shape_watch, dtype_watch) + ensure_tuple(watch_extras)"
        ],
        [
            "LOAD_GLOBAL",
            "can_color"
        ],
        [
            "LOAD_FAST",
            "color"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_FAST",
            "out"
        ],
        [
            "LOAD_GLOBAL",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.stderr"
        ],
        [
            "CALL",
            "getattr(out or sys.stderr, 'isatty', lambda: False)"
        ],
        [
            "STORE_FAST",
            "isatty"
        ],
        [
            "LOAD_GLOBAL",
            "bool"
        ],
        [
            "LOAD_FAST",
            "isatty"
        ],
        [
            "CALL",
            "isatty()"
        ],
        [
            "CALL",
            "bool(isatty())"
        ],
        [
            "STORE_FAST",
            "color"
        ],
        [
            "STORE_FAST",
            "color"
        ],
        [
            "LOAD_GLOBAL",
            "get_write_function"
        ],
        [
            "LOAD_FAST",
            "out"
        ],
        [
            "LOAD_FAST",
            "overwrite"
        ],
        [
            "CALL",
            "get_write_function(out, overwrite)"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.write"
        ],
        [
            "LOAD_FAST",
            "formatter_class"
        ],
        [
            "LOAD_FAST",
            "prefix"
        ],
        [
            "LOAD_FAST",
            "columns"
        ],
        [
            "LOAD_FAST",
            "color"
        ],
        [
            "CALL",
            "formatter_class(prefix, columns, color)"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.formatter"
        ],
        [
            "LOAD_FAST",
            "enabled"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.enabled"
        ],
        [
            "LOAD_GLOBAL",
            "PP"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "CALL",
            "PP(self)"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.pp"
        ],
        [
            "LOAD_GLOBAL",
            "Tracer"
        ],
        [
            "CALL",
            "        class ConfiguredTracer(Tracer):\n            config = self"
        ],
        [
            "STORE_FAST",
            "        class ConfiguredTracer(Tracer):\n            config = self"
        ],
        [
            "LOAD_FAST",
            "ConfiguredTracer"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.snoop"
        ],
        [
            "LOAD_GLOBAL",
            "Spy"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "CALL",
            "Spy(self)"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.spy"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.last_frame"
        ],
        [
            "LOAD_GLOBAL",
            "threading"
        ],
        [
            "LOAD_ATTR",
            "threading.local"
        ],
        [
            "CALL",
            "threading.local()"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.thread_local"
        ],
        [
            "LOAD_FAST",
            "replace_watch_extras"
        ],
        [
            "LOAD_GLOBAL",
            "ensure_tuple"
        ],
        [
            "LOAD_FAST",
            "replace_watch_extras"
        ],
        [
            "CALL",
            "ensure_tuple(replace_watch_extras)"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.watch_extras"
        ],
        [
            "LOAD_GLOBAL",
            "len_shape_watch"
        ],
        [
            "LOAD_GLOBAL",
            "dtype_watch"
        ],
        [
            "LOAD_GLOBAL",
            "ensure_tuple"
        ],
        [
            "LOAD_FAST",
            "watch_extras"
        ],
        [
            "CALL",
            "ensure_tuple(watch_extras)"
        ],
        [
            "BINARY_OP",
            "(len_shape_watch, dtype_watch) + ensure_tuple(watch_extras)"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.watch_extras"
        ],
        [
            "LOAD_CLASSDEREF",
            "self"
        ],
        [
            "STORE_NAME",
            "config"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_ATTR",
            "value.shape"
        ],
        [
            "STORE_FAST",
            "shape"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.ismethod"
        ],
        [
            "LOAD_FAST",
            "shape"
        ],
        [
            "CALL",
            "inspect.ismethod(shape)"
        ],
        [
            "LOAD_METHOD",
            "'{}.shape'.format"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CALL",
            "'{}.shape'.format(source)"
        ],
        [
            "LOAD_FAST",
            "shape"
        ],
        [
            "LOAD_GLOBAL",
            "Exception"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_GLOBAL",
            "QuerySet"
        ],
        [
            "CALL",
            "isinstance(value, QuerySet)"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "CALL",
            "len(value)"
        ],
        [
            "STORE_FAST",
            "length"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_GLOBAL",
            "six"
        ],
        [
            "LOAD_ATTR",
            "six.string_types"
        ],
        [
            "CALL",
            "isinstance(value, six.string_types)"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "COMPARE_OP",
            "length < 50"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_GLOBAL",
            "Mapping"
        ],
        [
            "LOAD_GLOBAL",
            "Set"
        ],
        [
            "LOAD_GLOBAL",
            "Sequence"
        ],
        [
            "CALL",
            "isinstance(value, (Mapping, Set, Sequence))"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "COMPARE_OP",
            "length == 0"
        ],
        [
            "LOAD_METHOD",
            "'len({})'.format"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CALL",
            "'len({})'.format(source)"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_ATTR",
            "value.dtype"
        ],
        [
            "STORE_FAST",
            "dtype"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.ismethod"
        ],
        [
            "LOAD_FAST",
            "dtype"
        ],
        [
            "CALL",
            "inspect.ismethod(dtype)"
        ],
        [
            "LOAD_METHOD",
            "'{}.dtype'.format"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CALL",
            "'{}.dtype'.format(source)"
        ],
        [
            "LOAD_FAST",
            "dtype"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_DEREF",
            "output"
        ],
        [
            "LOAD_GLOBAL",
            "six"
        ],
        [
            "LOAD_ATTR",
            "six.string_types"
        ],
        [
            "CALL",
            "isinstance(output, six.string_types)"
        ],
        [
            "LOAD_GLOBAL",
            "is_pathlike"
        ],
        [
            "LOAD_DEREF",
            "output"
        ],
        [
            "CALL",
            "is_pathlike(output)"
        ],
        [
            "STORE_FAST",
            "is_path"
        ],
        [
            "LOAD_FAST",
            "is_path"
        ],
        [
            "LOAD_GLOBAL",
            "FileWriter"
        ],
        [
            "LOAD_DEREF",
            "output"
        ],
        [
            "LOAD_FAST",
            "overwrite"
        ],
        [
            "CALL",
            "FileWriter(output, overwrite)"
        ],
        [
            "LOAD_ATTR",
            "FileWriter(output, overwrite).write"
        ],
        [
            "LOAD_GLOBAL",
            "callable"
        ],
        [
            "LOAD_DEREF",
            "output"
        ],
        [
            "CALL",
            "callable(output)"
        ],
        [
            "LOAD_DEREF",
            "output"
        ],
        [
            "STORE_FAST",
            "write"
        ],
        [
            "STORE_FAST",
            "        def write(s):\n            stream = output\n\n            if stream is None:\n                stream = sys.stderr\n\n            try:\n                stream.write(s)\n            except UnicodeEncodeError:\n                # God damn Python 2\n                stream.write(shitcode(s))"
        ],
        [
            "LOAD_FAST",
            "write"
        ],
        [
            "LOAD_DEREF",
            "output"
        ],
        [
            "STORE_FAST",
            "stream"
        ],
        [
            "LOAD_FAST",
            "stream"
        ],
        [
            "LOAD_GLOBAL",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.stderr"
        ],
        [
            "STORE_FAST",
            "stream"
        ],
        [
            "LOAD_FAST",
            "stream"
        ],
        [
            "LOAD_METHOD",
            "stream.write"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "CALL",
            "stream.write(s)"
        ],
        [
            "LOAD_GLOBAL",
            "UnicodeEncodeError"
        ],
        [
            "LOAD_FAST",
            "stream"
        ],
        [
            "LOAD_METHOD",
            "stream.write"
        ],
        [
            "LOAD_GLOBAL",
            "shitcode"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "CALL",
            "shitcode(s)"
        ],
        [
            "CALL",
            "stream.write(shitcode(s))"
        ],
        [
            "STORE_NAME",
            "    def __init__(self, path, overwrite):\n        self.path = six.text_type(path)\n        self.overwrite = overwrite"
        ],
        [
            "STORE_NAME",
            "    def write(self, s):\n        with open(self.path, 'w' if self.overwrite else 'a', encoding='utf-8') as f:\n            f.write(s)\n        self.overwrite = False"
        ],
        [
            "LOAD_GLOBAL",
            "six"
        ],
        [
            "LOAD_ATTR",
            "six.text_type"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "CALL",
            "six.text_type(path)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.path"
        ],
        [
            "LOAD_FAST",
            "overwrite"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.overwrite"
        ],
        [
            "LOAD_GLOBAL",
            "open"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.path"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.overwrite"
        ],
        [
            "CALL",
            "open(self.path, 'w' if self.overwrite else 'a', encoding='utf-8')"
        ],
        [
            "STORE_FAST",
            "f"
        ],
        [
            "LOAD_FAST",
            "f"
        ],
        [
            "LOAD_METHOD",
            "f.write"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "CALL",
            "f.write(s)"
        ],
        [
            "CALL",
            "        with open(self.path, 'w' if self.overwrite else 'a', encoding='utf-8') as f:\n            f.write(s)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.overwrite"
        ]
    ],
    "datetime.py": [
        [
            "STORE_NAME",
            "\"\"\"Concrete date/time and related types.\n\nSee http://www.iana.org/time-zones/repository/tz-link.html for\ntime zone and DST data sources.\n\"\"\""
        ],
        [
            "STORE_NAME",
            "__all__"
        ],
        [
            "STORE_NAME",
            "import time as _time"
        ],
        [
            "STORE_NAME",
            "import math as _math"
        ],
        [
            "STORE_NAME",
            "import sys"
        ],
        [
            "STORE_NAME",
            "from operator import index as _index"
        ],
        [
            "STORE_NAME",
            "def _cmp(x, y):\n    return 0 if x == y else 1 if x > y else -1"
        ],
        [
            "STORE_NAME",
            "MINYEAR"
        ],
        [
            "STORE_NAME",
            "MAXYEAR"
        ],
        [
            "STORE_NAME",
            "_MAXORDINAL"
        ],
        [
            "STORE_NAME",
            "_DAYS_IN_MONTH"
        ],
        [
            "STORE_NAME",
            "_DAYS_BEFORE_MONTH"
        ],
        [
            "STORE_NAME",
            "dbm"
        ],
        [
            "LOAD_NAME",
            "_DAYS_IN_MONTH"
        ],
        [
            "BINARY_SUBSCR",
            "_DAYS_IN_MONTH[1:]"
        ],
        [
            "STORE_NAME",
            "dim"
        ],
        [
            "LOAD_NAME",
            "_DAYS_BEFORE_MONTH"
        ],
        [
            "LOAD_METHOD",
            "_DAYS_BEFORE_MONTH.append"
        ],
        [
            "LOAD_NAME",
            "dbm"
        ],
        [
            "CALL",
            "_DAYS_BEFORE_MONTH.append(dbm)"
        ],
        [
            "LOAD_NAME",
            "dbm"
        ],
        [
            "LOAD_NAME",
            "dim"
        ],
        [
            "BINARY_OP",
            "dbm += dim"
        ],
        [
            "STORE_NAME",
            "dbm"
        ],
        [
            "DELETE_NAME",
            "dbm"
        ],
        [
            "DELETE_NAME",
            "dim"
        ],
        [
            "STORE_NAME",
            "def _is_leap(year):\n    \"year -> 1 if leap year, else 0.\"\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)"
        ],
        [
            "STORE_NAME",
            "def _days_before_year(year):\n    \"year -> number of days before January 1st of year.\"\n    y = year - 1\n    return y*365 + y//4 - y//100 + y//400"
        ],
        [
            "STORE_NAME",
            "def _days_in_month(year, month):\n    \"year, month -> number of days in that month in that year.\"\n    assert 1 <= month <= 12, month\n    if month == 2 and _is_leap(year):\n        return 29\n    return _DAYS_IN_MONTH[month]"
        ],
        [
            "STORE_NAME",
            "def _days_before_month(year, month):\n    \"year, month -> number of days in year preceding first day of month.\"\n    assert 1 <= month <= 12, 'month must be in 1..12'\n    return _DAYS_BEFORE_MONTH[month] + (month > 2 and _is_leap(year))"
        ],
        [
            "STORE_NAME",
            "def _ymd2ord(year, month, day):\n    \"year, month, day -> ordinal, considering 01-Jan-0001 as day 1.\"\n    assert 1 <= month <= 12, 'month must be in 1..12'\n    dim = _days_in_month(year, month)\n    assert 1 <= day <= dim, ('day must be in 1..%d' % dim)\n    return (_days_before_year(year) +\n            _days_before_month(year, month) +\n            day)"
        ],
        [
            "LOAD_NAME",
            "_days_before_year"
        ],
        [
            "CALL",
            "_days_before_year(401)"
        ],
        [
            "STORE_NAME",
            "_DI400Y"
        ],
        [
            "LOAD_NAME",
            "_days_before_year"
        ],
        [
            "CALL",
            "_days_before_year(101)"
        ],
        [
            "STORE_NAME",
            "_DI100Y"
        ],
        [
            "LOAD_NAME",
            "_days_before_year"
        ],
        [
            "CALL",
            "_days_before_year(5)"
        ],
        [
            "STORE_NAME",
            "_DI4Y"
        ],
        [
            "LOAD_NAME",
            "_DI4Y"
        ],
        [
            "COMPARE_OP",
            "_DI4Y == 4 * 365 + 1"
        ],
        [
            "LOAD_NAME",
            "_DI400Y"
        ],
        [
            "LOAD_NAME",
            "_DI100Y"
        ],
        [
            "BINARY_OP",
            "4 * _DI100Y"
        ],
        [
            "BINARY_OP",
            "4 * _DI100Y + 1"
        ],
        [
            "COMPARE_OP",
            "_DI400Y == 4 * _DI100Y + 1"
        ],
        [
            "LOAD_NAME",
            "_DI100Y"
        ],
        [
            "LOAD_NAME",
            "_DI4Y"
        ],
        [
            "BINARY_OP",
            "25 * _DI4Y"
        ],
        [
            "BINARY_OP",
            "25 * _DI4Y - 1"
        ],
        [
            "COMPARE_OP",
            "_DI100Y == 25 * _DI4Y - 1"
        ],
        [
            "STORE_NAME",
            "def _ord2ymd(n):\n    \"ordinal -> (year, month, day), considering 01-Jan-0001 as day 1.\"\n\n    # n is a 1-based index, starting at 1-Jan-1.  The pattern of leap years\n    # repeats exactly every 400 years.  The basic strategy is to find the\n    # closest 400-year boundary at or before n, then work with the offset\n    # from that boundary to n.  Life is much clearer if we subtract 1 from\n    # n first -- then the values of n at 400-year boundaries are exactly\n    # those divisible by _DI400Y:\n    #\n    #     D  M   Y            n              n-1\n    #     -- --- ----        ----------     ----------------\n    #     31 Dec -400        -_DI400Y       -_DI400Y -1\n    #      1 Jan -399         -_DI400Y +1   -_DI400Y      400-year boundary\n    #     ...\n    #     30 Dec  000        -1             -2\n    #     31 Dec  000         0             -1\n    #      1 Jan  001         1              0            400-year boundary\n    #      2 Jan  001         2              1\n    #      3 Jan  001         3              2\n    #     ...\n    #     31 Dec  400         _DI400Y        _DI400Y -1\n    #      1 Jan  401         _DI400Y +1     _DI400Y      400-year boundary\n    n -= 1\n    n400, n = divmod(n, _DI400Y)\n    year = n400 * 400 + 1   # ..., -399, 1, 401, ...\n\n    # Now n is the (non-negative) offset, in days, from January 1 of year, to\n    # the desired date.  Now compute how many 100-year cycles precede n.\n    # Note that it's possible for n100 to equal 4!  In that case 4 full\n    # 100-year cycles precede the desired day, which implies the desired\n    # day is December 31 at the end of a 400-year cycle.\n    n100, n = divmod(n, _DI100Y)\n\n    # Now compute how many 4-year cycles precede it.\n    n4, n = divmod(n, _DI4Y)\n\n    # And now how many single years.  Again n1 can be 4, and again meaning\n    # that the desired day is December 31 at the end of the 4-year cycle.\n    n1, n = divmod(n, 365)\n\n    year += n100 * 100 + n4 * 4 + n1\n    if n1 == 4 or n100 == 4:\n        assert n == 0\n        return year-1, 12, 31\n\n    # Now the year is correct, and n is the offset from January 1.  We find\n    # the month via an estimate that's either exact or one too large.\n    leapyear = n1 == 3 and (n4 != 24 or n100 == 3)\n    assert leapyear == _is_leap(year)\n    month = (n + 50) >> 5\n    preceding = _DAYS_BEFORE_MONTH[month] + (month > 2 and leapyear)\n    if preceding > n:  # estimate is too large\n        month -= 1\n        preceding -= _DAYS_IN_MONTH[month] + (month == 2 and leapyear)\n    n -= preceding\n    assert 0 <= n < _days_in_month(year, month)\n\n    # Now the year and month are correct, and n is the offset from the\n    # start of that month:  we're done!\n    return year, month, n+1"
        ],
        [
            "STORE_NAME",
            "_MONTHNAMES"
        ],
        [
            "STORE_NAME",
            "_DAYNAMES"
        ],
        [
            "STORE_NAME",
            "def _build_struct_time(y, m, d, hh, mm, ss, dstflag):\n    wday = (_ymd2ord(y, m, d) + 6) % 7\n    dnum = _days_before_month(y, m) + d\n    return _time.struct_time((y, m, d, hh, mm, ss, wday, dnum, dstflag))"
        ],
        [
            "STORE_NAME",
            "def _format_time(hh, mm, ss, us, timespec='auto'):\n    specs = {\n        'hours': '{:02d}',\n        'minutes': '{:02d}:{:02d}',\n        'seconds': '{:02d}:{:02d}:{:02d}',\n        'milliseconds': '{:02d}:{:02d}:{:02d}.{:03d}',\n        'microseconds': '{:02d}:{:02d}:{:02d}.{:06d}'\n    }\n\n    if timespec == 'auto':\n        # Skip trailing microseconds when us==0.\n        timespec = 'microseconds' if us else 'seconds'\n    elif timespec == 'milliseconds':\n        us //= 1000\n    try:\n        fmt = specs[timespec]\n    except KeyError:\n        raise ValueError('Unknown timespec value')\n    else:\n        return fmt.format(hh, mm, ss, us)"
        ],
        [
            "STORE_NAME",
            "def _format_offset(off):\n    s = ''\n    if off is not None:\n        if off.days < 0:\n            sign = \"-\"\n            off = -off\n        else:\n            sign = \"+\"\n        hh, mm = divmod(off, timedelta(hours=1))\n        mm, ss = divmod(mm, timedelta(minutes=1))\n        s += \"%s%02d:%02d\" % (sign, hh, mm)\n        if ss or ss.microseconds:\n            s += \":%02d\" % ss.seconds\n\n            if ss.microseconds:\n                s += '.%06d' % ss.microseconds\n    return s"
        ],
        [
            "STORE_NAME",
            "def _wrap_strftime(object, format, timetuple):\n    # Don't call utcoffset() or tzname() unless actually needed.\n    freplace = None  # the string to use for %f\n    zreplace = None  # the string to use for %z\n    Zreplace = None  # the string to use for %Z\n\n    # Scan format for %z and %Z escapes, replacing as needed.\n    newformat = []\n    push = newformat.append\n    i, n = 0, len(format)\n    while i < n:\n        ch = format[i]\n        i += 1\n        if ch == '%':\n            if i < n:\n                ch = format[i]\n                i += 1\n                if ch == 'f':\n                    if freplace is None:\n                        freplace = '%06d' % getattr(object,\n                                                    'microsecond', 0)\n                    newformat.append(freplace)\n                elif ch == 'z':\n                    if zreplace is None:\n                        zreplace = \"\"\n                        if hasattr(object, \"utcoffset\"):\n                            offset = object.utcoffset()\n                            if offset is not None:\n                                sign = '+'\n                                if offset.days < 0:\n                                    offset = -offset\n                                    sign = '-'\n                                h, rest = divmod(offset, timedelta(hours=1))\n                                m, rest = divmod(rest, timedelta(minutes=1))\n                                s = rest.seconds\n                                u = offset.microseconds\n                                if u:\n                                    zreplace = '%c%02d%02d%02d.%06d' % (sign, h, m, s, u)\n                                elif s:\n                                    zreplace = '%c%02d%02d%02d' % (sign, h, m, s)\n                                else:\n                                    zreplace = '%c%02d%02d' % (sign, h, m)\n                    assert '%' not in zreplace\n                    newformat.append(zreplace)\n                elif ch == 'Z':\n                    if Zreplace is None:\n                        Zreplace = \"\"\n                        if hasattr(object, \"tzname\"):\n                            s = object.tzname()\n                            if s is not None:\n                                # strftime is going to have at this: escape %\n                                Zreplace = s.replace('%', '%%')\n                    newformat.append(Zreplace)\n                else:\n                    push('%')\n                    push(ch)\n            else:\n                push('%')\n        else:\n            push(ch)\n    newformat = \"\".join(newformat)\n    return _time.strftime(newformat, timetuple)"
        ],
        [
            "STORE_NAME",
            "def _is_ascii_digit(c):\n    return c in \"0123456789\""
        ],
        [
            "STORE_NAME",
            "def _find_isoformat_datetime_separator(dtstr):\n    # See the comment in _datetimemodule.c:_find_isoformat_datetime_separator\n    len_dtstr = len(dtstr)\n    if len_dtstr == 7:\n        return 7\n\n    assert len_dtstr > 7\n    date_separator = \"-\"\n    week_indicator = \"W\"\n\n    if dtstr[4] == date_separator:\n        if dtstr[5] == week_indicator:\n            if len_dtstr < 8:\n                raise ValueError(\"Invalid ISO string\")\n            if len_dtstr > 8 and dtstr[8] == date_separator:\n                if len_dtstr == 9:\n                    raise ValueError(\"Invalid ISO string\")\n                if len_dtstr > 10 and _is_ascii_digit(dtstr[10]):\n                    # This is as far as we need to resolve the ambiguity for\n                    # the moment - if we have YYYY-Www-##, the separator is\n                    # either a hyphen at 8 or a number at 10.\n                    #\n                    # We'll assume it's a hyphen at 8 because it's way more\n                    # likely that someone will use a hyphen as a separator than\n                    # a number, but at this point it's really best effort\n                    # because this is an extension of the spec anyway.\n                    # TODO(pganssle): Document this\n                    return 8\n                return 10\n            else:\n                # YYYY-Www (8)\n                return 8\n        else:\n            # YYYY-MM-DD (10)\n            return 10\n    else:\n        if dtstr[4] == week_indicator:\n            # YYYYWww (7) or YYYYWwwd (8)\n            idx = 7\n            while idx < len_dtstr:\n                if not _is_ascii_digit(dtstr[idx]):\n                    break\n                idx += 1\n\n            if idx < 9:\n                return idx\n\n            if idx % 2 == 0:\n                # If the index of the last number is even, it's YYYYWwwd\n                return 7\n            else:\n                return 8\n        else:\n            # YYYYMMDD (8)\n            return 8"
        ],
        [
            "STORE_NAME",
            "def _parse_isoformat_date(dtstr):\n    # It is assumed that this is an ASCII-only string of lengths 7, 8 or 10,\n    # see the comment on Modules/_datetimemodule.c:_find_isoformat_datetime_separator\n    assert len(dtstr) in (7, 8, 10)\n    year = int(dtstr[0:4])\n    has_sep = dtstr[4] == '-'\n\n    pos = 4 + has_sep\n    if dtstr[pos:pos + 1] == \"W\":\n        # YYYY-?Www-?D?\n        pos += 1\n        weekno = int(dtstr[pos:pos + 2])\n        pos += 2\n\n        dayno = 1\n        if len(dtstr) > pos:\n            if (dtstr[pos:pos + 1] == '-') != has_sep:\n                raise ValueError(\"Inconsistent use of dash separator\")\n\n            pos += has_sep\n\n            dayno = int(dtstr[pos:pos + 1])\n\n        return list(_isoweek_to_gregorian(year, weekno, dayno))\n    else:\n        month = int(dtstr[pos:pos + 2])\n        pos += 2\n        if (dtstr[pos:pos + 1] == \"-\") != has_sep:\n            raise ValueError(\"Inconsistent use of dash separator\")\n\n        pos += has_sep\n        day = int(dtstr[pos:pos + 2])\n\n        return [year, month, day]"
        ],
        [
            "STORE_NAME",
            "_FRACTION_CORRECTION"
        ],
        [
            "STORE_NAME",
            "def _parse_hh_mm_ss_ff(tstr):\n    # Parses things of the form HH[:?MM[:?SS[{.,}fff[fff]]]]\n    len_str = len(tstr)\n\n    time_comps = [0, 0, 0, 0]\n    pos = 0\n    for comp in range(0, 3):\n        if (len_str - pos) < 2:\n            raise ValueError(\"Incomplete time component\")\n\n        time_comps[comp] = int(tstr[pos:pos+2])\n\n        pos += 2\n        next_char = tstr[pos:pos+1]\n\n        if comp == 0:\n            has_sep = next_char == ':'\n\n        if not next_char or comp >= 2:\n            break\n\n        if has_sep and next_char != ':':\n            raise ValueError(\"Invalid time separator: %c\" % next_char)\n\n        pos += has_sep\n\n    if pos < len_str:\n        if tstr[pos] not in '.,':\n            raise ValueError(\"Invalid microsecond component\")\n        else:\n            pos += 1\n\n            len_remainder = len_str - pos\n\n            if len_remainder >= 6:\n                to_parse = 6\n            else:\n                to_parse = len_remainder\n\n            time_comps[3] = int(tstr[pos:(pos+to_parse)])\n            if to_parse < 6:\n                time_comps[3] *= _FRACTION_CORRECTION[to_parse-1]\n            if (len_remainder > to_parse\n                    and not all(map(_is_ascii_digit, tstr[(pos+to_parse):]))):\n                raise ValueError(\"Non-digit values in unparsed fraction\")\n\n    return time_comps"
        ],
        [
            "STORE_NAME",
            "def _parse_isoformat_time(tstr):\n    # Format supported is HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]\n    len_str = len(tstr)\n    if len_str < 2:\n        raise ValueError(\"Isoformat time too short\")\n\n    # This is equivalent to re.search('[+-Z]', tstr), but faster\n    tz_pos = (tstr.find('-') + 1 or tstr.find('+') + 1 or tstr.find('Z') + 1)\n    timestr = tstr[:tz_pos-1] if tz_pos > 0 else tstr\n\n    time_comps = _parse_hh_mm_ss_ff(timestr)\n\n    tzi = None\n    if tz_pos == len_str and tstr[-1] == 'Z':\n        tzi = timezone.utc\n    elif tz_pos > 0:\n        tzstr = tstr[tz_pos:]\n\n        # Valid time zone strings are:\n        # HH                  len: 2\n        # HHMM                len: 4\n        # HH:MM               len: 5\n        # HHMMSS              len: 6\n        # HHMMSS.f+           len: 7+\n        # HH:MM:SS            len: 8\n        # HH:MM:SS.f+         len: 10+\n\n        if len(tzstr) in (0, 1, 3):\n            raise ValueError(\"Malformed time zone string\")\n\n        tz_comps = _parse_hh_mm_ss_ff(tzstr)\n\n        if all(x == 0 for x in tz_comps):\n            tzi = timezone.utc\n        else:\n            tzsign = -1 if tstr[tz_pos - 1] == '-' else 1\n\n            td = timedelta(hours=tz_comps[0], minutes=tz_comps[1],\n                           seconds=tz_comps[2], microseconds=tz_comps[3])\n\n            tzi = timezone(tzsign * td)\n\n    time_comps.append(tzi)\n\n    return time_comps"
        ],
        [
            "STORE_NAME",
            "def _isoweek_to_gregorian(year, week, day):\n    # Year is bounded this way because 9999-12-31 is (9999, 52, 5)\n    if not MINYEAR <= year <= MAXYEAR:\n        raise ValueError(f\"Year is out of range: {year}\")\n\n    if not 0 < week < 53:\n        out_of_range = True\n\n        if week == 53:\n            # ISO years have 53 weeks in them on years starting with a\n            # Thursday and leap years starting on a Wednesday\n            first_weekday = _ymd2ord(year, 1, 1) % 7\n            if (first_weekday == 4 or (first_weekday == 3 and\n                                       _is_leap(year))):\n                out_of_range = False\n\n        if out_of_range:\n            raise ValueError(f\"Invalid week: {week}\")\n\n    if not 0 < day < 8:\n        raise ValueError(f\"Invalid weekday: {day} (range is [1, 7])\")\n\n    # Now compute the offset from (Y, 1, 1) in days:\n    day_offset = (week - 1) * 7 + (day - 1)\n\n    # Calculate the ordinal day for monday, week 1\n    day_1 = _isoweek1monday(year)\n    ord_day = day_1 + day_offset\n\n    return _ord2ymd(ord_day)"
        ],
        [
            "STORE_NAME",
            "def _check_tzname(name):\n    if name is not None and not isinstance(name, str):\n        raise TypeError(\"tzinfo.tzname() must return None or string, \"\n                        \"not '%s'\" % type(name))"
        ],
        [
            "STORE_NAME",
            "def _check_utc_offset(name, offset):\n    assert name in (\"utcoffset\", \"dst\")\n    if offset is None:\n        return\n    if not isinstance(offset, timedelta):\n        raise TypeError(\"tzinfo.%s() must return None \"\n                        \"or timedelta, not '%s'\" % (name, type(offset)))\n    if not -timedelta(1) < offset < timedelta(1):\n        raise ValueError(\"%s()=%s, must be strictly between \"\n                         \"-timedelta(hours=24) and timedelta(hours=24)\" %\n                         (name, offset))"
        ],
        [
            "STORE_NAME",
            "def _check_date_fields(year, month, day):\n    year = _index(year)\n    month = _index(month)\n    day = _index(day)\n    if not MINYEAR <= year <= MAXYEAR:\n        raise ValueError('year must be in %d..%d' % (MINYEAR, MAXYEAR), year)\n    if not 1 <= month <= 12:\n        raise ValueError('month must be in 1..12', month)\n    dim = _days_in_month(year, month)\n    if not 1 <= day <= dim:\n        raise ValueError('day must be in 1..%d' % dim, day)\n    return year, month, day"
        ],
        [
            "STORE_NAME",
            "def _check_time_fields(hour, minute, second, microsecond, fold):\n    hour = _index(hour)\n    minute = _index(minute)\n    second = _index(second)\n    microsecond = _index(microsecond)\n    if not 0 <= hour <= 23:\n        raise ValueError('hour must be in 0..23', hour)\n    if not 0 <= minute <= 59:\n        raise ValueError('minute must be in 0..59', minute)\n    if not 0 <= second <= 59:\n        raise ValueError('second must be in 0..59', second)\n    if not 0 <= microsecond <= 999999:\n        raise ValueError('microsecond must be in 0..999999', microsecond)\n    if fold not in (0, 1):\n        raise ValueError('fold must be either 0 or 1', fold)\n    return hour, minute, second, microsecond, fold"
        ],
        [
            "STORE_NAME",
            "def _check_tzinfo_arg(tz):\n    if tz is not None and not isinstance(tz, tzinfo):\n        raise TypeError(\"tzinfo argument must be None or of a tzinfo subclass\")"
        ],
        [
            "STORE_NAME",
            "def _cmperror(x, y):\n    raise TypeError(\"can't compare '%s' to '%s'\" % (\n                    type(x).__name__, type(y).__name__))"
        ],
        [
            "STORE_NAME",
            "def _divide_and_round(a, b):\n    \"\"\"divide a by b and round result to the nearest integer\n\n    When the ratio is exactly half-way between two integers,\n    the even integer is returned.\n    \"\"\"\n    # Based on the reference implementation for divmod_near\n    # in Objects/longobject.c.\n    q, r = divmod(a, b)\n    # round up if either r / b > 0.5, or r / b == 0.5 and q is odd.\n    # The expression r / b > 0.5 is equivalent to 2 * r > b if b is\n    # positive, 2 * r < b if b negative.\n    r *= 2\n    greater_than_half = r > b if b > 0 else r < b\n    if greater_than_half or r == b and q % 2 == 1:\n        q += 1\n\n    return q"
        ],
        [
            "CALL",
            "class timedelta:\n    \"\"\"Represent the difference between two datetime objects.\n\n    Supported operators:\n\n    - add, subtract timedelta\n    - unary plus, minus, abs\n    - compare to timedelta\n    - multiply, divide by int\n\n    In addition, datetime supports subtraction of two datetime objects\n    returning a timedelta, and addition or subtraction of a datetime\n    and a timedelta giving a datetime.\n\n    Representation: (days, seconds, microseconds).  Why?  Because I\n    felt like it.\n    \"\"\"\n    __slots__ = '_days', '_seconds', '_microseconds', '_hashcode'\n\n    def __new__(cls, days=0, seconds=0, microseconds=0,\n                milliseconds=0, minutes=0, hours=0, weeks=0):\n        # Doing this efficiently and accurately in C is going to be difficult\n        # and error-prone, due to ubiquitous overflow possibilities, and that\n        # C double doesn't have enough bits of precision to represent\n        # microseconds over 10K years faithfully.  The code here tries to make\n        # explicit where go-fast assumptions can be relied on, in order to\n        # guide the C implementation; it's way more convoluted than speed-\n        # ignoring auto-overflow-to-long idiomatic Python could be.\n\n        # XXX Check that all inputs are ints or floats.\n\n        # Final values, all integer.\n        # s and us fit in 32-bit signed ints; d isn't bounded.\n        d = s = us = 0\n\n        # Normalize everything to days, seconds, microseconds.\n        days += weeks*7\n        seconds += minutes*60 + hours*3600\n        microseconds += milliseconds*1000\n\n        # Get rid of all fractions, and normalize s and us.\n        # Take a deep breath <wink>.\n        if isinstance(days, float):\n            dayfrac, days = _math.modf(days)\n            daysecondsfrac, daysecondswhole = _math.modf(dayfrac * (24.*3600.))\n            assert daysecondswhole == int(daysecondswhole)  # can't overflow\n            s = int(daysecondswhole)\n            assert days == int(days)\n            d = int(days)\n        else:\n            daysecondsfrac = 0.0\n            d = days\n        assert isinstance(daysecondsfrac, float)\n        assert abs(daysecondsfrac) <= 1.0\n        assert isinstance(d, int)\n        assert abs(s) <= 24 * 3600\n        # days isn't referenced again before redefinition\n\n        if isinstance(seconds, float):\n            secondsfrac, seconds = _math.modf(seconds)\n            assert seconds == int(seconds)\n            seconds = int(seconds)\n            secondsfrac += daysecondsfrac\n            assert abs(secondsfrac) <= 2.0\n        else:\n            secondsfrac = daysecondsfrac\n        # daysecondsfrac isn't referenced again\n        assert isinstance(secondsfrac, float)\n        assert abs(secondsfrac) <= 2.0\n\n        assert isinstance(seconds, int)\n        days, seconds = divmod(seconds, 24*3600)\n        d += days\n        s += int(seconds)    # can't overflow\n        assert isinstance(s, int)\n        assert abs(s) <= 2 * 24 * 3600\n        # seconds isn't referenced again before redefinition\n\n        usdouble = secondsfrac * 1e6\n        assert abs(usdouble) < 2.1e6    # exact value not critical\n        # secondsfrac isn't referenced again\n\n        if isinstance(microseconds, float):\n            microseconds = round(microseconds + usdouble)\n            seconds, microseconds = divmod(microseconds, 1000000)\n            days, seconds = divmod(seconds, 24*3600)\n            d += days\n            s += seconds\n        else:\n            microseconds = int(microseconds)\n            seconds, microseconds = divmod(microseconds, 1000000)\n            days, seconds = divmod(seconds, 24*3600)\n            d += days\n            s += seconds\n            microseconds = round(microseconds + usdouble)\n        assert isinstance(s, int)\n        assert isinstance(microseconds, int)\n        assert abs(s) <= 3 * 24 * 3600\n        assert abs(microseconds) < 3.1e6\n\n        # Just a little bit of carrying possible for microseconds and seconds.\n        seconds, us = divmod(microseconds, 1000000)\n        s += seconds\n        days, s = divmod(s, 24*3600)\n        d += days\n\n        assert isinstance(d, int)\n        assert isinstance(s, int) and 0 <= s < 24*3600\n        assert isinstance(us, int) and 0 <= us < 1000000\n\n        if abs(d) > 999999999:\n            raise OverflowError(\"timedelta # of days is too large: %d\" % d)\n\n        self = object.__new__(cls)\n        self._days = d\n        self._seconds = s\n        self._microseconds = us\n        self._hashcode = -1\n        return self\n\n    def __repr__(self):\n        args = []\n        if self._days:\n            args.append(\"days=%d\" % self._days)\n        if self._seconds:\n            args.append(\"seconds=%d\" % self._seconds)\n        if self._microseconds:\n            args.append(\"microseconds=%d\" % self._microseconds)\n        if not args:\n            args.append('0')\n        return \"%s.%s(%s)\" % (self.__class__.__module__,\n                              self.__class__.__qualname__,\n                              ', '.join(args))\n\n    def __str__(self):\n        mm, ss = divmod(self._seconds, 60)\n        hh, mm = divmod(mm, 60)\n        s = \"%d:%02d:%02d\" % (hh, mm, ss)\n        if self._days:\n            def plural(n):\n                return n, abs(n) != 1 and \"s\" or \"\"\n            s = (\"%d day%s, \" % plural(self._days)) + s\n        if self._microseconds:\n            s = s + \".%06d\" % self._microseconds\n        return s\n\n    def total_seconds(self):\n        \"\"\"Total seconds in the duration.\"\"\"\n        return ((self.days * 86400 + self.seconds) * 10**6 +\n                self.microseconds) / 10**6\n\n    # Read-only field accessors\n    @property\n    def days(self):\n        \"\"\"days\"\"\"\n        return self._days\n\n    @property\n    def seconds(self):\n        \"\"\"seconds\"\"\"\n        return self._seconds\n\n    @property\n    def microseconds(self):\n        \"\"\"microseconds\"\"\"\n        return self._microseconds\n\n    def __add__(self, other):\n        if isinstance(other, timedelta):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta(self._days + other._days,\n                             self._seconds + other._seconds,\n                             self._microseconds + other._microseconds)\n        return NotImplemented\n\n    __radd__ = __add__\n\n    def __sub__(self, other):\n        if isinstance(other, timedelta):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta(self._days - other._days,\n                             self._seconds - other._seconds,\n                             self._microseconds - other._microseconds)\n        return NotImplemented\n\n    def __rsub__(self, other):\n        if isinstance(other, timedelta):\n            return -self + other\n        return NotImplemented\n\n    def __neg__(self):\n        # for CPython compatibility, we cannot use\n        # our __class__ here, but need a real timedelta\n        return timedelta(-self._days,\n                         -self._seconds,\n                         -self._microseconds)\n\n    def __pos__(self):\n        return self\n\n    def __abs__(self):\n        if self._days < 0:\n            return -self\n        else:\n            return self\n\n    def __mul__(self, other):\n        if isinstance(other, int):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta(self._days * other,\n                             self._seconds * other,\n                             self._microseconds * other)\n        if isinstance(other, float):\n            usec = self._to_microseconds()\n            a, b = other.as_integer_ratio()\n            return timedelta(0, 0, _divide_and_round(usec * a, b))\n        return NotImplemented\n\n    __rmul__ = __mul__\n\n    def _to_microseconds(self):\n        return ((self._days * (24*3600) + self._seconds) * 1000000 +\n                self._microseconds)\n\n    def __floordiv__(self, other):\n        if not isinstance(other, (int, timedelta)):\n            return NotImplemented\n        usec = self._to_microseconds()\n        if isinstance(other, timedelta):\n            return usec // other._to_microseconds()\n        if isinstance(other, int):\n            return timedelta(0, 0, usec // other)\n\n    def __truediv__(self, other):\n        if not isinstance(other, (int, float, timedelta)):\n            return NotImplemented\n        usec = self._to_microseconds()\n        if isinstance(other, timedelta):\n            return usec / other._to_microseconds()\n        if isinstance(other, int):\n            return timedelta(0, 0, _divide_and_round(usec, other))\n        if isinstance(other, float):\n            a, b = other.as_integer_ratio()\n            return timedelta(0, 0, _divide_and_round(b * usec, a))\n\n    def __mod__(self, other):\n        if isinstance(other, timedelta):\n            r = self._to_microseconds() % other._to_microseconds()\n            return timedelta(0, 0, r)\n        return NotImplemented\n\n    def __divmod__(self, other):\n        if isinstance(other, timedelta):\n            q, r = divmod(self._to_microseconds(),\n                          other._to_microseconds())\n            return q, timedelta(0, 0, r)\n        return NotImplemented\n\n    # Comparisons of timedelta objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) == 0\n        else:\n            return NotImplemented\n\n    def __le__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) <= 0\n        else:\n            return NotImplemented\n\n    def __lt__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) < 0\n        else:\n            return NotImplemented\n\n    def __ge__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) >= 0\n        else:\n            return NotImplemented\n\n    def __gt__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) > 0\n        else:\n            return NotImplemented\n\n    def _cmp(self, other):\n        assert isinstance(other, timedelta)\n        return _cmp(self._getstate(), other._getstate())\n\n    def __hash__(self):\n        if self._hashcode == -1:\n            self._hashcode = hash(self._getstate())\n        return self._hashcode\n\n    def __bool__(self):\n        return (self._days != 0 or\n                self._seconds != 0 or\n                self._microseconds != 0)\n\n    # Pickle support.\n\n    def _getstate(self):\n        return (self._days, self._seconds, self._microseconds)\n\n    def __reduce__(self):\n        return (self.__class__, self._getstate())"
        ],
        [
            "STORE_NAME",
            "class timedelta:\n    \"\"\"Represent the difference between two datetime objects.\n\n    Supported operators:\n\n    - add, subtract timedelta\n    - unary plus, minus, abs\n    - compare to timedelta\n    - multiply, divide by int\n\n    In addition, datetime supports subtraction of two datetime objects\n    returning a timedelta, and addition or subtraction of a datetime\n    and a timedelta giving a datetime.\n\n    Representation: (days, seconds, microseconds).  Why?  Because I\n    felt like it.\n    \"\"\"\n    __slots__ = '_days', '_seconds', '_microseconds', '_hashcode'\n\n    def __new__(cls, days=0, seconds=0, microseconds=0,\n                milliseconds=0, minutes=0, hours=0, weeks=0):\n        # Doing this efficiently and accurately in C is going to be difficult\n        # and error-prone, due to ubiquitous overflow possibilities, and that\n        # C double doesn't have enough bits of precision to represent\n        # microseconds over 10K years faithfully.  The code here tries to make\n        # explicit where go-fast assumptions can be relied on, in order to\n        # guide the C implementation; it's way more convoluted than speed-\n        # ignoring auto-overflow-to-long idiomatic Python could be.\n\n        # XXX Check that all inputs are ints or floats.\n\n        # Final values, all integer.\n        # s and us fit in 32-bit signed ints; d isn't bounded.\n        d = s = us = 0\n\n        # Normalize everything to days, seconds, microseconds.\n        days += weeks*7\n        seconds += minutes*60 + hours*3600\n        microseconds += milliseconds*1000\n\n        # Get rid of all fractions, and normalize s and us.\n        # Take a deep breath <wink>.\n        if isinstance(days, float):\n            dayfrac, days = _math.modf(days)\n            daysecondsfrac, daysecondswhole = _math.modf(dayfrac * (24.*3600.))\n            assert daysecondswhole == int(daysecondswhole)  # can't overflow\n            s = int(daysecondswhole)\n            assert days == int(days)\n            d = int(days)\n        else:\n            daysecondsfrac = 0.0\n            d = days\n        assert isinstance(daysecondsfrac, float)\n        assert abs(daysecondsfrac) <= 1.0\n        assert isinstance(d, int)\n        assert abs(s) <= 24 * 3600\n        # days isn't referenced again before redefinition\n\n        if isinstance(seconds, float):\n            secondsfrac, seconds = _math.modf(seconds)\n            assert seconds == int(seconds)\n            seconds = int(seconds)\n            secondsfrac += daysecondsfrac\n            assert abs(secondsfrac) <= 2.0\n        else:\n            secondsfrac = daysecondsfrac\n        # daysecondsfrac isn't referenced again\n        assert isinstance(secondsfrac, float)\n        assert abs(secondsfrac) <= 2.0\n\n        assert isinstance(seconds, int)\n        days, seconds = divmod(seconds, 24*3600)\n        d += days\n        s += int(seconds)    # can't overflow\n        assert isinstance(s, int)\n        assert abs(s) <= 2 * 24 * 3600\n        # seconds isn't referenced again before redefinition\n\n        usdouble = secondsfrac * 1e6\n        assert abs(usdouble) < 2.1e6    # exact value not critical\n        # secondsfrac isn't referenced again\n\n        if isinstance(microseconds, float):\n            microseconds = round(microseconds + usdouble)\n            seconds, microseconds = divmod(microseconds, 1000000)\n            days, seconds = divmod(seconds, 24*3600)\n            d += days\n            s += seconds\n        else:\n            microseconds = int(microseconds)\n            seconds, microseconds = divmod(microseconds, 1000000)\n            days, seconds = divmod(seconds, 24*3600)\n            d += days\n            s += seconds\n            microseconds = round(microseconds + usdouble)\n        assert isinstance(s, int)\n        assert isinstance(microseconds, int)\n        assert abs(s) <= 3 * 24 * 3600\n        assert abs(microseconds) < 3.1e6\n\n        # Just a little bit of carrying possible for microseconds and seconds.\n        seconds, us = divmod(microseconds, 1000000)\n        s += seconds\n        days, s = divmod(s, 24*3600)\n        d += days\n\n        assert isinstance(d, int)\n        assert isinstance(s, int) and 0 <= s < 24*3600\n        assert isinstance(us, int) and 0 <= us < 1000000\n\n        if abs(d) > 999999999:\n            raise OverflowError(\"timedelta # of days is too large: %d\" % d)\n\n        self = object.__new__(cls)\n        self._days = d\n        self._seconds = s\n        self._microseconds = us\n        self._hashcode = -1\n        return self\n\n    def __repr__(self):\n        args = []\n        if self._days:\n            args.append(\"days=%d\" % self._days)\n        if self._seconds:\n            args.append(\"seconds=%d\" % self._seconds)\n        if self._microseconds:\n            args.append(\"microseconds=%d\" % self._microseconds)\n        if not args:\n            args.append('0')\n        return \"%s.%s(%s)\" % (self.__class__.__module__,\n                              self.__class__.__qualname__,\n                              ', '.join(args))\n\n    def __str__(self):\n        mm, ss = divmod(self._seconds, 60)\n        hh, mm = divmod(mm, 60)\n        s = \"%d:%02d:%02d\" % (hh, mm, ss)\n        if self._days:\n            def plural(n):\n                return n, abs(n) != 1 and \"s\" or \"\"\n            s = (\"%d day%s, \" % plural(self._days)) + s\n        if self._microseconds:\n            s = s + \".%06d\" % self._microseconds\n        return s\n\n    def total_seconds(self):\n        \"\"\"Total seconds in the duration.\"\"\"\n        return ((self.days * 86400 + self.seconds) * 10**6 +\n                self.microseconds) / 10**6\n\n    # Read-only field accessors\n    @property\n    def days(self):\n        \"\"\"days\"\"\"\n        return self._days\n\n    @property\n    def seconds(self):\n        \"\"\"seconds\"\"\"\n        return self._seconds\n\n    @property\n    def microseconds(self):\n        \"\"\"microseconds\"\"\"\n        return self._microseconds\n\n    def __add__(self, other):\n        if isinstance(other, timedelta):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta(self._days + other._days,\n                             self._seconds + other._seconds,\n                             self._microseconds + other._microseconds)\n        return NotImplemented\n\n    __radd__ = __add__\n\n    def __sub__(self, other):\n        if isinstance(other, timedelta):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta(self._days - other._days,\n                             self._seconds - other._seconds,\n                             self._microseconds - other._microseconds)\n        return NotImplemented\n\n    def __rsub__(self, other):\n        if isinstance(other, timedelta):\n            return -self + other\n        return NotImplemented\n\n    def __neg__(self):\n        # for CPython compatibility, we cannot use\n        # our __class__ here, but need a real timedelta\n        return timedelta(-self._days,\n                         -self._seconds,\n                         -self._microseconds)\n\n    def __pos__(self):\n        return self\n\n    def __abs__(self):\n        if self._days < 0:\n            return -self\n        else:\n            return self\n\n    def __mul__(self, other):\n        if isinstance(other, int):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta(self._days * other,\n                             self._seconds * other,\n                             self._microseconds * other)\n        if isinstance(other, float):\n            usec = self._to_microseconds()\n            a, b = other.as_integer_ratio()\n            return timedelta(0, 0, _divide_and_round(usec * a, b))\n        return NotImplemented\n\n    __rmul__ = __mul__\n\n    def _to_microseconds(self):\n        return ((self._days * (24*3600) + self._seconds) * 1000000 +\n                self._microseconds)\n\n    def __floordiv__(self, other):\n        if not isinstance(other, (int, timedelta)):\n            return NotImplemented\n        usec = self._to_microseconds()\n        if isinstance(other, timedelta):\n            return usec // other._to_microseconds()\n        if isinstance(other, int):\n            return timedelta(0, 0, usec // other)\n\n    def __truediv__(self, other):\n        if not isinstance(other, (int, float, timedelta)):\n            return NotImplemented\n        usec = self._to_microseconds()\n        if isinstance(other, timedelta):\n            return usec / other._to_microseconds()\n        if isinstance(other, int):\n            return timedelta(0, 0, _divide_and_round(usec, other))\n        if isinstance(other, float):\n            a, b = other.as_integer_ratio()\n            return timedelta(0, 0, _divide_and_round(b * usec, a))\n\n    def __mod__(self, other):\n        if isinstance(other, timedelta):\n            r = self._to_microseconds() % other._to_microseconds()\n            return timedelta(0, 0, r)\n        return NotImplemented\n\n    def __divmod__(self, other):\n        if isinstance(other, timedelta):\n            q, r = divmod(self._to_microseconds(),\n                          other._to_microseconds())\n            return q, timedelta(0, 0, r)\n        return NotImplemented\n\n    # Comparisons of timedelta objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) == 0\n        else:\n            return NotImplemented\n\n    def __le__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) <= 0\n        else:\n            return NotImplemented\n\n    def __lt__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) < 0\n        else:\n            return NotImplemented\n\n    def __ge__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) >= 0\n        else:\n            return NotImplemented\n\n    def __gt__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) > 0\n        else:\n            return NotImplemented\n\n    def _cmp(self, other):\n        assert isinstance(other, timedelta)\n        return _cmp(self._getstate(), other._getstate())\n\n    def __hash__(self):\n        if self._hashcode == -1:\n            self._hashcode = hash(self._getstate())\n        return self._hashcode\n\n    def __bool__(self):\n        return (self._days != 0 or\n                self._seconds != 0 or\n                self._microseconds != 0)\n\n    # Pickle support.\n\n    def _getstate(self):\n        return (self._days, self._seconds, self._microseconds)\n\n    def __reduce__(self):\n        return (self.__class__, self._getstate())"
        ],
        [
            "LOAD_NAME",
            "timedelta"
        ],
        [
            "CALL",
            "timedelta(-999999999)"
        ],
        [
            "LOAD_NAME",
            "timedelta"
        ],
        [
            "STORE_ATTR",
            "timedelta.min"
        ],
        [
            "LOAD_NAME",
            "timedelta"
        ],
        [
            "CALL",
            "timedelta(days=999999999, hours=23, minutes=59, seconds=59,\n                          microseconds=999999)"
        ],
        [
            "LOAD_NAME",
            "timedelta"
        ],
        [
            "STORE_ATTR",
            "timedelta.max"
        ],
        [
            "LOAD_NAME",
            "timedelta"
        ],
        [
            "CALL",
            "timedelta(microseconds=1)"
        ],
        [
            "LOAD_NAME",
            "timedelta"
        ],
        [
            "STORE_ATTR",
            "timedelta.resolution"
        ],
        [
            "CALL",
            "class date:\n    \"\"\"Concrete date type.\n\n    Constructors:\n\n    __new__()\n    fromtimestamp()\n    today()\n    fromordinal()\n\n    Operators:\n\n    __repr__, __str__\n    __eq__, __le__, __lt__, __ge__, __gt__, __hash__\n    __add__, __radd__, __sub__ (add/radd only with timedelta arg)\n\n    Methods:\n\n    timetuple()\n    toordinal()\n    weekday()\n    isoweekday(), isocalendar(), isoformat()\n    ctime()\n    strftime()\n\n    Properties (readonly):\n    year, month, day\n    \"\"\"\n    __slots__ = '_year', '_month', '_day', '_hashcode'\n\n    def __new__(cls, year, month=None, day=None):\n        \"\"\"Constructor.\n\n        Arguments:\n\n        year, month, day (required, base 1)\n        \"\"\"\n        if (month is None and\n            isinstance(year, (bytes, str)) and len(year) == 4 and\n            1 <= ord(year[2:3]) <= 12):\n            # Pickle support\n            if isinstance(year, str):\n                try:\n                    year = year.encode('latin1')\n                except UnicodeEncodeError:\n                    # More informative error message.\n                    raise ValueError(\n                        \"Failed to encode latin1 string when unpickling \"\n                        \"a date object. \"\n                        \"pickle.load(data, encoding='latin1') is assumed.\")\n            self = object.__new__(cls)\n            self.__setstate(year)\n            self._hashcode = -1\n            return self\n        year, month, day = _check_date_fields(year, month, day)\n        self = object.__new__(cls)\n        self._year = year\n        self._month = month\n        self._day = day\n        self._hashcode = -1\n        return self\n\n    # Additional constructors\n\n    @classmethod\n    def fromtimestamp(cls, t):\n        \"Construct a date from a POSIX timestamp (like time.time()).\"\n        y, m, d, hh, mm, ss, weekday, jday, dst = _time.localtime(t)\n        return cls(y, m, d)\n\n    @classmethod\n    def today(cls):\n        \"Construct a date from time.time().\"\n        t = _time.time()\n        return cls.fromtimestamp(t)\n\n    @classmethod\n    def fromordinal(cls, n):\n        \"\"\"Construct a date from a proleptic Gregorian ordinal.\n\n        January 1 of year 1 is day 1.  Only the year, month and day are\n        non-zero in the result.\n        \"\"\"\n        y, m, d = _ord2ymd(n)\n        return cls(y, m, d)\n\n    @classmethod\n    def fromisoformat(cls, date_string):\n        \"\"\"Construct a date from a string in ISO 8601 format.\"\"\"\n        if not isinstance(date_string, str):\n            raise TypeError('fromisoformat: argument must be str')\n\n        if len(date_string) not in (7, 8, 10):\n            raise ValueError(f'Invalid isoformat string: {date_string!r}')\n\n        try:\n            return cls(*_parse_isoformat_date(date_string))\n        except Exception:\n            raise ValueError(f'Invalid isoformat string: {date_string!r}')\n\n    @classmethod\n    def fromisocalendar(cls, year, week, day):\n        \"\"\"Construct a date from the ISO year, week number and weekday.\n\n        This is the inverse of the date.isocalendar() function\"\"\"\n        return cls(*_isoweek_to_gregorian(year, week, day))\n\n    # Conversions to string\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\n\n        >>> dt = datetime(2010, 1, 1)\n        >>> repr(dt)\n        'datetime.datetime(2010, 1, 1, 0, 0)'\n\n        >>> dt = datetime(2010, 1, 1, tzinfo=timezone.utc)\n        >>> repr(dt)\n        'datetime.datetime(2010, 1, 1, 0, 0, tzinfo=datetime.timezone.utc)'\n        \"\"\"\n        return \"%s.%s(%d, %d, %d)\" % (self.__class__.__module__,\n                                      self.__class__.__qualname__,\n                                      self._year,\n                                      self._month,\n                                      self._day)\n    # XXX These shouldn't depend on time.localtime(), because that\n    # clips the usable dates to [1970 .. 2038).  At least ctime() is\n    # easily done without using strftime() -- that's better too because\n    # strftime(\"%c\", ...) is locale specific.\n\n\n    def ctime(self):\n        \"Return ctime() style string.\"\n        weekday = self.toordinal() % 7 or 7\n        return \"%s %s %2d 00:00:00 %04d\" % (\n            _DAYNAMES[weekday],\n            _MONTHNAMES[self._month],\n            self._day, self._year)\n\n    def strftime(self, fmt):\n        \"Format using strftime().\"\n        return _wrap_strftime(self, fmt, self.timetuple())\n\n    def __format__(self, fmt):\n        if not isinstance(fmt, str):\n            raise TypeError(\"must be str, not %s\" % type(fmt).__name__)\n        if len(fmt) != 0:\n            return self.strftime(fmt)\n        return str(self)\n\n    def isoformat(self):\n        \"\"\"Return the date formatted according to ISO.\n\n        This is 'YYYY-MM-DD'.\n\n        References:\n        - http://www.w3.org/TR/NOTE-datetime\n        - http://www.cl.cam.ac.uk/~mgk25/iso-time.html\n        \"\"\"\n        return \"%04d-%02d-%02d\" % (self._year, self._month, self._day)\n\n    __str__ = isoformat\n\n    # Read-only field accessors\n    @property\n    def year(self):\n        \"\"\"year (1-9999)\"\"\"\n        return self._year\n\n    @property\n    def month(self):\n        \"\"\"month (1-12)\"\"\"\n        return self._month\n\n    @property\n    def day(self):\n        \"\"\"day (1-31)\"\"\"\n        return self._day\n\n    # Standard conversions, __eq__, __le__, __lt__, __ge__, __gt__,\n    # __hash__ (and helpers)\n\n    def timetuple(self):\n        \"Return local time tuple compatible with time.localtime().\"\n        return _build_struct_time(self._year, self._month, self._day,\n                                  0, 0, 0, -1)\n\n    def toordinal(self):\n        \"\"\"Return proleptic Gregorian ordinal for the year, month and day.\n\n        January 1 of year 1 is day 1.  Only the year, month and day values\n        contribute to the result.\n        \"\"\"\n        return _ymd2ord(self._year, self._month, self._day)\n\n    def replace(self, year=None, month=None, day=None):\n        \"\"\"Return a new date with new values for the specified fields.\"\"\"\n        if year is None:\n            year = self._year\n        if month is None:\n            month = self._month\n        if day is None:\n            day = self._day\n        return type(self)(year, month, day)\n\n    # Comparisons of date objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) == 0\n        return NotImplemented\n\n    def __le__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) <= 0\n        return NotImplemented\n\n    def __lt__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) < 0\n        return NotImplemented\n\n    def __ge__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) >= 0\n        return NotImplemented\n\n    def __gt__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) > 0\n        return NotImplemented\n\n    def _cmp(self, other):\n        assert isinstance(other, date)\n        y, m, d = self._year, self._month, self._day\n        y2, m2, d2 = other._year, other._month, other._day\n        return _cmp((y, m, d), (y2, m2, d2))\n\n    def __hash__(self):\n        \"Hash.\"\n        if self._hashcode == -1:\n            self._hashcode = hash(self._getstate())\n        return self._hashcode\n\n    # Computations\n\n    def __add__(self, other):\n        \"Add a date to a timedelta.\"\n        if isinstance(other, timedelta):\n            o = self.toordinal() + other.days\n            if 0 < o <= _MAXORDINAL:\n                return type(self).fromordinal(o)\n            raise OverflowError(\"result out of range\")\n        return NotImplemented\n\n    __radd__ = __add__\n\n    def __sub__(self, other):\n        \"\"\"Subtract two dates, or a date and a timedelta.\"\"\"\n        if isinstance(other, timedelta):\n            return self + timedelta(-other.days)\n        if isinstance(other, date):\n            days1 = self.toordinal()\n            days2 = other.toordinal()\n            return timedelta(days1 - days2)\n        return NotImplemented\n\n    def weekday(self):\n        \"Return day of the week, where Monday == 0 ... Sunday == 6.\"\n        return (self.toordinal() + 6) % 7\n\n    # Day-of-the-week and week-of-the-year, according to ISO\n\n    def isoweekday(self):\n        \"Return day of the week, where Monday == 1 ... Sunday == 7.\"\n        # 1-Jan-0001 is a Monday\n        return self.toordinal() % 7 or 7\n\n    def isocalendar(self):\n        \"\"\"Return a named tuple containing ISO year, week number, and weekday.\n\n        The first ISO week of the year is the (Mon-Sun) week\n        containing the year's first Thursday; everything else derives\n        from that.\n\n        The first week is 1; Monday is 1 ... Sunday is 7.\n\n        ISO calendar algorithm taken from\n        http://www.phys.uu.nl/~vgent/calendar/isocalendar.htm\n        (used with permission)\n        \"\"\"\n        year = self._year\n        week1monday = _isoweek1monday(year)\n        today = _ymd2ord(self._year, self._month, self._day)\n        # Internally, week and day have origin 0\n        week, day = divmod(today - week1monday, 7)\n        if week < 0:\n            year -= 1\n            week1monday = _isoweek1monday(year)\n            week, day = divmod(today - week1monday, 7)\n        elif week >= 52:\n            if today >= _isoweek1monday(year+1):\n                year += 1\n                week = 0\n        return _IsoCalendarDate(year, week+1, day+1)\n\n    # Pickle support.\n\n    def _getstate(self):\n        yhi, ylo = divmod(self._year, 256)\n        return bytes([yhi, ylo, self._month, self._day]),\n\n    def __setstate(self, string):\n        yhi, ylo, self._month, self._day = string\n        self._year = yhi * 256 + ylo\n\n    def __reduce__(self):\n        return (self.__class__, self._getstate())"
        ],
        [
            "STORE_NAME",
            "class date:\n    \"\"\"Concrete date type.\n\n    Constructors:\n\n    __new__()\n    fromtimestamp()\n    today()\n    fromordinal()\n\n    Operators:\n\n    __repr__, __str__\n    __eq__, __le__, __lt__, __ge__, __gt__, __hash__\n    __add__, __radd__, __sub__ (add/radd only with timedelta arg)\n\n    Methods:\n\n    timetuple()\n    toordinal()\n    weekday()\n    isoweekday(), isocalendar(), isoformat()\n    ctime()\n    strftime()\n\n    Properties (readonly):\n    year, month, day\n    \"\"\"\n    __slots__ = '_year', '_month', '_day', '_hashcode'\n\n    def __new__(cls, year, month=None, day=None):\n        \"\"\"Constructor.\n\n        Arguments:\n\n        year, month, day (required, base 1)\n        \"\"\"\n        if (month is None and\n            isinstance(year, (bytes, str)) and len(year) == 4 and\n            1 <= ord(year[2:3]) <= 12):\n            # Pickle support\n            if isinstance(year, str):\n                try:\n                    year = year.encode('latin1')\n                except UnicodeEncodeError:\n                    # More informative error message.\n                    raise ValueError(\n                        \"Failed to encode latin1 string when unpickling \"\n                        \"a date object. \"\n                        \"pickle.load(data, encoding='latin1') is assumed.\")\n            self = object.__new__(cls)\n            self.__setstate(year)\n            self._hashcode = -1\n            return self\n        year, month, day = _check_date_fields(year, month, day)\n        self = object.__new__(cls)\n        self._year = year\n        self._month = month\n        self._day = day\n        self._hashcode = -1\n        return self\n\n    # Additional constructors\n\n    @classmethod\n    def fromtimestamp(cls, t):\n        \"Construct a date from a POSIX timestamp (like time.time()).\"\n        y, m, d, hh, mm, ss, weekday, jday, dst = _time.localtime(t)\n        return cls(y, m, d)\n\n    @classmethod\n    def today(cls):\n        \"Construct a date from time.time().\"\n        t = _time.time()\n        return cls.fromtimestamp(t)\n\n    @classmethod\n    def fromordinal(cls, n):\n        \"\"\"Construct a date from a proleptic Gregorian ordinal.\n\n        January 1 of year 1 is day 1.  Only the year, month and day are\n        non-zero in the result.\n        \"\"\"\n        y, m, d = _ord2ymd(n)\n        return cls(y, m, d)\n\n    @classmethod\n    def fromisoformat(cls, date_string):\n        \"\"\"Construct a date from a string in ISO 8601 format.\"\"\"\n        if not isinstance(date_string, str):\n            raise TypeError('fromisoformat: argument must be str')\n\n        if len(date_string) not in (7, 8, 10):\n            raise ValueError(f'Invalid isoformat string: {date_string!r}')\n\n        try:\n            return cls(*_parse_isoformat_date(date_string))\n        except Exception:\n            raise ValueError(f'Invalid isoformat string: {date_string!r}')\n\n    @classmethod\n    def fromisocalendar(cls, year, week, day):\n        \"\"\"Construct a date from the ISO year, week number and weekday.\n\n        This is the inverse of the date.isocalendar() function\"\"\"\n        return cls(*_isoweek_to_gregorian(year, week, day))\n\n    # Conversions to string\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\n\n        >>> dt = datetime(2010, 1, 1)\n        >>> repr(dt)\n        'datetime.datetime(2010, 1, 1, 0, 0)'\n\n        >>> dt = datetime(2010, 1, 1, tzinfo=timezone.utc)\n        >>> repr(dt)\n        'datetime.datetime(2010, 1, 1, 0, 0, tzinfo=datetime.timezone.utc)'\n        \"\"\"\n        return \"%s.%s(%d, %d, %d)\" % (self.__class__.__module__,\n                                      self.__class__.__qualname__,\n                                      self._year,\n                                      self._month,\n                                      self._day)\n    # XXX These shouldn't depend on time.localtime(), because that\n    # clips the usable dates to [1970 .. 2038).  At least ctime() is\n    # easily done without using strftime() -- that's better too because\n    # strftime(\"%c\", ...) is locale specific.\n\n\n    def ctime(self):\n        \"Return ctime() style string.\"\n        weekday = self.toordinal() % 7 or 7\n        return \"%s %s %2d 00:00:00 %04d\" % (\n            _DAYNAMES[weekday],\n            _MONTHNAMES[self._month],\n            self._day, self._year)\n\n    def strftime(self, fmt):\n        \"Format using strftime().\"\n        return _wrap_strftime(self, fmt, self.timetuple())\n\n    def __format__(self, fmt):\n        if not isinstance(fmt, str):\n            raise TypeError(\"must be str, not %s\" % type(fmt).__name__)\n        if len(fmt) != 0:\n            return self.strftime(fmt)\n        return str(self)\n\n    def isoformat(self):\n        \"\"\"Return the date formatted according to ISO.\n\n        This is 'YYYY-MM-DD'.\n\n        References:\n        - http://www.w3.org/TR/NOTE-datetime\n        - http://www.cl.cam.ac.uk/~mgk25/iso-time.html\n        \"\"\"\n        return \"%04d-%02d-%02d\" % (self._year, self._month, self._day)\n\n    __str__ = isoformat\n\n    # Read-only field accessors\n    @property\n    def year(self):\n        \"\"\"year (1-9999)\"\"\"\n        return self._year\n\n    @property\n    def month(self):\n        \"\"\"month (1-12)\"\"\"\n        return self._month\n\n    @property\n    def day(self):\n        \"\"\"day (1-31)\"\"\"\n        return self._day\n\n    # Standard conversions, __eq__, __le__, __lt__, __ge__, __gt__,\n    # __hash__ (and helpers)\n\n    def timetuple(self):\n        \"Return local time tuple compatible with time.localtime().\"\n        return _build_struct_time(self._year, self._month, self._day,\n                                  0, 0, 0, -1)\n\n    def toordinal(self):\n        \"\"\"Return proleptic Gregorian ordinal for the year, month and day.\n\n        January 1 of year 1 is day 1.  Only the year, month and day values\n        contribute to the result.\n        \"\"\"\n        return _ymd2ord(self._year, self._month, self._day)\n\n    def replace(self, year=None, month=None, day=None):\n        \"\"\"Return a new date with new values for the specified fields.\"\"\"\n        if year is None:\n            year = self._year\n        if month is None:\n            month = self._month\n        if day is None:\n            day = self._day\n        return type(self)(year, month, day)\n\n    # Comparisons of date objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) == 0\n        return NotImplemented\n\n    def __le__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) <= 0\n        return NotImplemented\n\n    def __lt__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) < 0\n        return NotImplemented\n\n    def __ge__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) >= 0\n        return NotImplemented\n\n    def __gt__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) > 0\n        return NotImplemented\n\n    def _cmp(self, other):\n        assert isinstance(other, date)\n        y, m, d = self._year, self._month, self._day\n        y2, m2, d2 = other._year, other._month, other._day\n        return _cmp((y, m, d), (y2, m2, d2))\n\n    def __hash__(self):\n        \"Hash.\"\n        if self._hashcode == -1:\n            self._hashcode = hash(self._getstate())\n        return self._hashcode\n\n    # Computations\n\n    def __add__(self, other):\n        \"Add a date to a timedelta.\"\n        if isinstance(other, timedelta):\n            o = self.toordinal() + other.days\n            if 0 < o <= _MAXORDINAL:\n                return type(self).fromordinal(o)\n            raise OverflowError(\"result out of range\")\n        return NotImplemented\n\n    __radd__ = __add__\n\n    def __sub__(self, other):\n        \"\"\"Subtract two dates, or a date and a timedelta.\"\"\"\n        if isinstance(other, timedelta):\n            return self + timedelta(-other.days)\n        if isinstance(other, date):\n            days1 = self.toordinal()\n            days2 = other.toordinal()\n            return timedelta(days1 - days2)\n        return NotImplemented\n\n    def weekday(self):\n        \"Return day of the week, where Monday == 0 ... Sunday == 6.\"\n        return (self.toordinal() + 6) % 7\n\n    # Day-of-the-week and week-of-the-year, according to ISO\n\n    def isoweekday(self):\n        \"Return day of the week, where Monday == 1 ... Sunday == 7.\"\n        # 1-Jan-0001 is a Monday\n        return self.toordinal() % 7 or 7\n\n    def isocalendar(self):\n        \"\"\"Return a named tuple containing ISO year, week number, and weekday.\n\n        The first ISO week of the year is the (Mon-Sun) week\n        containing the year's first Thursday; everything else derives\n        from that.\n\n        The first week is 1; Monday is 1 ... Sunday is 7.\n\n        ISO calendar algorithm taken from\n        http://www.phys.uu.nl/~vgent/calendar/isocalendar.htm\n        (used with permission)\n        \"\"\"\n        year = self._year\n        week1monday = _isoweek1monday(year)\n        today = _ymd2ord(self._year, self._month, self._day)\n        # Internally, week and day have origin 0\n        week, day = divmod(today - week1monday, 7)\n        if week < 0:\n            year -= 1\n            week1monday = _isoweek1monday(year)\n            week, day = divmod(today - week1monday, 7)\n        elif week >= 52:\n            if today >= _isoweek1monday(year+1):\n                year += 1\n                week = 0\n        return _IsoCalendarDate(year, week+1, day+1)\n\n    # Pickle support.\n\n    def _getstate(self):\n        yhi, ylo = divmod(self._year, 256)\n        return bytes([yhi, ylo, self._month, self._day]),\n\n    def __setstate(self, string):\n        yhi, ylo, self._month, self._day = string\n        self._year = yhi * 256 + ylo\n\n    def __reduce__(self):\n        return (self.__class__, self._getstate())"
        ],
        [
            "LOAD_NAME",
            "date"
        ],
        [
            "STORE_NAME",
            "_date_class"
        ],
        [
            "LOAD_NAME",
            "date"
        ],
        [
            "CALL",
            "date(1, 1, 1)"
        ],
        [
            "LOAD_NAME",
            "date"
        ],
        [
            "STORE_ATTR",
            "date.min"
        ],
        [
            "LOAD_NAME",
            "date"
        ],
        [
            "CALL",
            "date(9999, 12, 31)"
        ],
        [
            "LOAD_NAME",
            "date"
        ],
        [
            "STORE_ATTR",
            "date.max"
        ],
        [
            "LOAD_NAME",
            "timedelta"
        ],
        [
            "CALL",
            "timedelta(days=1)"
        ],
        [
            "LOAD_NAME",
            "date"
        ],
        [
            "STORE_ATTR",
            "date.resolution"
        ],
        [
            "CALL",
            "class tzinfo:\n    \"\"\"Abstract base class for time zone info classes.\n\n    Subclasses must override the name(), utcoffset() and dst() methods.\n    \"\"\"\n    __slots__ = ()\n\n    def tzname(self, dt):\n        \"datetime -> string name of time zone.\"\n        raise NotImplementedError(\"tzinfo subclass must override tzname()\")\n\n    def utcoffset(self, dt):\n        \"datetime -> timedelta, positive for east of UTC, negative for west of UTC\"\n        raise NotImplementedError(\"tzinfo subclass must override utcoffset()\")\n\n    def dst(self, dt):\n        \"\"\"datetime -> DST offset as timedelta, positive for east of UTC.\n\n        Return 0 if DST not in effect.  utcoffset() must include the DST\n        offset.\n        \"\"\"\n        raise NotImplementedError(\"tzinfo subclass must override dst()\")\n\n    def fromutc(self, dt):\n        \"datetime in UTC -> datetime in local time.\"\n\n        if not isinstance(dt, datetime):\n            raise TypeError(\"fromutc() requires a datetime argument\")\n        if dt.tzinfo is not self:\n            raise ValueError(\"dt.tzinfo is not self\")\n\n        dtoff = dt.utcoffset()\n        if dtoff is None:\n            raise ValueError(\"fromutc() requires a non-None utcoffset() \"\n                             \"result\")\n\n        # See the long comment block at the end of this file for an\n        # explanation of this algorithm.\n        dtdst = dt.dst()\n        if dtdst is None:\n            raise ValueError(\"fromutc() requires a non-None dst() result\")\n        delta = dtoff - dtdst\n        if delta:\n            dt += delta\n            dtdst = dt.dst()\n            if dtdst is None:\n                raise ValueError(\"fromutc(): dt.dst gave inconsistent \"\n                                 \"results; cannot convert\")\n        return dt + dtdst\n\n    # Pickle support.\n\n    def __reduce__(self):\n        getinitargs = getattr(self, \"__getinitargs__\", None)\n        if getinitargs:\n            args = getinitargs()\n        else:\n            args = ()\n        return (self.__class__, args, self.__getstate__())"
        ],
        [
            "STORE_NAME",
            "class tzinfo:\n    \"\"\"Abstract base class for time zone info classes.\n\n    Subclasses must override the name(), utcoffset() and dst() methods.\n    \"\"\"\n    __slots__ = ()\n\n    def tzname(self, dt):\n        \"datetime -> string name of time zone.\"\n        raise NotImplementedError(\"tzinfo subclass must override tzname()\")\n\n    def utcoffset(self, dt):\n        \"datetime -> timedelta, positive for east of UTC, negative for west of UTC\"\n        raise NotImplementedError(\"tzinfo subclass must override utcoffset()\")\n\n    def dst(self, dt):\n        \"\"\"datetime -> DST offset as timedelta, positive for east of UTC.\n\n        Return 0 if DST not in effect.  utcoffset() must include the DST\n        offset.\n        \"\"\"\n        raise NotImplementedError(\"tzinfo subclass must override dst()\")\n\n    def fromutc(self, dt):\n        \"datetime in UTC -> datetime in local time.\"\n\n        if not isinstance(dt, datetime):\n            raise TypeError(\"fromutc() requires a datetime argument\")\n        if dt.tzinfo is not self:\n            raise ValueError(\"dt.tzinfo is not self\")\n\n        dtoff = dt.utcoffset()\n        if dtoff is None:\n            raise ValueError(\"fromutc() requires a non-None utcoffset() \"\n                             \"result\")\n\n        # See the long comment block at the end of this file for an\n        # explanation of this algorithm.\n        dtdst = dt.dst()\n        if dtdst is None:\n            raise ValueError(\"fromutc() requires a non-None dst() result\")\n        delta = dtoff - dtdst\n        if delta:\n            dt += delta\n            dtdst = dt.dst()\n            if dtdst is None:\n                raise ValueError(\"fromutc(): dt.dst gave inconsistent \"\n                                 \"results; cannot convert\")\n        return dt + dtdst\n\n    # Pickle support.\n\n    def __reduce__(self):\n        getinitargs = getattr(self, \"__getinitargs__\", None)\n        if getinitargs:\n            args = getinitargs()\n        else:\n            args = ()\n        return (self.__class__, args, self.__getstate__())"
        ],
        [
            "LOAD_NAME",
            "tuple"
        ],
        [
            "CALL",
            "class IsoCalendarDate(tuple):\n\n    def __new__(cls, year, week, weekday, /):\n        return super().__new__(cls, (year, week, weekday))\n\n    @property\n    def year(self):\n        return self[0]\n\n    @property\n    def week(self):\n        return self[1]\n\n    @property\n    def weekday(self):\n        return self[2]\n\n    def __reduce__(self):\n        # This code is intended to pickle the object without making the\n        # class public. See https://bugs.python.org/msg352381\n        return (tuple, (tuple(self),))\n\n    def __repr__(self):\n        return (f'{self.__class__.__name__}'\n                f'(year={self[0]}, week={self[1]}, weekday={self[2]})')"
        ],
        [
            "STORE_NAME",
            "class IsoCalendarDate(tuple):\n\n    def __new__(cls, year, week, weekday, /):\n        return super().__new__(cls, (year, week, weekday))\n\n    @property\n    def year(self):\n        return self[0]\n\n    @property\n    def week(self):\n        return self[1]\n\n    @property\n    def weekday(self):\n        return self[2]\n\n    def __reduce__(self):\n        # This code is intended to pickle the object without making the\n        # class public. See https://bugs.python.org/msg352381\n        return (tuple, (tuple(self),))\n\n    def __repr__(self):\n        return (f'{self.__class__.__name__}'\n                f'(year={self[0]}, week={self[1]}, weekday={self[2]})')"
        ],
        [
            "LOAD_NAME",
            "IsoCalendarDate"
        ],
        [
            "STORE_NAME",
            "_IsoCalendarDate"
        ],
        [
            "DELETE_NAME",
            "IsoCalendarDate"
        ],
        [
            "LOAD_NAME",
            "tzinfo"
        ],
        [
            "STORE_NAME",
            "_tzinfo_class"
        ],
        [
            "CALL",
            "class time:\n    \"\"\"Time with time zone.\n\n    Constructors:\n\n    __new__()\n\n    Operators:\n\n    __repr__, __str__\n    __eq__, __le__, __lt__, __ge__, __gt__, __hash__\n\n    Methods:\n\n    strftime()\n    isoformat()\n    utcoffset()\n    tzname()\n    dst()\n\n    Properties (readonly):\n    hour, minute, second, microsecond, tzinfo, fold\n    \"\"\"\n    __slots__ = '_hour', '_minute', '_second', '_microsecond', '_tzinfo', '_hashcode', '_fold'\n\n    def __new__(cls, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0):\n        \"\"\"Constructor.\n\n        Arguments:\n\n        hour, minute (required)\n        second, microsecond (default to zero)\n        tzinfo (default to None)\n        fold (keyword only, default to zero)\n        \"\"\"\n        if (isinstance(hour, (bytes, str)) and len(hour) == 6 and\n            ord(hour[0:1])&0x7F < 24):\n            # Pickle support\n            if isinstance(hour, str):\n                try:\n                    hour = hour.encode('latin1')\n                except UnicodeEncodeError:\n                    # More informative error message.\n                    raise ValueError(\n                        \"Failed to encode latin1 string when unpickling \"\n                        \"a time object. \"\n                        \"pickle.load(data, encoding='latin1') is assumed.\")\n            self = object.__new__(cls)\n            self.__setstate(hour, minute or None)\n            self._hashcode = -1\n            return self\n        hour, minute, second, microsecond, fold = _check_time_fields(\n            hour, minute, second, microsecond, fold)\n        _check_tzinfo_arg(tzinfo)\n        self = object.__new__(cls)\n        self._hour = hour\n        self._minute = minute\n        self._second = second\n        self._microsecond = microsecond\n        self._tzinfo = tzinfo\n        self._hashcode = -1\n        self._fold = fold\n        return self\n\n    # Read-only field accessors\n    @property\n    def hour(self):\n        \"\"\"hour (0-23)\"\"\"\n        return self._hour\n\n    @property\n    def minute(self):\n        \"\"\"minute (0-59)\"\"\"\n        return self._minute\n\n    @property\n    def second(self):\n        \"\"\"second (0-59)\"\"\"\n        return self._second\n\n    @property\n    def microsecond(self):\n        \"\"\"microsecond (0-999999)\"\"\"\n        return self._microsecond\n\n    @property\n    def tzinfo(self):\n        \"\"\"timezone info object\"\"\"\n        return self._tzinfo\n\n    @property\n    def fold(self):\n        return self._fold\n\n    # Standard conversions, __hash__ (and helpers)\n\n    # Comparisons of time objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other, allow_mixed=True) == 0\n        else:\n            return NotImplemented\n\n    def __le__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) <= 0\n        else:\n            return NotImplemented\n\n    def __lt__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) < 0\n        else:\n            return NotImplemented\n\n    def __ge__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) >= 0\n        else:\n            return NotImplemented\n\n    def __gt__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) > 0\n        else:\n            return NotImplemented\n\n    def _cmp(self, other, allow_mixed=False):\n        assert isinstance(other, time)\n        mytz = self._tzinfo\n        ottz = other._tzinfo\n        myoff = otoff = None\n\n        if mytz is ottz:\n            base_compare = True\n        else:\n            myoff = self.utcoffset()\n            otoff = other.utcoffset()\n            base_compare = myoff == otoff\n\n        if base_compare:\n            return _cmp((self._hour, self._minute, self._second,\n                         self._microsecond),\n                        (other._hour, other._minute, other._second,\n                         other._microsecond))\n        if myoff is None or otoff is None:\n            if allow_mixed:\n                return 2 # arbitrary non-zero value\n            else:\n                raise TypeError(\"cannot compare naive and aware times\")\n        myhhmm = self._hour * 60 + self._minute - myoff//timedelta(minutes=1)\n        othhmm = other._hour * 60 + other._minute - otoff//timedelta(minutes=1)\n        return _cmp((myhhmm, self._second, self._microsecond),\n                    (othhmm, other._second, other._microsecond))\n\n    def __hash__(self):\n        \"\"\"Hash.\"\"\"\n        if self._hashcode == -1:\n            if self.fold:\n                t = self.replace(fold=0)\n            else:\n                t = self\n            tzoff = t.utcoffset()\n            if not tzoff:  # zero or None\n                self._hashcode = hash(t._getstate()[0])\n            else:\n                h, m = divmod(timedelta(hours=self.hour, minutes=self.minute) - tzoff,\n                              timedelta(hours=1))\n                assert not m % timedelta(minutes=1), \"whole minute\"\n                m //= timedelta(minutes=1)\n                if 0 <= h < 24:\n                    self._hashcode = hash(time(h, m, self.second, self.microsecond))\n                else:\n                    self._hashcode = hash((h, m, self.second, self.microsecond))\n        return self._hashcode\n\n    # Conversion to string\n\n    def _tzstr(self):\n        \"\"\"Return formatted timezone offset (+xx:xx) or an empty string.\"\"\"\n        off = self.utcoffset()\n        return _format_offset(off)\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\"\"\"\n        if self._microsecond != 0:\n            s = \", %d, %d\" % (self._second, self._microsecond)\n        elif self._second != 0:\n            s = \", %d\" % self._second\n        else:\n            s = \"\"\n        s= \"%s.%s(%d, %d%s)\" % (self.__class__.__module__,\n                                self.__class__.__qualname__,\n                                self._hour, self._minute, s)\n        if self._tzinfo is not None:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", tzinfo=%r\" % self._tzinfo + \")\"\n        if self._fold:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", fold=1)\"\n        return s\n\n    def isoformat(self, timespec='auto'):\n        \"\"\"Return the time formatted according to ISO.\n\n        The full format is 'HH:MM:SS.mmmmmm+zz:zz'. By default, the fractional\n        part is omitted if self.microsecond == 0.\n\n        The optional argument timespec specifies the number of additional\n        terms of the time to include. Valid options are 'auto', 'hours',\n        'minutes', 'seconds', 'milliseconds' and 'microseconds'.\n        \"\"\"\n        s = _format_time(self._hour, self._minute, self._second,\n                          self._microsecond, timespec)\n        tz = self._tzstr()\n        if tz:\n            s += tz\n        return s\n\n    __str__ = isoformat\n\n    @classmethod\n    def fromisoformat(cls, time_string):\n        \"\"\"Construct a time from a string in one of the ISO 8601 formats.\"\"\"\n        if not isinstance(time_string, str):\n            raise TypeError('fromisoformat: argument must be str')\n\n        # The spec actually requires that time-only ISO 8601 strings start with\n        # T, but the extended format allows this to be omitted as long as there\n        # is no ambiguity with date strings.\n        time_string = time_string.removeprefix('T')\n\n        try:\n            return cls(*_parse_isoformat_time(time_string))\n        except Exception:\n            raise ValueError(f'Invalid isoformat string: {time_string!r}')\n\n\n    def strftime(self, fmt):\n        \"\"\"Format using strftime().  The date part of the timestamp passed\n        to underlying strftime should not be used.\n        \"\"\"\n        # The year must be >= 1000 else Python's strftime implementation\n        # can raise a bogus exception.\n        timetuple = (1900, 1, 1,\n                     self._hour, self._minute, self._second,\n                     0, 1, -1)\n        return _wrap_strftime(self, fmt, timetuple)\n\n    def __format__(self, fmt):\n        if not isinstance(fmt, str):\n            raise TypeError(\"must be str, not %s\" % type(fmt).__name__)\n        if len(fmt) != 0:\n            return self.strftime(fmt)\n        return str(self)\n\n    # Timezone functions\n\n    def utcoffset(self):\n        \"\"\"Return the timezone offset as timedelta, positive east of UTC\n         (negative west of UTC).\"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.utcoffset(None)\n        _check_utc_offset(\"utcoffset\", offset)\n        return offset\n\n    def tzname(self):\n        \"\"\"Return the timezone name.\n\n        Note that the name is 100% informational -- there's no requirement that\n        it mean anything in particular. For example, \"GMT\", \"UTC\", \"-500\",\n        \"-5:00\", \"EDT\", \"US/Eastern\", \"America/New York\" are all valid replies.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        name = self._tzinfo.tzname(None)\n        _check_tzname(name)\n        return name\n\n    def dst(self):\n        \"\"\"Return 0 if DST is not in effect, or the DST offset (as timedelta\n        positive eastward) if DST is in effect.\n\n        This is purely informational; the DST offset has already been added to\n        the UTC offset returned by utcoffset() if applicable, so there's no\n        need to consult dst() unless you're interested in displaying the DST\n        info.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.dst(None)\n        _check_utc_offset(\"dst\", offset)\n        return offset\n\n    def replace(self, hour=None, minute=None, second=None, microsecond=None,\n                tzinfo=True, *, fold=None):\n        \"\"\"Return a new time with new values for the specified fields.\"\"\"\n        if hour is None:\n            hour = self.hour\n        if minute is None:\n            minute = self.minute\n        if second is None:\n            second = self.second\n        if microsecond is None:\n            microsecond = self.microsecond\n        if tzinfo is True:\n            tzinfo = self.tzinfo\n        if fold is None:\n            fold = self._fold\n        return type(self)(hour, minute, second, microsecond, tzinfo, fold=fold)\n\n    # Pickle support.\n\n    def _getstate(self, protocol=3):\n        us2, us3 = divmod(self._microsecond, 256)\n        us1, us2 = divmod(us2, 256)\n        h = self._hour\n        if self._fold and protocol > 3:\n            h += 128\n        basestate = bytes([h, self._minute, self._second,\n                           us1, us2, us3])\n        if self._tzinfo is None:\n            return (basestate,)\n        else:\n            return (basestate, self._tzinfo)\n\n    def __setstate(self, string, tzinfo):\n        if tzinfo is not None and not isinstance(tzinfo, _tzinfo_class):\n            raise TypeError(\"bad tzinfo state arg\")\n        h, self._minute, self._second, us1, us2, us3 = string\n        if h > 127:\n            self._fold = 1\n            self._hour = h - 128\n        else:\n            self._fold = 0\n            self._hour = h\n        self._microsecond = (((us1 << 8) | us2) << 8) | us3\n        self._tzinfo = tzinfo\n\n    def __reduce_ex__(self, protocol):\n        return (self.__class__, self._getstate(protocol))\n\n    def __reduce__(self):\n        return self.__reduce_ex__(2)"
        ],
        [
            "STORE_NAME",
            "class time:\n    \"\"\"Time with time zone.\n\n    Constructors:\n\n    __new__()\n\n    Operators:\n\n    __repr__, __str__\n    __eq__, __le__, __lt__, __ge__, __gt__, __hash__\n\n    Methods:\n\n    strftime()\n    isoformat()\n    utcoffset()\n    tzname()\n    dst()\n\n    Properties (readonly):\n    hour, minute, second, microsecond, tzinfo, fold\n    \"\"\"\n    __slots__ = '_hour', '_minute', '_second', '_microsecond', '_tzinfo', '_hashcode', '_fold'\n\n    def __new__(cls, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0):\n        \"\"\"Constructor.\n\n        Arguments:\n\n        hour, minute (required)\n        second, microsecond (default to zero)\n        tzinfo (default to None)\n        fold (keyword only, default to zero)\n        \"\"\"\n        if (isinstance(hour, (bytes, str)) and len(hour) == 6 and\n            ord(hour[0:1])&0x7F < 24):\n            # Pickle support\n            if isinstance(hour, str):\n                try:\n                    hour = hour.encode('latin1')\n                except UnicodeEncodeError:\n                    # More informative error message.\n                    raise ValueError(\n                        \"Failed to encode latin1 string when unpickling \"\n                        \"a time object. \"\n                        \"pickle.load(data, encoding='latin1') is assumed.\")\n            self = object.__new__(cls)\n            self.__setstate(hour, minute or None)\n            self._hashcode = -1\n            return self\n        hour, minute, second, microsecond, fold = _check_time_fields(\n            hour, minute, second, microsecond, fold)\n        _check_tzinfo_arg(tzinfo)\n        self = object.__new__(cls)\n        self._hour = hour\n        self._minute = minute\n        self._second = second\n        self._microsecond = microsecond\n        self._tzinfo = tzinfo\n        self._hashcode = -1\n        self._fold = fold\n        return self\n\n    # Read-only field accessors\n    @property\n    def hour(self):\n        \"\"\"hour (0-23)\"\"\"\n        return self._hour\n\n    @property\n    def minute(self):\n        \"\"\"minute (0-59)\"\"\"\n        return self._minute\n\n    @property\n    def second(self):\n        \"\"\"second (0-59)\"\"\"\n        return self._second\n\n    @property\n    def microsecond(self):\n        \"\"\"microsecond (0-999999)\"\"\"\n        return self._microsecond\n\n    @property\n    def tzinfo(self):\n        \"\"\"timezone info object\"\"\"\n        return self._tzinfo\n\n    @property\n    def fold(self):\n        return self._fold\n\n    # Standard conversions, __hash__ (and helpers)\n\n    # Comparisons of time objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other, allow_mixed=True) == 0\n        else:\n            return NotImplemented\n\n    def __le__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) <= 0\n        else:\n            return NotImplemented\n\n    def __lt__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) < 0\n        else:\n            return NotImplemented\n\n    def __ge__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) >= 0\n        else:\n            return NotImplemented\n\n    def __gt__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) > 0\n        else:\n            return NotImplemented\n\n    def _cmp(self, other, allow_mixed=False):\n        assert isinstance(other, time)\n        mytz = self._tzinfo\n        ottz = other._tzinfo\n        myoff = otoff = None\n\n        if mytz is ottz:\n            base_compare = True\n        else:\n            myoff = self.utcoffset()\n            otoff = other.utcoffset()\n            base_compare = myoff == otoff\n\n        if base_compare:\n            return _cmp((self._hour, self._minute, self._second,\n                         self._microsecond),\n                        (other._hour, other._minute, other._second,\n                         other._microsecond))\n        if myoff is None or otoff is None:\n            if allow_mixed:\n                return 2 # arbitrary non-zero value\n            else:\n                raise TypeError(\"cannot compare naive and aware times\")\n        myhhmm = self._hour * 60 + self._minute - myoff//timedelta(minutes=1)\n        othhmm = other._hour * 60 + other._minute - otoff//timedelta(minutes=1)\n        return _cmp((myhhmm, self._second, self._microsecond),\n                    (othhmm, other._second, other._microsecond))\n\n    def __hash__(self):\n        \"\"\"Hash.\"\"\"\n        if self._hashcode == -1:\n            if self.fold:\n                t = self.replace(fold=0)\n            else:\n                t = self\n            tzoff = t.utcoffset()\n            if not tzoff:  # zero or None\n                self._hashcode = hash(t._getstate()[0])\n            else:\n                h, m = divmod(timedelta(hours=self.hour, minutes=self.minute) - tzoff,\n                              timedelta(hours=1))\n                assert not m % timedelta(minutes=1), \"whole minute\"\n                m //= timedelta(minutes=1)\n                if 0 <= h < 24:\n                    self._hashcode = hash(time(h, m, self.second, self.microsecond))\n                else:\n                    self._hashcode = hash((h, m, self.second, self.microsecond))\n        return self._hashcode\n\n    # Conversion to string\n\n    def _tzstr(self):\n        \"\"\"Return formatted timezone offset (+xx:xx) or an empty string.\"\"\"\n        off = self.utcoffset()\n        return _format_offset(off)\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\"\"\"\n        if self._microsecond != 0:\n            s = \", %d, %d\" % (self._second, self._microsecond)\n        elif self._second != 0:\n            s = \", %d\" % self._second\n        else:\n            s = \"\"\n        s= \"%s.%s(%d, %d%s)\" % (self.__class__.__module__,\n                                self.__class__.__qualname__,\n                                self._hour, self._minute, s)\n        if self._tzinfo is not None:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", tzinfo=%r\" % self._tzinfo + \")\"\n        if self._fold:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", fold=1)\"\n        return s\n\n    def isoformat(self, timespec='auto'):\n        \"\"\"Return the time formatted according to ISO.\n\n        The full format is 'HH:MM:SS.mmmmmm+zz:zz'. By default, the fractional\n        part is omitted if self.microsecond == 0.\n\n        The optional argument timespec specifies the number of additional\n        terms of the time to include. Valid options are 'auto', 'hours',\n        'minutes', 'seconds', 'milliseconds' and 'microseconds'.\n        \"\"\"\n        s = _format_time(self._hour, self._minute, self._second,\n                          self._microsecond, timespec)\n        tz = self._tzstr()\n        if tz:\n            s += tz\n        return s\n\n    __str__ = isoformat\n\n    @classmethod\n    def fromisoformat(cls, time_string):\n        \"\"\"Construct a time from a string in one of the ISO 8601 formats.\"\"\"\n        if not isinstance(time_string, str):\n            raise TypeError('fromisoformat: argument must be str')\n\n        # The spec actually requires that time-only ISO 8601 strings start with\n        # T, but the extended format allows this to be omitted as long as there\n        # is no ambiguity with date strings.\n        time_string = time_string.removeprefix('T')\n\n        try:\n            return cls(*_parse_isoformat_time(time_string))\n        except Exception:\n            raise ValueError(f'Invalid isoformat string: {time_string!r}')\n\n\n    def strftime(self, fmt):\n        \"\"\"Format using strftime().  The date part of the timestamp passed\n        to underlying strftime should not be used.\n        \"\"\"\n        # The year must be >= 1000 else Python's strftime implementation\n        # can raise a bogus exception.\n        timetuple = (1900, 1, 1,\n                     self._hour, self._minute, self._second,\n                     0, 1, -1)\n        return _wrap_strftime(self, fmt, timetuple)\n\n    def __format__(self, fmt):\n        if not isinstance(fmt, str):\n            raise TypeError(\"must be str, not %s\" % type(fmt).__name__)\n        if len(fmt) != 0:\n            return self.strftime(fmt)\n        return str(self)\n\n    # Timezone functions\n\n    def utcoffset(self):\n        \"\"\"Return the timezone offset as timedelta, positive east of UTC\n         (negative west of UTC).\"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.utcoffset(None)\n        _check_utc_offset(\"utcoffset\", offset)\n        return offset\n\n    def tzname(self):\n        \"\"\"Return the timezone name.\n\n        Note that the name is 100% informational -- there's no requirement that\n        it mean anything in particular. For example, \"GMT\", \"UTC\", \"-500\",\n        \"-5:00\", \"EDT\", \"US/Eastern\", \"America/New York\" are all valid replies.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        name = self._tzinfo.tzname(None)\n        _check_tzname(name)\n        return name\n\n    def dst(self):\n        \"\"\"Return 0 if DST is not in effect, or the DST offset (as timedelta\n        positive eastward) if DST is in effect.\n\n        This is purely informational; the DST offset has already been added to\n        the UTC offset returned by utcoffset() if applicable, so there's no\n        need to consult dst() unless you're interested in displaying the DST\n        info.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.dst(None)\n        _check_utc_offset(\"dst\", offset)\n        return offset\n\n    def replace(self, hour=None, minute=None, second=None, microsecond=None,\n                tzinfo=True, *, fold=None):\n        \"\"\"Return a new time with new values for the specified fields.\"\"\"\n        if hour is None:\n            hour = self.hour\n        if minute is None:\n            minute = self.minute\n        if second is None:\n            second = self.second\n        if microsecond is None:\n            microsecond = self.microsecond\n        if tzinfo is True:\n            tzinfo = self.tzinfo\n        if fold is None:\n            fold = self._fold\n        return type(self)(hour, minute, second, microsecond, tzinfo, fold=fold)\n\n    # Pickle support.\n\n    def _getstate(self, protocol=3):\n        us2, us3 = divmod(self._microsecond, 256)\n        us1, us2 = divmod(us2, 256)\n        h = self._hour\n        if self._fold and protocol > 3:\n            h += 128\n        basestate = bytes([h, self._minute, self._second,\n                           us1, us2, us3])\n        if self._tzinfo is None:\n            return (basestate,)\n        else:\n            return (basestate, self._tzinfo)\n\n    def __setstate(self, string, tzinfo):\n        if tzinfo is not None and not isinstance(tzinfo, _tzinfo_class):\n            raise TypeError(\"bad tzinfo state arg\")\n        h, self._minute, self._second, us1, us2, us3 = string\n        if h > 127:\n            self._fold = 1\n            self._hour = h - 128\n        else:\n            self._fold = 0\n            self._hour = h\n        self._microsecond = (((us1 << 8) | us2) << 8) | us3\n        self._tzinfo = tzinfo\n\n    def __reduce_ex__(self, protocol):\n        return (self.__class__, self._getstate(protocol))\n\n    def __reduce__(self):\n        return self.__reduce_ex__(2)"
        ],
        [
            "LOAD_NAME",
            "time"
        ],
        [
            "STORE_NAME",
            "_time_class"
        ],
        [
            "LOAD_NAME",
            "time"
        ],
        [
            "CALL",
            "time(0, 0, 0)"
        ],
        [
            "LOAD_NAME",
            "time"
        ],
        [
            "STORE_ATTR",
            "time.min"
        ],
        [
            "LOAD_NAME",
            "time"
        ],
        [
            "CALL",
            "time(23, 59, 59, 999999)"
        ],
        [
            "LOAD_NAME",
            "time"
        ],
        [
            "STORE_ATTR",
            "time.max"
        ],
        [
            "LOAD_NAME",
            "timedelta"
        ],
        [
            "CALL",
            "timedelta(microseconds=1)"
        ],
        [
            "LOAD_NAME",
            "time"
        ],
        [
            "STORE_ATTR",
            "time.resolution"
        ],
        [
            "LOAD_NAME",
            "date"
        ],
        [
            "CALL",
            "class datetime(date):\n    \"\"\"datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])\n\n    The year, month and day arguments are required. tzinfo may be None, or an\n    instance of a tzinfo subclass. The remaining arguments may be ints.\n    \"\"\"\n    __slots__ = date.__slots__ + time.__slots__\n\n    def __new__(cls, year, month=None, day=None, hour=0, minute=0, second=0,\n                microsecond=0, tzinfo=None, *, fold=0):\n        if (isinstance(year, (bytes, str)) and len(year) == 10 and\n            1 <= ord(year[2:3])&0x7F <= 12):\n            # Pickle support\n            if isinstance(year, str):\n                try:\n                    year = bytes(year, 'latin1')\n                except UnicodeEncodeError:\n                    # More informative error message.\n                    raise ValueError(\n                        \"Failed to encode latin1 string when unpickling \"\n                        \"a datetime object. \"\n                        \"pickle.load(data, encoding='latin1') is assumed.\")\n            self = object.__new__(cls)\n            self.__setstate(year, month)\n            self._hashcode = -1\n            return self\n        year, month, day = _check_date_fields(year, month, day)\n        hour, minute, second, microsecond, fold = _check_time_fields(\n            hour, minute, second, microsecond, fold)\n        _check_tzinfo_arg(tzinfo)\n        self = object.__new__(cls)\n        self._year = year\n        self._month = month\n        self._day = day\n        self._hour = hour\n        self._minute = minute\n        self._second = second\n        self._microsecond = microsecond\n        self._tzinfo = tzinfo\n        self._hashcode = -1\n        self._fold = fold\n        return self\n\n    # Read-only field accessors\n    @property\n    def hour(self):\n        \"\"\"hour (0-23)\"\"\"\n        return self._hour\n\n    @property\n    def minute(self):\n        \"\"\"minute (0-59)\"\"\"\n        return self._minute\n\n    @property\n    def second(self):\n        \"\"\"second (0-59)\"\"\"\n        return self._second\n\n    @property\n    def microsecond(self):\n        \"\"\"microsecond (0-999999)\"\"\"\n        return self._microsecond\n\n    @property\n    def tzinfo(self):\n        \"\"\"timezone info object\"\"\"\n        return self._tzinfo\n\n    @property\n    def fold(self):\n        return self._fold\n\n    @classmethod\n    def _fromtimestamp(cls, t, utc, tz):\n        \"\"\"Construct a datetime from a POSIX timestamp (like time.time()).\n\n        A timezone info object may be passed in as well.\n        \"\"\"\n        frac, t = _math.modf(t)\n        us = round(frac * 1e6)\n        if us >= 1000000:\n            t += 1\n            us -= 1000000\n        elif us < 0:\n            t -= 1\n            us += 1000000\n\n        converter = _time.gmtime if utc else _time.localtime\n        y, m, d, hh, mm, ss, weekday, jday, dst = converter(t)\n        ss = min(ss, 59)    # clamp out leap seconds if the platform has them\n        result = cls(y, m, d, hh, mm, ss, us, tz)\n        if tz is None and not utc:\n            # As of version 2015f max fold in IANA database is\n            # 23 hours at 1969-09-30 13:00:00 in Kwajalein.\n            # Let's probe 24 hours in the past to detect a transition:\n            max_fold_seconds = 24 * 3600\n\n            # On Windows localtime_s throws an OSError for negative values,\n            # thus we can't perform fold detection for values of time less\n            # than the max time fold. See comments in _datetimemodule's\n            # version of this method for more details.\n            if t < max_fold_seconds and sys.platform.startswith(\"win\"):\n                return result\n\n            y, m, d, hh, mm, ss = converter(t - max_fold_seconds)[:6]\n            probe1 = cls(y, m, d, hh, mm, ss, us, tz)\n            trans = result - probe1 - timedelta(0, max_fold_seconds)\n            if trans.days < 0:\n                y, m, d, hh, mm, ss = converter(t + trans // timedelta(0, 1))[:6]\n                probe2 = cls(y, m, d, hh, mm, ss, us, tz)\n                if probe2 == result:\n                    result._fold = 1\n        elif tz is not None:\n            result = tz.fromutc(result)\n        return result\n\n    @classmethod\n    def fromtimestamp(cls, t, tz=None):\n        \"\"\"Construct a datetime from a POSIX timestamp (like time.time()).\n\n        A timezone info object may be passed in as well.\n        \"\"\"\n        _check_tzinfo_arg(tz)\n\n        return cls._fromtimestamp(t, tz is not None, tz)\n\n    @classmethod\n    def utcfromtimestamp(cls, t):\n        \"\"\"Construct a naive UTC datetime from a POSIX timestamp.\"\"\"\n        return cls._fromtimestamp(t, True, None)\n\n    @classmethod\n    def now(cls, tz=None):\n        \"Construct a datetime from time.time() and optional time zone info.\"\n        t = _time.time()\n        return cls.fromtimestamp(t, tz)\n\n    @classmethod\n    def utcnow(cls):\n        \"Construct a UTC datetime from time.time().\"\n        t = _time.time()\n        return cls.utcfromtimestamp(t)\n\n    @classmethod\n    def combine(cls, date, time, tzinfo=True):\n        \"Construct a datetime from a given date and a given time.\"\n        if not isinstance(date, _date_class):\n            raise TypeError(\"date argument must be a date instance\")\n        if not isinstance(time, _time_class):\n            raise TypeError(\"time argument must be a time instance\")\n        if tzinfo is True:\n            tzinfo = time.tzinfo\n        return cls(date.year, date.month, date.day,\n                   time.hour, time.minute, time.second, time.microsecond,\n                   tzinfo, fold=time.fold)\n\n    @classmethod\n    def fromisoformat(cls, date_string):\n        \"\"\"Construct a datetime from a string in one of the ISO 8601 formats.\"\"\"\n        if not isinstance(date_string, str):\n            raise TypeError('fromisoformat: argument must be str')\n\n        if len(date_string) < 7:\n            raise ValueError(f'Invalid isoformat string: {date_string!r}')\n\n        # Split this at the separator\n        try:\n            separator_location = _find_isoformat_datetime_separator(date_string)\n            dstr = date_string[0:separator_location]\n            tstr = date_string[(separator_location+1):]\n\n            date_components = _parse_isoformat_date(dstr)\n        except ValueError:\n            raise ValueError(\n                f'Invalid isoformat string: {date_string!r}') from None\n\n        if tstr:\n            try:\n                time_components = _parse_isoformat_time(tstr)\n            except ValueError:\n                raise ValueError(\n                    f'Invalid isoformat string: {date_string!r}') from None\n        else:\n            time_components = [0, 0, 0, 0, None]\n\n        return cls(*(date_components + time_components))\n\n    def timetuple(self):\n        \"Return local time tuple compatible with time.localtime().\"\n        dst = self.dst()\n        if dst is None:\n            dst = -1\n        elif dst:\n            dst = 1\n        else:\n            dst = 0\n        return _build_struct_time(self.year, self.month, self.day,\n                                  self.hour, self.minute, self.second,\n                                  dst)\n\n    def _mktime(self):\n        \"\"\"Return integer POSIX timestamp.\"\"\"\n        epoch = datetime(1970, 1, 1)\n        max_fold_seconds = 24 * 3600\n        t = (self - epoch) // timedelta(0, 1)\n        def local(u):\n            y, m, d, hh, mm, ss = _time.localtime(u)[:6]\n            return (datetime(y, m, d, hh, mm, ss) - epoch) // timedelta(0, 1)\n\n        # Our goal is to solve t = local(u) for u.\n        a = local(t) - t\n        u1 = t - a\n        t1 = local(u1)\n        if t1 == t:\n            # We found one solution, but it may not be the one we need.\n            # Look for an earlier solution (if `fold` is 0), or a\n            # later one (if `fold` is 1).\n            u2 = u1 + (-max_fold_seconds, max_fold_seconds)[self.fold]\n            b = local(u2) - u2\n            if a == b:\n                return u1\n        else:\n            b = t1 - u1\n            assert a != b\n        u2 = t - b\n        t2 = local(u2)\n        if t2 == t:\n            return u2\n        if t1 == t:\n            return u1\n        # We have found both offsets a and b, but neither t - a nor t - b is\n        # a solution.  This means t is in the gap.\n        return (max, min)[self.fold](u1, u2)\n\n\n    def timestamp(self):\n        \"Return POSIX timestamp as float\"\n        if self._tzinfo is None:\n            s = self._mktime()\n            return s + self.microsecond / 1e6\n        else:\n            return (self - _EPOCH).total_seconds()\n\n    def utctimetuple(self):\n        \"Return UTC time tuple compatible with time.gmtime().\"\n        offset = self.utcoffset()\n        if offset:\n            self -= offset\n        y, m, d = self.year, self.month, self.day\n        hh, mm, ss = self.hour, self.minute, self.second\n        return _build_struct_time(y, m, d, hh, mm, ss, 0)\n\n    def date(self):\n        \"Return the date part.\"\n        return date(self._year, self._month, self._day)\n\n    def time(self):\n        \"Return the time part, with tzinfo None.\"\n        return time(self.hour, self.minute, self.second, self.microsecond, fold=self.fold)\n\n    def timetz(self):\n        \"Return the time part, with same tzinfo.\"\n        return time(self.hour, self.minute, self.second, self.microsecond,\n                    self._tzinfo, fold=self.fold)\n\n    def replace(self, year=None, month=None, day=None, hour=None,\n                minute=None, second=None, microsecond=None, tzinfo=True,\n                *, fold=None):\n        \"\"\"Return a new datetime with new values for the specified fields.\"\"\"\n        if year is None:\n            year = self.year\n        if month is None:\n            month = self.month\n        if day is None:\n            day = self.day\n        if hour is None:\n            hour = self.hour\n        if minute is None:\n            minute = self.minute\n        if second is None:\n            second = self.second\n        if microsecond is None:\n            microsecond = self.microsecond\n        if tzinfo is True:\n            tzinfo = self.tzinfo\n        if fold is None:\n            fold = self.fold\n        return type(self)(year, month, day, hour, minute, second,\n                          microsecond, tzinfo, fold=fold)\n\n    def _local_timezone(self):\n        if self.tzinfo is None:\n            ts = self._mktime()\n        else:\n            ts = (self - _EPOCH) // timedelta(seconds=1)\n        localtm = _time.localtime(ts)\n        local = datetime(*localtm[:6])\n        # Extract TZ data\n        gmtoff = localtm.tm_gmtoff\n        zone = localtm.tm_zone\n        return timezone(timedelta(seconds=gmtoff), zone)\n\n    def astimezone(self, tz=None):\n        if tz is None:\n            tz = self._local_timezone()\n        elif not isinstance(tz, tzinfo):\n            raise TypeError(\"tz argument must be an instance of tzinfo\")\n\n        mytz = self.tzinfo\n        if mytz is None:\n            mytz = self._local_timezone()\n            myoffset = mytz.utcoffset(self)\n        else:\n            myoffset = mytz.utcoffset(self)\n            if myoffset is None:\n                mytz = self.replace(tzinfo=None)._local_timezone()\n                myoffset = mytz.utcoffset(self)\n\n        if tz is mytz:\n            return self\n\n        # Convert self to UTC, and attach the new time zone object.\n        utc = (self - myoffset).replace(tzinfo=tz)\n\n        # Convert from UTC to tz's local time.\n        return tz.fromutc(utc)\n\n    # Ways to produce a string.\n\n    def ctime(self):\n        \"Return ctime() style string.\"\n        weekday = self.toordinal() % 7 or 7\n        return \"%s %s %2d %02d:%02d:%02d %04d\" % (\n            _DAYNAMES[weekday],\n            _MONTHNAMES[self._month],\n            self._day,\n            self._hour, self._minute, self._second,\n            self._year)\n\n    def isoformat(self, sep='T', timespec='auto'):\n        \"\"\"Return the time formatted according to ISO.\n\n        The full format looks like 'YYYY-MM-DD HH:MM:SS.mmmmmm'.\n        By default, the fractional part is omitted if self.microsecond == 0.\n\n        If self.tzinfo is not None, the UTC offset is also attached, giving\n        giving a full format of 'YYYY-MM-DD HH:MM:SS.mmmmmm+HH:MM'.\n\n        Optional argument sep specifies the separator between date and\n        time, default 'T'.\n\n        The optional argument timespec specifies the number of additional\n        terms of the time to include. Valid options are 'auto', 'hours',\n        'minutes', 'seconds', 'milliseconds' and 'microseconds'.\n        \"\"\"\n        s = (\"%04d-%02d-%02d%c\" % (self._year, self._month, self._day, sep) +\n             _format_time(self._hour, self._minute, self._second,\n                          self._microsecond, timespec))\n\n        off = self.utcoffset()\n        tz = _format_offset(off)\n        if tz:\n            s += tz\n\n        return s\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\"\"\"\n        L = [self._year, self._month, self._day,  # These are never zero\n             self._hour, self._minute, self._second, self._microsecond]\n        if L[-1] == 0:\n            del L[-1]\n        if L[-1] == 0:\n            del L[-1]\n        s = \"%s.%s(%s)\" % (self.__class__.__module__,\n                           self.__class__.__qualname__,\n                           \", \".join(map(str, L)))\n        if self._tzinfo is not None:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", tzinfo=%r\" % self._tzinfo + \")\"\n        if self._fold:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", fold=1)\"\n        return s\n\n    def __str__(self):\n        \"Convert to string, for str().\"\n        return self.isoformat(sep=' ')\n\n    @classmethod\n    def strptime(cls, date_string, format):\n        'string, format -> new datetime parsed from a string (like time.strptime()).'\n        import _strptime\n        return _strptime._strptime_datetime(cls, date_string, format)\n\n    def utcoffset(self):\n        \"\"\"Return the timezone offset as timedelta positive east of UTC (negative west of\n        UTC).\"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.utcoffset(self)\n        _check_utc_offset(\"utcoffset\", offset)\n        return offset\n\n    def tzname(self):\n        \"\"\"Return the timezone name.\n\n        Note that the name is 100% informational -- there's no requirement that\n        it mean anything in particular. For example, \"GMT\", \"UTC\", \"-500\",\n        \"-5:00\", \"EDT\", \"US/Eastern\", \"America/New York\" are all valid replies.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        name = self._tzinfo.tzname(self)\n        _check_tzname(name)\n        return name\n\n    def dst(self):\n        \"\"\"Return 0 if DST is not in effect, or the DST offset (as timedelta\n        positive eastward) if DST is in effect.\n\n        This is purely informational; the DST offset has already been added to\n        the UTC offset returned by utcoffset() if applicable, so there's no\n        need to consult dst() unless you're interested in displaying the DST\n        info.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.dst(self)\n        _check_utc_offset(\"dst\", offset)\n        return offset\n\n    # Comparisons of datetime objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other, allow_mixed=True) == 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            return False\n\n    def __le__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) <= 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __lt__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) < 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __ge__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) >= 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __gt__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) > 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def _cmp(self, other, allow_mixed=False):\n        assert isinstance(other, datetime)\n        mytz = self._tzinfo\n        ottz = other._tzinfo\n        myoff = otoff = None\n\n        if mytz is ottz:\n            base_compare = True\n        else:\n            myoff = self.utcoffset()\n            otoff = other.utcoffset()\n            # Assume that allow_mixed means that we are called from __eq__\n            if allow_mixed:\n                if myoff != self.replace(fold=not self.fold).utcoffset():\n                    return 2\n                if otoff != other.replace(fold=not other.fold).utcoffset():\n                    return 2\n            base_compare = myoff == otoff\n\n        if base_compare:\n            return _cmp((self._year, self._month, self._day,\n                         self._hour, self._minute, self._second,\n                         self._microsecond),\n                        (other._year, other._month, other._day,\n                         other._hour, other._minute, other._second,\n                         other._microsecond))\n        if myoff is None or otoff is None:\n            if allow_mixed:\n                return 2 # arbitrary non-zero value\n            else:\n                raise TypeError(\"cannot compare naive and aware datetimes\")\n        # XXX What follows could be done more efficiently...\n        diff = self - other     # this will take offsets into account\n        if diff.days < 0:\n            return -1\n        return diff and 1 or 0\n\n    def __add__(self, other):\n        \"Add a datetime and a timedelta.\"\n        if not isinstance(other, timedelta):\n            return NotImplemented\n        delta = timedelta(self.toordinal(),\n                          hours=self._hour,\n                          minutes=self._minute,\n                          seconds=self._second,\n                          microseconds=self._microsecond)\n        delta += other\n        hour, rem = divmod(delta.seconds, 3600)\n        minute, second = divmod(rem, 60)\n        if 0 < delta.days <= _MAXORDINAL:\n            return type(self).combine(date.fromordinal(delta.days),\n                                      time(hour, minute, second,\n                                           delta.microseconds,\n                                           tzinfo=self._tzinfo))\n        raise OverflowError(\"result out of range\")\n\n    __radd__ = __add__\n\n    def __sub__(self, other):\n        \"Subtract two datetimes, or a datetime and a timedelta.\"\n        if not isinstance(other, datetime):\n            if isinstance(other, timedelta):\n                return self + -other\n            return NotImplemented\n\n        days1 = self.toordinal()\n        days2 = other.toordinal()\n        secs1 = self._second + self._minute * 60 + self._hour * 3600\n        secs2 = other._second + other._minute * 60 + other._hour * 3600\n        base = timedelta(days1 - days2,\n                         secs1 - secs2,\n                         self._microsecond - other._microsecond)\n        if self._tzinfo is other._tzinfo:\n            return base\n        myoff = self.utcoffset()\n        otoff = other.utcoffset()\n        if myoff == otoff:\n            return base\n        if myoff is None or otoff is None:\n            raise TypeError(\"cannot mix naive and timezone-aware time\")\n        return base + otoff - myoff\n\n    def __hash__(self):\n        if self._hashcode == -1:\n            if self.fold:\n                t = self.replace(fold=0)\n            else:\n                t = self\n            tzoff = t.utcoffset()\n            if tzoff is None:\n                self._hashcode = hash(t._getstate()[0])\n            else:\n                days = _ymd2ord(self.year, self.month, self.day)\n                seconds = self.hour * 3600 + self.minute * 60 + self.second\n                self._hashcode = hash(timedelta(days, seconds, self.microsecond) - tzoff)\n        return self._hashcode\n\n    # Pickle support.\n\n    def _getstate(self, protocol=3):\n        yhi, ylo = divmod(self._year, 256)\n        us2, us3 = divmod(self._microsecond, 256)\n        us1, us2 = divmod(us2, 256)\n        m = self._month\n        if self._fold and protocol > 3:\n            m += 128\n        basestate = bytes([yhi, ylo, m, self._day,\n                           self._hour, self._minute, self._second,\n                           us1, us2, us3])\n        if self._tzinfo is None:\n            return (basestate,)\n        else:\n            return (basestate, self._tzinfo)\n\n    def __setstate(self, string, tzinfo):\n        if tzinfo is not None and not isinstance(tzinfo, _tzinfo_class):\n            raise TypeError(\"bad tzinfo state arg\")\n        (yhi, ylo, m, self._day, self._hour,\n         self._minute, self._second, us1, us2, us3) = string\n        if m > 127:\n            self._fold = 1\n            self._month = m - 128\n        else:\n            self._fold = 0\n            self._month = m\n        self._year = yhi * 256 + ylo\n        self._microsecond = (((us1 << 8) | us2) << 8) | us3\n        self._tzinfo = tzinfo\n\n    def __reduce_ex__(self, protocol):\n        return (self.__class__, self._getstate(protocol))\n\n    def __reduce__(self):\n        return self.__reduce_ex__(2)"
        ],
        [
            "STORE_NAME",
            "class datetime(date):\n    \"\"\"datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])\n\n    The year, month and day arguments are required. tzinfo may be None, or an\n    instance of a tzinfo subclass. The remaining arguments may be ints.\n    \"\"\"\n    __slots__ = date.__slots__ + time.__slots__\n\n    def __new__(cls, year, month=None, day=None, hour=0, minute=0, second=0,\n                microsecond=0, tzinfo=None, *, fold=0):\n        if (isinstance(year, (bytes, str)) and len(year) == 10 and\n            1 <= ord(year[2:3])&0x7F <= 12):\n            # Pickle support\n            if isinstance(year, str):\n                try:\n                    year = bytes(year, 'latin1')\n                except UnicodeEncodeError:\n                    # More informative error message.\n                    raise ValueError(\n                        \"Failed to encode latin1 string when unpickling \"\n                        \"a datetime object. \"\n                        \"pickle.load(data, encoding='latin1') is assumed.\")\n            self = object.__new__(cls)\n            self.__setstate(year, month)\n            self._hashcode = -1\n            return self\n        year, month, day = _check_date_fields(year, month, day)\n        hour, minute, second, microsecond, fold = _check_time_fields(\n            hour, minute, second, microsecond, fold)\n        _check_tzinfo_arg(tzinfo)\n        self = object.__new__(cls)\n        self._year = year\n        self._month = month\n        self._day = day\n        self._hour = hour\n        self._minute = minute\n        self._second = second\n        self._microsecond = microsecond\n        self._tzinfo = tzinfo\n        self._hashcode = -1\n        self._fold = fold\n        return self\n\n    # Read-only field accessors\n    @property\n    def hour(self):\n        \"\"\"hour (0-23)\"\"\"\n        return self._hour\n\n    @property\n    def minute(self):\n        \"\"\"minute (0-59)\"\"\"\n        return self._minute\n\n    @property\n    def second(self):\n        \"\"\"second (0-59)\"\"\"\n        return self._second\n\n    @property\n    def microsecond(self):\n        \"\"\"microsecond (0-999999)\"\"\"\n        return self._microsecond\n\n    @property\n    def tzinfo(self):\n        \"\"\"timezone info object\"\"\"\n        return self._tzinfo\n\n    @property\n    def fold(self):\n        return self._fold\n\n    @classmethod\n    def _fromtimestamp(cls, t, utc, tz):\n        \"\"\"Construct a datetime from a POSIX timestamp (like time.time()).\n\n        A timezone info object may be passed in as well.\n        \"\"\"\n        frac, t = _math.modf(t)\n        us = round(frac * 1e6)\n        if us >= 1000000:\n            t += 1\n            us -= 1000000\n        elif us < 0:\n            t -= 1\n            us += 1000000\n\n        converter = _time.gmtime if utc else _time.localtime\n        y, m, d, hh, mm, ss, weekday, jday, dst = converter(t)\n        ss = min(ss, 59)    # clamp out leap seconds if the platform has them\n        result = cls(y, m, d, hh, mm, ss, us, tz)\n        if tz is None and not utc:\n            # As of version 2015f max fold in IANA database is\n            # 23 hours at 1969-09-30 13:00:00 in Kwajalein.\n            # Let's probe 24 hours in the past to detect a transition:\n            max_fold_seconds = 24 * 3600\n\n            # On Windows localtime_s throws an OSError for negative values,\n            # thus we can't perform fold detection for values of time less\n            # than the max time fold. See comments in _datetimemodule's\n            # version of this method for more details.\n            if t < max_fold_seconds and sys.platform.startswith(\"win\"):\n                return result\n\n            y, m, d, hh, mm, ss = converter(t - max_fold_seconds)[:6]\n            probe1 = cls(y, m, d, hh, mm, ss, us, tz)\n            trans = result - probe1 - timedelta(0, max_fold_seconds)\n            if trans.days < 0:\n                y, m, d, hh, mm, ss = converter(t + trans // timedelta(0, 1))[:6]\n                probe2 = cls(y, m, d, hh, mm, ss, us, tz)\n                if probe2 == result:\n                    result._fold = 1\n        elif tz is not None:\n            result = tz.fromutc(result)\n        return result\n\n    @classmethod\n    def fromtimestamp(cls, t, tz=None):\n        \"\"\"Construct a datetime from a POSIX timestamp (like time.time()).\n\n        A timezone info object may be passed in as well.\n        \"\"\"\n        _check_tzinfo_arg(tz)\n\n        return cls._fromtimestamp(t, tz is not None, tz)\n\n    @classmethod\n    def utcfromtimestamp(cls, t):\n        \"\"\"Construct a naive UTC datetime from a POSIX timestamp.\"\"\"\n        return cls._fromtimestamp(t, True, None)\n\n    @classmethod\n    def now(cls, tz=None):\n        \"Construct a datetime from time.time() and optional time zone info.\"\n        t = _time.time()\n        return cls.fromtimestamp(t, tz)\n\n    @classmethod\n    def utcnow(cls):\n        \"Construct a UTC datetime from time.time().\"\n        t = _time.time()\n        return cls.utcfromtimestamp(t)\n\n    @classmethod\n    def combine(cls, date, time, tzinfo=True):\n        \"Construct a datetime from a given date and a given time.\"\n        if not isinstance(date, _date_class):\n            raise TypeError(\"date argument must be a date instance\")\n        if not isinstance(time, _time_class):\n            raise TypeError(\"time argument must be a time instance\")\n        if tzinfo is True:\n            tzinfo = time.tzinfo\n        return cls(date.year, date.month, date.day,\n                   time.hour, time.minute, time.second, time.microsecond,\n                   tzinfo, fold=time.fold)\n\n    @classmethod\n    def fromisoformat(cls, date_string):\n        \"\"\"Construct a datetime from a string in one of the ISO 8601 formats.\"\"\"\n        if not isinstance(date_string, str):\n            raise TypeError('fromisoformat: argument must be str')\n\n        if len(date_string) < 7:\n            raise ValueError(f'Invalid isoformat string: {date_string!r}')\n\n        # Split this at the separator\n        try:\n            separator_location = _find_isoformat_datetime_separator(date_string)\n            dstr = date_string[0:separator_location]\n            tstr = date_string[(separator_location+1):]\n\n            date_components = _parse_isoformat_date(dstr)\n        except ValueError:\n            raise ValueError(\n                f'Invalid isoformat string: {date_string!r}') from None\n\n        if tstr:\n            try:\n                time_components = _parse_isoformat_time(tstr)\n            except ValueError:\n                raise ValueError(\n                    f'Invalid isoformat string: {date_string!r}') from None\n        else:\n            time_components = [0, 0, 0, 0, None]\n\n        return cls(*(date_components + time_components))\n\n    def timetuple(self):\n        \"Return local time tuple compatible with time.localtime().\"\n        dst = self.dst()\n        if dst is None:\n            dst = -1\n        elif dst:\n            dst = 1\n        else:\n            dst = 0\n        return _build_struct_time(self.year, self.month, self.day,\n                                  self.hour, self.minute, self.second,\n                                  dst)\n\n    def _mktime(self):\n        \"\"\"Return integer POSIX timestamp.\"\"\"\n        epoch = datetime(1970, 1, 1)\n        max_fold_seconds = 24 * 3600\n        t = (self - epoch) // timedelta(0, 1)\n        def local(u):\n            y, m, d, hh, mm, ss = _time.localtime(u)[:6]\n            return (datetime(y, m, d, hh, mm, ss) - epoch) // timedelta(0, 1)\n\n        # Our goal is to solve t = local(u) for u.\n        a = local(t) - t\n        u1 = t - a\n        t1 = local(u1)\n        if t1 == t:\n            # We found one solution, but it may not be the one we need.\n            # Look for an earlier solution (if `fold` is 0), or a\n            # later one (if `fold` is 1).\n            u2 = u1 + (-max_fold_seconds, max_fold_seconds)[self.fold]\n            b = local(u2) - u2\n            if a == b:\n                return u1\n        else:\n            b = t1 - u1\n            assert a != b\n        u2 = t - b\n        t2 = local(u2)\n        if t2 == t:\n            return u2\n        if t1 == t:\n            return u1\n        # We have found both offsets a and b, but neither t - a nor t - b is\n        # a solution.  This means t is in the gap.\n        return (max, min)[self.fold](u1, u2)\n\n\n    def timestamp(self):\n        \"Return POSIX timestamp as float\"\n        if self._tzinfo is None:\n            s = self._mktime()\n            return s + self.microsecond / 1e6\n        else:\n            return (self - _EPOCH).total_seconds()\n\n    def utctimetuple(self):\n        \"Return UTC time tuple compatible with time.gmtime().\"\n        offset = self.utcoffset()\n        if offset:\n            self -= offset\n        y, m, d = self.year, self.month, self.day\n        hh, mm, ss = self.hour, self.minute, self.second\n        return _build_struct_time(y, m, d, hh, mm, ss, 0)\n\n    def date(self):\n        \"Return the date part.\"\n        return date(self._year, self._month, self._day)\n\n    def time(self):\n        \"Return the time part, with tzinfo None.\"\n        return time(self.hour, self.minute, self.second, self.microsecond, fold=self.fold)\n\n    def timetz(self):\n        \"Return the time part, with same tzinfo.\"\n        return time(self.hour, self.minute, self.second, self.microsecond,\n                    self._tzinfo, fold=self.fold)\n\n    def replace(self, year=None, month=None, day=None, hour=None,\n                minute=None, second=None, microsecond=None, tzinfo=True,\n                *, fold=None):\n        \"\"\"Return a new datetime with new values for the specified fields.\"\"\"\n        if year is None:\n            year = self.year\n        if month is None:\n            month = self.month\n        if day is None:\n            day = self.day\n        if hour is None:\n            hour = self.hour\n        if minute is None:\n            minute = self.minute\n        if second is None:\n            second = self.second\n        if microsecond is None:\n            microsecond = self.microsecond\n        if tzinfo is True:\n            tzinfo = self.tzinfo\n        if fold is None:\n            fold = self.fold\n        return type(self)(year, month, day, hour, minute, second,\n                          microsecond, tzinfo, fold=fold)\n\n    def _local_timezone(self):\n        if self.tzinfo is None:\n            ts = self._mktime()\n        else:\n            ts = (self - _EPOCH) // timedelta(seconds=1)\n        localtm = _time.localtime(ts)\n        local = datetime(*localtm[:6])\n        # Extract TZ data\n        gmtoff = localtm.tm_gmtoff\n        zone = localtm.tm_zone\n        return timezone(timedelta(seconds=gmtoff), zone)\n\n    def astimezone(self, tz=None):\n        if tz is None:\n            tz = self._local_timezone()\n        elif not isinstance(tz, tzinfo):\n            raise TypeError(\"tz argument must be an instance of tzinfo\")\n\n        mytz = self.tzinfo\n        if mytz is None:\n            mytz = self._local_timezone()\n            myoffset = mytz.utcoffset(self)\n        else:\n            myoffset = mytz.utcoffset(self)\n            if myoffset is None:\n                mytz = self.replace(tzinfo=None)._local_timezone()\n                myoffset = mytz.utcoffset(self)\n\n        if tz is mytz:\n            return self\n\n        # Convert self to UTC, and attach the new time zone object.\n        utc = (self - myoffset).replace(tzinfo=tz)\n\n        # Convert from UTC to tz's local time.\n        return tz.fromutc(utc)\n\n    # Ways to produce a string.\n\n    def ctime(self):\n        \"Return ctime() style string.\"\n        weekday = self.toordinal() % 7 or 7\n        return \"%s %s %2d %02d:%02d:%02d %04d\" % (\n            _DAYNAMES[weekday],\n            _MONTHNAMES[self._month],\n            self._day,\n            self._hour, self._minute, self._second,\n            self._year)\n\n    def isoformat(self, sep='T', timespec='auto'):\n        \"\"\"Return the time formatted according to ISO.\n\n        The full format looks like 'YYYY-MM-DD HH:MM:SS.mmmmmm'.\n        By default, the fractional part is omitted if self.microsecond == 0.\n\n        If self.tzinfo is not None, the UTC offset is also attached, giving\n        giving a full format of 'YYYY-MM-DD HH:MM:SS.mmmmmm+HH:MM'.\n\n        Optional argument sep specifies the separator between date and\n        time, default 'T'.\n\n        The optional argument timespec specifies the number of additional\n        terms of the time to include. Valid options are 'auto', 'hours',\n        'minutes', 'seconds', 'milliseconds' and 'microseconds'.\n        \"\"\"\n        s = (\"%04d-%02d-%02d%c\" % (self._year, self._month, self._day, sep) +\n             _format_time(self._hour, self._minute, self._second,\n                          self._microsecond, timespec))\n\n        off = self.utcoffset()\n        tz = _format_offset(off)\n        if tz:\n            s += tz\n\n        return s\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\"\"\"\n        L = [self._year, self._month, self._day,  # These are never zero\n             self._hour, self._minute, self._second, self._microsecond]\n        if L[-1] == 0:\n            del L[-1]\n        if L[-1] == 0:\n            del L[-1]\n        s = \"%s.%s(%s)\" % (self.__class__.__module__,\n                           self.__class__.__qualname__,\n                           \", \".join(map(str, L)))\n        if self._tzinfo is not None:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", tzinfo=%r\" % self._tzinfo + \")\"\n        if self._fold:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", fold=1)\"\n        return s\n\n    def __str__(self):\n        \"Convert to string, for str().\"\n        return self.isoformat(sep=' ')\n\n    @classmethod\n    def strptime(cls, date_string, format):\n        'string, format -> new datetime parsed from a string (like time.strptime()).'\n        import _strptime\n        return _strptime._strptime_datetime(cls, date_string, format)\n\n    def utcoffset(self):\n        \"\"\"Return the timezone offset as timedelta positive east of UTC (negative west of\n        UTC).\"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.utcoffset(self)\n        _check_utc_offset(\"utcoffset\", offset)\n        return offset\n\n    def tzname(self):\n        \"\"\"Return the timezone name.\n\n        Note that the name is 100% informational -- there's no requirement that\n        it mean anything in particular. For example, \"GMT\", \"UTC\", \"-500\",\n        \"-5:00\", \"EDT\", \"US/Eastern\", \"America/New York\" are all valid replies.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        name = self._tzinfo.tzname(self)\n        _check_tzname(name)\n        return name\n\n    def dst(self):\n        \"\"\"Return 0 if DST is not in effect, or the DST offset (as timedelta\n        positive eastward) if DST is in effect.\n\n        This is purely informational; the DST offset has already been added to\n        the UTC offset returned by utcoffset() if applicable, so there's no\n        need to consult dst() unless you're interested in displaying the DST\n        info.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.dst(self)\n        _check_utc_offset(\"dst\", offset)\n        return offset\n\n    # Comparisons of datetime objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other, allow_mixed=True) == 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            return False\n\n    def __le__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) <= 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __lt__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) < 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __ge__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) >= 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __gt__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) > 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def _cmp(self, other, allow_mixed=False):\n        assert isinstance(other, datetime)\n        mytz = self._tzinfo\n        ottz = other._tzinfo\n        myoff = otoff = None\n\n        if mytz is ottz:\n            base_compare = True\n        else:\n            myoff = self.utcoffset()\n            otoff = other.utcoffset()\n            # Assume that allow_mixed means that we are called from __eq__\n            if allow_mixed:\n                if myoff != self.replace(fold=not self.fold).utcoffset():\n                    return 2\n                if otoff != other.replace(fold=not other.fold).utcoffset():\n                    return 2\n            base_compare = myoff == otoff\n\n        if base_compare:\n            return _cmp((self._year, self._month, self._day,\n                         self._hour, self._minute, self._second,\n                         self._microsecond),\n                        (other._year, other._month, other._day,\n                         other._hour, other._minute, other._second,\n                         other._microsecond))\n        if myoff is None or otoff is None:\n            if allow_mixed:\n                return 2 # arbitrary non-zero value\n            else:\n                raise TypeError(\"cannot compare naive and aware datetimes\")\n        # XXX What follows could be done more efficiently...\n        diff = self - other     # this will take offsets into account\n        if diff.days < 0:\n            return -1\n        return diff and 1 or 0\n\n    def __add__(self, other):\n        \"Add a datetime and a timedelta.\"\n        if not isinstance(other, timedelta):\n            return NotImplemented\n        delta = timedelta(self.toordinal(),\n                          hours=self._hour,\n                          minutes=self._minute,\n                          seconds=self._second,\n                          microseconds=self._microsecond)\n        delta += other\n        hour, rem = divmod(delta.seconds, 3600)\n        minute, second = divmod(rem, 60)\n        if 0 < delta.days <= _MAXORDINAL:\n            return type(self).combine(date.fromordinal(delta.days),\n                                      time(hour, minute, second,\n                                           delta.microseconds,\n                                           tzinfo=self._tzinfo))\n        raise OverflowError(\"result out of range\")\n\n    __radd__ = __add__\n\n    def __sub__(self, other):\n        \"Subtract two datetimes, or a datetime and a timedelta.\"\n        if not isinstance(other, datetime):\n            if isinstance(other, timedelta):\n                return self + -other\n            return NotImplemented\n\n        days1 = self.toordinal()\n        days2 = other.toordinal()\n        secs1 = self._second + self._minute * 60 + self._hour * 3600\n        secs2 = other._second + other._minute * 60 + other._hour * 3600\n        base = timedelta(days1 - days2,\n                         secs1 - secs2,\n                         self._microsecond - other._microsecond)\n        if self._tzinfo is other._tzinfo:\n            return base\n        myoff = self.utcoffset()\n        otoff = other.utcoffset()\n        if myoff == otoff:\n            return base\n        if myoff is None or otoff is None:\n            raise TypeError(\"cannot mix naive and timezone-aware time\")\n        return base + otoff - myoff\n\n    def __hash__(self):\n        if self._hashcode == -1:\n            if self.fold:\n                t = self.replace(fold=0)\n            else:\n                t = self\n            tzoff = t.utcoffset()\n            if tzoff is None:\n                self._hashcode = hash(t._getstate()[0])\n            else:\n                days = _ymd2ord(self.year, self.month, self.day)\n                seconds = self.hour * 3600 + self.minute * 60 + self.second\n                self._hashcode = hash(timedelta(days, seconds, self.microsecond) - tzoff)\n        return self._hashcode\n\n    # Pickle support.\n\n    def _getstate(self, protocol=3):\n        yhi, ylo = divmod(self._year, 256)\n        us2, us3 = divmod(self._microsecond, 256)\n        us1, us2 = divmod(us2, 256)\n        m = self._month\n        if self._fold and protocol > 3:\n            m += 128\n        basestate = bytes([yhi, ylo, m, self._day,\n                           self._hour, self._minute, self._second,\n                           us1, us2, us3])\n        if self._tzinfo is None:\n            return (basestate,)\n        else:\n            return (basestate, self._tzinfo)\n\n    def __setstate(self, string, tzinfo):\n        if tzinfo is not None and not isinstance(tzinfo, _tzinfo_class):\n            raise TypeError(\"bad tzinfo state arg\")\n        (yhi, ylo, m, self._day, self._hour,\n         self._minute, self._second, us1, us2, us3) = string\n        if m > 127:\n            self._fold = 1\n            self._month = m - 128\n        else:\n            self._fold = 0\n            self._month = m\n        self._year = yhi * 256 + ylo\n        self._microsecond = (((us1 << 8) | us2) << 8) | us3\n        self._tzinfo = tzinfo\n\n    def __reduce_ex__(self, protocol):\n        return (self.__class__, self._getstate(protocol))\n\n    def __reduce__(self):\n        return self.__reduce_ex__(2)"
        ],
        [
            "LOAD_NAME",
            "datetime"
        ],
        [
            "CALL",
            "datetime(1, 1, 1)"
        ],
        [
            "LOAD_NAME",
            "datetime"
        ],
        [
            "STORE_ATTR",
            "datetime.min"
        ],
        [
            "LOAD_NAME",
            "datetime"
        ],
        [
            "CALL",
            "datetime(9999, 12, 31, 23, 59, 59, 999999)"
        ],
        [
            "LOAD_NAME",
            "datetime"
        ],
        [
            "STORE_ATTR",
            "datetime.max"
        ],
        [
            "LOAD_NAME",
            "timedelta"
        ],
        [
            "CALL",
            "timedelta(microseconds=1)"
        ],
        [
            "LOAD_NAME",
            "datetime"
        ],
        [
            "STORE_ATTR",
            "datetime.resolution"
        ],
        [
            "STORE_NAME",
            "def _isoweek1monday(year):\n    # Helper to calculate the day number of the Monday starting week 1\n    # XXX This could be done more efficiently\n    THURSDAY = 3\n    firstday = _ymd2ord(year, 1, 1)\n    firstweekday = (firstday + 6) % 7  # See weekday() above\n    week1monday = firstday - firstweekday\n    if firstweekday > THURSDAY:\n        week1monday += 7\n    return week1monday"
        ],
        [
            "LOAD_NAME",
            "tzinfo"
        ],
        [
            "CALL",
            "class timezone(tzinfo):\n    __slots__ = '_offset', '_name'\n\n    # Sentinel value to disallow None\n    _Omitted = object()\n    def __new__(cls, offset, name=_Omitted):\n        if not isinstance(offset, timedelta):\n            raise TypeError(\"offset must be a timedelta\")\n        if name is cls._Omitted:\n            if not offset:\n                return cls.utc\n            name = None\n        elif not isinstance(name, str):\n            raise TypeError(\"name must be a string\")\n        if not cls._minoffset <= offset <= cls._maxoffset:\n            raise ValueError(\"offset must be a timedelta \"\n                             \"strictly between -timedelta(hours=24) and \"\n                             \"timedelta(hours=24).\")\n        return cls._create(offset, name)\n\n    @classmethod\n    def _create(cls, offset, name=None):\n        self = tzinfo.__new__(cls)\n        self._offset = offset\n        self._name = name\n        return self\n\n    def __getinitargs__(self):\n        \"\"\"pickle support\"\"\"\n        if self._name is None:\n            return (self._offset,)\n        return (self._offset, self._name)\n\n    def __eq__(self, other):\n        if isinstance(other, timezone):\n            return self._offset == other._offset\n        return NotImplemented\n\n    def __hash__(self):\n        return hash(self._offset)\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\n\n        >>> tz = timezone.utc\n        >>> repr(tz)\n        'datetime.timezone.utc'\n        >>> tz = timezone(timedelta(hours=-5), 'EST')\n        >>> repr(tz)\n        \"datetime.timezone(datetime.timedelta(-1, 68400), 'EST')\"\n        \"\"\"\n        if self is self.utc:\n            return 'datetime.timezone.utc'\n        if self._name is None:\n            return \"%s.%s(%r)\" % (self.__class__.__module__,\n                                  self.__class__.__qualname__,\n                                  self._offset)\n        return \"%s.%s(%r, %r)\" % (self.__class__.__module__,\n                                  self.__class__.__qualname__,\n                                  self._offset, self._name)\n\n    def __str__(self):\n        return self.tzname(None)\n\n    def utcoffset(self, dt):\n        if isinstance(dt, datetime) or dt is None:\n            return self._offset\n        raise TypeError(\"utcoffset() argument must be a datetime instance\"\n                        \" or None\")\n\n    def tzname(self, dt):\n        if isinstance(dt, datetime) or dt is None:\n            if self._name is None:\n                return self._name_from_offset(self._offset)\n            return self._name\n        raise TypeError(\"tzname() argument must be a datetime instance\"\n                        \" or None\")\n\n    def dst(self, dt):\n        if isinstance(dt, datetime) or dt is None:\n            return None\n        raise TypeError(\"dst() argument must be a datetime instance\"\n                        \" or None\")\n\n    def fromutc(self, dt):\n        if isinstance(dt, datetime):\n            if dt.tzinfo is not self:\n                raise ValueError(\"fromutc: dt.tzinfo \"\n                                 \"is not self\")\n            return dt + self._offset\n        raise TypeError(\"fromutc() argument must be a datetime instance\"\n                        \" or None\")\n\n    _maxoffset = timedelta(hours=24, microseconds=-1)\n    _minoffset = -_maxoffset\n\n    @staticmethod\n    def _name_from_offset(delta):\n        if not delta:\n            return 'UTC'\n        if delta < timedelta(0):\n            sign = '-'\n            delta = -delta\n        else:\n            sign = '+'\n        hours, rest = divmod(delta, timedelta(hours=1))\n        minutes, rest = divmod(rest, timedelta(minutes=1))\n        seconds = rest.seconds\n        microseconds = rest.microseconds\n        if microseconds:\n            return (f'UTC{sign}{hours:02d}:{minutes:02d}:{seconds:02d}'\n                    f'.{microseconds:06d}')\n        if seconds:\n            return f'UTC{sign}{hours:02d}:{minutes:02d}:{seconds:02d}'\n        return f'UTC{sign}{hours:02d}:{minutes:02d}'"
        ],
        [
            "STORE_NAME",
            "class timezone(tzinfo):\n    __slots__ = '_offset', '_name'\n\n    # Sentinel value to disallow None\n    _Omitted = object()\n    def __new__(cls, offset, name=_Omitted):\n        if not isinstance(offset, timedelta):\n            raise TypeError(\"offset must be a timedelta\")\n        if name is cls._Omitted:\n            if not offset:\n                return cls.utc\n            name = None\n        elif not isinstance(name, str):\n            raise TypeError(\"name must be a string\")\n        if not cls._minoffset <= offset <= cls._maxoffset:\n            raise ValueError(\"offset must be a timedelta \"\n                             \"strictly between -timedelta(hours=24) and \"\n                             \"timedelta(hours=24).\")\n        return cls._create(offset, name)\n\n    @classmethod\n    def _create(cls, offset, name=None):\n        self = tzinfo.__new__(cls)\n        self._offset = offset\n        self._name = name\n        return self\n\n    def __getinitargs__(self):\n        \"\"\"pickle support\"\"\"\n        if self._name is None:\n            return (self._offset,)\n        return (self._offset, self._name)\n\n    def __eq__(self, other):\n        if isinstance(other, timezone):\n            return self._offset == other._offset\n        return NotImplemented\n\n    def __hash__(self):\n        return hash(self._offset)\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\n\n        >>> tz = timezone.utc\n        >>> repr(tz)\n        'datetime.timezone.utc'\n        >>> tz = timezone(timedelta(hours=-5), 'EST')\n        >>> repr(tz)\n        \"datetime.timezone(datetime.timedelta(-1, 68400), 'EST')\"\n        \"\"\"\n        if self is self.utc:\n            return 'datetime.timezone.utc'\n        if self._name is None:\n            return \"%s.%s(%r)\" % (self.__class__.__module__,\n                                  self.__class__.__qualname__,\n                                  self._offset)\n        return \"%s.%s(%r, %r)\" % (self.__class__.__module__,\n                                  self.__class__.__qualname__,\n                                  self._offset, self._name)\n\n    def __str__(self):\n        return self.tzname(None)\n\n    def utcoffset(self, dt):\n        if isinstance(dt, datetime) or dt is None:\n            return self._offset\n        raise TypeError(\"utcoffset() argument must be a datetime instance\"\n                        \" or None\")\n\n    def tzname(self, dt):\n        if isinstance(dt, datetime) or dt is None:\n            if self._name is None:\n                return self._name_from_offset(self._offset)\n            return self._name\n        raise TypeError(\"tzname() argument must be a datetime instance\"\n                        \" or None\")\n\n    def dst(self, dt):\n        if isinstance(dt, datetime) or dt is None:\n            return None\n        raise TypeError(\"dst() argument must be a datetime instance\"\n                        \" or None\")\n\n    def fromutc(self, dt):\n        if isinstance(dt, datetime):\n            if dt.tzinfo is not self:\n                raise ValueError(\"fromutc: dt.tzinfo \"\n                                 \"is not self\")\n            return dt + self._offset\n        raise TypeError(\"fromutc() argument must be a datetime instance\"\n                        \" or None\")\n\n    _maxoffset = timedelta(hours=24, microseconds=-1)\n    _minoffset = -_maxoffset\n\n    @staticmethod\n    def _name_from_offset(delta):\n        if not delta:\n            return 'UTC'\n        if delta < timedelta(0):\n            sign = '-'\n            delta = -delta\n        else:\n            sign = '+'\n        hours, rest = divmod(delta, timedelta(hours=1))\n        minutes, rest = divmod(rest, timedelta(minutes=1))\n        seconds = rest.seconds\n        microseconds = rest.microseconds\n        if microseconds:\n            return (f'UTC{sign}{hours:02d}:{minutes:02d}:{seconds:02d}'\n                    f'.{microseconds:06d}')\n        if seconds:\n            return f'UTC{sign}{hours:02d}:{minutes:02d}:{seconds:02d}'\n        return f'UTC{sign}{hours:02d}:{minutes:02d}'"
        ],
        [
            "LOAD_NAME",
            "timezone"
        ],
        [
            "LOAD_METHOD",
            "timezone._create"
        ],
        [
            "LOAD_NAME",
            "timedelta"
        ],
        [
            "CALL",
            "timedelta(0)"
        ],
        [
            "CALL",
            "timezone._create(timedelta(0))"
        ],
        [
            "STORE_NAME",
            "UTC"
        ],
        [
            "LOAD_NAME",
            "timezone"
        ],
        [
            "STORE_ATTR",
            "timezone.utc"
        ],
        [
            "LOAD_NAME",
            "timezone"
        ],
        [
            "LOAD_METHOD",
            "timezone._create"
        ],
        [
            "LOAD_NAME",
            "timedelta"
        ],
        [
            "CALL",
            "timedelta(hours=23, minutes=59)"
        ],
        [
            "UNARY_NEGATIVE",
            "-timedelta(hours=23, minutes=59)"
        ],
        [
            "CALL",
            "timezone._create(-timedelta(hours=23, minutes=59))"
        ],
        [
            "LOAD_NAME",
            "timezone"
        ],
        [
            "STORE_ATTR",
            "timezone.min"
        ],
        [
            "LOAD_NAME",
            "timezone"
        ],
        [
            "LOAD_METHOD",
            "timezone._create"
        ],
        [
            "LOAD_NAME",
            "timedelta"
        ],
        [
            "CALL",
            "timedelta(hours=23, minutes=59)"
        ],
        [
            "CALL",
            "timezone._create(timedelta(hours=23, minutes=59))"
        ],
        [
            "LOAD_NAME",
            "timezone"
        ],
        [
            "STORE_ATTR",
            "timezone.max"
        ],
        [
            "LOAD_NAME",
            "datetime"
        ],
        [
            "LOAD_NAME",
            "timezone"
        ],
        [
            "LOAD_ATTR",
            "timezone.utc"
        ],
        [
            "CALL",
            "datetime(1970, 1, 1, tzinfo=timezone.utc)"
        ],
        [
            "STORE_NAME",
            "_EPOCH"
        ],
        [
            "DELETE_NAME",
            "_DAYNAMES"
        ],
        [
            "DELETE_NAME",
            "_DAYS_BEFORE_MONTH"
        ],
        [
            "DELETE_NAME",
            "_DAYS_IN_MONTH"
        ],
        [
            "DELETE_NAME",
            "_DI100Y"
        ],
        [
            "DELETE_NAME",
            "_DI400Y"
        ],
        [
            "DELETE_NAME",
            "_DI4Y"
        ],
        [
            "DELETE_NAME",
            "_EPOCH"
        ],
        [
            "DELETE_NAME",
            "_MAXORDINAL"
        ],
        [
            "DELETE_NAME",
            "_MONTHNAMES"
        ],
        [
            "DELETE_NAME",
            "_build_struct_time"
        ],
        [
            "DELETE_NAME",
            "_check_date_fields"
        ],
        [
            "DELETE_NAME",
            "_check_time_fields"
        ],
        [
            "DELETE_NAME",
            "_check_tzinfo_arg"
        ],
        [
            "DELETE_NAME",
            "_check_tzname"
        ],
        [
            "DELETE_NAME",
            "_check_utc_offset"
        ],
        [
            "DELETE_NAME",
            "_cmp"
        ],
        [
            "DELETE_NAME",
            "_cmperror"
        ],
        [
            "DELETE_NAME",
            "_date_class"
        ],
        [
            "DELETE_NAME",
            "_days_before_month"
        ],
        [
            "DELETE_NAME",
            "_days_before_year"
        ],
        [
            "DELETE_NAME",
            "_days_in_month"
        ],
        [
            "DELETE_NAME",
            "_format_time"
        ],
        [
            "DELETE_NAME",
            "_format_offset"
        ],
        [
            "DELETE_NAME",
            "_index"
        ],
        [
            "DELETE_NAME",
            "_is_leap"
        ],
        [
            "DELETE_NAME",
            "_isoweek1monday"
        ],
        [
            "DELETE_NAME",
            "_math"
        ],
        [
            "DELETE_NAME",
            "_ord2ymd"
        ],
        [
            "DELETE_NAME",
            "_time"
        ],
        [
            "DELETE_NAME",
            "_time_class"
        ],
        [
            "DELETE_NAME",
            "_tzinfo_class"
        ],
        [
            "DELETE_NAME",
            "_wrap_strftime"
        ],
        [
            "DELETE_NAME",
            "_ymd2ord"
        ],
        [
            "DELETE_NAME",
            "_divide_and_round"
        ],
        [
            "DELETE_NAME",
            "_parse_isoformat_date"
        ],
        [
            "DELETE_NAME",
            "_parse_isoformat_time"
        ],
        [
            "DELETE_NAME",
            "_parse_hh_mm_ss_ff"
        ],
        [
            "DELETE_NAME",
            "_IsoCalendarDate"
        ],
        [
            "DELETE_NAME",
            "_isoweek_to_gregorian"
        ],
        [
            "DELETE_NAME",
            "_find_isoformat_datetime_separator"
        ],
        [
            "DELETE_NAME",
            "_FRACTION_CORRECTION"
        ],
        [
            "DELETE_NAME",
            "_is_ascii_digit"
        ],
        [
            "STORE_NAME",
            "from _datetime import __doc__"
        ],
        [
            "LOAD_NAME",
            "ImportError"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_FAST",
            "y"
        ],
        [
            "COMPARE_OP",
            "x == y"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_FAST",
            "y"
        ],
        [
            "COMPARE_OP",
            "x > y"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "BINARY_OP",
            "year % 4"
        ],
        [
            "COMPARE_OP",
            "year % 4 == 0"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "BINARY_OP",
            "year % 100"
        ],
        [
            "COMPARE_OP",
            "year % 100 != 0"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "BINARY_OP",
            "year % 400"
        ],
        [
            "COMPARE_OP",
            "year % 400 == 0"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "BINARY_OP",
            "year - 1"
        ],
        [
            "STORE_FAST",
            "y"
        ],
        [
            "LOAD_FAST",
            "y"
        ],
        [
            "BINARY_OP",
            "y*365"
        ],
        [
            "LOAD_FAST",
            "y"
        ],
        [
            "BINARY_OP",
            "y//4"
        ],
        [
            "BINARY_OP",
            "y*365 + y//4"
        ],
        [
            "LOAD_FAST",
            "y"
        ],
        [
            "BINARY_OP",
            "y//100"
        ],
        [
            "BINARY_OP",
            "y*365 + y//4 - y//100"
        ],
        [
            "LOAD_FAST",
            "y"
        ],
        [
            "BINARY_OP",
            "y//400"
        ],
        [
            "BINARY_OP",
            "y*365 + y//4 - y//100 + y//400"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "COMPARE_OP",
            "1 <= month <= 12"
        ],
        [
            "COMPARE_OP",
            "1 <= month <= 12"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "COMPARE_OP",
            "month == 2"
        ],
        [
            "LOAD_GLOBAL",
            "_is_leap"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "CALL",
            "_is_leap(year)"
        ],
        [
            "LOAD_GLOBAL",
            "_DAYS_IN_MONTH"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "BINARY_SUBSCR",
            "_DAYS_IN_MONTH[month]"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "COMPARE_OP",
            "1 <= month <= 12"
        ],
        [
            "COMPARE_OP",
            "1 <= month <= 12"
        ],
        [
            "LOAD_GLOBAL",
            "_DAYS_BEFORE_MONTH"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "BINARY_SUBSCR",
            "_DAYS_BEFORE_MONTH[month]"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "COMPARE_OP",
            "month > 2"
        ],
        [
            "LOAD_GLOBAL",
            "_is_leap"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "CALL",
            "_is_leap(year)"
        ],
        [
            "BINARY_OP",
            "_DAYS_BEFORE_MONTH[month] + (month > 2 and _is_leap(year))"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "COMPARE_OP",
            "1 <= month <= 12"
        ],
        [
            "COMPARE_OP",
            "1 <= month <= 12"
        ],
        [
            "LOAD_GLOBAL",
            "_days_in_month"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "CALL",
            "_days_in_month(year, month)"
        ],
        [
            "STORE_FAST",
            "dim"
        ],
        [
            "LOAD_FAST",
            "day"
        ],
        [
            "COMPARE_OP",
            "1 <= day <= dim"
        ],
        [
            "LOAD_FAST",
            "dim"
        ],
        [
            "COMPARE_OP",
            "1 <= day <= dim"
        ],
        [
            "LOAD_FAST",
            "dim"
        ],
        [
            "BINARY_OP",
            "'day must be in 1..%d' % dim"
        ],
        [
            "LOAD_GLOBAL",
            "_days_before_year"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "CALL",
            "_days_before_year(year)"
        ],
        [
            "LOAD_GLOBAL",
            "_days_before_month"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "CALL",
            "_days_before_month(year, month)"
        ],
        [
            "BINARY_OP",
            "_days_before_year(year) +\n            _days_before_month(year, month)"
        ],
        [
            "LOAD_FAST",
            "day"
        ],
        [
            "BINARY_OP",
            "_days_before_year(year) +\n            _days_before_month(year, month) +\n            day"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "BINARY_OP",
            "n -= 1"
        ],
        [
            "STORE_FAST",
            "n"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "LOAD_GLOBAL",
            "_DI400Y"
        ],
        [
            "CALL",
            "divmod(n, _DI400Y)"
        ],
        [
            "STORE_FAST",
            "n400"
        ],
        [
            "STORE_FAST",
            "n"
        ],
        [
            "LOAD_FAST",
            "n400"
        ],
        [
            "BINARY_OP",
            "n400 * 400"
        ],
        [
            "BINARY_OP",
            "n400 * 400 + 1"
        ],
        [
            "STORE_FAST",
            "year"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "LOAD_GLOBAL",
            "_DI100Y"
        ],
        [
            "CALL",
            "divmod(n, _DI100Y)"
        ],
        [
            "STORE_FAST",
            "n100"
        ],
        [
            "STORE_FAST",
            "n"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "LOAD_GLOBAL",
            "_DI4Y"
        ],
        [
            "CALL",
            "divmod(n, _DI4Y)"
        ],
        [
            "STORE_FAST",
            "n4"
        ],
        [
            "STORE_FAST",
            "n"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "CALL",
            "divmod(n, 365)"
        ],
        [
            "STORE_FAST",
            "n1"
        ],
        [
            "STORE_FAST",
            "n"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "LOAD_FAST",
            "n100"
        ],
        [
            "BINARY_OP",
            "n100 * 100"
        ],
        [
            "LOAD_FAST",
            "n4"
        ],
        [
            "BINARY_OP",
            "n4 * 4"
        ],
        [
            "BINARY_OP",
            "n100 * 100 + n4 * 4"
        ],
        [
            "LOAD_FAST",
            "n1"
        ],
        [
            "BINARY_OP",
            "n100 * 100 + n4 * 4 + n1"
        ],
        [
            "BINARY_OP",
            "year += n100 * 100 + n4 * 4 + n1"
        ],
        [
            "STORE_FAST",
            "year"
        ],
        [
            "LOAD_FAST",
            "n1"
        ],
        [
            "COMPARE_OP",
            "n1 == 4"
        ],
        [
            "LOAD_FAST",
            "n100"
        ],
        [
            "COMPARE_OP",
            "n100 == 4"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "COMPARE_OP",
            "n == 0"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "BINARY_OP",
            "year-1"
        ],
        [
            "LOAD_FAST",
            "n1"
        ],
        [
            "COMPARE_OP",
            "n1 == 3"
        ],
        [
            "LOAD_FAST",
            "n4"
        ],
        [
            "COMPARE_OP",
            "n4 != 24"
        ],
        [
            "LOAD_FAST",
            "n100"
        ],
        [
            "COMPARE_OP",
            "n100 == 3"
        ],
        [
            "STORE_FAST",
            "leapyear"
        ],
        [
            "LOAD_FAST",
            "leapyear"
        ],
        [
            "LOAD_GLOBAL",
            "_is_leap"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "CALL",
            "_is_leap(year)"
        ],
        [
            "COMPARE_OP",
            "leapyear == _is_leap(year)"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "BINARY_OP",
            "n + 50"
        ],
        [
            "BINARY_OP",
            "(n + 50) >> 5"
        ],
        [
            "STORE_FAST",
            "month"
        ],
        [
            "LOAD_GLOBAL",
            "_DAYS_BEFORE_MONTH"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "BINARY_SUBSCR",
            "_DAYS_BEFORE_MONTH[month]"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "COMPARE_OP",
            "month > 2"
        ],
        [
            "LOAD_FAST",
            "leapyear"
        ],
        [
            "BINARY_OP",
            "_DAYS_BEFORE_MONTH[month] + (month > 2 and leapyear)"
        ],
        [
            "STORE_FAST",
            "preceding"
        ],
        [
            "LOAD_FAST",
            "preceding"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "COMPARE_OP",
            "preceding > n"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "BINARY_OP",
            "month -= 1"
        ],
        [
            "STORE_FAST",
            "month"
        ],
        [
            "LOAD_FAST",
            "preceding"
        ],
        [
            "LOAD_GLOBAL",
            "_DAYS_IN_MONTH"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "BINARY_SUBSCR",
            "_DAYS_IN_MONTH[month]"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "COMPARE_OP",
            "month == 2"
        ],
        [
            "LOAD_FAST",
            "leapyear"
        ],
        [
            "BINARY_OP",
            "_DAYS_IN_MONTH[month] + (month == 2 and leapyear)"
        ],
        [
            "BINARY_OP",
            "preceding -= _DAYS_IN_MONTH[month] + (month == 2 and leapyear)"
        ],
        [
            "STORE_FAST",
            "preceding"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "LOAD_FAST",
            "preceding"
        ],
        [
            "BINARY_OP",
            "n -= preceding"
        ],
        [
            "STORE_FAST",
            "n"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "COMPARE_OP",
            "0 <= n < _days_in_month(year, month)"
        ],
        [
            "LOAD_GLOBAL",
            "_days_in_month"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "CALL",
            "_days_in_month(year, month)"
        ],
        [
            "COMPARE_OP",
            "0 <= n < _days_in_month(year, month)"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "BINARY_OP",
            "n+1"
        ],
        [
            "LOAD_GLOBAL",
            "_ymd2ord"
        ],
        [
            "LOAD_FAST",
            "y"
        ],
        [
            "LOAD_FAST",
            "m"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "CALL",
            "_ymd2ord(y, m, d)"
        ],
        [
            "BINARY_OP",
            "_ymd2ord(y, m, d) + 6"
        ],
        [
            "BINARY_OP",
            "(_ymd2ord(y, m, d) + 6) % 7"
        ],
        [
            "STORE_FAST",
            "wday"
        ],
        [
            "LOAD_GLOBAL",
            "_days_before_month"
        ],
        [
            "LOAD_FAST",
            "y"
        ],
        [
            "LOAD_FAST",
            "m"
        ],
        [
            "CALL",
            "_days_before_month(y, m)"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "BINARY_OP",
            "_days_before_month(y, m) + d"
        ],
        [
            "STORE_FAST",
            "dnum"
        ],
        [
            "LOAD_GLOBAL",
            "_time"
        ],
        [
            "LOAD_ATTR",
            "_time.struct_time"
        ],
        [
            "LOAD_FAST",
            "y"
        ],
        [
            "LOAD_FAST",
            "m"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "LOAD_FAST",
            "hh"
        ],
        [
            "LOAD_FAST",
            "mm"
        ],
        [
            "LOAD_FAST",
            "ss"
        ],
        [
            "LOAD_FAST",
            "wday"
        ],
        [
            "LOAD_FAST",
            "dnum"
        ],
        [
            "LOAD_FAST",
            "dstflag"
        ],
        [
            "CALL",
            "_time.struct_time((y, m, d, hh, mm, ss, wday, dnum, dstflag))"
        ],
        [
            "STORE_FAST",
            "specs"
        ],
        [
            "LOAD_FAST",
            "timespec"
        ],
        [
            "COMPARE_OP",
            "timespec == 'auto'"
        ],
        [
            "LOAD_FAST",
            "us"
        ],
        [
            "STORE_FAST",
            "timespec"
        ],
        [
            "LOAD_FAST",
            "timespec"
        ],
        [
            "COMPARE_OP",
            "timespec == 'milliseconds'"
        ],
        [
            "LOAD_FAST",
            "us"
        ],
        [
            "BINARY_OP",
            "us //= 1000"
        ],
        [
            "STORE_FAST",
            "us"
        ],
        [
            "LOAD_FAST",
            "specs"
        ],
        [
            "LOAD_FAST",
            "timespec"
        ],
        [
            "BINARY_SUBSCR",
            "specs[timespec]"
        ],
        [
            "STORE_FAST",
            "fmt"
        ],
        [
            "LOAD_FAST",
            "fmt"
        ],
        [
            "LOAD_METHOD",
            "fmt.format"
        ],
        [
            "LOAD_FAST",
            "hh"
        ],
        [
            "LOAD_FAST",
            "mm"
        ],
        [
            "LOAD_FAST",
            "ss"
        ],
        [
            "LOAD_FAST",
            "us"
        ],
        [
            "CALL",
            "fmt.format(hh, mm, ss, us)"
        ],
        [
            "LOAD_GLOBAL",
            "KeyError"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError('Unknown timespec value')"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "off"
        ],
        [
            "LOAD_FAST",
            "off"
        ],
        [
            "LOAD_ATTR",
            "off.days"
        ],
        [
            "COMPARE_OP",
            "off.days < 0"
        ],
        [
            "STORE_FAST",
            "sign"
        ],
        [
            "LOAD_FAST",
            "off"
        ],
        [
            "UNARY_NEGATIVE",
            "-off"
        ],
        [
            "STORE_FAST",
            "off"
        ],
        [
            "STORE_FAST",
            "sign"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "off"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "timedelta(hours=1)"
        ],
        [
            "CALL",
            "divmod(off, timedelta(hours=1))"
        ],
        [
            "STORE_FAST",
            "hh"
        ],
        [
            "STORE_FAST",
            "mm"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "mm"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "timedelta(minutes=1)"
        ],
        [
            "CALL",
            "divmod(mm, timedelta(minutes=1))"
        ],
        [
            "STORE_FAST",
            "mm"
        ],
        [
            "STORE_FAST",
            "ss"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "sign"
        ],
        [
            "LOAD_FAST",
            "hh"
        ],
        [
            "LOAD_FAST",
            "mm"
        ],
        [
            "BINARY_OP",
            "\"%s%02d:%02d\" % (sign, hh, mm)"
        ],
        [
            "BINARY_OP",
            "s += \"%s%02d:%02d\" % (sign, hh, mm)"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "ss"
        ],
        [
            "LOAD_FAST",
            "ss"
        ],
        [
            "LOAD_ATTR",
            "ss.microseconds"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "ss"
        ],
        [
            "LOAD_ATTR",
            "ss.seconds"
        ],
        [
            "BINARY_OP",
            "\":%02d\" % ss.seconds"
        ],
        [
            "BINARY_OP",
            "s += \":%02d\" % ss.seconds"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "ss"
        ],
        [
            "LOAD_ATTR",
            "ss.microseconds"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "ss"
        ],
        [
            "LOAD_ATTR",
            "ss.microseconds"
        ],
        [
            "BINARY_OP",
            "'.%06d' % ss.microseconds"
        ],
        [
            "BINARY_OP",
            "s += '.%06d' % ss.microseconds"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "STORE_FAST",
            "freplace"
        ],
        [
            "STORE_FAST",
            "zreplace"
        ],
        [
            "STORE_FAST",
            "Zreplace"
        ],
        [
            "STORE_FAST",
            "newformat"
        ],
        [
            "LOAD_FAST",
            "newformat"
        ],
        [
            "LOAD_ATTR",
            "newformat.append"
        ],
        [
            "STORE_FAST",
            "push"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "format"
        ],
        [
            "CALL",
            "len(format)"
        ],
        [
            "STORE_FAST",
            "n"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "COMPARE_OP",
            "i < n"
        ],
        [
            "LOAD_FAST",
            "format"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_SUBSCR",
            "format[i]"
        ],
        [
            "STORE_FAST",
            "ch"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_OP",
            "i += 1"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "ch"
        ],
        [
            "COMPARE_OP",
            "ch == '%'"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "COMPARE_OP",
            "i < n"
        ],
        [
            "LOAD_FAST",
            "format"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_SUBSCR",
            "format[i]"
        ],
        [
            "STORE_FAST",
            "ch"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_OP",
            "i += 1"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "ch"
        ],
        [
            "COMPARE_OP",
            "ch == 'f'"
        ],
        [
            "LOAD_FAST",
            "freplace"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_FAST",
            "object"
        ],
        [
            "CALL",
            "getattr(object,\n                                                    'microsecond', 0)"
        ],
        [
            "BINARY_OP",
            "'%06d' % getattr(object,\n                                                    'microsecond', 0)"
        ],
        [
            "STORE_FAST",
            "freplace"
        ],
        [
            "LOAD_FAST",
            "newformat"
        ],
        [
            "LOAD_METHOD",
            "newformat.append"
        ],
        [
            "LOAD_FAST",
            "freplace"
        ],
        [
            "CALL",
            "newformat.append(freplace)"
        ],
        [
            "LOAD_FAST",
            "ch"
        ],
        [
            "COMPARE_OP",
            "ch == 'z'"
        ],
        [
            "LOAD_FAST",
            "zreplace"
        ],
        [
            "STORE_FAST",
            "zreplace"
        ],
        [
            "LOAD_GLOBAL",
            "hasattr"
        ],
        [
            "LOAD_FAST",
            "object"
        ],
        [
            "CALL",
            "hasattr(object, \"utcoffset\")"
        ],
        [
            "LOAD_FAST",
            "object"
        ],
        [
            "LOAD_METHOD",
            "object.utcoffset"
        ],
        [
            "CALL",
            "object.utcoffset()"
        ],
        [
            "STORE_FAST",
            "offset"
        ],
        [
            "LOAD_FAST",
            "offset"
        ],
        [
            "STORE_FAST",
            "sign"
        ],
        [
            "LOAD_FAST",
            "offset"
        ],
        [
            "LOAD_ATTR",
            "offset.days"
        ],
        [
            "COMPARE_OP",
            "offset.days < 0"
        ],
        [
            "LOAD_FAST",
            "offset"
        ],
        [
            "UNARY_NEGATIVE",
            "-offset"
        ],
        [
            "STORE_FAST",
            "offset"
        ],
        [
            "STORE_FAST",
            "sign"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "offset"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "timedelta(hours=1)"
        ],
        [
            "CALL",
            "divmod(offset, timedelta(hours=1))"
        ],
        [
            "STORE_FAST",
            "h"
        ],
        [
            "STORE_FAST",
            "rest"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "rest"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "timedelta(minutes=1)"
        ],
        [
            "CALL",
            "divmod(rest, timedelta(minutes=1))"
        ],
        [
            "STORE_FAST",
            "m"
        ],
        [
            "STORE_FAST",
            "rest"
        ],
        [
            "LOAD_FAST",
            "rest"
        ],
        [
            "LOAD_ATTR",
            "rest.seconds"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "offset"
        ],
        [
            "LOAD_ATTR",
            "offset.microseconds"
        ],
        [
            "STORE_FAST",
            "u"
        ],
        [
            "LOAD_FAST",
            "u"
        ],
        [
            "LOAD_FAST",
            "sign"
        ],
        [
            "LOAD_FAST",
            "h"
        ],
        [
            "LOAD_FAST",
            "m"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "u"
        ],
        [
            "BINARY_OP",
            "'%c%02d%02d%02d.%06d' % (sign, h, m, s, u)"
        ],
        [
            "STORE_FAST",
            "zreplace"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "sign"
        ],
        [
            "LOAD_FAST",
            "h"
        ],
        [
            "LOAD_FAST",
            "m"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "BINARY_OP",
            "'%c%02d%02d%02d' % (sign, h, m, s)"
        ],
        [
            "STORE_FAST",
            "zreplace"
        ],
        [
            "LOAD_FAST",
            "sign"
        ],
        [
            "LOAD_FAST",
            "h"
        ],
        [
            "LOAD_FAST",
            "m"
        ],
        [
            "BINARY_OP",
            "'%c%02d%02d' % (sign, h, m)"
        ],
        [
            "STORE_FAST",
            "zreplace"
        ],
        [
            "LOAD_FAST",
            "zreplace"
        ],
        [
            "CONTAINS_OP",
            "'%' not in zreplace"
        ],
        [
            "LOAD_FAST",
            "newformat"
        ],
        [
            "LOAD_METHOD",
            "newformat.append"
        ],
        [
            "LOAD_FAST",
            "zreplace"
        ],
        [
            "CALL",
            "newformat.append(zreplace)"
        ],
        [
            "LOAD_FAST",
            "ch"
        ],
        [
            "COMPARE_OP",
            "ch == 'Z'"
        ],
        [
            "LOAD_FAST",
            "Zreplace"
        ],
        [
            "STORE_FAST",
            "Zreplace"
        ],
        [
            "LOAD_GLOBAL",
            "hasattr"
        ],
        [
            "LOAD_FAST",
            "object"
        ],
        [
            "CALL",
            "hasattr(object, \"tzname\")"
        ],
        [
            "LOAD_FAST",
            "object"
        ],
        [
            "LOAD_METHOD",
            "object.tzname"
        ],
        [
            "CALL",
            "object.tzname()"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_METHOD",
            "s.replace"
        ],
        [
            "CALL",
            "s.replace('%', '%%')"
        ],
        [
            "STORE_FAST",
            "Zreplace"
        ],
        [
            "LOAD_FAST",
            "newformat"
        ],
        [
            "LOAD_METHOD",
            "newformat.append"
        ],
        [
            "LOAD_FAST",
            "Zreplace"
        ],
        [
            "CALL",
            "newformat.append(Zreplace)"
        ],
        [
            "LOAD_FAST",
            "push"
        ],
        [
            "CALL",
            "push('%')"
        ],
        [
            "LOAD_FAST",
            "push"
        ],
        [
            "LOAD_FAST",
            "ch"
        ],
        [
            "CALL",
            "push(ch)"
        ],
        [
            "LOAD_FAST",
            "push"
        ],
        [
            "CALL",
            "push('%')"
        ],
        [
            "LOAD_FAST",
            "push"
        ],
        [
            "LOAD_FAST",
            "ch"
        ],
        [
            "CALL",
            "push(ch)"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "COMPARE_OP",
            "i < n"
        ],
        [
            "LOAD_METHOD",
            "\"\".join"
        ],
        [
            "LOAD_FAST",
            "newformat"
        ],
        [
            "CALL",
            "\"\".join(newformat)"
        ],
        [
            "STORE_FAST",
            "newformat"
        ],
        [
            "LOAD_GLOBAL",
            "_time"
        ],
        [
            "LOAD_ATTR",
            "_time.strftime"
        ],
        [
            "LOAD_FAST",
            "newformat"
        ],
        [
            "LOAD_FAST",
            "timetuple"
        ],
        [
            "CALL",
            "_time.strftime(newformat, timetuple)"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "CONTAINS_OP",
            "c in \"0123456789\""
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "dtstr"
        ],
        [
            "CALL",
            "len(dtstr)"
        ],
        [
            "STORE_FAST",
            "len_dtstr"
        ],
        [
            "LOAD_FAST",
            "len_dtstr"
        ],
        [
            "COMPARE_OP",
            "len_dtstr == 7"
        ],
        [
            "LOAD_FAST",
            "len_dtstr"
        ],
        [
            "COMPARE_OP",
            "len_dtstr > 7"
        ],
        [
            "STORE_FAST",
            "date_separator"
        ],
        [
            "STORE_FAST",
            "week_indicator"
        ],
        [
            "LOAD_FAST",
            "dtstr"
        ],
        [
            "BINARY_SUBSCR",
            "dtstr[4]"
        ],
        [
            "LOAD_FAST",
            "date_separator"
        ],
        [
            "COMPARE_OP",
            "dtstr[4] == date_separator"
        ],
        [
            "LOAD_FAST",
            "dtstr"
        ],
        [
            "BINARY_SUBSCR",
            "dtstr[5]"
        ],
        [
            "LOAD_FAST",
            "week_indicator"
        ],
        [
            "COMPARE_OP",
            "dtstr[5] == week_indicator"
        ],
        [
            "LOAD_FAST",
            "len_dtstr"
        ],
        [
            "COMPARE_OP",
            "len_dtstr < 8"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError(\"Invalid ISO string\")"
        ],
        [
            "LOAD_FAST",
            "len_dtstr"
        ],
        [
            "COMPARE_OP",
            "len_dtstr > 8"
        ],
        [
            "LOAD_FAST",
            "dtstr"
        ],
        [
            "BINARY_SUBSCR",
            "dtstr[8]"
        ],
        [
            "LOAD_FAST",
            "date_separator"
        ],
        [
            "COMPARE_OP",
            "dtstr[8] == date_separator"
        ],
        [
            "LOAD_FAST",
            "len_dtstr"
        ],
        [
            "COMPARE_OP",
            "len_dtstr == 9"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError(\"Invalid ISO string\")"
        ],
        [
            "LOAD_FAST",
            "len_dtstr"
        ],
        [
            "COMPARE_OP",
            "len_dtstr > 10"
        ],
        [
            "LOAD_GLOBAL",
            "_is_ascii_digit"
        ],
        [
            "LOAD_FAST",
            "dtstr"
        ],
        [
            "BINARY_SUBSCR",
            "dtstr[10]"
        ],
        [
            "CALL",
            "_is_ascii_digit(dtstr[10])"
        ],
        [
            "LOAD_FAST",
            "dtstr"
        ],
        [
            "BINARY_SUBSCR",
            "dtstr[4]"
        ],
        [
            "LOAD_FAST",
            "week_indicator"
        ],
        [
            "COMPARE_OP",
            "dtstr[4] == week_indicator"
        ],
        [
            "STORE_FAST",
            "idx"
        ],
        [
            "LOAD_FAST",
            "idx"
        ],
        [
            "LOAD_FAST",
            "len_dtstr"
        ],
        [
            "COMPARE_OP",
            "idx < len_dtstr"
        ],
        [
            "LOAD_GLOBAL",
            "_is_ascii_digit"
        ],
        [
            "LOAD_FAST",
            "dtstr"
        ],
        [
            "LOAD_FAST",
            "idx"
        ],
        [
            "BINARY_SUBSCR",
            "dtstr[idx]"
        ],
        [
            "CALL",
            "_is_ascii_digit(dtstr[idx])"
        ],
        [
            "LOAD_FAST",
            "idx"
        ],
        [
            "BINARY_OP",
            "idx += 1"
        ],
        [
            "STORE_FAST",
            "idx"
        ],
        [
            "LOAD_FAST",
            "idx"
        ],
        [
            "LOAD_FAST",
            "len_dtstr"
        ],
        [
            "COMPARE_OP",
            "idx < len_dtstr"
        ],
        [
            "LOAD_FAST",
            "idx"
        ],
        [
            "COMPARE_OP",
            "idx < 9"
        ],
        [
            "LOAD_FAST",
            "idx"
        ],
        [
            "LOAD_FAST",
            "idx"
        ],
        [
            "BINARY_OP",
            "idx % 2"
        ],
        [
            "COMPARE_OP",
            "idx % 2 == 0"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "dtstr"
        ],
        [
            "CALL",
            "len(dtstr)"
        ],
        [
            "CONTAINS_OP",
            "len(dtstr) in (7, 8, 10)"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "LOAD_FAST",
            "dtstr"
        ],
        [
            "BINARY_SUBSCR",
            "dtstr[0:4]"
        ],
        [
            "CALL",
            "int(dtstr[0:4])"
        ],
        [
            "STORE_FAST",
            "year"
        ],
        [
            "LOAD_FAST",
            "dtstr"
        ],
        [
            "BINARY_SUBSCR",
            "dtstr[4]"
        ],
        [
            "COMPARE_OP",
            "dtstr[4] == '-'"
        ],
        [
            "STORE_FAST",
            "has_sep"
        ],
        [
            "LOAD_FAST",
            "has_sep"
        ],
        [
            "BINARY_OP",
            "4 + has_sep"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "dtstr"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos + 1"
        ],
        [
            "BINARY_SUBSCR",
            "dtstr[pos:pos + 1]"
        ],
        [
            "COMPARE_OP",
            "dtstr[pos:pos + 1] == \"W\""
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos += 1"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "LOAD_FAST",
            "dtstr"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos + 2"
        ],
        [
            "BINARY_SUBSCR",
            "dtstr[pos:pos + 2]"
        ],
        [
            "CALL",
            "int(dtstr[pos:pos + 2])"
        ],
        [
            "STORE_FAST",
            "weekno"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos += 2"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "STORE_FAST",
            "dayno"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "dtstr"
        ],
        [
            "CALL",
            "len(dtstr)"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "COMPARE_OP",
            "len(dtstr) > pos"
        ],
        [
            "LOAD_FAST",
            "dtstr"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos + 1"
        ],
        [
            "BINARY_SUBSCR",
            "dtstr[pos:pos + 1]"
        ],
        [
            "COMPARE_OP",
            "dtstr[pos:pos + 1] == '-'"
        ],
        [
            "LOAD_FAST",
            "has_sep"
        ],
        [
            "COMPARE_OP",
            "(dtstr[pos:pos + 1] == '-') != has_sep"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError(\"Inconsistent use of dash separator\")"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "has_sep"
        ],
        [
            "BINARY_OP",
            "pos += has_sep"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "LOAD_FAST",
            "dtstr"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos + 1"
        ],
        [
            "BINARY_SUBSCR",
            "dtstr[pos:pos + 1]"
        ],
        [
            "CALL",
            "int(dtstr[pos:pos + 1])"
        ],
        [
            "STORE_FAST",
            "dayno"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_GLOBAL",
            "_isoweek_to_gregorian"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "LOAD_FAST",
            "weekno"
        ],
        [
            "LOAD_FAST",
            "dayno"
        ],
        [
            "CALL",
            "_isoweek_to_gregorian(year, weekno, dayno)"
        ],
        [
            "CALL",
            "list(_isoweek_to_gregorian(year, weekno, dayno))"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "LOAD_FAST",
            "dtstr"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos + 2"
        ],
        [
            "BINARY_SUBSCR",
            "dtstr[pos:pos + 2]"
        ],
        [
            "CALL",
            "int(dtstr[pos:pos + 2])"
        ],
        [
            "STORE_FAST",
            "month"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos += 2"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "dtstr"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos + 1"
        ],
        [
            "BINARY_SUBSCR",
            "dtstr[pos:pos + 1]"
        ],
        [
            "COMPARE_OP",
            "dtstr[pos:pos + 1] == \"-\""
        ],
        [
            "LOAD_FAST",
            "has_sep"
        ],
        [
            "COMPARE_OP",
            "(dtstr[pos:pos + 1] == \"-\") != has_sep"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError(\"Inconsistent use of dash separator\")"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "has_sep"
        ],
        [
            "BINARY_OP",
            "pos += has_sep"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "LOAD_FAST",
            "dtstr"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos + 2"
        ],
        [
            "BINARY_SUBSCR",
            "dtstr[pos:pos + 2]"
        ],
        [
            "CALL",
            "int(dtstr[pos:pos + 2])"
        ],
        [
            "STORE_FAST",
            "day"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "LOAD_FAST",
            "day"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "tstr"
        ],
        [
            "CALL",
            "len(tstr)"
        ],
        [
            "STORE_FAST",
            "len_str"
        ],
        [
            "STORE_FAST",
            "time_comps"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_GLOBAL",
            "range"
        ],
        [
            "CALL",
            "range(0, 3)"
        ],
        [
            "STORE_FAST",
            "comp"
        ],
        [
            "LOAD_FAST",
            "len_str"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "len_str - pos"
        ],
        [
            "COMPARE_OP",
            "(len_str - pos) < 2"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError(\"Incomplete time component\")"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "LOAD_FAST",
            "tstr"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos+2"
        ],
        [
            "BINARY_SUBSCR",
            "tstr[pos:pos+2]"
        ],
        [
            "CALL",
            "int(tstr[pos:pos+2])"
        ],
        [
            "LOAD_FAST",
            "time_comps"
        ],
        [
            "LOAD_FAST",
            "comp"
        ],
        [
            "STORE_SUBSCR",
            "time_comps[comp]"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos += 2"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "tstr"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos+1"
        ],
        [
            "BINARY_SUBSCR",
            "tstr[pos:pos+1]"
        ],
        [
            "STORE_FAST",
            "next_char"
        ],
        [
            "LOAD_FAST",
            "comp"
        ],
        [
            "COMPARE_OP",
            "comp == 0"
        ],
        [
            "LOAD_FAST",
            "next_char"
        ],
        [
            "COMPARE_OP",
            "next_char == ':'"
        ],
        [
            "STORE_FAST",
            "has_sep"
        ],
        [
            "LOAD_FAST",
            "next_char"
        ],
        [
            "LOAD_FAST",
            "comp"
        ],
        [
            "COMPARE_OP",
            "comp >= 2"
        ],
        [
            "LOAD_FAST",
            "has_sep"
        ],
        [
            "LOAD_FAST",
            "next_char"
        ],
        [
            "COMPARE_OP",
            "next_char != ':'"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "LOAD_FAST",
            "next_char"
        ],
        [
            "BINARY_OP",
            "\"Invalid time separator: %c\" % next_char"
        ],
        [
            "CALL",
            "ValueError(\"Invalid time separator: %c\" % next_char)"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "has_sep"
        ],
        [
            "BINARY_OP",
            "pos += has_sep"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "len_str"
        ],
        [
            "COMPARE_OP",
            "pos < len_str"
        ],
        [
            "LOAD_FAST",
            "tstr"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_SUBSCR",
            "tstr[pos]"
        ],
        [
            "CONTAINS_OP",
            "tstr[pos] not in '.,'"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError(\"Invalid microsecond component\")"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "pos += 1"
        ],
        [
            "STORE_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "len_str"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "BINARY_OP",
            "len_str - pos"
        ],
        [
            "STORE_FAST",
            "len_remainder"
        ],
        [
            "LOAD_FAST",
            "len_remainder"
        ],
        [
            "COMPARE_OP",
            "len_remainder >= 6"
        ],
        [
            "STORE_FAST",
            "to_parse"
        ],
        [
            "LOAD_FAST",
            "len_remainder"
        ],
        [
            "STORE_FAST",
            "to_parse"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "LOAD_FAST",
            "tstr"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "to_parse"
        ],
        [
            "BINARY_OP",
            "pos+to_parse"
        ],
        [
            "BINARY_SUBSCR",
            "tstr[pos:(pos+to_parse)]"
        ],
        [
            "CALL",
            "int(tstr[pos:(pos+to_parse)])"
        ],
        [
            "LOAD_FAST",
            "time_comps"
        ],
        [
            "STORE_SUBSCR",
            "time_comps[3]"
        ],
        [
            "LOAD_FAST",
            "to_parse"
        ],
        [
            "COMPARE_OP",
            "to_parse < 6"
        ],
        [
            "LOAD_FAST",
            "time_comps"
        ],
        [
            "BINARY_SUBSCR",
            "time_comps[3]"
        ],
        [
            "LOAD_GLOBAL",
            "_FRACTION_CORRECTION"
        ],
        [
            "LOAD_FAST",
            "to_parse"
        ],
        [
            "BINARY_OP",
            "to_parse-1"
        ],
        [
            "BINARY_SUBSCR",
            "_FRACTION_CORRECTION[to_parse-1]"
        ],
        [
            "BINARY_OP",
            "time_comps[3] *= _FRACTION_CORRECTION[to_parse-1]"
        ],
        [
            "STORE_SUBSCR",
            "time_comps[3]"
        ],
        [
            "LOAD_FAST",
            "len_remainder"
        ],
        [
            "LOAD_FAST",
            "to_parse"
        ],
        [
            "COMPARE_OP",
            "len_remainder > to_parse"
        ],
        [
            "LOAD_GLOBAL",
            "all"
        ],
        [
            "LOAD_GLOBAL",
            "map"
        ],
        [
            "LOAD_GLOBAL",
            "_is_ascii_digit"
        ],
        [
            "LOAD_FAST",
            "tstr"
        ],
        [
            "LOAD_FAST",
            "pos"
        ],
        [
            "LOAD_FAST",
            "to_parse"
        ],
        [
            "BINARY_OP",
            "pos+to_parse"
        ],
        [
            "BINARY_SUBSCR",
            "tstr[(pos+to_parse):]"
        ],
        [
            "CALL",
            "map(_is_ascii_digit, tstr[(pos+to_parse):])"
        ],
        [
            "CALL",
            "all(map(_is_ascii_digit, tstr[(pos+to_parse):]))"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError(\"Non-digit values in unparsed fraction\")"
        ],
        [
            "LOAD_FAST",
            "time_comps"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "tstr"
        ],
        [
            "CALL",
            "len(tstr)"
        ],
        [
            "STORE_FAST",
            "len_str"
        ],
        [
            "LOAD_FAST",
            "len_str"
        ],
        [
            "COMPARE_OP",
            "len_str < 2"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError(\"Isoformat time too short\")"
        ],
        [
            "LOAD_FAST",
            "tstr"
        ],
        [
            "LOAD_METHOD",
            "tstr.find"
        ],
        [
            "CALL",
            "tstr.find('-')"
        ],
        [
            "BINARY_OP",
            "tstr.find('-') + 1"
        ],
        [
            "LOAD_FAST",
            "tstr"
        ],
        [
            "LOAD_METHOD",
            "tstr.find"
        ],
        [
            "CALL",
            "tstr.find('+')"
        ],
        [
            "BINARY_OP",
            "tstr.find('+') + 1"
        ],
        [
            "LOAD_FAST",
            "tstr"
        ],
        [
            "LOAD_METHOD",
            "tstr.find"
        ],
        [
            "CALL",
            "tstr.find('Z')"
        ],
        [
            "BINARY_OP",
            "tstr.find('Z') + 1"
        ],
        [
            "STORE_FAST",
            "tz_pos"
        ],
        [
            "LOAD_FAST",
            "tz_pos"
        ],
        [
            "COMPARE_OP",
            "tz_pos > 0"
        ],
        [
            "LOAD_FAST",
            "tstr"
        ],
        [
            "LOAD_FAST",
            "tz_pos"
        ],
        [
            "BINARY_OP",
            "tz_pos-1"
        ],
        [
            "BINARY_SUBSCR",
            "tstr[:tz_pos-1]"
        ],
        [
            "LOAD_FAST",
            "tstr"
        ],
        [
            "STORE_FAST",
            "timestr"
        ],
        [
            "LOAD_GLOBAL",
            "_parse_hh_mm_ss_ff"
        ],
        [
            "LOAD_FAST",
            "timestr"
        ],
        [
            "CALL",
            "_parse_hh_mm_ss_ff(timestr)"
        ],
        [
            "STORE_FAST",
            "time_comps"
        ],
        [
            "STORE_FAST",
            "tzi"
        ],
        [
            "LOAD_FAST",
            "tz_pos"
        ],
        [
            "LOAD_FAST",
            "len_str"
        ],
        [
            "COMPARE_OP",
            "tz_pos == len_str"
        ],
        [
            "LOAD_FAST",
            "tstr"
        ],
        [
            "BINARY_SUBSCR",
            "tstr[-1]"
        ],
        [
            "COMPARE_OP",
            "tstr[-1] == 'Z'"
        ],
        [
            "LOAD_GLOBAL",
            "timezone"
        ],
        [
            "LOAD_ATTR",
            "timezone.utc"
        ],
        [
            "STORE_FAST",
            "tzi"
        ],
        [
            "LOAD_FAST",
            "tz_pos"
        ],
        [
            "COMPARE_OP",
            "tz_pos > 0"
        ],
        [
            "LOAD_FAST",
            "tstr"
        ],
        [
            "LOAD_FAST",
            "tz_pos"
        ],
        [
            "BINARY_SUBSCR",
            "tstr[tz_pos:]"
        ],
        [
            "STORE_FAST",
            "tzstr"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "tzstr"
        ],
        [
            "CALL",
            "len(tzstr)"
        ],
        [
            "CONTAINS_OP",
            "len(tzstr) in (0, 1, 3)"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError(\"Malformed time zone string\")"
        ],
        [
            "LOAD_GLOBAL",
            "_parse_hh_mm_ss_ff"
        ],
        [
            "LOAD_FAST",
            "tzstr"
        ],
        [
            "CALL",
            "_parse_hh_mm_ss_ff(tzstr)"
        ],
        [
            "STORE_FAST",
            "tz_comps"
        ],
        [
            "LOAD_GLOBAL",
            "all"
        ],
        [
            "LOAD_FAST",
            "tz_comps"
        ],
        [
            "CALL",
            "(x == 0 for x in tz_comps)"
        ],
        [
            "CALL",
            "all(x == 0 for x in tz_comps)"
        ],
        [
            "LOAD_GLOBAL",
            "timezone"
        ],
        [
            "LOAD_ATTR",
            "timezone.utc"
        ],
        [
            "STORE_FAST",
            "tzi"
        ],
        [
            "LOAD_FAST",
            "tstr"
        ],
        [
            "LOAD_FAST",
            "tz_pos"
        ],
        [
            "BINARY_OP",
            "tz_pos - 1"
        ],
        [
            "BINARY_SUBSCR",
            "tstr[tz_pos - 1]"
        ],
        [
            "COMPARE_OP",
            "tstr[tz_pos - 1] == '-'"
        ],
        [
            "STORE_FAST",
            "tzsign"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "LOAD_FAST",
            "tz_comps"
        ],
        [
            "BINARY_SUBSCR",
            "tz_comps[0]"
        ],
        [
            "LOAD_FAST",
            "tz_comps"
        ],
        [
            "BINARY_SUBSCR",
            "tz_comps[1]"
        ],
        [
            "LOAD_FAST",
            "tz_comps"
        ],
        [
            "BINARY_SUBSCR",
            "tz_comps[2]"
        ],
        [
            "LOAD_FAST",
            "tz_comps"
        ],
        [
            "BINARY_SUBSCR",
            "tz_comps[3]"
        ],
        [
            "CALL",
            "timedelta(hours=tz_comps[0], minutes=tz_comps[1],\n                           seconds=tz_comps[2], microseconds=tz_comps[3])"
        ],
        [
            "STORE_FAST",
            "td"
        ],
        [
            "LOAD_GLOBAL",
            "timezone"
        ],
        [
            "LOAD_FAST",
            "tzsign"
        ],
        [
            "LOAD_FAST",
            "td"
        ],
        [
            "BINARY_OP",
            "tzsign * td"
        ],
        [
            "CALL",
            "timezone(tzsign * td)"
        ],
        [
            "STORE_FAST",
            "tzi"
        ],
        [
            "LOAD_FAST",
            "time_comps"
        ],
        [
            "LOAD_METHOD",
            "time_comps.append"
        ],
        [
            "LOAD_FAST",
            "tzi"
        ],
        [
            "CALL",
            "time_comps.append(tzi)"
        ],
        [
            "LOAD_FAST",
            "time_comps"
        ],
        [
            "LOAD_FAST",
            "(x == 0 for x in tz_comps)"
        ],
        [
            "STORE_FAST",
            "x"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "COMPARE_OP",
            "x == 0"
        ],
        [
            "LOAD_GLOBAL",
            "MINYEAR"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "COMPARE_OP",
            "MINYEAR <= year <= MAXYEAR"
        ],
        [
            "LOAD_GLOBAL",
            "MAXYEAR"
        ],
        [
            "COMPARE_OP",
            "MINYEAR <= year <= MAXYEAR"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "CALL",
            "ValueError(f\"Year is out of range: {year}\")"
        ],
        [
            "LOAD_FAST",
            "week"
        ],
        [
            "COMPARE_OP",
            "0 < week < 53"
        ],
        [
            "COMPARE_OP",
            "0 < week < 53"
        ],
        [
            "STORE_FAST",
            "out_of_range"
        ],
        [
            "LOAD_FAST",
            "week"
        ],
        [
            "COMPARE_OP",
            "week == 53"
        ],
        [
            "LOAD_GLOBAL",
            "_ymd2ord"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "CALL",
            "_ymd2ord(year, 1, 1)"
        ],
        [
            "BINARY_OP",
            "_ymd2ord(year, 1, 1) % 7"
        ],
        [
            "STORE_FAST",
            "first_weekday"
        ],
        [
            "LOAD_FAST",
            "first_weekday"
        ],
        [
            "COMPARE_OP",
            "first_weekday == 4"
        ],
        [
            "LOAD_FAST",
            "first_weekday"
        ],
        [
            "COMPARE_OP",
            "first_weekday == 3"
        ],
        [
            "LOAD_GLOBAL",
            "_is_leap"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "CALL",
            "_is_leap(year)"
        ],
        [
            "STORE_FAST",
            "out_of_range"
        ],
        [
            "LOAD_FAST",
            "out_of_range"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "CALL",
            "ValueError(f\"Invalid week: {week}\")"
        ],
        [
            "LOAD_FAST",
            "day"
        ],
        [
            "COMPARE_OP",
            "0 < day < 8"
        ],
        [
            "COMPARE_OP",
            "0 < day < 8"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "CALL",
            "ValueError(f\"Invalid weekday: {day} (range is [1, 7])\")"
        ],
        [
            "LOAD_FAST",
            "week"
        ],
        [
            "BINARY_OP",
            "week - 1"
        ],
        [
            "BINARY_OP",
            "(week - 1) * 7"
        ],
        [
            "LOAD_FAST",
            "day"
        ],
        [
            "BINARY_OP",
            "day - 1"
        ],
        [
            "BINARY_OP",
            "(week - 1) * 7 + (day - 1)"
        ],
        [
            "STORE_FAST",
            "day_offset"
        ],
        [
            "LOAD_GLOBAL",
            "_isoweek1monday"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "CALL",
            "_isoweek1monday(year)"
        ],
        [
            "STORE_FAST",
            "day_1"
        ],
        [
            "LOAD_FAST",
            "day_1"
        ],
        [
            "LOAD_FAST",
            "day_offset"
        ],
        [
            "BINARY_OP",
            "day_1 + day_offset"
        ],
        [
            "STORE_FAST",
            "ord_day"
        ],
        [
            "LOAD_GLOBAL",
            "_ord2ymd"
        ],
        [
            "LOAD_FAST",
            "ord_day"
        ],
        [
            "CALL",
            "_ord2ymd(ord_day)"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "CALL",
            "isinstance(name, str)"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "LOAD_GLOBAL",
            "type"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "CALL",
            "type(name)"
        ],
        [
            "BINARY_OP",
            "\"tzinfo.tzname() must return None or string, \"\n                        \"not '%s'\" % type(name)"
        ],
        [
            "CALL",
            "TypeError(\"tzinfo.tzname() must return None or string, \"\n                        \"not '%s'\" % type(name))"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "CONTAINS_OP",
            "name in (\"utcoffset\", \"dst\")"
        ],
        [
            "LOAD_FAST",
            "offset"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "offset"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "isinstance(offset, timedelta)"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_GLOBAL",
            "type"
        ],
        [
            "LOAD_FAST",
            "offset"
        ],
        [
            "CALL",
            "type(offset)"
        ],
        [
            "BUILD_STRING",
            "\"tzinfo.%s() must return None \"\n                        \"or timedelta, not '%s'\" % (name, type(offset))"
        ],
        [
            "CALL",
            "TypeError(\"tzinfo.%s() must return None \"\n                        \"or timedelta, not '%s'\" % (name, type(offset)))"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "timedelta(1)"
        ],
        [
            "UNARY_NEGATIVE",
            "-timedelta(1)"
        ],
        [
            "LOAD_FAST",
            "offset"
        ],
        [
            "COMPARE_OP",
            "-timedelta(1) < offset < timedelta(1)"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "timedelta(1)"
        ],
        [
            "COMPARE_OP",
            "-timedelta(1) < offset < timedelta(1)"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "offset"
        ],
        [
            "BUILD_STRING",
            "\"%s()=%s, must be strictly between \"\n                         \"-timedelta(hours=24) and timedelta(hours=24)\" %\n                         (name, offset)"
        ],
        [
            "CALL",
            "ValueError(\"%s()=%s, must be strictly between \"\n                         \"-timedelta(hours=24) and timedelta(hours=24)\" %\n                         (name, offset))"
        ],
        [
            "LOAD_GLOBAL",
            "_index"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "CALL",
            "_index(year)"
        ],
        [
            "STORE_FAST",
            "year"
        ],
        [
            "LOAD_GLOBAL",
            "_index"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "CALL",
            "_index(month)"
        ],
        [
            "STORE_FAST",
            "month"
        ],
        [
            "LOAD_GLOBAL",
            "_index"
        ],
        [
            "LOAD_FAST",
            "day"
        ],
        [
            "CALL",
            "_index(day)"
        ],
        [
            "STORE_FAST",
            "day"
        ],
        [
            "LOAD_GLOBAL",
            "MINYEAR"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "COMPARE_OP",
            "MINYEAR <= year <= MAXYEAR"
        ],
        [
            "LOAD_GLOBAL",
            "MAXYEAR"
        ],
        [
            "COMPARE_OP",
            "MINYEAR <= year <= MAXYEAR"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "LOAD_GLOBAL",
            "MINYEAR"
        ],
        [
            "LOAD_GLOBAL",
            "MAXYEAR"
        ],
        [
            "BINARY_OP",
            "'year must be in %d..%d' % (MINYEAR, MAXYEAR)"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "CALL",
            "ValueError('year must be in %d..%d' % (MINYEAR, MAXYEAR), year)"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "COMPARE_OP",
            "1 <= month <= 12"
        ],
        [
            "COMPARE_OP",
            "1 <= month <= 12"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "CALL",
            "ValueError('month must be in 1..12', month)"
        ],
        [
            "LOAD_GLOBAL",
            "_days_in_month"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "CALL",
            "_days_in_month(year, month)"
        ],
        [
            "STORE_FAST",
            "dim"
        ],
        [
            "LOAD_FAST",
            "day"
        ],
        [
            "COMPARE_OP",
            "1 <= day <= dim"
        ],
        [
            "LOAD_FAST",
            "dim"
        ],
        [
            "COMPARE_OP",
            "1 <= day <= dim"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "LOAD_FAST",
            "dim"
        ],
        [
            "BINARY_OP",
            "'day must be in 1..%d' % dim"
        ],
        [
            "LOAD_FAST",
            "day"
        ],
        [
            "CALL",
            "ValueError('day must be in 1..%d' % dim, day)"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "LOAD_FAST",
            "day"
        ],
        [
            "LOAD_GLOBAL",
            "_index"
        ],
        [
            "LOAD_FAST",
            "hour"
        ],
        [
            "CALL",
            "_index(hour)"
        ],
        [
            "STORE_FAST",
            "hour"
        ],
        [
            "LOAD_GLOBAL",
            "_index"
        ],
        [
            "LOAD_FAST",
            "minute"
        ],
        [
            "CALL",
            "_index(minute)"
        ],
        [
            "STORE_FAST",
            "minute"
        ],
        [
            "LOAD_GLOBAL",
            "_index"
        ],
        [
            "LOAD_FAST",
            "second"
        ],
        [
            "CALL",
            "_index(second)"
        ],
        [
            "STORE_FAST",
            "second"
        ],
        [
            "LOAD_GLOBAL",
            "_index"
        ],
        [
            "LOAD_FAST",
            "microsecond"
        ],
        [
            "CALL",
            "_index(microsecond)"
        ],
        [
            "STORE_FAST",
            "microsecond"
        ],
        [
            "LOAD_FAST",
            "hour"
        ],
        [
            "COMPARE_OP",
            "0 <= hour <= 23"
        ],
        [
            "COMPARE_OP",
            "0 <= hour <= 23"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "LOAD_FAST",
            "hour"
        ],
        [
            "CALL",
            "ValueError('hour must be in 0..23', hour)"
        ],
        [
            "LOAD_FAST",
            "minute"
        ],
        [
            "COMPARE_OP",
            "0 <= minute <= 59"
        ],
        [
            "COMPARE_OP",
            "0 <= minute <= 59"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "LOAD_FAST",
            "minute"
        ],
        [
            "CALL",
            "ValueError('minute must be in 0..59', minute)"
        ],
        [
            "LOAD_FAST",
            "second"
        ],
        [
            "COMPARE_OP",
            "0 <= second <= 59"
        ],
        [
            "COMPARE_OP",
            "0 <= second <= 59"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "LOAD_FAST",
            "second"
        ],
        [
            "CALL",
            "ValueError('second must be in 0..59', second)"
        ],
        [
            "LOAD_FAST",
            "microsecond"
        ],
        [
            "COMPARE_OP",
            "0 <= microsecond <= 999999"
        ],
        [
            "COMPARE_OP",
            "0 <= microsecond <= 999999"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "LOAD_FAST",
            "microsecond"
        ],
        [
            "CALL",
            "ValueError('microsecond must be in 0..999999', microsecond)"
        ],
        [
            "LOAD_FAST",
            "fold"
        ],
        [
            "CONTAINS_OP",
            "fold not in (0, 1)"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "LOAD_FAST",
            "fold"
        ],
        [
            "CALL",
            "ValueError('fold must be either 0 or 1', fold)"
        ],
        [
            "LOAD_FAST",
            "hour"
        ],
        [
            "LOAD_FAST",
            "minute"
        ],
        [
            "LOAD_FAST",
            "second"
        ],
        [
            "LOAD_FAST",
            "microsecond"
        ],
        [
            "LOAD_FAST",
            "fold"
        ],
        [
            "LOAD_FAST",
            "tz"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "tz"
        ],
        [
            "LOAD_GLOBAL",
            "tzinfo"
        ],
        [
            "CALL",
            "isinstance(tz, tzinfo)"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "CALL",
            "TypeError(\"tzinfo argument must be None or of a tzinfo subclass\")"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "LOAD_GLOBAL",
            "type"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "type(x)"
        ],
        [
            "LOAD_ATTR",
            "type(x).__name__"
        ],
        [
            "LOAD_GLOBAL",
            "type"
        ],
        [
            "LOAD_FAST",
            "y"
        ],
        [
            "CALL",
            "type(y)"
        ],
        [
            "LOAD_ATTR",
            "type(y).__name__"
        ],
        [
            "BUILD_STRING",
            "\"can't compare '%s' to '%s'\" % (\n                    type(x).__name__, type(y).__name__)"
        ],
        [
            "CALL",
            "TypeError(\"can't compare '%s' to '%s'\" % (\n                    type(x).__name__, type(y).__name__))"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "a"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "CALL",
            "divmod(a, b)"
        ],
        [
            "STORE_FAST",
            "q"
        ],
        [
            "STORE_FAST",
            "r"
        ],
        [
            "LOAD_FAST",
            "r"
        ],
        [
            "BINARY_OP",
            "r *= 2"
        ],
        [
            "STORE_FAST",
            "r"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "COMPARE_OP",
            "b > 0"
        ],
        [
            "LOAD_FAST",
            "r"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "COMPARE_OP",
            "r > b"
        ],
        [
            "LOAD_FAST",
            "r"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "COMPARE_OP",
            "r < b"
        ],
        [
            "STORE_FAST",
            "greater_than_half"
        ],
        [
            "LOAD_FAST",
            "greater_than_half"
        ],
        [
            "LOAD_FAST",
            "r"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "COMPARE_OP",
            "r == b"
        ],
        [
            "LOAD_FAST",
            "q"
        ],
        [
            "BINARY_OP",
            "q % 2"
        ],
        [
            "COMPARE_OP",
            "q % 2 == 1"
        ],
        [
            "LOAD_FAST",
            "q"
        ],
        [
            "BINARY_OP",
            "q += 1"
        ],
        [
            "STORE_FAST",
            "q"
        ],
        [
            "LOAD_FAST",
            "q"
        ],
        [
            "STORE_NAME",
            "\"\"\"Represent the difference between two datetime objects.\n\n    Supported operators:\n\n    - add, subtract timedelta\n    - unary plus, minus, abs\n    - compare to timedelta\n    - multiply, divide by int\n\n    In addition, datetime supports subtraction of two datetime objects\n    returning a timedelta, and addition or subtraction of a datetime\n    and a timedelta giving a datetime.\n\n    Representation: (days, seconds, microseconds).  Why?  Because I\n    felt like it.\n    \"\"\""
        ],
        [
            "STORE_NAME",
            "__slots__"
        ],
        [
            "STORE_NAME",
            "    def __new__(cls, days=0, seconds=0, microseconds=0,\n                milliseconds=0, minutes=0, hours=0, weeks=0):\n        # Doing this efficiently and accurately in C is going to be difficult\n        # and error-prone, due to ubiquitous overflow possibilities, and that\n        # C double doesn't have enough bits of precision to represent\n        # microseconds over 10K years faithfully.  The code here tries to make\n        # explicit where go-fast assumptions can be relied on, in order to\n        # guide the C implementation; it's way more convoluted than speed-\n        # ignoring auto-overflow-to-long idiomatic Python could be.\n\n        # XXX Check that all inputs are ints or floats.\n\n        # Final values, all integer.\n        # s and us fit in 32-bit signed ints; d isn't bounded.\n        d = s = us = 0\n\n        # Normalize everything to days, seconds, microseconds.\n        days += weeks*7\n        seconds += minutes*60 + hours*3600\n        microseconds += milliseconds*1000\n\n        # Get rid of all fractions, and normalize s and us.\n        # Take a deep breath <wink>.\n        if isinstance(days, float):\n            dayfrac, days = _math.modf(days)\n            daysecondsfrac, daysecondswhole = _math.modf(dayfrac * (24.*3600.))\n            assert daysecondswhole == int(daysecondswhole)  # can't overflow\n            s = int(daysecondswhole)\n            assert days == int(days)\n            d = int(days)\n        else:\n            daysecondsfrac = 0.0\n            d = days\n        assert isinstance(daysecondsfrac, float)\n        assert abs(daysecondsfrac) <= 1.0\n        assert isinstance(d, int)\n        assert abs(s) <= 24 * 3600\n        # days isn't referenced again before redefinition\n\n        if isinstance(seconds, float):\n            secondsfrac, seconds = _math.modf(seconds)\n            assert seconds == int(seconds)\n            seconds = int(seconds)\n            secondsfrac += daysecondsfrac\n            assert abs(secondsfrac) <= 2.0\n        else:\n            secondsfrac = daysecondsfrac\n        # daysecondsfrac isn't referenced again\n        assert isinstance(secondsfrac, float)\n        assert abs(secondsfrac) <= 2.0\n\n        assert isinstance(seconds, int)\n        days, seconds = divmod(seconds, 24*3600)\n        d += days\n        s += int(seconds)    # can't overflow\n        assert isinstance(s, int)\n        assert abs(s) <= 2 * 24 * 3600\n        # seconds isn't referenced again before redefinition\n\n        usdouble = secondsfrac * 1e6\n        assert abs(usdouble) < 2.1e6    # exact value not critical\n        # secondsfrac isn't referenced again\n\n        if isinstance(microseconds, float):\n            microseconds = round(microseconds + usdouble)\n            seconds, microseconds = divmod(microseconds, 1000000)\n            days, seconds = divmod(seconds, 24*3600)\n            d += days\n            s += seconds\n        else:\n            microseconds = int(microseconds)\n            seconds, microseconds = divmod(microseconds, 1000000)\n            days, seconds = divmod(seconds, 24*3600)\n            d += days\n            s += seconds\n            microseconds = round(microseconds + usdouble)\n        assert isinstance(s, int)\n        assert isinstance(microseconds, int)\n        assert abs(s) <= 3 * 24 * 3600\n        assert abs(microseconds) < 3.1e6\n\n        # Just a little bit of carrying possible for microseconds and seconds.\n        seconds, us = divmod(microseconds, 1000000)\n        s += seconds\n        days, s = divmod(s, 24*3600)\n        d += days\n\n        assert isinstance(d, int)\n        assert isinstance(s, int) and 0 <= s < 24*3600\n        assert isinstance(us, int) and 0 <= us < 1000000\n\n        if abs(d) > 999999999:\n            raise OverflowError(\"timedelta # of days is too large: %d\" % d)\n\n        self = object.__new__(cls)\n        self._days = d\n        self._seconds = s\n        self._microseconds = us\n        self._hashcode = -1\n        return self"
        ],
        [
            "STORE_NAME",
            "    def __repr__(self):\n        args = []\n        if self._days:\n            args.append(\"days=%d\" % self._days)\n        if self._seconds:\n            args.append(\"seconds=%d\" % self._seconds)\n        if self._microseconds:\n            args.append(\"microseconds=%d\" % self._microseconds)\n        if not args:\n            args.append('0')\n        return \"%s.%s(%s)\" % (self.__class__.__module__,\n                              self.__class__.__qualname__,\n                              ', '.join(args))"
        ],
        [
            "STORE_NAME",
            "    def __str__(self):\n        mm, ss = divmod(self._seconds, 60)\n        hh, mm = divmod(mm, 60)\n        s = \"%d:%02d:%02d\" % (hh, mm, ss)\n        if self._days:\n            def plural(n):\n                return n, abs(n) != 1 and \"s\" or \"\"\n            s = (\"%d day%s, \" % plural(self._days)) + s\n        if self._microseconds:\n            s = s + \".%06d\" % self._microseconds\n        return s"
        ],
        [
            "STORE_NAME",
            "    def total_seconds(self):\n        \"\"\"Total seconds in the duration.\"\"\"\n        return ((self.days * 86400 + self.seconds) * 10**6 +\n                self.microseconds) / 10**6"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "    @property\n    def days(self):\n        \"\"\"days\"\"\"\n        return self._days"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "    @property\n    def seconds(self):\n        \"\"\"seconds\"\"\"\n        return self._seconds"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "    @property\n    def microseconds(self):\n        \"\"\"microseconds\"\"\"\n        return self._microseconds"
        ],
        [
            "STORE_NAME",
            "    def __add__(self, other):\n        if isinstance(other, timedelta):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta(self._days + other._days,\n                             self._seconds + other._seconds,\n                             self._microseconds + other._microseconds)\n        return NotImplemented"
        ],
        [
            "LOAD_NAME",
            "__add__"
        ],
        [
            "STORE_NAME",
            "__radd__"
        ],
        [
            "STORE_NAME",
            "    def __sub__(self, other):\n        if isinstance(other, timedelta):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta(self._days - other._days,\n                             self._seconds - other._seconds,\n                             self._microseconds - other._microseconds)\n        return NotImplemented"
        ],
        [
            "STORE_NAME",
            "    def __rsub__(self, other):\n        if isinstance(other, timedelta):\n            return -self + other\n        return NotImplemented"
        ],
        [
            "STORE_NAME",
            "    def __neg__(self):\n        # for CPython compatibility, we cannot use\n        # our __class__ here, but need a real timedelta\n        return timedelta(-self._days,\n                         -self._seconds,\n                         -self._microseconds)"
        ],
        [
            "STORE_NAME",
            "    def __pos__(self):\n        return self"
        ],
        [
            "STORE_NAME",
            "    def __abs__(self):\n        if self._days < 0:\n            return -self\n        else:\n            return self"
        ],
        [
            "STORE_NAME",
            "    def __mul__(self, other):\n        if isinstance(other, int):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta(self._days * other,\n                             self._seconds * other,\n                             self._microseconds * other)\n        if isinstance(other, float):\n            usec = self._to_microseconds()\n            a, b = other.as_integer_ratio()\n            return timedelta(0, 0, _divide_and_round(usec * a, b))\n        return NotImplemented"
        ],
        [
            "LOAD_NAME",
            "__mul__"
        ],
        [
            "STORE_NAME",
            "__rmul__"
        ],
        [
            "STORE_NAME",
            "    def _to_microseconds(self):\n        return ((self._days * (24*3600) + self._seconds) * 1000000 +\n                self._microseconds)"
        ],
        [
            "STORE_NAME",
            "    def __floordiv__(self, other):\n        if not isinstance(other, (int, timedelta)):\n            return NotImplemented\n        usec = self._to_microseconds()\n        if isinstance(other, timedelta):\n            return usec // other._to_microseconds()\n        if isinstance(other, int):\n            return timedelta(0, 0, usec // other)"
        ],
        [
            "STORE_NAME",
            "    def __truediv__(self, other):\n        if not isinstance(other, (int, float, timedelta)):\n            return NotImplemented\n        usec = self._to_microseconds()\n        if isinstance(other, timedelta):\n            return usec / other._to_microseconds()\n        if isinstance(other, int):\n            return timedelta(0, 0, _divide_and_round(usec, other))\n        if isinstance(other, float):\n            a, b = other.as_integer_ratio()\n            return timedelta(0, 0, _divide_and_round(b * usec, a))"
        ],
        [
            "STORE_NAME",
            "    def __mod__(self, other):\n        if isinstance(other, timedelta):\n            r = self._to_microseconds() % other._to_microseconds()\n            return timedelta(0, 0, r)\n        return NotImplemented"
        ],
        [
            "STORE_NAME",
            "    def __divmod__(self, other):\n        if isinstance(other, timedelta):\n            q, r = divmod(self._to_microseconds(),\n                          other._to_microseconds())\n            return q, timedelta(0, 0, r)\n        return NotImplemented"
        ],
        [
            "STORE_NAME",
            "    def __eq__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) == 0\n        else:\n            return NotImplemented"
        ],
        [
            "STORE_NAME",
            "    def __le__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) <= 0\n        else:\n            return NotImplemented"
        ],
        [
            "STORE_NAME",
            "    def __lt__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) < 0\n        else:\n            return NotImplemented"
        ],
        [
            "STORE_NAME",
            "    def __ge__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) >= 0\n        else:\n            return NotImplemented"
        ],
        [
            "STORE_NAME",
            "    def __gt__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) > 0\n        else:\n            return NotImplemented"
        ],
        [
            "STORE_NAME",
            "    def _cmp(self, other):\n        assert isinstance(other, timedelta)\n        return _cmp(self._getstate(), other._getstate())"
        ],
        [
            "STORE_NAME",
            "    def __hash__(self):\n        if self._hashcode == -1:\n            self._hashcode = hash(self._getstate())\n        return self._hashcode"
        ],
        [
            "STORE_NAME",
            "    def __bool__(self):\n        return (self._days != 0 or\n                self._seconds != 0 or\n                self._microseconds != 0)"
        ],
        [
            "STORE_NAME",
            "    def _getstate(self):\n        return (self._days, self._seconds, self._microseconds)"
        ],
        [
            "STORE_NAME",
            "    def __reduce__(self):\n        return (self.__class__, self._getstate())"
        ],
        [
            "STORE_FAST",
            "d"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "STORE_FAST",
            "us"
        ],
        [
            "LOAD_FAST",
            "days"
        ],
        [
            "LOAD_FAST",
            "weeks"
        ],
        [
            "BINARY_OP",
            "weeks*7"
        ],
        [
            "BINARY_OP",
            "days += weeks*7"
        ],
        [
            "STORE_FAST",
            "days"
        ],
        [
            "LOAD_FAST",
            "seconds"
        ],
        [
            "LOAD_FAST",
            "minutes"
        ],
        [
            "BINARY_OP",
            "minutes*60"
        ],
        [
            "LOAD_FAST",
            "hours"
        ],
        [
            "BINARY_OP",
            "hours*3600"
        ],
        [
            "BINARY_OP",
            "minutes*60 + hours*3600"
        ],
        [
            "BINARY_OP",
            "seconds += minutes*60 + hours*3600"
        ],
        [
            "STORE_FAST",
            "seconds"
        ],
        [
            "LOAD_FAST",
            "microseconds"
        ],
        [
            "LOAD_FAST",
            "milliseconds"
        ],
        [
            "BINARY_OP",
            "milliseconds*1000"
        ],
        [
            "BINARY_OP",
            "microseconds += milliseconds*1000"
        ],
        [
            "STORE_FAST",
            "microseconds"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "days"
        ],
        [
            "LOAD_GLOBAL",
            "float"
        ],
        [
            "CALL",
            "isinstance(days, float)"
        ],
        [
            "LOAD_GLOBAL",
            "_math"
        ],
        [
            "LOAD_ATTR",
            "_math.modf"
        ],
        [
            "LOAD_FAST",
            "days"
        ],
        [
            "CALL",
            "_math.modf(days)"
        ],
        [
            "STORE_FAST",
            "dayfrac"
        ],
        [
            "STORE_FAST",
            "days"
        ],
        [
            "LOAD_GLOBAL",
            "_math"
        ],
        [
            "LOAD_ATTR",
            "_math.modf"
        ],
        [
            "LOAD_FAST",
            "dayfrac"
        ],
        [
            "BINARY_OP",
            "dayfrac * (24.*3600.)"
        ],
        [
            "CALL",
            "_math.modf(dayfrac * (24.*3600.))"
        ],
        [
            "STORE_FAST",
            "daysecondsfrac"
        ],
        [
            "STORE_FAST",
            "daysecondswhole"
        ],
        [
            "LOAD_FAST",
            "daysecondswhole"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "LOAD_FAST",
            "daysecondswhole"
        ],
        [
            "CALL",
            "int(daysecondswhole)"
        ],
        [
            "COMPARE_OP",
            "daysecondswhole == int(daysecondswhole)"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "LOAD_FAST",
            "daysecondswhole"
        ],
        [
            "CALL",
            "int(daysecondswhole)"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "days"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "LOAD_FAST",
            "days"
        ],
        [
            "CALL",
            "int(days)"
        ],
        [
            "COMPARE_OP",
            "days == int(days)"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "LOAD_FAST",
            "days"
        ],
        [
            "CALL",
            "int(days)"
        ],
        [
            "STORE_FAST",
            "d"
        ],
        [
            "STORE_FAST",
            "daysecondsfrac"
        ],
        [
            "LOAD_FAST",
            "days"
        ],
        [
            "STORE_FAST",
            "d"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "daysecondsfrac"
        ],
        [
            "LOAD_GLOBAL",
            "float"
        ],
        [
            "CALL",
            "isinstance(daysecondsfrac, float)"
        ],
        [
            "LOAD_GLOBAL",
            "abs"
        ],
        [
            "LOAD_FAST",
            "daysecondsfrac"
        ],
        [
            "CALL",
            "abs(daysecondsfrac)"
        ],
        [
            "COMPARE_OP",
            "abs(daysecondsfrac) <= 1.0"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "CALL",
            "isinstance(d, int)"
        ],
        [
            "LOAD_GLOBAL",
            "abs"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "CALL",
            "abs(s)"
        ],
        [
            "COMPARE_OP",
            "abs(s) <= 24 * 3600"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "seconds"
        ],
        [
            "LOAD_GLOBAL",
            "float"
        ],
        [
            "CALL",
            "isinstance(seconds, float)"
        ],
        [
            "LOAD_GLOBAL",
            "_math"
        ],
        [
            "LOAD_ATTR",
            "_math.modf"
        ],
        [
            "LOAD_FAST",
            "seconds"
        ],
        [
            "CALL",
            "_math.modf(seconds)"
        ],
        [
            "STORE_FAST",
            "secondsfrac"
        ],
        [
            "STORE_FAST",
            "seconds"
        ],
        [
            "LOAD_FAST",
            "seconds"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "LOAD_FAST",
            "seconds"
        ],
        [
            "CALL",
            "int(seconds)"
        ],
        [
            "COMPARE_OP",
            "seconds == int(seconds)"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "LOAD_FAST",
            "seconds"
        ],
        [
            "CALL",
            "int(seconds)"
        ],
        [
            "STORE_FAST",
            "seconds"
        ],
        [
            "LOAD_FAST",
            "secondsfrac"
        ],
        [
            "LOAD_FAST",
            "daysecondsfrac"
        ],
        [
            "BINARY_OP",
            "secondsfrac += daysecondsfrac"
        ],
        [
            "STORE_FAST",
            "secondsfrac"
        ],
        [
            "LOAD_GLOBAL",
            "abs"
        ],
        [
            "LOAD_FAST",
            "secondsfrac"
        ],
        [
            "CALL",
            "abs(secondsfrac)"
        ],
        [
            "COMPARE_OP",
            "abs(secondsfrac) <= 2.0"
        ],
        [
            "LOAD_FAST",
            "daysecondsfrac"
        ],
        [
            "STORE_FAST",
            "secondsfrac"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "secondsfrac"
        ],
        [
            "LOAD_GLOBAL",
            "float"
        ],
        [
            "CALL",
            "isinstance(secondsfrac, float)"
        ],
        [
            "LOAD_GLOBAL",
            "abs"
        ],
        [
            "LOAD_FAST",
            "secondsfrac"
        ],
        [
            "CALL",
            "abs(secondsfrac)"
        ],
        [
            "COMPARE_OP",
            "abs(secondsfrac) <= 2.0"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "seconds"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "CALL",
            "isinstance(seconds, int)"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "seconds"
        ],
        [
            "CALL",
            "divmod(seconds, 24*3600)"
        ],
        [
            "STORE_FAST",
            "days"
        ],
        [
            "STORE_FAST",
            "seconds"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "LOAD_FAST",
            "days"
        ],
        [
            "BINARY_OP",
            "d += days"
        ],
        [
            "STORE_FAST",
            "d"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "LOAD_FAST",
            "seconds"
        ],
        [
            "CALL",
            "int(seconds)"
        ],
        [
            "BINARY_OP",
            "s += int(seconds)"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "CALL",
            "isinstance(s, int)"
        ],
        [
            "LOAD_GLOBAL",
            "abs"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "CALL",
            "abs(s)"
        ],
        [
            "COMPARE_OP",
            "abs(s) <= 2 * 24 * 3600"
        ],
        [
            "LOAD_FAST",
            "secondsfrac"
        ],
        [
            "BINARY_OP",
            "secondsfrac * 1e6"
        ],
        [
            "STORE_FAST",
            "usdouble"
        ],
        [
            "LOAD_GLOBAL",
            "abs"
        ],
        [
            "LOAD_FAST",
            "usdouble"
        ],
        [
            "CALL",
            "abs(usdouble)"
        ],
        [
            "COMPARE_OP",
            "abs(usdouble) < 2.1e6"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "microseconds"
        ],
        [
            "LOAD_GLOBAL",
            "float"
        ],
        [
            "CALL",
            "isinstance(microseconds, float)"
        ],
        [
            "LOAD_GLOBAL",
            "round"
        ],
        [
            "LOAD_FAST",
            "microseconds"
        ],
        [
            "LOAD_FAST",
            "usdouble"
        ],
        [
            "BINARY_OP",
            "microseconds + usdouble"
        ],
        [
            "CALL",
            "round(microseconds + usdouble)"
        ],
        [
            "STORE_FAST",
            "microseconds"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "microseconds"
        ],
        [
            "CALL",
            "divmod(microseconds, 1000000)"
        ],
        [
            "STORE_FAST",
            "seconds"
        ],
        [
            "STORE_FAST",
            "microseconds"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "seconds"
        ],
        [
            "CALL",
            "divmod(seconds, 24*3600)"
        ],
        [
            "STORE_FAST",
            "days"
        ],
        [
            "STORE_FAST",
            "seconds"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "LOAD_FAST",
            "days"
        ],
        [
            "BINARY_OP",
            "d += days"
        ],
        [
            "STORE_FAST",
            "d"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "seconds"
        ],
        [
            "BINARY_OP",
            "s += seconds"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "LOAD_FAST",
            "microseconds"
        ],
        [
            "CALL",
            "int(microseconds)"
        ],
        [
            "STORE_FAST",
            "microseconds"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "microseconds"
        ],
        [
            "CALL",
            "divmod(microseconds, 1000000)"
        ],
        [
            "STORE_FAST",
            "seconds"
        ],
        [
            "STORE_FAST",
            "microseconds"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "seconds"
        ],
        [
            "CALL",
            "divmod(seconds, 24*3600)"
        ],
        [
            "STORE_FAST",
            "days"
        ],
        [
            "STORE_FAST",
            "seconds"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "LOAD_FAST",
            "days"
        ],
        [
            "BINARY_OP",
            "d += days"
        ],
        [
            "STORE_FAST",
            "d"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "seconds"
        ],
        [
            "BINARY_OP",
            "s += seconds"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_GLOBAL",
            "round"
        ],
        [
            "LOAD_FAST",
            "microseconds"
        ],
        [
            "LOAD_FAST",
            "usdouble"
        ],
        [
            "BINARY_OP",
            "microseconds + usdouble"
        ],
        [
            "CALL",
            "round(microseconds + usdouble)"
        ],
        [
            "STORE_FAST",
            "microseconds"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "CALL",
            "isinstance(s, int)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "microseconds"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "CALL",
            "isinstance(microseconds, int)"
        ],
        [
            "LOAD_GLOBAL",
            "abs"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "CALL",
            "abs(s)"
        ],
        [
            "COMPARE_OP",
            "abs(s) <= 3 * 24 * 3600"
        ],
        [
            "LOAD_GLOBAL",
            "abs"
        ],
        [
            "LOAD_FAST",
            "microseconds"
        ],
        [
            "CALL",
            "abs(microseconds)"
        ],
        [
            "COMPARE_OP",
            "abs(microseconds) < 3.1e6"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "microseconds"
        ],
        [
            "CALL",
            "divmod(microseconds, 1000000)"
        ],
        [
            "STORE_FAST",
            "seconds"
        ],
        [
            "STORE_FAST",
            "us"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "seconds"
        ],
        [
            "BINARY_OP",
            "s += seconds"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "CALL",
            "divmod(s, 24*3600)"
        ],
        [
            "STORE_FAST",
            "days"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "LOAD_FAST",
            "days"
        ],
        [
            "BINARY_OP",
            "d += days"
        ],
        [
            "STORE_FAST",
            "d"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "CALL",
            "isinstance(d, int)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "CALL",
            "isinstance(s, int)"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "COMPARE_OP",
            "0 <= s < 24*3600"
        ],
        [
            "COMPARE_OP",
            "0 <= s < 24*3600"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "us"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "CALL",
            "isinstance(us, int)"
        ],
        [
            "LOAD_FAST",
            "us"
        ],
        [
            "COMPARE_OP",
            "0 <= us < 1000000"
        ],
        [
            "COMPARE_OP",
            "0 <= us < 1000000"
        ],
        [
            "LOAD_GLOBAL",
            "abs"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "CALL",
            "abs(d)"
        ],
        [
            "COMPARE_OP",
            "abs(d) > 999999999"
        ],
        [
            "LOAD_GLOBAL",
            "OverflowError"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "BINARY_OP",
            "\"timedelta # of days is too large: %d\" % d"
        ],
        [
            "CALL",
            "OverflowError(\"timedelta # of days is too large: %d\" % d)"
        ],
        [
            "LOAD_GLOBAL",
            "object"
        ],
        [
            "LOAD_METHOD",
            "object.__new__"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "CALL",
            "object.__new__(cls)"
        ],
        [
            "STORE_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._days"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._seconds"
        ],
        [
            "LOAD_FAST",
            "us"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._microseconds"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._hashcode"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_FAST",
            "args"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._days"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_METHOD",
            "args.append"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._days"
        ],
        [
            "BINARY_OP",
            "\"days=%d\" % self._days"
        ],
        [
            "CALL",
            "args.append(\"days=%d\" % self._days)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._seconds"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_METHOD",
            "args.append"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._seconds"
        ],
        [
            "BINARY_OP",
            "\"seconds=%d\" % self._seconds"
        ],
        [
            "CALL",
            "args.append(\"seconds=%d\" % self._seconds)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._microseconds"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_METHOD",
            "args.append"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._microseconds"
        ],
        [
            "BINARY_OP",
            "\"microseconds=%d\" % self._microseconds"
        ],
        [
            "CALL",
            "args.append(\"microseconds=%d\" % self._microseconds)"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_METHOD",
            "args.append"
        ],
        [
            "CALL",
            "args.append('0')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.__class__"
        ],
        [
            "LOAD_ATTR",
            "self.__class__.__module__"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.__class__"
        ],
        [
            "LOAD_ATTR",
            "self.__class__.__qualname__"
        ],
        [
            "LOAD_METHOD",
            "', '.join"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "CALL",
            "', '.join(args)"
        ],
        [
            "BUILD_STRING",
            "\"%s.%s(%s)\" % (self.__class__.__module__,\n                              self.__class__.__qualname__,\n                              ', '.join(args))"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._seconds"
        ],
        [
            "CALL",
            "divmod(self._seconds, 60)"
        ],
        [
            "STORE_FAST",
            "mm"
        ],
        [
            "STORE_FAST",
            "ss"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "mm"
        ],
        [
            "CALL",
            "divmod(mm, 60)"
        ],
        [
            "STORE_FAST",
            "hh"
        ],
        [
            "STORE_FAST",
            "mm"
        ],
        [
            "LOAD_FAST",
            "hh"
        ],
        [
            "LOAD_FAST",
            "mm"
        ],
        [
            "LOAD_FAST",
            "ss"
        ],
        [
            "BINARY_OP",
            "\"%d:%02d:%02d\" % (hh, mm, ss)"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._days"
        ],
        [
            "STORE_FAST",
            "            def plural(n):\n                return n, abs(n) != 1 and \"s\" or \"\""
        ],
        [
            "LOAD_FAST",
            "plural"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._days"
        ],
        [
            "CALL",
            "plural(self._days)"
        ],
        [
            "BINARY_OP",
            "\"%d day%s, \" % plural(self._days)"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "BINARY_OP",
            "(\"%d day%s, \" % plural(self._days)) + s"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._microseconds"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._microseconds"
        ],
        [
            "BINARY_OP",
            "\".%06d\" % self._microseconds"
        ],
        [
            "BINARY_OP",
            "s + \".%06d\" % self._microseconds"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "LOAD_GLOBAL",
            "abs"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "CALL",
            "abs(n)"
        ],
        [
            "COMPARE_OP",
            "abs(n) != 1"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.days"
        ],
        [
            "BINARY_OP",
            "self.days * 86400"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.seconds"
        ],
        [
            "BINARY_OP",
            "self.days * 86400 + self.seconds"
        ],
        [
            "BINARY_OP",
            "(self.days * 86400 + self.seconds) * 10**6"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.microseconds"
        ],
        [
            "BINARY_OP",
            "(self.days * 86400 + self.seconds) * 10**6 +\n                self.microseconds"
        ],
        [
            "BINARY_OP",
            "((self.days * 86400 + self.seconds) * 10**6 +\n                self.microseconds) / 10**6"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._days"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._seconds"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._microseconds"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "isinstance(other, timedelta)"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._days"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._days"
        ],
        [
            "BINARY_OP",
            "self._days + other._days"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._seconds"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._seconds"
        ],
        [
            "BINARY_OP",
            "self._seconds + other._seconds"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._microseconds"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._microseconds"
        ],
        [
            "BINARY_OP",
            "self._microseconds + other._microseconds"
        ],
        [
            "CALL",
            "timedelta(self._days + other._days,\n                             self._seconds + other._seconds,\n                             self._microseconds + other._microseconds)"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "isinstance(other, timedelta)"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._days"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._days"
        ],
        [
            "BINARY_OP",
            "self._days - other._days"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._seconds"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._seconds"
        ],
        [
            "BINARY_OP",
            "self._seconds - other._seconds"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._microseconds"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._microseconds"
        ],
        [
            "BINARY_OP",
            "self._microseconds - other._microseconds"
        ],
        [
            "CALL",
            "timedelta(self._days - other._days,\n                             self._seconds - other._seconds,\n                             self._microseconds - other._microseconds)"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "isinstance(other, timedelta)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "UNARY_NEGATIVE",
            "-self"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "BINARY_OP",
            "-self + other"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._days"
        ],
        [
            "UNARY_NEGATIVE",
            "-self._days"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._seconds"
        ],
        [
            "UNARY_NEGATIVE",
            "-self._seconds"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._microseconds"
        ],
        [
            "UNARY_NEGATIVE",
            "-self._microseconds"
        ],
        [
            "CALL",
            "timedelta(-self._days,\n                         -self._seconds,\n                         -self._microseconds)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._days"
        ],
        [
            "COMPARE_OP",
            "self._days < 0"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "UNARY_NEGATIVE",
            "-self"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "CALL",
            "isinstance(other, int)"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._days"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "BINARY_OP",
            "self._days * other"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._seconds"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "BINARY_OP",
            "self._seconds * other"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._microseconds"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "BINARY_OP",
            "self._microseconds * other"
        ],
        [
            "CALL",
            "timedelta(self._days * other,\n                             self._seconds * other,\n                             self._microseconds * other)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "float"
        ],
        [
            "CALL",
            "isinstance(other, float)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._to_microseconds"
        ],
        [
            "CALL",
            "self._to_microseconds()"
        ],
        [
            "STORE_FAST",
            "usec"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_METHOD",
            "other.as_integer_ratio"
        ],
        [
            "CALL",
            "other.as_integer_ratio()"
        ],
        [
            "STORE_FAST",
            "a"
        ],
        [
            "STORE_FAST",
            "b"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "LOAD_GLOBAL",
            "_divide_and_round"
        ],
        [
            "LOAD_FAST",
            "usec"
        ],
        [
            "LOAD_FAST",
            "a"
        ],
        [
            "BINARY_OP",
            "usec * a"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "CALL",
            "_divide_and_round(usec * a, b)"
        ],
        [
            "CALL",
            "timedelta(0, 0, _divide_and_round(usec * a, b))"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._days"
        ],
        [
            "BINARY_OP",
            "self._days * (24*3600)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._seconds"
        ],
        [
            "BINARY_OP",
            "self._days * (24*3600) + self._seconds"
        ],
        [
            "BINARY_OP",
            "(self._days * (24*3600) + self._seconds) * 1000000"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._microseconds"
        ],
        [
            "BINARY_OP",
            "(self._days * (24*3600) + self._seconds) * 1000000 +\n                self._microseconds"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "isinstance(other, (int, timedelta))"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._to_microseconds"
        ],
        [
            "CALL",
            "self._to_microseconds()"
        ],
        [
            "STORE_FAST",
            "usec"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "isinstance(other, timedelta)"
        ],
        [
            "LOAD_FAST",
            "usec"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_METHOD",
            "other._to_microseconds"
        ],
        [
            "CALL",
            "other._to_microseconds()"
        ],
        [
            "BINARY_OP",
            "usec // other._to_microseconds()"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "CALL",
            "isinstance(other, int)"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "LOAD_FAST",
            "usec"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "BINARY_OP",
            "usec // other"
        ],
        [
            "CALL",
            "timedelta(0, 0, usec // other)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "LOAD_GLOBAL",
            "float"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "isinstance(other, (int, float, timedelta))"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._to_microseconds"
        ],
        [
            "CALL",
            "self._to_microseconds()"
        ],
        [
            "STORE_FAST",
            "usec"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "isinstance(other, timedelta)"
        ],
        [
            "LOAD_FAST",
            "usec"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_METHOD",
            "other._to_microseconds"
        ],
        [
            "CALL",
            "other._to_microseconds()"
        ],
        [
            "BINARY_OP",
            "usec / other._to_microseconds()"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "CALL",
            "isinstance(other, int)"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "LOAD_GLOBAL",
            "_divide_and_round"
        ],
        [
            "LOAD_FAST",
            "usec"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "CALL",
            "_divide_and_round(usec, other)"
        ],
        [
            "CALL",
            "timedelta(0, 0, _divide_and_round(usec, other))"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "float"
        ],
        [
            "CALL",
            "isinstance(other, float)"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_METHOD",
            "other.as_integer_ratio"
        ],
        [
            "CALL",
            "other.as_integer_ratio()"
        ],
        [
            "STORE_FAST",
            "a"
        ],
        [
            "STORE_FAST",
            "b"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "LOAD_GLOBAL",
            "_divide_and_round"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "LOAD_FAST",
            "usec"
        ],
        [
            "BINARY_OP",
            "b * usec"
        ],
        [
            "LOAD_FAST",
            "a"
        ],
        [
            "CALL",
            "_divide_and_round(b * usec, a)"
        ],
        [
            "CALL",
            "timedelta(0, 0, _divide_and_round(b * usec, a))"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "isinstance(other, timedelta)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._to_microseconds"
        ],
        [
            "CALL",
            "self._to_microseconds()"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_METHOD",
            "other._to_microseconds"
        ],
        [
            "CALL",
            "other._to_microseconds()"
        ],
        [
            "BINARY_OP",
            "self._to_microseconds() % other._to_microseconds()"
        ],
        [
            "STORE_FAST",
            "r"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "LOAD_FAST",
            "r"
        ],
        [
            "CALL",
            "timedelta(0, 0, r)"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "isinstance(other, timedelta)"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._to_microseconds"
        ],
        [
            "CALL",
            "self._to_microseconds()"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_METHOD",
            "other._to_microseconds"
        ],
        [
            "CALL",
            "other._to_microseconds()"
        ],
        [
            "CALL",
            "divmod(self._to_microseconds(),\n                          other._to_microseconds())"
        ],
        [
            "STORE_FAST",
            "q"
        ],
        [
            "STORE_FAST",
            "r"
        ],
        [
            "LOAD_FAST",
            "q"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "LOAD_FAST",
            "r"
        ],
        [
            "CALL",
            "timedelta(0, 0, r)"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "isinstance(other, timedelta)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._cmp"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "CALL",
            "self._cmp(other)"
        ],
        [
            "COMPARE_OP",
            "self._cmp(other) == 0"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "isinstance(other, timedelta)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._cmp"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "CALL",
            "self._cmp(other)"
        ],
        [
            "COMPARE_OP",
            "self._cmp(other) <= 0"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "isinstance(other, timedelta)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._cmp"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "CALL",
            "self._cmp(other)"
        ],
        [
            "COMPARE_OP",
            "self._cmp(other) < 0"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "isinstance(other, timedelta)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._cmp"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "CALL",
            "self._cmp(other)"
        ],
        [
            "COMPARE_OP",
            "self._cmp(other) >= 0"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "isinstance(other, timedelta)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._cmp"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "CALL",
            "self._cmp(other)"
        ],
        [
            "COMPARE_OP",
            "self._cmp(other) > 0"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "isinstance(other, timedelta)"
        ],
        [
            "LOAD_GLOBAL",
            "_cmp"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._getstate"
        ],
        [
            "CALL",
            "self._getstate()"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_METHOD",
            "other._getstate"
        ],
        [
            "CALL",
            "other._getstate()"
        ],
        [
            "CALL",
            "_cmp(self._getstate(), other._getstate())"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._hashcode"
        ],
        [
            "COMPARE_OP",
            "self._hashcode == -1"
        ],
        [
            "LOAD_GLOBAL",
            "hash"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._getstate"
        ],
        [
            "CALL",
            "self._getstate()"
        ],
        [
            "CALL",
            "hash(self._getstate())"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._hashcode"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._hashcode"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._days"
        ],
        [
            "COMPARE_OP",
            "self._days != 0"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._seconds"
        ],
        [
            "COMPARE_OP",
            "self._seconds != 0"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._microseconds"
        ],
        [
            "COMPARE_OP",
            "self._microseconds != 0"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._days"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._seconds"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._microseconds"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.__class__"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._getstate"
        ],
        [
            "CALL",
            "self._getstate()"
        ],
        [
            "STORE_NAME",
            "\"\"\"Concrete date type.\n\n    Constructors:\n\n    __new__()\n    fromtimestamp()\n    today()\n    fromordinal()\n\n    Operators:\n\n    __repr__, __str__\n    __eq__, __le__, __lt__, __ge__, __gt__, __hash__\n    __add__, __radd__, __sub__ (add/radd only with timedelta arg)\n\n    Methods:\n\n    timetuple()\n    toordinal()\n    weekday()\n    isoweekday(), isocalendar(), isoformat()\n    ctime()\n    strftime()\n\n    Properties (readonly):\n    year, month, day\n    \"\"\""
        ],
        [
            "STORE_NAME",
            "__slots__"
        ],
        [
            "STORE_NAME",
            "    def __new__(cls, year, month=None, day=None):\n        \"\"\"Constructor.\n\n        Arguments:\n\n        year, month, day (required, base 1)\n        \"\"\"\n        if (month is None and\n            isinstance(year, (bytes, str)) and len(year) == 4 and\n            1 <= ord(year[2:3]) <= 12):\n            # Pickle support\n            if isinstance(year, str):\n                try:\n                    year = year.encode('latin1')\n                except UnicodeEncodeError:\n                    # More informative error message.\n                    raise ValueError(\n                        \"Failed to encode latin1 string when unpickling \"\n                        \"a date object. \"\n                        \"pickle.load(data, encoding='latin1') is assumed.\")\n            self = object.__new__(cls)\n            self.__setstate(year)\n            self._hashcode = -1\n            return self\n        year, month, day = _check_date_fields(year, month, day)\n        self = object.__new__(cls)\n        self._year = year\n        self._month = month\n        self._day = day\n        self._hashcode = -1\n        return self"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def fromtimestamp(cls, t):\n        \"Construct a date from a POSIX timestamp (like time.time()).\"\n        y, m, d, hh, mm, ss, weekday, jday, dst = _time.localtime(t)\n        return cls(y, m, d)"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def today(cls):\n        \"Construct a date from time.time().\"\n        t = _time.time()\n        return cls.fromtimestamp(t)"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def fromordinal(cls, n):\n        \"\"\"Construct a date from a proleptic Gregorian ordinal.\n\n        January 1 of year 1 is day 1.  Only the year, month and day are\n        non-zero in the result.\n        \"\"\"\n        y, m, d = _ord2ymd(n)\n        return cls(y, m, d)"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def fromisoformat(cls, date_string):\n        \"\"\"Construct a date from a string in ISO 8601 format.\"\"\"\n        if not isinstance(date_string, str):\n            raise TypeError('fromisoformat: argument must be str')\n\n        if len(date_string) not in (7, 8, 10):\n            raise ValueError(f'Invalid isoformat string: {date_string!r}')\n\n        try:\n            return cls(*_parse_isoformat_date(date_string))\n        except Exception:\n            raise ValueError(f'Invalid isoformat string: {date_string!r}')"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def fromisocalendar(cls, year, week, day):\n        \"\"\"Construct a date from the ISO year, week number and weekday.\n\n        This is the inverse of the date.isocalendar() function\"\"\"\n        return cls(*_isoweek_to_gregorian(year, week, day))"
        ],
        [
            "STORE_NAME",
            "    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\n\n        >>> dt = datetime(2010, 1, 1)\n        >>> repr(dt)\n        'datetime.datetime(2010, 1, 1, 0, 0)'\n\n        >>> dt = datetime(2010, 1, 1, tzinfo=timezone.utc)\n        >>> repr(dt)\n        'datetime.datetime(2010, 1, 1, 0, 0, tzinfo=datetime.timezone.utc)'\n        \"\"\"\n        return \"%s.%s(%d, %d, %d)\" % (self.__class__.__module__,\n                                      self.__class__.__qualname__,\n                                      self._year,\n                                      self._month,\n                                      self._day)"
        ],
        [
            "STORE_NAME",
            "    def ctime(self):\n        \"Return ctime() style string.\"\n        weekday = self.toordinal() % 7 or 7\n        return \"%s %s %2d 00:00:00 %04d\" % (\n            _DAYNAMES[weekday],\n            _MONTHNAMES[self._month],\n            self._day, self._year)"
        ],
        [
            "STORE_NAME",
            "    def strftime(self, fmt):\n        \"Format using strftime().\"\n        return _wrap_strftime(self, fmt, self.timetuple())"
        ],
        [
            "STORE_NAME",
            "    def __format__(self, fmt):\n        if not isinstance(fmt, str):\n            raise TypeError(\"must be str, not %s\" % type(fmt).__name__)\n        if len(fmt) != 0:\n            return self.strftime(fmt)\n        return str(self)"
        ],
        [
            "STORE_NAME",
            "    def isoformat(self):\n        \"\"\"Return the date formatted according to ISO.\n\n        This is 'YYYY-MM-DD'.\n\n        References:\n        - http://www.w3.org/TR/NOTE-datetime\n        - http://www.cl.cam.ac.uk/~mgk25/iso-time.html\n        \"\"\"\n        return \"%04d-%02d-%02d\" % (self._year, self._month, self._day)"
        ],
        [
            "LOAD_NAME",
            "isoformat"
        ],
        [
            "STORE_NAME",
            "__str__"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "    @property\n    def year(self):\n        \"\"\"year (1-9999)\"\"\"\n        return self._year"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "    @property\n    def month(self):\n        \"\"\"month (1-12)\"\"\"\n        return self._month"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "    @property\n    def day(self):\n        \"\"\"day (1-31)\"\"\"\n        return self._day"
        ],
        [
            "STORE_NAME",
            "    def timetuple(self):\n        \"Return local time tuple compatible with time.localtime().\"\n        return _build_struct_time(self._year, self._month, self._day,\n                                  0, 0, 0, -1)"
        ],
        [
            "STORE_NAME",
            "    def toordinal(self):\n        \"\"\"Return proleptic Gregorian ordinal for the year, month and day.\n\n        January 1 of year 1 is day 1.  Only the year, month and day values\n        contribute to the result.\n        \"\"\"\n        return _ymd2ord(self._year, self._month, self._day)"
        ],
        [
            "STORE_NAME",
            "    def replace(self, year=None, month=None, day=None):\n        \"\"\"Return a new date with new values for the specified fields.\"\"\"\n        if year is None:\n            year = self._year\n        if month is None:\n            month = self._month\n        if day is None:\n            day = self._day\n        return type(self)(year, month, day)"
        ],
        [
            "STORE_NAME",
            "    def __eq__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) == 0\n        return NotImplemented"
        ],
        [
            "STORE_NAME",
            "    def __le__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) <= 0\n        return NotImplemented"
        ],
        [
            "STORE_NAME",
            "    def __lt__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) < 0\n        return NotImplemented"
        ],
        [
            "STORE_NAME",
            "    def __ge__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) >= 0\n        return NotImplemented"
        ],
        [
            "STORE_NAME",
            "    def __gt__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) > 0\n        return NotImplemented"
        ],
        [
            "STORE_NAME",
            "    def _cmp(self, other):\n        assert isinstance(other, date)\n        y, m, d = self._year, self._month, self._day\n        y2, m2, d2 = other._year, other._month, other._day\n        return _cmp((y, m, d), (y2, m2, d2))"
        ],
        [
            "STORE_NAME",
            "    def __hash__(self):\n        \"Hash.\"\n        if self._hashcode == -1:\n            self._hashcode = hash(self._getstate())\n        return self._hashcode"
        ],
        [
            "STORE_NAME",
            "    def __add__(self, other):\n        \"Add a date to a timedelta.\"\n        if isinstance(other, timedelta):\n            o = self.toordinal() + other.days\n            if 0 < o <= _MAXORDINAL:\n                return type(self).fromordinal(o)\n            raise OverflowError(\"result out of range\")\n        return NotImplemented"
        ],
        [
            "LOAD_NAME",
            "__add__"
        ],
        [
            "STORE_NAME",
            "__radd__"
        ],
        [
            "STORE_NAME",
            "    def __sub__(self, other):\n        \"\"\"Subtract two dates, or a date and a timedelta.\"\"\"\n        if isinstance(other, timedelta):\n            return self + timedelta(-other.days)\n        if isinstance(other, date):\n            days1 = self.toordinal()\n            days2 = other.toordinal()\n            return timedelta(days1 - days2)\n        return NotImplemented"
        ],
        [
            "STORE_NAME",
            "    def weekday(self):\n        \"Return day of the week, where Monday == 0 ... Sunday == 6.\"\n        return (self.toordinal() + 6) % 7"
        ],
        [
            "STORE_NAME",
            "    def isoweekday(self):\n        \"Return day of the week, where Monday == 1 ... Sunday == 7.\"\n        # 1-Jan-0001 is a Monday\n        return self.toordinal() % 7 or 7"
        ],
        [
            "STORE_NAME",
            "    def isocalendar(self):\n        \"\"\"Return a named tuple containing ISO year, week number, and weekday.\n\n        The first ISO week of the year is the (Mon-Sun) week\n        containing the year's first Thursday; everything else derives\n        from that.\n\n        The first week is 1; Monday is 1 ... Sunday is 7.\n\n        ISO calendar algorithm taken from\n        http://www.phys.uu.nl/~vgent/calendar/isocalendar.htm\n        (used with permission)\n        \"\"\"\n        year = self._year\n        week1monday = _isoweek1monday(year)\n        today = _ymd2ord(self._year, self._month, self._day)\n        # Internally, week and day have origin 0\n        week, day = divmod(today - week1monday, 7)\n        if week < 0:\n            year -= 1\n            week1monday = _isoweek1monday(year)\n            week, day = divmod(today - week1monday, 7)\n        elif week >= 52:\n            if today >= _isoweek1monday(year+1):\n                year += 1\n                week = 0\n        return _IsoCalendarDate(year, week+1, day+1)"
        ],
        [
            "STORE_NAME",
            "    def _getstate(self):\n        yhi, ylo = divmod(self._year, 256)\n        return bytes([yhi, ylo, self._month, self._day]),"
        ],
        [
            "STORE_NAME",
            "    def __setstate(self, string):\n        yhi, ylo, self._month, self._day = string\n        self._year = yhi * 256 + ylo"
        ],
        [
            "STORE_NAME",
            "    def __reduce__(self):\n        return (self.__class__, self._getstate())"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "LOAD_GLOBAL",
            "bytes"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "CALL",
            "isinstance(year, (bytes, str))"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "CALL",
            "len(year)"
        ],
        [
            "COMPARE_OP",
            "len(year) == 4"
        ],
        [
            "LOAD_GLOBAL",
            "ord"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "BINARY_SUBSCR",
            "year[2:3]"
        ],
        [
            "CALL",
            "ord(year[2:3])"
        ],
        [
            "COMPARE_OP",
            "1 <= ord(year[2:3]) <= 12"
        ],
        [
            "COMPARE_OP",
            "1 <= ord(year[2:3]) <= 12"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "CALL",
            "isinstance(year, str)"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "LOAD_METHOD",
            "year.encode"
        ],
        [
            "CALL",
            "year.encode('latin1')"
        ],
        [
            "STORE_FAST",
            "year"
        ],
        [
            "LOAD_GLOBAL",
            "UnicodeEncodeError"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError(\n                        \"Failed to encode latin1 string when unpickling \"\n                        \"a date object. \"\n                        \"pickle.load(data, encoding='latin1') is assumed.\")"
        ],
        [
            "LOAD_GLOBAL",
            "object"
        ],
        [
            "LOAD_METHOD",
            "object.__new__"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "CALL",
            "object.__new__(cls)"
        ],
        [
            "STORE_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.__setstate"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "CALL",
            "self.__setstate(year)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._hashcode"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_GLOBAL",
            "_check_date_fields"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "LOAD_FAST",
            "day"
        ],
        [
            "CALL",
            "_check_date_fields(year, month, day)"
        ],
        [
            "STORE_FAST",
            "year"
        ],
        [
            "STORE_FAST",
            "month"
        ],
        [
            "STORE_FAST",
            "day"
        ],
        [
            "LOAD_GLOBAL",
            "object"
        ],
        [
            "LOAD_METHOD",
            "object.__new__"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "CALL",
            "object.__new__(cls)"
        ],
        [
            "STORE_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._year"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._month"
        ],
        [
            "LOAD_FAST",
            "day"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._day"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._hashcode"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_GLOBAL",
            "_time"
        ],
        [
            "LOAD_ATTR",
            "_time.localtime"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "CALL",
            "_time.localtime(t)"
        ],
        [
            "STORE_FAST",
            "y"
        ],
        [
            "STORE_FAST",
            "m"
        ],
        [
            "STORE_FAST",
            "d"
        ],
        [
            "STORE_FAST",
            "hh"
        ],
        [
            "STORE_FAST",
            "mm"
        ],
        [
            "STORE_FAST",
            "ss"
        ],
        [
            "STORE_FAST",
            "weekday"
        ],
        [
            "STORE_FAST",
            "jday"
        ],
        [
            "STORE_FAST",
            "dst"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_FAST",
            "y"
        ],
        [
            "LOAD_FAST",
            "m"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "CALL",
            "cls(y, m, d)"
        ],
        [
            "LOAD_GLOBAL",
            "_time"
        ],
        [
            "LOAD_ATTR",
            "_time.time"
        ],
        [
            "CALL",
            "_time.time()"
        ],
        [
            "STORE_FAST",
            "t"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_METHOD",
            "cls.fromtimestamp"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "CALL",
            "cls.fromtimestamp(t)"
        ],
        [
            "LOAD_GLOBAL",
            "_ord2ymd"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "CALL",
            "_ord2ymd(n)"
        ],
        [
            "STORE_FAST",
            "y"
        ],
        [
            "STORE_FAST",
            "m"
        ],
        [
            "STORE_FAST",
            "d"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_FAST",
            "y"
        ],
        [
            "LOAD_FAST",
            "m"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "CALL",
            "cls(y, m, d)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "date_string"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "CALL",
            "isinstance(date_string, str)"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "CALL",
            "TypeError('fromisoformat: argument must be str')"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "date_string"
        ],
        [
            "CALL",
            "len(date_string)"
        ],
        [
            "CONTAINS_OP",
            "len(date_string) not in (7, 8, 10)"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "CALL",
            "ValueError(f'Invalid isoformat string: {date_string!r}')"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_GLOBAL",
            "_parse_isoformat_date"
        ],
        [
            "LOAD_FAST",
            "date_string"
        ],
        [
            "CALL",
            "_parse_isoformat_date(date_string)"
        ],
        [
            "CALL_FUNCTION_EX",
            "cls(*_parse_isoformat_date(date_string))"
        ],
        [
            "LOAD_GLOBAL",
            "Exception"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "CALL",
            "ValueError(f'Invalid isoformat string: {date_string!r}')"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_GLOBAL",
            "_isoweek_to_gregorian"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "LOAD_FAST",
            "week"
        ],
        [
            "LOAD_FAST",
            "day"
        ],
        [
            "CALL",
            "_isoweek_to_gregorian(year, week, day)"
        ],
        [
            "CALL_FUNCTION_EX",
            "cls(*_isoweek_to_gregorian(year, week, day))"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.__class__"
        ],
        [
            "LOAD_ATTR",
            "self.__class__.__module__"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.__class__"
        ],
        [
            "LOAD_ATTR",
            "self.__class__.__qualname__"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._year"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._month"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._day"
        ],
        [
            "BINARY_OP",
            "\"%s.%s(%d, %d, %d)\" % (self.__class__.__module__,\n                                      self.__class__.__qualname__,\n                                      self._year,\n                                      self._month,\n                                      self._day)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.toordinal"
        ],
        [
            "CALL",
            "self.toordinal()"
        ],
        [
            "BINARY_OP",
            "self.toordinal() % 7"
        ],
        [
            "STORE_FAST",
            "weekday"
        ],
        [
            "LOAD_GLOBAL",
            "_DAYNAMES"
        ],
        [
            "LOAD_FAST",
            "weekday"
        ],
        [
            "BINARY_SUBSCR",
            "_DAYNAMES[weekday]"
        ],
        [
            "LOAD_GLOBAL",
            "_MONTHNAMES"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._month"
        ],
        [
            "BINARY_SUBSCR",
            "_MONTHNAMES[self._month]"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._day"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._year"
        ],
        [
            "BINARY_OP",
            "\"%s %s %2d 00:00:00 %04d\" % (\n            _DAYNAMES[weekday],\n            _MONTHNAMES[self._month],\n            self._day, self._year)"
        ],
        [
            "LOAD_GLOBAL",
            "_wrap_strftime"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "fmt"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.timetuple"
        ],
        [
            "CALL",
            "self.timetuple()"
        ],
        [
            "CALL",
            "_wrap_strftime(self, fmt, self.timetuple())"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "fmt"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "CALL",
            "isinstance(fmt, str)"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "LOAD_GLOBAL",
            "type"
        ],
        [
            "LOAD_FAST",
            "fmt"
        ],
        [
            "CALL",
            "type(fmt)"
        ],
        [
            "LOAD_ATTR",
            "type(fmt).__name__"
        ],
        [
            "BINARY_OP",
            "\"must be str, not %s\" % type(fmt).__name__"
        ],
        [
            "CALL",
            "TypeError(\"must be str, not %s\" % type(fmt).__name__)"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "fmt"
        ],
        [
            "CALL",
            "len(fmt)"
        ],
        [
            "COMPARE_OP",
            "len(fmt) != 0"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.strftime"
        ],
        [
            "LOAD_FAST",
            "fmt"
        ],
        [
            "CALL",
            "self.strftime(fmt)"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "str(self)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._year"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._month"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._day"
        ],
        [
            "BINARY_OP",
            "\"%04d-%02d-%02d\" % (self._year, self._month, self._day)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._year"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._month"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._day"
        ],
        [
            "LOAD_GLOBAL",
            "_build_struct_time"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._year"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._month"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._day"
        ],
        [
            "CALL",
            "_build_struct_time(self._year, self._month, self._day,\n                                  0, 0, 0, -1)"
        ],
        [
            "LOAD_GLOBAL",
            "_ymd2ord"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._year"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._month"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._day"
        ],
        [
            "CALL",
            "_ymd2ord(self._year, self._month, self._day)"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._year"
        ],
        [
            "STORE_FAST",
            "year"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._month"
        ],
        [
            "STORE_FAST",
            "month"
        ],
        [
            "LOAD_FAST",
            "day"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._day"
        ],
        [
            "STORE_FAST",
            "day"
        ],
        [
            "LOAD_GLOBAL",
            "type"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "type(self)"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "LOAD_FAST",
            "day"
        ],
        [
            "CALL",
            "type(self)(year, month, day)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "date"
        ],
        [
            "CALL",
            "isinstance(other, date)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._cmp"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "CALL",
            "self._cmp(other)"
        ],
        [
            "COMPARE_OP",
            "self._cmp(other) == 0"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "date"
        ],
        [
            "CALL",
            "isinstance(other, date)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._cmp"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "CALL",
            "self._cmp(other)"
        ],
        [
            "COMPARE_OP",
            "self._cmp(other) <= 0"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "date"
        ],
        [
            "CALL",
            "isinstance(other, date)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._cmp"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "CALL",
            "self._cmp(other)"
        ],
        [
            "COMPARE_OP",
            "self._cmp(other) < 0"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "date"
        ],
        [
            "CALL",
            "isinstance(other, date)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._cmp"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "CALL",
            "self._cmp(other)"
        ],
        [
            "COMPARE_OP",
            "self._cmp(other) >= 0"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "date"
        ],
        [
            "CALL",
            "isinstance(other, date)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._cmp"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "CALL",
            "self._cmp(other)"
        ],
        [
            "COMPARE_OP",
            "self._cmp(other) > 0"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "date"
        ],
        [
            "CALL",
            "isinstance(other, date)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._year"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._month"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._day"
        ],
        [
            "STORE_FAST",
            "d"
        ],
        [
            "STORE_FAST",
            "m"
        ],
        [
            "STORE_FAST",
            "y"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._year"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._month"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._day"
        ],
        [
            "STORE_FAST",
            "d2"
        ],
        [
            "STORE_FAST",
            "m2"
        ],
        [
            "STORE_FAST",
            "y2"
        ],
        [
            "LOAD_GLOBAL",
            "_cmp"
        ],
        [
            "LOAD_FAST",
            "y"
        ],
        [
            "LOAD_FAST",
            "m"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "LOAD_FAST",
            "y2"
        ],
        [
            "LOAD_FAST",
            "m2"
        ],
        [
            "LOAD_FAST",
            "d2"
        ],
        [
            "CALL",
            "_cmp((y, m, d), (y2, m2, d2))"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._hashcode"
        ],
        [
            "COMPARE_OP",
            "self._hashcode == -1"
        ],
        [
            "LOAD_GLOBAL",
            "hash"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._getstate"
        ],
        [
            "CALL",
            "self._getstate()"
        ],
        [
            "CALL",
            "hash(self._getstate())"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._hashcode"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._hashcode"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "isinstance(other, timedelta)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.toordinal"
        ],
        [
            "CALL",
            "self.toordinal()"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other.days"
        ],
        [
            "BINARY_OP",
            "self.toordinal() + other.days"
        ],
        [
            "STORE_FAST",
            "o"
        ],
        [
            "LOAD_FAST",
            "o"
        ],
        [
            "COMPARE_OP",
            "0 < o <= _MAXORDINAL"
        ],
        [
            "LOAD_GLOBAL",
            "_MAXORDINAL"
        ],
        [
            "COMPARE_OP",
            "0 < o <= _MAXORDINAL"
        ],
        [
            "LOAD_GLOBAL",
            "type"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "type(self)"
        ],
        [
            "LOAD_METHOD",
            "type(self).fromordinal"
        ],
        [
            "LOAD_FAST",
            "o"
        ],
        [
            "CALL",
            "type(self).fromordinal(o)"
        ],
        [
            "LOAD_GLOBAL",
            "OverflowError"
        ],
        [
            "CALL",
            "OverflowError(\"result out of range\")"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "isinstance(other, timedelta)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other.days"
        ],
        [
            "UNARY_NEGATIVE",
            "-other.days"
        ],
        [
            "CALL",
            "timedelta(-other.days)"
        ],
        [
            "BINARY_OP",
            "self + timedelta(-other.days)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "date"
        ],
        [
            "CALL",
            "isinstance(other, date)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.toordinal"
        ],
        [
            "CALL",
            "self.toordinal()"
        ],
        [
            "STORE_FAST",
            "days1"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_METHOD",
            "other.toordinal"
        ],
        [
            "CALL",
            "other.toordinal()"
        ],
        [
            "STORE_FAST",
            "days2"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "LOAD_FAST",
            "days1"
        ],
        [
            "LOAD_FAST",
            "days2"
        ],
        [
            "BINARY_OP",
            "days1 - days2"
        ],
        [
            "CALL",
            "timedelta(days1 - days2)"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.toordinal"
        ],
        [
            "CALL",
            "self.toordinal()"
        ],
        [
            "BINARY_OP",
            "self.toordinal() + 6"
        ],
        [
            "BINARY_OP",
            "(self.toordinal() + 6) % 7"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.toordinal"
        ],
        [
            "CALL",
            "self.toordinal()"
        ],
        [
            "BINARY_OP",
            "self.toordinal() % 7"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._year"
        ],
        [
            "STORE_FAST",
            "year"
        ],
        [
            "LOAD_GLOBAL",
            "_isoweek1monday"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "CALL",
            "_isoweek1monday(year)"
        ],
        [
            "STORE_FAST",
            "week1monday"
        ],
        [
            "LOAD_GLOBAL",
            "_ymd2ord"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._year"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._month"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._day"
        ],
        [
            "CALL",
            "_ymd2ord(self._year, self._month, self._day)"
        ],
        [
            "STORE_FAST",
            "today"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "today"
        ],
        [
            "LOAD_FAST",
            "week1monday"
        ],
        [
            "BINARY_OP",
            "today - week1monday"
        ],
        [
            "CALL",
            "divmod(today - week1monday, 7)"
        ],
        [
            "STORE_FAST",
            "week"
        ],
        [
            "STORE_FAST",
            "day"
        ],
        [
            "LOAD_FAST",
            "week"
        ],
        [
            "COMPARE_OP",
            "week < 0"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "BINARY_OP",
            "year -= 1"
        ],
        [
            "STORE_FAST",
            "year"
        ],
        [
            "LOAD_GLOBAL",
            "_isoweek1monday"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "CALL",
            "_isoweek1monday(year)"
        ],
        [
            "STORE_FAST",
            "week1monday"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "today"
        ],
        [
            "LOAD_FAST",
            "week1monday"
        ],
        [
            "BINARY_OP",
            "today - week1monday"
        ],
        [
            "CALL",
            "divmod(today - week1monday, 7)"
        ],
        [
            "STORE_FAST",
            "week"
        ],
        [
            "STORE_FAST",
            "day"
        ],
        [
            "LOAD_FAST",
            "week"
        ],
        [
            "COMPARE_OP",
            "week >= 52"
        ],
        [
            "LOAD_FAST",
            "today"
        ],
        [
            "LOAD_GLOBAL",
            "_isoweek1monday"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "BINARY_OP",
            "year+1"
        ],
        [
            "CALL",
            "_isoweek1monday(year+1)"
        ],
        [
            "COMPARE_OP",
            "today >= _isoweek1monday(year+1)"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "BINARY_OP",
            "year += 1"
        ],
        [
            "STORE_FAST",
            "year"
        ],
        [
            "STORE_FAST",
            "week"
        ],
        [
            "LOAD_GLOBAL",
            "_IsoCalendarDate"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "LOAD_FAST",
            "week"
        ],
        [
            "BINARY_OP",
            "week+1"
        ],
        [
            "LOAD_FAST",
            "day"
        ],
        [
            "BINARY_OP",
            "day+1"
        ],
        [
            "CALL",
            "_IsoCalendarDate(year, week+1, day+1)"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._year"
        ],
        [
            "CALL",
            "divmod(self._year, 256)"
        ],
        [
            "STORE_FAST",
            "yhi"
        ],
        [
            "STORE_FAST",
            "ylo"
        ],
        [
            "LOAD_GLOBAL",
            "bytes"
        ],
        [
            "LOAD_FAST",
            "yhi"
        ],
        [
            "LOAD_FAST",
            "ylo"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._month"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._day"
        ],
        [
            "CALL",
            "bytes([yhi, ylo, self._month, self._day])"
        ],
        [
            "LOAD_FAST",
            "string"
        ],
        [
            "STORE_FAST",
            "yhi"
        ],
        [
            "STORE_FAST",
            "ylo"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._month"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._day"
        ],
        [
            "LOAD_FAST",
            "yhi"
        ],
        [
            "BINARY_OP",
            "yhi * 256"
        ],
        [
            "LOAD_FAST",
            "ylo"
        ],
        [
            "BINARY_OP",
            "yhi * 256 + ylo"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._year"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.__class__"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._getstate"
        ],
        [
            "CALL",
            "self._getstate()"
        ],
        [
            "STORE_NAME",
            "\"\"\"Abstract base class for time zone info classes.\n\n    Subclasses must override the name(), utcoffset() and dst() methods.\n    \"\"\""
        ],
        [
            "STORE_NAME",
            "__slots__"
        ],
        [
            "STORE_NAME",
            "    def tzname(self, dt):\n        \"datetime -> string name of time zone.\"\n        raise NotImplementedError(\"tzinfo subclass must override tzname()\")"
        ],
        [
            "STORE_NAME",
            "    def utcoffset(self, dt):\n        \"datetime -> timedelta, positive for east of UTC, negative for west of UTC\"\n        raise NotImplementedError(\"tzinfo subclass must override utcoffset()\")"
        ],
        [
            "STORE_NAME",
            "    def dst(self, dt):\n        \"\"\"datetime -> DST offset as timedelta, positive for east of UTC.\n\n        Return 0 if DST not in effect.  utcoffset() must include the DST\n        offset.\n        \"\"\"\n        raise NotImplementedError(\"tzinfo subclass must override dst()\")"
        ],
        [
            "STORE_NAME",
            "    def fromutc(self, dt):\n        \"datetime in UTC -> datetime in local time.\"\n\n        if not isinstance(dt, datetime):\n            raise TypeError(\"fromutc() requires a datetime argument\")\n        if dt.tzinfo is not self:\n            raise ValueError(\"dt.tzinfo is not self\")\n\n        dtoff = dt.utcoffset()\n        if dtoff is None:\n            raise ValueError(\"fromutc() requires a non-None utcoffset() \"\n                             \"result\")\n\n        # See the long comment block at the end of this file for an\n        # explanation of this algorithm.\n        dtdst = dt.dst()\n        if dtdst is None:\n            raise ValueError(\"fromutc() requires a non-None dst() result\")\n        delta = dtoff - dtdst\n        if delta:\n            dt += delta\n            dtdst = dt.dst()\n            if dtdst is None:\n                raise ValueError(\"fromutc(): dt.dst gave inconsistent \"\n                                 \"results; cannot convert\")\n        return dt + dtdst"
        ],
        [
            "STORE_NAME",
            "    def __reduce__(self):\n        getinitargs = getattr(self, \"__getinitargs__\", None)\n        if getinitargs:\n            args = getinitargs()\n        else:\n            args = ()\n        return (self.__class__, args, self.__getstate__())"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplementedError"
        ],
        [
            "CALL",
            "NotImplementedError(\"tzinfo subclass must override tzname()\")"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplementedError"
        ],
        [
            "CALL",
            "NotImplementedError(\"tzinfo subclass must override utcoffset()\")"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplementedError"
        ],
        [
            "CALL",
            "NotImplementedError(\"tzinfo subclass must override dst()\")"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "dt"
        ],
        [
            "LOAD_GLOBAL",
            "datetime"
        ],
        [
            "CALL",
            "isinstance(dt, datetime)"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "CALL",
            "TypeError(\"fromutc() requires a datetime argument\")"
        ],
        [
            "LOAD_FAST",
            "dt"
        ],
        [
            "LOAD_ATTR",
            "dt.tzinfo"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "IS_OP",
            "dt.tzinfo is not self"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError(\"dt.tzinfo is not self\")"
        ],
        [
            "LOAD_FAST",
            "dt"
        ],
        [
            "LOAD_METHOD",
            "dt.utcoffset"
        ],
        [
            "CALL",
            "dt.utcoffset()"
        ],
        [
            "STORE_FAST",
            "dtoff"
        ],
        [
            "LOAD_FAST",
            "dtoff"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError(\"fromutc() requires a non-None utcoffset() \"\n                             \"result\")"
        ],
        [
            "LOAD_FAST",
            "dt"
        ],
        [
            "LOAD_METHOD",
            "dt.dst"
        ],
        [
            "CALL",
            "dt.dst()"
        ],
        [
            "STORE_FAST",
            "dtdst"
        ],
        [
            "LOAD_FAST",
            "dtdst"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError(\"fromutc() requires a non-None dst() result\")"
        ],
        [
            "LOAD_FAST",
            "dtoff"
        ],
        [
            "LOAD_FAST",
            "dtdst"
        ],
        [
            "BINARY_OP",
            "dtoff - dtdst"
        ],
        [
            "STORE_FAST",
            "delta"
        ],
        [
            "LOAD_FAST",
            "delta"
        ],
        [
            "LOAD_FAST",
            "dt"
        ],
        [
            "LOAD_FAST",
            "delta"
        ],
        [
            "BINARY_OP",
            "dt += delta"
        ],
        [
            "STORE_FAST",
            "dt"
        ],
        [
            "LOAD_FAST",
            "dt"
        ],
        [
            "LOAD_METHOD",
            "dt.dst"
        ],
        [
            "CALL",
            "dt.dst()"
        ],
        [
            "STORE_FAST",
            "dtdst"
        ],
        [
            "LOAD_FAST",
            "dtdst"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError(\"fromutc(): dt.dst gave inconsistent \"\n                                 \"results; cannot convert\")"
        ],
        [
            "LOAD_FAST",
            "dt"
        ],
        [
            "LOAD_FAST",
            "dtdst"
        ],
        [
            "BINARY_OP",
            "dt + dtdst"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "getattr(self, \"__getinitargs__\", None)"
        ],
        [
            "STORE_FAST",
            "getinitargs"
        ],
        [
            "LOAD_FAST",
            "getinitargs"
        ],
        [
            "LOAD_FAST",
            "getinitargs"
        ],
        [
            "CALL",
            "getinitargs()"
        ],
        [
            "STORE_FAST",
            "args"
        ],
        [
            "STORE_FAST",
            "args"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.__class__"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.__getstate__"
        ],
        [
            "CALL",
            "self.__getstate__()"
        ],
        [
            "STORE_NAME",
            "    def __new__(cls, year, week, weekday, /):\n        return super().__new__(cls, (year, week, weekday))"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "    @property\n    def year(self):\n        return self[0]"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "    @property\n    def week(self):\n        return self[1]"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "    @property\n    def weekday(self):\n        return self[2]"
        ],
        [
            "STORE_NAME",
            "    def __reduce__(self):\n        # This code is intended to pickle the object without making the\n        # class public. See https://bugs.python.org/msg352381\n        return (tuple, (tuple(self),))"
        ],
        [
            "STORE_NAME",
            "    def __repr__(self):\n        return (f'{self.__class__.__name__}'\n                f'(year={self[0]}, week={self[1]}, weekday={self[2]})')"
        ],
        [
            "STORE_NAME",
            "    def __repr__(self):\n        return (f'{self.__class__.__name__}'\n                f'(year={self[0]}, week={self[1]}, weekday={self[2]})')"
        ],
        [
            "LOAD_GLOBAL",
            "super"
        ],
        [
            "CALL",
            "super()"
        ],
        [
            "LOAD_METHOD",
            "super().__new__"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "LOAD_FAST",
            "week"
        ],
        [
            "LOAD_FAST",
            "weekday"
        ],
        [
            "CALL",
            "super().__new__(cls, (year, week, weekday))"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "BINARY_SUBSCR",
            "self[0]"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "BINARY_SUBSCR",
            "self[1]"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "BINARY_SUBSCR",
            "self[2]"
        ],
        [
            "LOAD_GLOBAL",
            "tuple"
        ],
        [
            "LOAD_GLOBAL",
            "tuple"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "tuple(self)"
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "LOAD_ATTR",
            ""
        ],
        [
            "LOAD_ATTR",
            ""
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "BINARY_SUBSCR",
            ""
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "BINARY_SUBSCR",
            ""
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "BINARY_SUBSCR",
            ""
        ],
        [
            "STORE_NAME",
            "\"\"\"Time with time zone.\n\n    Constructors:\n\n    __new__()\n\n    Operators:\n\n    __repr__, __str__\n    __eq__, __le__, __lt__, __ge__, __gt__, __hash__\n\n    Methods:\n\n    strftime()\n    isoformat()\n    utcoffset()\n    tzname()\n    dst()\n\n    Properties (readonly):\n    hour, minute, second, microsecond, tzinfo, fold\n    \"\"\""
        ],
        [
            "STORE_NAME",
            "__slots__"
        ],
        [
            "STORE_NAME",
            "    def __new__(cls, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0):\n        \"\"\"Constructor.\n\n        Arguments:\n\n        hour, minute (required)\n        second, microsecond (default to zero)\n        tzinfo (default to None)\n        fold (keyword only, default to zero)\n        \"\"\"\n        if (isinstance(hour, (bytes, str)) and len(hour) == 6 and\n            ord(hour[0:1])&0x7F < 24):\n            # Pickle support\n            if isinstance(hour, str):\n                try:\n                    hour = hour.encode('latin1')\n                except UnicodeEncodeError:\n                    # More informative error message.\n                    raise ValueError(\n                        \"Failed to encode latin1 string when unpickling \"\n                        \"a time object. \"\n                        \"pickle.load(data, encoding='latin1') is assumed.\")\n            self = object.__new__(cls)\n            self.__setstate(hour, minute or None)\n            self._hashcode = -1\n            return self\n        hour, minute, second, microsecond, fold = _check_time_fields(\n            hour, minute, second, microsecond, fold)\n        _check_tzinfo_arg(tzinfo)\n        self = object.__new__(cls)\n        self._hour = hour\n        self._minute = minute\n        self._second = second\n        self._microsecond = microsecond\n        self._tzinfo = tzinfo\n        self._hashcode = -1\n        self._fold = fold\n        return self"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "    @property\n    def hour(self):\n        \"\"\"hour (0-23)\"\"\"\n        return self._hour"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "    @property\n    def minute(self):\n        \"\"\"minute (0-59)\"\"\"\n        return self._minute"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "    @property\n    def second(self):\n        \"\"\"second (0-59)\"\"\"\n        return self._second"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "    @property\n    def microsecond(self):\n        \"\"\"microsecond (0-999999)\"\"\"\n        return self._microsecond"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "    @property\n    def tzinfo(self):\n        \"\"\"timezone info object\"\"\"\n        return self._tzinfo"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "    @property\n    def fold(self):\n        return self._fold"
        ],
        [
            "STORE_NAME",
            "    def __eq__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other, allow_mixed=True) == 0\n        else:\n            return NotImplemented"
        ],
        [
            "STORE_NAME",
            "    def __le__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) <= 0\n        else:\n            return NotImplemented"
        ],
        [
            "STORE_NAME",
            "    def __lt__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) < 0\n        else:\n            return NotImplemented"
        ],
        [
            "STORE_NAME",
            "    def __ge__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) >= 0\n        else:\n            return NotImplemented"
        ],
        [
            "STORE_NAME",
            "    def __gt__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) > 0\n        else:\n            return NotImplemented"
        ],
        [
            "STORE_NAME",
            "    def _cmp(self, other, allow_mixed=False):\n        assert isinstance(other, time)\n        mytz = self._tzinfo\n        ottz = other._tzinfo\n        myoff = otoff = None\n\n        if mytz is ottz:\n            base_compare = True\n        else:\n            myoff = self.utcoffset()\n            otoff = other.utcoffset()\n            base_compare = myoff == otoff\n\n        if base_compare:\n            return _cmp((self._hour, self._minute, self._second,\n                         self._microsecond),\n                        (other._hour, other._minute, other._second,\n                         other._microsecond))\n        if myoff is None or otoff is None:\n            if allow_mixed:\n                return 2 # arbitrary non-zero value\n            else:\n                raise TypeError(\"cannot compare naive and aware times\")\n        myhhmm = self._hour * 60 + self._minute - myoff//timedelta(minutes=1)\n        othhmm = other._hour * 60 + other._minute - otoff//timedelta(minutes=1)\n        return _cmp((myhhmm, self._second, self._microsecond),\n                    (othhmm, other._second, other._microsecond))"
        ],
        [
            "STORE_NAME",
            "    def __hash__(self):\n        \"\"\"Hash.\"\"\"\n        if self._hashcode == -1:\n            if self.fold:\n                t = self.replace(fold=0)\n            else:\n                t = self\n            tzoff = t.utcoffset()\n            if not tzoff:  # zero or None\n                self._hashcode = hash(t._getstate()[0])\n            else:\n                h, m = divmod(timedelta(hours=self.hour, minutes=self.minute) - tzoff,\n                              timedelta(hours=1))\n                assert not m % timedelta(minutes=1), \"whole minute\"\n                m //= timedelta(minutes=1)\n                if 0 <= h < 24:\n                    self._hashcode = hash(time(h, m, self.second, self.microsecond))\n                else:\n                    self._hashcode = hash((h, m, self.second, self.microsecond))\n        return self._hashcode"
        ],
        [
            "STORE_NAME",
            "    def _tzstr(self):\n        \"\"\"Return formatted timezone offset (+xx:xx) or an empty string.\"\"\"\n        off = self.utcoffset()\n        return _format_offset(off)"
        ],
        [
            "STORE_NAME",
            "    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\"\"\"\n        if self._microsecond != 0:\n            s = \", %d, %d\" % (self._second, self._microsecond)\n        elif self._second != 0:\n            s = \", %d\" % self._second\n        else:\n            s = \"\"\n        s= \"%s.%s(%d, %d%s)\" % (self.__class__.__module__,\n                                self.__class__.__qualname__,\n                                self._hour, self._minute, s)\n        if self._tzinfo is not None:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", tzinfo=%r\" % self._tzinfo + \")\"\n        if self._fold:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", fold=1)\"\n        return s"
        ],
        [
            "STORE_NAME",
            "    def isoformat(self, timespec='auto'):\n        \"\"\"Return the time formatted according to ISO.\n\n        The full format is 'HH:MM:SS.mmmmmm+zz:zz'. By default, the fractional\n        part is omitted if self.microsecond == 0.\n\n        The optional argument timespec specifies the number of additional\n        terms of the time to include. Valid options are 'auto', 'hours',\n        'minutes', 'seconds', 'milliseconds' and 'microseconds'.\n        \"\"\"\n        s = _format_time(self._hour, self._minute, self._second,\n                          self._microsecond, timespec)\n        tz = self._tzstr()\n        if tz:\n            s += tz\n        return s"
        ],
        [
            "LOAD_NAME",
            "isoformat"
        ],
        [
            "STORE_NAME",
            "__str__"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def fromisoformat(cls, time_string):\n        \"\"\"Construct a time from a string in one of the ISO 8601 formats.\"\"\"\n        if not isinstance(time_string, str):\n            raise TypeError('fromisoformat: argument must be str')\n\n        # The spec actually requires that time-only ISO 8601 strings start with\n        # T, but the extended format allows this to be omitted as long as there\n        # is no ambiguity with date strings.\n        time_string = time_string.removeprefix('T')\n\n        try:\n            return cls(*_parse_isoformat_time(time_string))\n        except Exception:\n            raise ValueError(f'Invalid isoformat string: {time_string!r}')"
        ],
        [
            "STORE_NAME",
            "    def strftime(self, fmt):\n        \"\"\"Format using strftime().  The date part of the timestamp passed\n        to underlying strftime should not be used.\n        \"\"\"\n        # The year must be >= 1000 else Python's strftime implementation\n        # can raise a bogus exception.\n        timetuple = (1900, 1, 1,\n                     self._hour, self._minute, self._second,\n                     0, 1, -1)\n        return _wrap_strftime(self, fmt, timetuple)"
        ],
        [
            "STORE_NAME",
            "    def __format__(self, fmt):\n        if not isinstance(fmt, str):\n            raise TypeError(\"must be str, not %s\" % type(fmt).__name__)\n        if len(fmt) != 0:\n            return self.strftime(fmt)\n        return str(self)"
        ],
        [
            "STORE_NAME",
            "    def utcoffset(self):\n        \"\"\"Return the timezone offset as timedelta, positive east of UTC\n         (negative west of UTC).\"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.utcoffset(None)\n        _check_utc_offset(\"utcoffset\", offset)\n        return offset"
        ],
        [
            "STORE_NAME",
            "    def tzname(self):\n        \"\"\"Return the timezone name.\n\n        Note that the name is 100% informational -- there's no requirement that\n        it mean anything in particular. For example, \"GMT\", \"UTC\", \"-500\",\n        \"-5:00\", \"EDT\", \"US/Eastern\", \"America/New York\" are all valid replies.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        name = self._tzinfo.tzname(None)\n        _check_tzname(name)\n        return name"
        ],
        [
            "STORE_NAME",
            "    def dst(self):\n        \"\"\"Return 0 if DST is not in effect, or the DST offset (as timedelta\n        positive eastward) if DST is in effect.\n\n        This is purely informational; the DST offset has already been added to\n        the UTC offset returned by utcoffset() if applicable, so there's no\n        need to consult dst() unless you're interested in displaying the DST\n        info.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.dst(None)\n        _check_utc_offset(\"dst\", offset)\n        return offset"
        ],
        [
            "STORE_NAME",
            "    def replace(self, hour=None, minute=None, second=None, microsecond=None,\n                tzinfo=True, *, fold=None):\n        \"\"\"Return a new time with new values for the specified fields.\"\"\"\n        if hour is None:\n            hour = self.hour\n        if minute is None:\n            minute = self.minute\n        if second is None:\n            second = self.second\n        if microsecond is None:\n            microsecond = self.microsecond\n        if tzinfo is True:\n            tzinfo = self.tzinfo\n        if fold is None:\n            fold = self._fold\n        return type(self)(hour, minute, second, microsecond, tzinfo, fold=fold)"
        ],
        [
            "STORE_NAME",
            "    def _getstate(self, protocol=3):\n        us2, us3 = divmod(self._microsecond, 256)\n        us1, us2 = divmod(us2, 256)\n        h = self._hour\n        if self._fold and protocol > 3:\n            h += 128\n        basestate = bytes([h, self._minute, self._second,\n                           us1, us2, us3])\n        if self._tzinfo is None:\n            return (basestate,)\n        else:\n            return (basestate, self._tzinfo)"
        ],
        [
            "STORE_NAME",
            "    def __setstate(self, string, tzinfo):\n        if tzinfo is not None and not isinstance(tzinfo, _tzinfo_class):\n            raise TypeError(\"bad tzinfo state arg\")\n        h, self._minute, self._second, us1, us2, us3 = string\n        if h > 127:\n            self._fold = 1\n            self._hour = h - 128\n        else:\n            self._fold = 0\n            self._hour = h\n        self._microsecond = (((us1 << 8) | us2) << 8) | us3\n        self._tzinfo = tzinfo"
        ],
        [
            "STORE_NAME",
            "    def __reduce_ex__(self, protocol):\n        return (self.__class__, self._getstate(protocol))"
        ],
        [
            "STORE_NAME",
            "    def __reduce__(self):\n        return self.__reduce_ex__(2)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "hour"
        ],
        [
            "LOAD_GLOBAL",
            "bytes"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "CALL",
            "isinstance(hour, (bytes, str))"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "hour"
        ],
        [
            "CALL",
            "len(hour)"
        ],
        [
            "COMPARE_OP",
            "len(hour) == 6"
        ],
        [
            "LOAD_GLOBAL",
            "ord"
        ],
        [
            "LOAD_FAST",
            "hour"
        ],
        [
            "BINARY_SUBSCR",
            "hour[0:1]"
        ],
        [
            "CALL",
            "ord(hour[0:1])"
        ],
        [
            "BINARY_OP",
            "ord(hour[0:1])&0x7F"
        ],
        [
            "COMPARE_OP",
            "ord(hour[0:1])&0x7F < 24"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "hour"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "CALL",
            "isinstance(hour, str)"
        ],
        [
            "LOAD_FAST",
            "hour"
        ],
        [
            "LOAD_METHOD",
            "hour.encode"
        ],
        [
            "CALL",
            "hour.encode('latin1')"
        ],
        [
            "STORE_FAST",
            "hour"
        ],
        [
            "LOAD_GLOBAL",
            "UnicodeEncodeError"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError(\n                        \"Failed to encode latin1 string when unpickling \"\n                        \"a time object. \"\n                        \"pickle.load(data, encoding='latin1') is assumed.\")"
        ],
        [
            "LOAD_GLOBAL",
            "object"
        ],
        [
            "LOAD_METHOD",
            "object.__new__"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "CALL",
            "object.__new__(cls)"
        ],
        [
            "STORE_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.__setstate"
        ],
        [
            "LOAD_FAST",
            "hour"
        ],
        [
            "LOAD_FAST",
            "minute"
        ],
        [
            "CALL",
            "self.__setstate(hour, minute or None)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._hashcode"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_GLOBAL",
            "_check_time_fields"
        ],
        [
            "LOAD_FAST",
            "hour"
        ],
        [
            "LOAD_FAST",
            "minute"
        ],
        [
            "LOAD_FAST",
            "second"
        ],
        [
            "LOAD_FAST",
            "microsecond"
        ],
        [
            "LOAD_FAST",
            "fold"
        ],
        [
            "CALL",
            "_check_time_fields(\n            hour, minute, second, microsecond, fold)"
        ],
        [
            "STORE_FAST",
            "hour"
        ],
        [
            "STORE_FAST",
            "minute"
        ],
        [
            "STORE_FAST",
            "second"
        ],
        [
            "STORE_FAST",
            "microsecond"
        ],
        [
            "STORE_FAST",
            "fold"
        ],
        [
            "LOAD_GLOBAL",
            "_check_tzinfo_arg"
        ],
        [
            "LOAD_FAST",
            "tzinfo"
        ],
        [
            "CALL",
            "_check_tzinfo_arg(tzinfo)"
        ],
        [
            "LOAD_GLOBAL",
            "object"
        ],
        [
            "LOAD_METHOD",
            "object.__new__"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "CALL",
            "object.__new__(cls)"
        ],
        [
            "STORE_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "hour"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._hour"
        ],
        [
            "LOAD_FAST",
            "minute"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._minute"
        ],
        [
            "LOAD_FAST",
            "second"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._second"
        ],
        [
            "LOAD_FAST",
            "microsecond"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._microsecond"
        ],
        [
            "LOAD_FAST",
            "tzinfo"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._tzinfo"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._hashcode"
        ],
        [
            "LOAD_FAST",
            "fold"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._fold"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._hour"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._minute"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._second"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._microsecond"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._tzinfo"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._fold"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "time"
        ],
        [
            "CALL",
            "isinstance(other, time)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._cmp"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "CALL",
            "self._cmp(other, allow_mixed=True)"
        ],
        [
            "COMPARE_OP",
            "self._cmp(other, allow_mixed=True) == 0"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "time"
        ],
        [
            "CALL",
            "isinstance(other, time)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._cmp"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "CALL",
            "self._cmp(other)"
        ],
        [
            "COMPARE_OP",
            "self._cmp(other) <= 0"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "time"
        ],
        [
            "CALL",
            "isinstance(other, time)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._cmp"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "CALL",
            "self._cmp(other)"
        ],
        [
            "COMPARE_OP",
            "self._cmp(other) < 0"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "time"
        ],
        [
            "CALL",
            "isinstance(other, time)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._cmp"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "CALL",
            "self._cmp(other)"
        ],
        [
            "COMPARE_OP",
            "self._cmp(other) >= 0"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "time"
        ],
        [
            "CALL",
            "isinstance(other, time)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._cmp"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "CALL",
            "self._cmp(other)"
        ],
        [
            "COMPARE_OP",
            "self._cmp(other) > 0"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "time"
        ],
        [
            "CALL",
            "isinstance(other, time)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._tzinfo"
        ],
        [
            "STORE_FAST",
            "mytz"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._tzinfo"
        ],
        [
            "STORE_FAST",
            "ottz"
        ],
        [
            "STORE_FAST",
            "myoff"
        ],
        [
            "STORE_FAST",
            "otoff"
        ],
        [
            "LOAD_FAST",
            "mytz"
        ],
        [
            "LOAD_FAST",
            "ottz"
        ],
        [
            "IS_OP",
            "mytz is ottz"
        ],
        [
            "STORE_FAST",
            "base_compare"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.utcoffset"
        ],
        [
            "CALL",
            "self.utcoffset()"
        ],
        [
            "STORE_FAST",
            "myoff"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_METHOD",
            "other.utcoffset"
        ],
        [
            "CALL",
            "other.utcoffset()"
        ],
        [
            "STORE_FAST",
            "otoff"
        ],
        [
            "LOAD_FAST",
            "myoff"
        ],
        [
            "LOAD_FAST",
            "otoff"
        ],
        [
            "COMPARE_OP",
            "myoff == otoff"
        ],
        [
            "STORE_FAST",
            "base_compare"
        ],
        [
            "LOAD_FAST",
            "base_compare"
        ],
        [
            "LOAD_GLOBAL",
            "_cmp"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._hour"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._minute"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._second"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._microsecond"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._hour"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._minute"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._second"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._microsecond"
        ],
        [
            "CALL",
            "_cmp((self._hour, self._minute, self._second,\n                         self._microsecond),\n                        (other._hour, other._minute, other._second,\n                         other._microsecond))"
        ],
        [
            "LOAD_FAST",
            "myoff"
        ],
        [
            "LOAD_FAST",
            "otoff"
        ],
        [
            "LOAD_FAST",
            "allow_mixed"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "CALL",
            "TypeError(\"cannot compare naive and aware times\")"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._hour"
        ],
        [
            "BINARY_OP",
            "self._hour * 60"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._minute"
        ],
        [
            "BINARY_OP",
            "self._hour * 60 + self._minute"
        ],
        [
            "LOAD_FAST",
            "myoff"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "timedelta(minutes=1)"
        ],
        [
            "BINARY_OP",
            "myoff//timedelta(minutes=1)"
        ],
        [
            "BINARY_OP",
            "self._hour * 60 + self._minute - myoff//timedelta(minutes=1)"
        ],
        [
            "STORE_FAST",
            "myhhmm"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._hour"
        ],
        [
            "BINARY_OP",
            "other._hour * 60"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._minute"
        ],
        [
            "BINARY_OP",
            "other._hour * 60 + other._minute"
        ],
        [
            "LOAD_FAST",
            "otoff"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "timedelta(minutes=1)"
        ],
        [
            "BINARY_OP",
            "otoff//timedelta(minutes=1)"
        ],
        [
            "BINARY_OP",
            "other._hour * 60 + other._minute - otoff//timedelta(minutes=1)"
        ],
        [
            "STORE_FAST",
            "othhmm"
        ],
        [
            "LOAD_GLOBAL",
            "_cmp"
        ],
        [
            "LOAD_FAST",
            "myhhmm"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._second"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._microsecond"
        ],
        [
            "LOAD_FAST",
            "othhmm"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._second"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._microsecond"
        ],
        [
            "CALL",
            "_cmp((myhhmm, self._second, self._microsecond),\n                    (othhmm, other._second, other._microsecond))"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._hashcode"
        ],
        [
            "COMPARE_OP",
            "self._hashcode == -1"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.fold"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.replace"
        ],
        [
            "CALL",
            "self.replace(fold=0)"
        ],
        [
            "STORE_FAST",
            "t"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_FAST",
            "t"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "LOAD_METHOD",
            "t.utcoffset"
        ],
        [
            "CALL",
            "t.utcoffset()"
        ],
        [
            "STORE_FAST",
            "tzoff"
        ],
        [
            "LOAD_FAST",
            "tzoff"
        ],
        [
            "LOAD_GLOBAL",
            "hash"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "LOAD_METHOD",
            "t._getstate"
        ],
        [
            "CALL",
            "t._getstate()"
        ],
        [
            "BINARY_SUBSCR",
            "t._getstate()[0]"
        ],
        [
            "CALL",
            "hash(t._getstate()[0])"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._hashcode"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.hour"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.minute"
        ],
        [
            "CALL",
            "timedelta(hours=self.hour, minutes=self.minute)"
        ],
        [
            "LOAD_FAST",
            "tzoff"
        ],
        [
            "BINARY_OP",
            "timedelta(hours=self.hour, minutes=self.minute) - tzoff"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "timedelta(hours=1)"
        ],
        [
            "CALL",
            "divmod(timedelta(hours=self.hour, minutes=self.minute) - tzoff,\n                              timedelta(hours=1))"
        ],
        [
            "STORE_FAST",
            "h"
        ],
        [
            "STORE_FAST",
            "m"
        ],
        [
            "LOAD_FAST",
            "m"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "timedelta(minutes=1)"
        ],
        [
            "BINARY_OP",
            "m % timedelta(minutes=1)"
        ],
        [
            "LOAD_FAST",
            "m"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "timedelta(minutes=1)"
        ],
        [
            "BINARY_OP",
            "m //= timedelta(minutes=1)"
        ],
        [
            "STORE_FAST",
            "m"
        ],
        [
            "LOAD_FAST",
            "h"
        ],
        [
            "COMPARE_OP",
            "0 <= h < 24"
        ],
        [
            "COMPARE_OP",
            "0 <= h < 24"
        ],
        [
            "LOAD_GLOBAL",
            "hash"
        ],
        [
            "LOAD_GLOBAL",
            "time"
        ],
        [
            "LOAD_FAST",
            "h"
        ],
        [
            "LOAD_FAST",
            "m"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.second"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.microsecond"
        ],
        [
            "CALL",
            "time(h, m, self.second, self.microsecond)"
        ],
        [
            "CALL",
            "hash(time(h, m, self.second, self.microsecond))"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._hashcode"
        ],
        [
            "LOAD_GLOBAL",
            "hash"
        ],
        [
            "LOAD_FAST",
            "h"
        ],
        [
            "LOAD_FAST",
            "m"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.second"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.microsecond"
        ],
        [
            "CALL",
            "hash((h, m, self.second, self.microsecond))"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._hashcode"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._hashcode"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.utcoffset"
        ],
        [
            "CALL",
            "self.utcoffset()"
        ],
        [
            "STORE_FAST",
            "off"
        ],
        [
            "LOAD_GLOBAL",
            "_format_offset"
        ],
        [
            "LOAD_FAST",
            "off"
        ],
        [
            "CALL",
            "_format_offset(off)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._microsecond"
        ],
        [
            "COMPARE_OP",
            "self._microsecond != 0"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._second"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._microsecond"
        ],
        [
            "BINARY_OP",
            "\", %d, %d\" % (self._second, self._microsecond)"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._second"
        ],
        [
            "COMPARE_OP",
            "self._second != 0"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._second"
        ],
        [
            "BINARY_OP",
            "\", %d\" % self._second"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.__class__"
        ],
        [
            "LOAD_ATTR",
            "self.__class__.__module__"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.__class__"
        ],
        [
            "LOAD_ATTR",
            "self.__class__.__qualname__"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._hour"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._minute"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "BINARY_OP",
            "\"%s.%s(%d, %d%s)\" % (self.__class__.__module__,\n                                self.__class__.__qualname__,\n                                self._hour, self._minute, s)"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._tzinfo"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "BINARY_SUBSCR",
            "s[-1:]"
        ],
        [
            "COMPARE_OP",
            "s[-1:] == \")\""
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "BINARY_SUBSCR",
            "s[:-1]"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._tzinfo"
        ],
        [
            "BINARY_OP",
            "\", tzinfo=%r\" % self._tzinfo"
        ],
        [
            "BINARY_OP",
            "s[:-1] + \", tzinfo=%r\" % self._tzinfo"
        ],
        [
            "BINARY_OP",
            "s[:-1] + \", tzinfo=%r\" % self._tzinfo + \")\""
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._fold"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "BINARY_SUBSCR",
            "s[-1:]"
        ],
        [
            "COMPARE_OP",
            "s[-1:] == \")\""
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "BINARY_SUBSCR",
            "s[:-1]"
        ],
        [
            "BINARY_OP",
            "s[:-1] + \", fold=1)\""
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_GLOBAL",
            "_format_time"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._hour"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._minute"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._second"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._microsecond"
        ],
        [
            "LOAD_FAST",
            "timespec"
        ],
        [
            "CALL",
            "_format_time(self._hour, self._minute, self._second,\n                          self._microsecond, timespec)"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._tzstr"
        ],
        [
            "CALL",
            "self._tzstr()"
        ],
        [
            "STORE_FAST",
            "tz"
        ],
        [
            "LOAD_FAST",
            "tz"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "tz"
        ],
        [
            "BINARY_OP",
            "s += tz"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "time_string"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "CALL",
            "isinstance(time_string, str)"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "CALL",
            "TypeError('fromisoformat: argument must be str')"
        ],
        [
            "LOAD_FAST",
            "time_string"
        ],
        [
            "LOAD_METHOD",
            "time_string.removeprefix"
        ],
        [
            "CALL",
            "time_string.removeprefix('T')"
        ],
        [
            "STORE_FAST",
            "time_string"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_GLOBAL",
            "_parse_isoformat_time"
        ],
        [
            "LOAD_FAST",
            "time_string"
        ],
        [
            "CALL",
            "_parse_isoformat_time(time_string)"
        ],
        [
            "CALL_FUNCTION_EX",
            "cls(*_parse_isoformat_time(time_string))"
        ],
        [
            "LOAD_GLOBAL",
            "Exception"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "CALL",
            "ValueError(f'Invalid isoformat string: {time_string!r}')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._hour"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._minute"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._second"
        ],
        [
            "STORE_FAST",
            "timetuple"
        ],
        [
            "LOAD_GLOBAL",
            "_wrap_strftime"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "fmt"
        ],
        [
            "LOAD_FAST",
            "timetuple"
        ],
        [
            "CALL",
            "_wrap_strftime(self, fmt, timetuple)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "fmt"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "CALL",
            "isinstance(fmt, str)"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "LOAD_GLOBAL",
            "type"
        ],
        [
            "LOAD_FAST",
            "fmt"
        ],
        [
            "CALL",
            "type(fmt)"
        ],
        [
            "LOAD_ATTR",
            "type(fmt).__name__"
        ],
        [
            "BINARY_OP",
            "\"must be str, not %s\" % type(fmt).__name__"
        ],
        [
            "CALL",
            "TypeError(\"must be str, not %s\" % type(fmt).__name__)"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "fmt"
        ],
        [
            "CALL",
            "len(fmt)"
        ],
        [
            "COMPARE_OP",
            "len(fmt) != 0"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.strftime"
        ],
        [
            "LOAD_FAST",
            "fmt"
        ],
        [
            "CALL",
            "self.strftime(fmt)"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "str(self)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._tzinfo"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._tzinfo"
        ],
        [
            "LOAD_METHOD",
            "self._tzinfo.utcoffset"
        ],
        [
            "CALL",
            "self._tzinfo.utcoffset(None)"
        ],
        [
            "STORE_FAST",
            "offset"
        ],
        [
            "LOAD_GLOBAL",
            "_check_utc_offset"
        ],
        [
            "LOAD_FAST",
            "offset"
        ],
        [
            "CALL",
            "_check_utc_offset(\"utcoffset\", offset)"
        ],
        [
            "LOAD_FAST",
            "offset"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._tzinfo"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._tzinfo"
        ],
        [
            "LOAD_METHOD",
            "self._tzinfo.tzname"
        ],
        [
            "CALL",
            "self._tzinfo.tzname(None)"
        ],
        [
            "STORE_FAST",
            "name"
        ],
        [
            "LOAD_GLOBAL",
            "_check_tzname"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "CALL",
            "_check_tzname(name)"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._tzinfo"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._tzinfo"
        ],
        [
            "LOAD_METHOD",
            "self._tzinfo.dst"
        ],
        [
            "CALL",
            "self._tzinfo.dst(None)"
        ],
        [
            "STORE_FAST",
            "offset"
        ],
        [
            "LOAD_GLOBAL",
            "_check_utc_offset"
        ],
        [
            "LOAD_FAST",
            "offset"
        ],
        [
            "CALL",
            "_check_utc_offset(\"dst\", offset)"
        ],
        [
            "LOAD_FAST",
            "offset"
        ],
        [
            "LOAD_FAST",
            "hour"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.hour"
        ],
        [
            "STORE_FAST",
            "hour"
        ],
        [
            "LOAD_FAST",
            "minute"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.minute"
        ],
        [
            "STORE_FAST",
            "minute"
        ],
        [
            "LOAD_FAST",
            "second"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.second"
        ],
        [
            "STORE_FAST",
            "second"
        ],
        [
            "LOAD_FAST",
            "microsecond"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.microsecond"
        ],
        [
            "STORE_FAST",
            "microsecond"
        ],
        [
            "LOAD_FAST",
            "tzinfo"
        ],
        [
            "IS_OP",
            "tzinfo is True"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.tzinfo"
        ],
        [
            "STORE_FAST",
            "tzinfo"
        ],
        [
            "LOAD_FAST",
            "fold"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._fold"
        ],
        [
            "STORE_FAST",
            "fold"
        ],
        [
            "LOAD_GLOBAL",
            "type"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "type(self)"
        ],
        [
            "LOAD_FAST",
            "hour"
        ],
        [
            "LOAD_FAST",
            "minute"
        ],
        [
            "LOAD_FAST",
            "second"
        ],
        [
            "LOAD_FAST",
            "microsecond"
        ],
        [
            "LOAD_FAST",
            "tzinfo"
        ],
        [
            "LOAD_FAST",
            "fold"
        ],
        [
            "CALL",
            "type(self)(hour, minute, second, microsecond, tzinfo, fold=fold)"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._microsecond"
        ],
        [
            "CALL",
            "divmod(self._microsecond, 256)"
        ],
        [
            "STORE_FAST",
            "us2"
        ],
        [
            "STORE_FAST",
            "us3"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "us2"
        ],
        [
            "CALL",
            "divmod(us2, 256)"
        ],
        [
            "STORE_FAST",
            "us1"
        ],
        [
            "STORE_FAST",
            "us2"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._hour"
        ],
        [
            "STORE_FAST",
            "h"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._fold"
        ],
        [
            "LOAD_FAST",
            "protocol"
        ],
        [
            "COMPARE_OP",
            "protocol > 3"
        ],
        [
            "LOAD_FAST",
            "h"
        ],
        [
            "BINARY_OP",
            "h += 128"
        ],
        [
            "STORE_FAST",
            "h"
        ],
        [
            "LOAD_GLOBAL",
            "bytes"
        ],
        [
            "LOAD_FAST",
            "h"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._minute"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._second"
        ],
        [
            "LOAD_FAST",
            "us1"
        ],
        [
            "LOAD_FAST",
            "us2"
        ],
        [
            "LOAD_FAST",
            "us3"
        ],
        [
            "CALL",
            "bytes([h, self._minute, self._second,\n                           us1, us2, us3])"
        ],
        [
            "STORE_FAST",
            "basestate"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._tzinfo"
        ],
        [
            "LOAD_FAST",
            "basestate"
        ],
        [
            "LOAD_FAST",
            "basestate"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._tzinfo"
        ],
        [
            "LOAD_FAST",
            "tzinfo"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "tzinfo"
        ],
        [
            "LOAD_GLOBAL",
            "_tzinfo_class"
        ],
        [
            "CALL",
            "isinstance(tzinfo, _tzinfo_class)"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "CALL",
            "TypeError(\"bad tzinfo state arg\")"
        ],
        [
            "LOAD_FAST",
            "string"
        ],
        [
            "STORE_FAST",
            "h"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._minute"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._second"
        ],
        [
            "STORE_FAST",
            "us1"
        ],
        [
            "STORE_FAST",
            "us2"
        ],
        [
            "STORE_FAST",
            "us3"
        ],
        [
            "LOAD_FAST",
            "h"
        ],
        [
            "COMPARE_OP",
            "h > 127"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._fold"
        ],
        [
            "LOAD_FAST",
            "h"
        ],
        [
            "BINARY_OP",
            "h - 128"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._hour"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._fold"
        ],
        [
            "LOAD_FAST",
            "h"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._hour"
        ],
        [
            "LOAD_FAST",
            "us1"
        ],
        [
            "BINARY_OP",
            "us1 << 8"
        ],
        [
            "LOAD_FAST",
            "us2"
        ],
        [
            "BINARY_OP",
            "(us1 << 8) | us2"
        ],
        [
            "BINARY_OP",
            "((us1 << 8) | us2) << 8"
        ],
        [
            "LOAD_FAST",
            "us3"
        ],
        [
            "BINARY_OP",
            "(((us1 << 8) | us2) << 8) | us3"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._microsecond"
        ],
        [
            "LOAD_FAST",
            "tzinfo"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._tzinfo"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.__class__"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._getstate"
        ],
        [
            "LOAD_FAST",
            "protocol"
        ],
        [
            "CALL",
            "self._getstate(protocol)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.__reduce_ex__"
        ],
        [
            "CALL",
            "self.__reduce_ex__(2)"
        ],
        [
            "STORE_NAME",
            "\"\"\"datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])\n\n    The year, month and day arguments are required. tzinfo may be None, or an\n    instance of a tzinfo subclass. The remaining arguments may be ints.\n    \"\"\""
        ],
        [
            "LOAD_NAME",
            "date"
        ],
        [
            "LOAD_ATTR",
            "date.__slots__"
        ],
        [
            "LOAD_NAME",
            "time"
        ],
        [
            "LOAD_ATTR",
            "time.__slots__"
        ],
        [
            "BINARY_OP",
            "date.__slots__ + time.__slots__"
        ],
        [
            "STORE_NAME",
            "__slots__"
        ],
        [
            "STORE_NAME",
            "    def __new__(cls, year, month=None, day=None, hour=0, minute=0, second=0,\n                microsecond=0, tzinfo=None, *, fold=0):\n        if (isinstance(year, (bytes, str)) and len(year) == 10 and\n            1 <= ord(year[2:3])&0x7F <= 12):\n            # Pickle support\n            if isinstance(year, str):\n                try:\n                    year = bytes(year, 'latin1')\n                except UnicodeEncodeError:\n                    # More informative error message.\n                    raise ValueError(\n                        \"Failed to encode latin1 string when unpickling \"\n                        \"a datetime object. \"\n                        \"pickle.load(data, encoding='latin1') is assumed.\")\n            self = object.__new__(cls)\n            self.__setstate(year, month)\n            self._hashcode = -1\n            return self\n        year, month, day = _check_date_fields(year, month, day)\n        hour, minute, second, microsecond, fold = _check_time_fields(\n            hour, minute, second, microsecond, fold)\n        _check_tzinfo_arg(tzinfo)\n        self = object.__new__(cls)\n        self._year = year\n        self._month = month\n        self._day = day\n        self._hour = hour\n        self._minute = minute\n        self._second = second\n        self._microsecond = microsecond\n        self._tzinfo = tzinfo\n        self._hashcode = -1\n        self._fold = fold\n        return self"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "    @property\n    def hour(self):\n        \"\"\"hour (0-23)\"\"\"\n        return self._hour"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "    @property\n    def minute(self):\n        \"\"\"minute (0-59)\"\"\"\n        return self._minute"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "    @property\n    def second(self):\n        \"\"\"second (0-59)\"\"\"\n        return self._second"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "    @property\n    def microsecond(self):\n        \"\"\"microsecond (0-999999)\"\"\"\n        return self._microsecond"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "    @property\n    def tzinfo(self):\n        \"\"\"timezone info object\"\"\"\n        return self._tzinfo"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "    @property\n    def fold(self):\n        return self._fold"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def _fromtimestamp(cls, t, utc, tz):\n        \"\"\"Construct a datetime from a POSIX timestamp (like time.time()).\n\n        A timezone info object may be passed in as well.\n        \"\"\"\n        frac, t = _math.modf(t)\n        us = round(frac * 1e6)\n        if us >= 1000000:\n            t += 1\n            us -= 1000000\n        elif us < 0:\n            t -= 1\n            us += 1000000\n\n        converter = _time.gmtime if utc else _time.localtime\n        y, m, d, hh, mm, ss, weekday, jday, dst = converter(t)\n        ss = min(ss, 59)    # clamp out leap seconds if the platform has them\n        result = cls(y, m, d, hh, mm, ss, us, tz)\n        if tz is None and not utc:\n            # As of version 2015f max fold in IANA database is\n            # 23 hours at 1969-09-30 13:00:00 in Kwajalein.\n            # Let's probe 24 hours in the past to detect a transition:\n            max_fold_seconds = 24 * 3600\n\n            # On Windows localtime_s throws an OSError for negative values,\n            # thus we can't perform fold detection for values of time less\n            # than the max time fold. See comments in _datetimemodule's\n            # version of this method for more details.\n            if t < max_fold_seconds and sys.platform.startswith(\"win\"):\n                return result\n\n            y, m, d, hh, mm, ss = converter(t - max_fold_seconds)[:6]\n            probe1 = cls(y, m, d, hh, mm, ss, us, tz)\n            trans = result - probe1 - timedelta(0, max_fold_seconds)\n            if trans.days < 0:\n                y, m, d, hh, mm, ss = converter(t + trans // timedelta(0, 1))[:6]\n                probe2 = cls(y, m, d, hh, mm, ss, us, tz)\n                if probe2 == result:\n                    result._fold = 1\n        elif tz is not None:\n            result = tz.fromutc(result)\n        return result"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def fromtimestamp(cls, t, tz=None):\n        \"\"\"Construct a datetime from a POSIX timestamp (like time.time()).\n\n        A timezone info object may be passed in as well.\n        \"\"\"\n        _check_tzinfo_arg(tz)\n\n        return cls._fromtimestamp(t, tz is not None, tz)"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def utcfromtimestamp(cls, t):\n        \"\"\"Construct a naive UTC datetime from a POSIX timestamp.\"\"\"\n        return cls._fromtimestamp(t, True, None)"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def now(cls, tz=None):\n        \"Construct a datetime from time.time() and optional time zone info.\"\n        t = _time.time()\n        return cls.fromtimestamp(t, tz)"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def utcnow(cls):\n        \"Construct a UTC datetime from time.time().\"\n        t = _time.time()\n        return cls.utcfromtimestamp(t)"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def combine(cls, date, time, tzinfo=True):\n        \"Construct a datetime from a given date and a given time.\"\n        if not isinstance(date, _date_class):\n            raise TypeError(\"date argument must be a date instance\")\n        if not isinstance(time, _time_class):\n            raise TypeError(\"time argument must be a time instance\")\n        if tzinfo is True:\n            tzinfo = time.tzinfo\n        return cls(date.year, date.month, date.day,\n                   time.hour, time.minute, time.second, time.microsecond,\n                   tzinfo, fold=time.fold)"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def fromisoformat(cls, date_string):\n        \"\"\"Construct a datetime from a string in one of the ISO 8601 formats.\"\"\"\n        if not isinstance(date_string, str):\n            raise TypeError('fromisoformat: argument must be str')\n\n        if len(date_string) < 7:\n            raise ValueError(f'Invalid isoformat string: {date_string!r}')\n\n        # Split this at the separator\n        try:\n            separator_location = _find_isoformat_datetime_separator(date_string)\n            dstr = date_string[0:separator_location]\n            tstr = date_string[(separator_location+1):]\n\n            date_components = _parse_isoformat_date(dstr)\n        except ValueError:\n            raise ValueError(\n                f'Invalid isoformat string: {date_string!r}') from None\n\n        if tstr:\n            try:\n                time_components = _parse_isoformat_time(tstr)\n            except ValueError:\n                raise ValueError(\n                    f'Invalid isoformat string: {date_string!r}') from None\n        else:\n            time_components = [0, 0, 0, 0, None]\n\n        return cls(*(date_components + time_components))"
        ],
        [
            "STORE_NAME",
            "    def timetuple(self):\n        \"Return local time tuple compatible with time.localtime().\"\n        dst = self.dst()\n        if dst is None:\n            dst = -1\n        elif dst:\n            dst = 1\n        else:\n            dst = 0\n        return _build_struct_time(self.year, self.month, self.day,\n                                  self.hour, self.minute, self.second,\n                                  dst)"
        ],
        [
            "STORE_NAME",
            "    def _mktime(self):\n        \"\"\"Return integer POSIX timestamp.\"\"\"\n        epoch = datetime(1970, 1, 1)\n        max_fold_seconds = 24 * 3600\n        t = (self - epoch) // timedelta(0, 1)\n        def local(u):\n            y, m, d, hh, mm, ss = _time.localtime(u)[:6]\n            return (datetime(y, m, d, hh, mm, ss) - epoch) // timedelta(0, 1)\n\n        # Our goal is to solve t = local(u) for u.\n        a = local(t) - t\n        u1 = t - a\n        t1 = local(u1)\n        if t1 == t:\n            # We found one solution, but it may not be the one we need.\n            # Look for an earlier solution (if `fold` is 0), or a\n            # later one (if `fold` is 1).\n            u2 = u1 + (-max_fold_seconds, max_fold_seconds)[self.fold]\n            b = local(u2) - u2\n            if a == b:\n                return u1\n        else:\n            b = t1 - u1\n            assert a != b\n        u2 = t - b\n        t2 = local(u2)\n        if t2 == t:\n            return u2\n        if t1 == t:\n            return u1\n        # We have found both offsets a and b, but neither t - a nor t - b is\n        # a solution.  This means t is in the gap.\n        return (max, min)[self.fold](u1, u2)"
        ],
        [
            "STORE_NAME",
            "    def timestamp(self):\n        \"Return POSIX timestamp as float\"\n        if self._tzinfo is None:\n            s = self._mktime()\n            return s + self.microsecond / 1e6\n        else:\n            return (self - _EPOCH).total_seconds()"
        ],
        [
            "STORE_NAME",
            "    def utctimetuple(self):\n        \"Return UTC time tuple compatible with time.gmtime().\"\n        offset = self.utcoffset()\n        if offset:\n            self -= offset\n        y, m, d = self.year, self.month, self.day\n        hh, mm, ss = self.hour, self.minute, self.second\n        return _build_struct_time(y, m, d, hh, mm, ss, 0)"
        ],
        [
            "STORE_NAME",
            "    def date(self):\n        \"Return the date part.\"\n        return date(self._year, self._month, self._day)"
        ],
        [
            "STORE_NAME",
            "    def time(self):\n        \"Return the time part, with tzinfo None.\"\n        return time(self.hour, self.minute, self.second, self.microsecond, fold=self.fold)"
        ],
        [
            "STORE_NAME",
            "    def timetz(self):\n        \"Return the time part, with same tzinfo.\"\n        return time(self.hour, self.minute, self.second, self.microsecond,\n                    self._tzinfo, fold=self.fold)"
        ],
        [
            "STORE_NAME",
            "    def replace(self, year=None, month=None, day=None, hour=None,\n                minute=None, second=None, microsecond=None, tzinfo=True,\n                *, fold=None):\n        \"\"\"Return a new datetime with new values for the specified fields.\"\"\"\n        if year is None:\n            year = self.year\n        if month is None:\n            month = self.month\n        if day is None:\n            day = self.day\n        if hour is None:\n            hour = self.hour\n        if minute is None:\n            minute = self.minute\n        if second is None:\n            second = self.second\n        if microsecond is None:\n            microsecond = self.microsecond\n        if tzinfo is True:\n            tzinfo = self.tzinfo\n        if fold is None:\n            fold = self.fold\n        return type(self)(year, month, day, hour, minute, second,\n                          microsecond, tzinfo, fold=fold)"
        ],
        [
            "STORE_NAME",
            "    def _local_timezone(self):\n        if self.tzinfo is None:\n            ts = self._mktime()\n        else:\n            ts = (self - _EPOCH) // timedelta(seconds=1)\n        localtm = _time.localtime(ts)\n        local = datetime(*localtm[:6])\n        # Extract TZ data\n        gmtoff = localtm.tm_gmtoff\n        zone = localtm.tm_zone\n        return timezone(timedelta(seconds=gmtoff), zone)"
        ],
        [
            "STORE_NAME",
            "    def astimezone(self, tz=None):\n        if tz is None:\n            tz = self._local_timezone()\n        elif not isinstance(tz, tzinfo):\n            raise TypeError(\"tz argument must be an instance of tzinfo\")\n\n        mytz = self.tzinfo\n        if mytz is None:\n            mytz = self._local_timezone()\n            myoffset = mytz.utcoffset(self)\n        else:\n            myoffset = mytz.utcoffset(self)\n            if myoffset is None:\n                mytz = self.replace(tzinfo=None)._local_timezone()\n                myoffset = mytz.utcoffset(self)\n\n        if tz is mytz:\n            return self\n\n        # Convert self to UTC, and attach the new time zone object.\n        utc = (self - myoffset).replace(tzinfo=tz)\n\n        # Convert from UTC to tz's local time.\n        return tz.fromutc(utc)"
        ],
        [
            "STORE_NAME",
            "    def ctime(self):\n        \"Return ctime() style string.\"\n        weekday = self.toordinal() % 7 or 7\n        return \"%s %s %2d %02d:%02d:%02d %04d\" % (\n            _DAYNAMES[weekday],\n            _MONTHNAMES[self._month],\n            self._day,\n            self._hour, self._minute, self._second,\n            self._year)"
        ],
        [
            "STORE_NAME",
            "    def isoformat(self, sep='T', timespec='auto'):\n        \"\"\"Return the time formatted according to ISO.\n\n        The full format looks like 'YYYY-MM-DD HH:MM:SS.mmmmmm'.\n        By default, the fractional part is omitted if self.microsecond == 0.\n\n        If self.tzinfo is not None, the UTC offset is also attached, giving\n        giving a full format of 'YYYY-MM-DD HH:MM:SS.mmmmmm+HH:MM'.\n\n        Optional argument sep specifies the separator between date and\n        time, default 'T'.\n\n        The optional argument timespec specifies the number of additional\n        terms of the time to include. Valid options are 'auto', 'hours',\n        'minutes', 'seconds', 'milliseconds' and 'microseconds'.\n        \"\"\"\n        s = (\"%04d-%02d-%02d%c\" % (self._year, self._month, self._day, sep) +\n             _format_time(self._hour, self._minute, self._second,\n                          self._microsecond, timespec))\n\n        off = self.utcoffset()\n        tz = _format_offset(off)\n        if tz:\n            s += tz\n\n        return s"
        ],
        [
            "STORE_NAME",
            "    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\"\"\"\n        L = [self._year, self._month, self._day,  # These are never zero\n             self._hour, self._minute, self._second, self._microsecond]\n        if L[-1] == 0:\n            del L[-1]\n        if L[-1] == 0:\n            del L[-1]\n        s = \"%s.%s(%s)\" % (self.__class__.__module__,\n                           self.__class__.__qualname__,\n                           \", \".join(map(str, L)))\n        if self._tzinfo is not None:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", tzinfo=%r\" % self._tzinfo + \")\"\n        if self._fold:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", fold=1)\"\n        return s"
        ],
        [
            "STORE_NAME",
            "    def __str__(self):\n        \"Convert to string, for str().\"\n        return self.isoformat(sep=' ')"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def strptime(cls, date_string, format):\n        'string, format -> new datetime parsed from a string (like time.strptime()).'\n        import _strptime\n        return _strptime._strptime_datetime(cls, date_string, format)"
        ],
        [
            "STORE_NAME",
            "    def utcoffset(self):\n        \"\"\"Return the timezone offset as timedelta positive east of UTC (negative west of\n        UTC).\"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.utcoffset(self)\n        _check_utc_offset(\"utcoffset\", offset)\n        return offset"
        ],
        [
            "STORE_NAME",
            "    def tzname(self):\n        \"\"\"Return the timezone name.\n\n        Note that the name is 100% informational -- there's no requirement that\n        it mean anything in particular. For example, \"GMT\", \"UTC\", \"-500\",\n        \"-5:00\", \"EDT\", \"US/Eastern\", \"America/New York\" are all valid replies.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        name = self._tzinfo.tzname(self)\n        _check_tzname(name)\n        return name"
        ],
        [
            "STORE_NAME",
            "    def dst(self):\n        \"\"\"Return 0 if DST is not in effect, or the DST offset (as timedelta\n        positive eastward) if DST is in effect.\n\n        This is purely informational; the DST offset has already been added to\n        the UTC offset returned by utcoffset() if applicable, so there's no\n        need to consult dst() unless you're interested in displaying the DST\n        info.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.dst(self)\n        _check_utc_offset(\"dst\", offset)\n        return offset"
        ],
        [
            "STORE_NAME",
            "    def __eq__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other, allow_mixed=True) == 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            return False"
        ],
        [
            "STORE_NAME",
            "    def __le__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) <= 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)"
        ],
        [
            "STORE_NAME",
            "    def __lt__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) < 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)"
        ],
        [
            "STORE_NAME",
            "    def __ge__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) >= 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)"
        ],
        [
            "STORE_NAME",
            "    def __gt__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) > 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)"
        ],
        [
            "STORE_NAME",
            "    def _cmp(self, other, allow_mixed=False):\n        assert isinstance(other, datetime)\n        mytz = self._tzinfo\n        ottz = other._tzinfo\n        myoff = otoff = None\n\n        if mytz is ottz:\n            base_compare = True\n        else:\n            myoff = self.utcoffset()\n            otoff = other.utcoffset()\n            # Assume that allow_mixed means that we are called from __eq__\n            if allow_mixed:\n                if myoff != self.replace(fold=not self.fold).utcoffset():\n                    return 2\n                if otoff != other.replace(fold=not other.fold).utcoffset():\n                    return 2\n            base_compare = myoff == otoff\n\n        if base_compare:\n            return _cmp((self._year, self._month, self._day,\n                         self._hour, self._minute, self._second,\n                         self._microsecond),\n                        (other._year, other._month, other._day,\n                         other._hour, other._minute, other._second,\n                         other._microsecond))\n        if myoff is None or otoff is None:\n            if allow_mixed:\n                return 2 # arbitrary non-zero value\n            else:\n                raise TypeError(\"cannot compare naive and aware datetimes\")\n        # XXX What follows could be done more efficiently...\n        diff = self - other     # this will take offsets into account\n        if diff.days < 0:\n            return -1\n        return diff and 1 or 0"
        ],
        [
            "STORE_NAME",
            "    def __add__(self, other):\n        \"Add a datetime and a timedelta.\"\n        if not isinstance(other, timedelta):\n            return NotImplemented\n        delta = timedelta(self.toordinal(),\n                          hours=self._hour,\n                          minutes=self._minute,\n                          seconds=self._second,\n                          microseconds=self._microsecond)\n        delta += other\n        hour, rem = divmod(delta.seconds, 3600)\n        minute, second = divmod(rem, 60)\n        if 0 < delta.days <= _MAXORDINAL:\n            return type(self).combine(date.fromordinal(delta.days),\n                                      time(hour, minute, second,\n                                           delta.microseconds,\n                                           tzinfo=self._tzinfo))\n        raise OverflowError(\"result out of range\")"
        ],
        [
            "LOAD_NAME",
            "__add__"
        ],
        [
            "STORE_NAME",
            "__radd__"
        ],
        [
            "STORE_NAME",
            "    def __sub__(self, other):\n        \"Subtract two datetimes, or a datetime and a timedelta.\"\n        if not isinstance(other, datetime):\n            if isinstance(other, timedelta):\n                return self + -other\n            return NotImplemented\n\n        days1 = self.toordinal()\n        days2 = other.toordinal()\n        secs1 = self._second + self._minute * 60 + self._hour * 3600\n        secs2 = other._second + other._minute * 60 + other._hour * 3600\n        base = timedelta(days1 - days2,\n                         secs1 - secs2,\n                         self._microsecond - other._microsecond)\n        if self._tzinfo is other._tzinfo:\n            return base\n        myoff = self.utcoffset()\n        otoff = other.utcoffset()\n        if myoff == otoff:\n            return base\n        if myoff is None or otoff is None:\n            raise TypeError(\"cannot mix naive and timezone-aware time\")\n        return base + otoff - myoff"
        ],
        [
            "STORE_NAME",
            "    def __hash__(self):\n        if self._hashcode == -1:\n            if self.fold:\n                t = self.replace(fold=0)\n            else:\n                t = self\n            tzoff = t.utcoffset()\n            if tzoff is None:\n                self._hashcode = hash(t._getstate()[0])\n            else:\n                days = _ymd2ord(self.year, self.month, self.day)\n                seconds = self.hour * 3600 + self.minute * 60 + self.second\n                self._hashcode = hash(timedelta(days, seconds, self.microsecond) - tzoff)\n        return self._hashcode"
        ],
        [
            "STORE_NAME",
            "    def _getstate(self, protocol=3):\n        yhi, ylo = divmod(self._year, 256)\n        us2, us3 = divmod(self._microsecond, 256)\n        us1, us2 = divmod(us2, 256)\n        m = self._month\n        if self._fold and protocol > 3:\n            m += 128\n        basestate = bytes([yhi, ylo, m, self._day,\n                           self._hour, self._minute, self._second,\n                           us1, us2, us3])\n        if self._tzinfo is None:\n            return (basestate,)\n        else:\n            return (basestate, self._tzinfo)"
        ],
        [
            "STORE_NAME",
            "    def __setstate(self, string, tzinfo):\n        if tzinfo is not None and not isinstance(tzinfo, _tzinfo_class):\n            raise TypeError(\"bad tzinfo state arg\")\n        (yhi, ylo, m, self._day, self._hour,\n         self._minute, self._second, us1, us2, us3) = string\n        if m > 127:\n            self._fold = 1\n            self._month = m - 128\n        else:\n            self._fold = 0\n            self._month = m\n        self._year = yhi * 256 + ylo\n        self._microsecond = (((us1 << 8) | us2) << 8) | us3\n        self._tzinfo = tzinfo"
        ],
        [
            "STORE_NAME",
            "    def __reduce_ex__(self, protocol):\n        return (self.__class__, self._getstate(protocol))"
        ],
        [
            "STORE_NAME",
            "    def __reduce__(self):\n        return self.__reduce_ex__(2)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "LOAD_GLOBAL",
            "bytes"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "CALL",
            "isinstance(year, (bytes, str))"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "CALL",
            "len(year)"
        ],
        [
            "COMPARE_OP",
            "len(year) == 10"
        ],
        [
            "LOAD_GLOBAL",
            "ord"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "BINARY_SUBSCR",
            "year[2:3]"
        ],
        [
            "CALL",
            "ord(year[2:3])"
        ],
        [
            "BINARY_OP",
            "ord(year[2:3])&0x7F"
        ],
        [
            "COMPARE_OP",
            "1 <= ord(year[2:3])&0x7F <= 12"
        ],
        [
            "COMPARE_OP",
            "1 <= ord(year[2:3])&0x7F <= 12"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "CALL",
            "isinstance(year, str)"
        ],
        [
            "LOAD_GLOBAL",
            "bytes"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "CALL",
            "bytes(year, 'latin1')"
        ],
        [
            "STORE_FAST",
            "year"
        ],
        [
            "LOAD_GLOBAL",
            "UnicodeEncodeError"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError(\n                        \"Failed to encode latin1 string when unpickling \"\n                        \"a datetime object. \"\n                        \"pickle.load(data, encoding='latin1') is assumed.\")"
        ],
        [
            "LOAD_GLOBAL",
            "object"
        ],
        [
            "LOAD_METHOD",
            "object.__new__"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "CALL",
            "object.__new__(cls)"
        ],
        [
            "STORE_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.__setstate"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "CALL",
            "self.__setstate(year, month)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._hashcode"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_GLOBAL",
            "_check_date_fields"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "LOAD_FAST",
            "day"
        ],
        [
            "CALL",
            "_check_date_fields(year, month, day)"
        ],
        [
            "STORE_FAST",
            "year"
        ],
        [
            "STORE_FAST",
            "month"
        ],
        [
            "STORE_FAST",
            "day"
        ],
        [
            "LOAD_GLOBAL",
            "_check_time_fields"
        ],
        [
            "LOAD_FAST",
            "hour"
        ],
        [
            "LOAD_FAST",
            "minute"
        ],
        [
            "LOAD_FAST",
            "second"
        ],
        [
            "LOAD_FAST",
            "microsecond"
        ],
        [
            "LOAD_FAST",
            "fold"
        ],
        [
            "CALL",
            "_check_time_fields(\n            hour, minute, second, microsecond, fold)"
        ],
        [
            "STORE_FAST",
            "hour"
        ],
        [
            "STORE_FAST",
            "minute"
        ],
        [
            "STORE_FAST",
            "second"
        ],
        [
            "STORE_FAST",
            "microsecond"
        ],
        [
            "STORE_FAST",
            "fold"
        ],
        [
            "LOAD_GLOBAL",
            "_check_tzinfo_arg"
        ],
        [
            "LOAD_FAST",
            "tzinfo"
        ],
        [
            "CALL",
            "_check_tzinfo_arg(tzinfo)"
        ],
        [
            "LOAD_GLOBAL",
            "object"
        ],
        [
            "LOAD_METHOD",
            "object.__new__"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "CALL",
            "object.__new__(cls)"
        ],
        [
            "STORE_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._year"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._month"
        ],
        [
            "LOAD_FAST",
            "day"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._day"
        ],
        [
            "LOAD_FAST",
            "hour"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._hour"
        ],
        [
            "LOAD_FAST",
            "minute"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._minute"
        ],
        [
            "LOAD_FAST",
            "second"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._second"
        ],
        [
            "LOAD_FAST",
            "microsecond"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._microsecond"
        ],
        [
            "LOAD_FAST",
            "tzinfo"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._tzinfo"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._hashcode"
        ],
        [
            "LOAD_FAST",
            "fold"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._fold"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._hour"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._minute"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._second"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._microsecond"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._tzinfo"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._fold"
        ],
        [
            "LOAD_GLOBAL",
            "_math"
        ],
        [
            "LOAD_ATTR",
            "_math.modf"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "CALL",
            "_math.modf(t)"
        ],
        [
            "STORE_FAST",
            "frac"
        ],
        [
            "STORE_FAST",
            "t"
        ],
        [
            "LOAD_GLOBAL",
            "round"
        ],
        [
            "LOAD_FAST",
            "frac"
        ],
        [
            "BINARY_OP",
            "frac * 1e6"
        ],
        [
            "CALL",
            "round(frac * 1e6)"
        ],
        [
            "STORE_FAST",
            "us"
        ],
        [
            "LOAD_FAST",
            "us"
        ],
        [
            "COMPARE_OP",
            "us >= 1000000"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "BINARY_OP",
            "t += 1"
        ],
        [
            "STORE_FAST",
            "t"
        ],
        [
            "LOAD_FAST",
            "us"
        ],
        [
            "BINARY_OP",
            "us -= 1000000"
        ],
        [
            "STORE_FAST",
            "us"
        ],
        [
            "LOAD_FAST",
            "us"
        ],
        [
            "COMPARE_OP",
            "us < 0"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "BINARY_OP",
            "t -= 1"
        ],
        [
            "STORE_FAST",
            "t"
        ],
        [
            "LOAD_FAST",
            "us"
        ],
        [
            "BINARY_OP",
            "us += 1000000"
        ],
        [
            "STORE_FAST",
            "us"
        ],
        [
            "LOAD_FAST",
            "utc"
        ],
        [
            "LOAD_GLOBAL",
            "_time"
        ],
        [
            "LOAD_ATTR",
            "_time.gmtime"
        ],
        [
            "LOAD_GLOBAL",
            "_time"
        ],
        [
            "LOAD_ATTR",
            "_time.localtime"
        ],
        [
            "STORE_FAST",
            "converter"
        ],
        [
            "LOAD_FAST",
            "converter"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "CALL",
            "converter(t)"
        ],
        [
            "STORE_FAST",
            "y"
        ],
        [
            "STORE_FAST",
            "m"
        ],
        [
            "STORE_FAST",
            "d"
        ],
        [
            "STORE_FAST",
            "hh"
        ],
        [
            "STORE_FAST",
            "mm"
        ],
        [
            "STORE_FAST",
            "ss"
        ],
        [
            "STORE_FAST",
            "weekday"
        ],
        [
            "STORE_FAST",
            "jday"
        ],
        [
            "STORE_FAST",
            "dst"
        ],
        [
            "LOAD_GLOBAL",
            "min"
        ],
        [
            "LOAD_FAST",
            "ss"
        ],
        [
            "CALL",
            "min(ss, 59)"
        ],
        [
            "STORE_FAST",
            "ss"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_FAST",
            "y"
        ],
        [
            "LOAD_FAST",
            "m"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "LOAD_FAST",
            "hh"
        ],
        [
            "LOAD_FAST",
            "mm"
        ],
        [
            "LOAD_FAST",
            "ss"
        ],
        [
            "LOAD_FAST",
            "us"
        ],
        [
            "LOAD_FAST",
            "tz"
        ],
        [
            "CALL",
            "cls(y, m, d, hh, mm, ss, us, tz)"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "tz"
        ],
        [
            "LOAD_FAST",
            "utc"
        ],
        [
            "STORE_FAST",
            "max_fold_seconds"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "LOAD_FAST",
            "max_fold_seconds"
        ],
        [
            "COMPARE_OP",
            "t < max_fold_seconds"
        ],
        [
            "LOAD_GLOBAL",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.platform"
        ],
        [
            "LOAD_METHOD",
            "sys.platform.startswith"
        ],
        [
            "CALL",
            "sys.platform.startswith(\"win\")"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "converter"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "LOAD_FAST",
            "max_fold_seconds"
        ],
        [
            "BINARY_OP",
            "t - max_fold_seconds"
        ],
        [
            "CALL",
            "converter(t - max_fold_seconds)"
        ],
        [
            "BINARY_SUBSCR",
            "converter(t - max_fold_seconds)[:6]"
        ],
        [
            "STORE_FAST",
            "y"
        ],
        [
            "STORE_FAST",
            "m"
        ],
        [
            "STORE_FAST",
            "d"
        ],
        [
            "STORE_FAST",
            "hh"
        ],
        [
            "STORE_FAST",
            "mm"
        ],
        [
            "STORE_FAST",
            "ss"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_FAST",
            "y"
        ],
        [
            "LOAD_FAST",
            "m"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "LOAD_FAST",
            "hh"
        ],
        [
            "LOAD_FAST",
            "mm"
        ],
        [
            "LOAD_FAST",
            "ss"
        ],
        [
            "LOAD_FAST",
            "us"
        ],
        [
            "LOAD_FAST",
            "tz"
        ],
        [
            "CALL",
            "cls(y, m, d, hh, mm, ss, us, tz)"
        ],
        [
            "STORE_FAST",
            "probe1"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "probe1"
        ],
        [
            "BINARY_OP",
            "result - probe1"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "LOAD_FAST",
            "max_fold_seconds"
        ],
        [
            "CALL",
            "timedelta(0, max_fold_seconds)"
        ],
        [
            "BINARY_OP",
            "result - probe1 - timedelta(0, max_fold_seconds)"
        ],
        [
            "STORE_FAST",
            "trans"
        ],
        [
            "LOAD_FAST",
            "trans"
        ],
        [
            "LOAD_ATTR",
            "trans.days"
        ],
        [
            "COMPARE_OP",
            "trans.days < 0"
        ],
        [
            "LOAD_FAST",
            "converter"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "LOAD_FAST",
            "trans"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "timedelta(0, 1)"
        ],
        [
            "BINARY_OP",
            "trans // timedelta(0, 1)"
        ],
        [
            "BINARY_OP",
            "t + trans // timedelta(0, 1)"
        ],
        [
            "CALL",
            "converter(t + trans // timedelta(0, 1))"
        ],
        [
            "BINARY_SUBSCR",
            "converter(t + trans // timedelta(0, 1))[:6]"
        ],
        [
            "STORE_FAST",
            "y"
        ],
        [
            "STORE_FAST",
            "m"
        ],
        [
            "STORE_FAST",
            "d"
        ],
        [
            "STORE_FAST",
            "hh"
        ],
        [
            "STORE_FAST",
            "mm"
        ],
        [
            "STORE_FAST",
            "ss"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_FAST",
            "y"
        ],
        [
            "LOAD_FAST",
            "m"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "LOAD_FAST",
            "hh"
        ],
        [
            "LOAD_FAST",
            "mm"
        ],
        [
            "LOAD_FAST",
            "ss"
        ],
        [
            "LOAD_FAST",
            "us"
        ],
        [
            "LOAD_FAST",
            "tz"
        ],
        [
            "CALL",
            "cls(y, m, d, hh, mm, ss, us, tz)"
        ],
        [
            "STORE_FAST",
            "probe2"
        ],
        [
            "LOAD_FAST",
            "probe2"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "COMPARE_OP",
            "probe2 == result"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "STORE_ATTR",
            "result._fold"
        ],
        [
            "LOAD_FAST",
            "tz"
        ],
        [
            "LOAD_FAST",
            "tz"
        ],
        [
            "LOAD_METHOD",
            "tz.fromutc"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "CALL",
            "tz.fromutc(result)"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_GLOBAL",
            "_check_tzinfo_arg"
        ],
        [
            "LOAD_FAST",
            "tz"
        ],
        [
            "CALL",
            "_check_tzinfo_arg(tz)"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_METHOD",
            "cls._fromtimestamp"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "LOAD_FAST",
            "tz"
        ],
        [
            "IS_OP",
            "tz is not None"
        ],
        [
            "LOAD_FAST",
            "tz"
        ],
        [
            "CALL",
            "cls._fromtimestamp(t, tz is not None, tz)"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_METHOD",
            "cls._fromtimestamp"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "CALL",
            "cls._fromtimestamp(t, True, None)"
        ],
        [
            "LOAD_GLOBAL",
            "_time"
        ],
        [
            "LOAD_ATTR",
            "_time.time"
        ],
        [
            "CALL",
            "_time.time()"
        ],
        [
            "STORE_FAST",
            "t"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_METHOD",
            "cls.fromtimestamp"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "LOAD_FAST",
            "tz"
        ],
        [
            "CALL",
            "cls.fromtimestamp(t, tz)"
        ],
        [
            "LOAD_GLOBAL",
            "_time"
        ],
        [
            "LOAD_ATTR",
            "_time.time"
        ],
        [
            "CALL",
            "_time.time()"
        ],
        [
            "STORE_FAST",
            "t"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_METHOD",
            "cls.utcfromtimestamp"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "CALL",
            "cls.utcfromtimestamp(t)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "date"
        ],
        [
            "LOAD_GLOBAL",
            "_date_class"
        ],
        [
            "CALL",
            "isinstance(date, _date_class)"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "CALL",
            "TypeError(\"date argument must be a date instance\")"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "time"
        ],
        [
            "LOAD_GLOBAL",
            "_time_class"
        ],
        [
            "CALL",
            "isinstance(time, _time_class)"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "CALL",
            "TypeError(\"time argument must be a time instance\")"
        ],
        [
            "LOAD_FAST",
            "tzinfo"
        ],
        [
            "IS_OP",
            "tzinfo is True"
        ],
        [
            "LOAD_FAST",
            "time"
        ],
        [
            "LOAD_ATTR",
            "time.tzinfo"
        ],
        [
            "STORE_FAST",
            "tzinfo"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_FAST",
            "date"
        ],
        [
            "LOAD_ATTR",
            "date.year"
        ],
        [
            "LOAD_FAST",
            "date"
        ],
        [
            "LOAD_ATTR",
            "date.month"
        ],
        [
            "LOAD_FAST",
            "date"
        ],
        [
            "LOAD_ATTR",
            "date.day"
        ],
        [
            "LOAD_FAST",
            "time"
        ],
        [
            "LOAD_ATTR",
            "time.hour"
        ],
        [
            "LOAD_FAST",
            "time"
        ],
        [
            "LOAD_ATTR",
            "time.minute"
        ],
        [
            "LOAD_FAST",
            "time"
        ],
        [
            "LOAD_ATTR",
            "time.second"
        ],
        [
            "LOAD_FAST",
            "time"
        ],
        [
            "LOAD_ATTR",
            "time.microsecond"
        ],
        [
            "LOAD_FAST",
            "tzinfo"
        ],
        [
            "LOAD_FAST",
            "time"
        ],
        [
            "LOAD_ATTR",
            "time.fold"
        ],
        [
            "CALL",
            "cls(date.year, date.month, date.day,\n                   time.hour, time.minute, time.second, time.microsecond,\n                   tzinfo, fold=time.fold)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "date_string"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "CALL",
            "isinstance(date_string, str)"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "CALL",
            "TypeError('fromisoformat: argument must be str')"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "date_string"
        ],
        [
            "CALL",
            "len(date_string)"
        ],
        [
            "COMPARE_OP",
            "len(date_string) < 7"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "CALL",
            "ValueError(f'Invalid isoformat string: {date_string!r}')"
        ],
        [
            "LOAD_GLOBAL",
            "_find_isoformat_datetime_separator"
        ],
        [
            "LOAD_FAST",
            "date_string"
        ],
        [
            "CALL",
            "_find_isoformat_datetime_separator(date_string)"
        ],
        [
            "STORE_FAST",
            "separator_location"
        ],
        [
            "LOAD_FAST",
            "date_string"
        ],
        [
            "LOAD_FAST",
            "separator_location"
        ],
        [
            "BINARY_SUBSCR",
            "date_string[0:separator_location]"
        ],
        [
            "STORE_FAST",
            "dstr"
        ],
        [
            "LOAD_FAST",
            "date_string"
        ],
        [
            "LOAD_FAST",
            "separator_location"
        ],
        [
            "BINARY_OP",
            "separator_location+1"
        ],
        [
            "BINARY_SUBSCR",
            "date_string[(separator_location+1):]"
        ],
        [
            "STORE_FAST",
            "tstr"
        ],
        [
            "LOAD_GLOBAL",
            "_parse_isoformat_date"
        ],
        [
            "LOAD_FAST",
            "dstr"
        ],
        [
            "CALL",
            "_parse_isoformat_date(dstr)"
        ],
        [
            "STORE_FAST",
            "date_components"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "CALL",
            "ValueError(\n                f'Invalid isoformat string: {date_string!r}')"
        ],
        [
            "LOAD_FAST",
            "tstr"
        ],
        [
            "LOAD_GLOBAL",
            "_parse_isoformat_time"
        ],
        [
            "LOAD_FAST",
            "tstr"
        ],
        [
            "CALL",
            "_parse_isoformat_time(tstr)"
        ],
        [
            "STORE_FAST",
            "time_components"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "CALL",
            "ValueError(\n                    f'Invalid isoformat string: {date_string!r}')"
        ],
        [
            "STORE_FAST",
            "time_components"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_FAST",
            "date_components"
        ],
        [
            "LOAD_FAST",
            "time_components"
        ],
        [
            "BINARY_OP",
            "date_components + time_components"
        ],
        [
            "CALL_FUNCTION_EX",
            "cls(*(date_components + time_components))"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.dst"
        ],
        [
            "CALL",
            "self.dst()"
        ],
        [
            "STORE_FAST",
            "dst"
        ],
        [
            "LOAD_FAST",
            "dst"
        ],
        [
            "STORE_FAST",
            "dst"
        ],
        [
            "LOAD_FAST",
            "dst"
        ],
        [
            "STORE_FAST",
            "dst"
        ],
        [
            "STORE_FAST",
            "dst"
        ],
        [
            "LOAD_GLOBAL",
            "_build_struct_time"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.year"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.month"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.day"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.hour"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.minute"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.second"
        ],
        [
            "LOAD_FAST",
            "dst"
        ],
        [
            "CALL",
            "_build_struct_time(self.year, self.month, self.day,\n                                  self.hour, self.minute, self.second,\n                                  dst)"
        ],
        [
            "LOAD_GLOBAL",
            "datetime"
        ],
        [
            "CALL",
            "datetime(1970, 1, 1)"
        ],
        [
            "STORE_DEREF",
            "epoch"
        ],
        [
            "STORE_FAST",
            "max_fold_seconds"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_DEREF",
            "epoch"
        ],
        [
            "BINARY_OP",
            "self - epoch"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "timedelta(0, 1)"
        ],
        [
            "BINARY_OP",
            "(self - epoch) // timedelta(0, 1)"
        ],
        [
            "STORE_FAST",
            "t"
        ],
        [
            "STORE_FAST",
            "        def local(u):\n            y, m, d, hh, mm, ss = _time.localtime(u)[:6]\n            return (datetime(y, m, d, hh, mm, ss) - epoch) // timedelta(0, 1)"
        ],
        [
            "LOAD_FAST",
            "local"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "CALL",
            "local(t)"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "BINARY_OP",
            "local(t) - t"
        ],
        [
            "STORE_FAST",
            "a"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "LOAD_FAST",
            "a"
        ],
        [
            "BINARY_OP",
            "t - a"
        ],
        [
            "STORE_FAST",
            "u1"
        ],
        [
            "LOAD_FAST",
            "local"
        ],
        [
            "LOAD_FAST",
            "u1"
        ],
        [
            "CALL",
            "local(u1)"
        ],
        [
            "STORE_FAST",
            "t1"
        ],
        [
            "LOAD_FAST",
            "t1"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "COMPARE_OP",
            "t1 == t"
        ],
        [
            "LOAD_FAST",
            "u1"
        ],
        [
            "LOAD_FAST",
            "max_fold_seconds"
        ],
        [
            "UNARY_NEGATIVE",
            "-max_fold_seconds"
        ],
        [
            "LOAD_FAST",
            "max_fold_seconds"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.fold"
        ],
        [
            "BINARY_SUBSCR",
            "(-max_fold_seconds, max_fold_seconds)[self.fold]"
        ],
        [
            "BINARY_OP",
            "u1 + (-max_fold_seconds, max_fold_seconds)[self.fold]"
        ],
        [
            "STORE_FAST",
            "u2"
        ],
        [
            "LOAD_FAST",
            "local"
        ],
        [
            "LOAD_FAST",
            "u2"
        ],
        [
            "CALL",
            "local(u2)"
        ],
        [
            "LOAD_FAST",
            "u2"
        ],
        [
            "BINARY_OP",
            "local(u2) - u2"
        ],
        [
            "STORE_FAST",
            "b"
        ],
        [
            "LOAD_FAST",
            "a"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "COMPARE_OP",
            "a == b"
        ],
        [
            "LOAD_FAST",
            "u1"
        ],
        [
            "LOAD_FAST",
            "t1"
        ],
        [
            "LOAD_FAST",
            "u1"
        ],
        [
            "BINARY_OP",
            "t1 - u1"
        ],
        [
            "STORE_FAST",
            "b"
        ],
        [
            "LOAD_FAST",
            "a"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "COMPARE_OP",
            "a != b"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "BINARY_OP",
            "t - b"
        ],
        [
            "STORE_FAST",
            "u2"
        ],
        [
            "LOAD_FAST",
            "local"
        ],
        [
            "LOAD_FAST",
            "u2"
        ],
        [
            "CALL",
            "local(u2)"
        ],
        [
            "STORE_FAST",
            "t2"
        ],
        [
            "LOAD_FAST",
            "t2"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "COMPARE_OP",
            "t2 == t"
        ],
        [
            "LOAD_FAST",
            "u2"
        ],
        [
            "LOAD_FAST",
            "t1"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "COMPARE_OP",
            "t1 == t"
        ],
        [
            "LOAD_FAST",
            "u1"
        ],
        [
            "LOAD_GLOBAL",
            "max"
        ],
        [
            "LOAD_GLOBAL",
            "min"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.fold"
        ],
        [
            "BINARY_SUBSCR",
            "(max, min)[self.fold]"
        ],
        [
            "LOAD_FAST",
            "u1"
        ],
        [
            "LOAD_FAST",
            "u2"
        ],
        [
            "CALL",
            "(max, min)[self.fold](u1, u2)"
        ],
        [
            "LOAD_GLOBAL",
            "_time"
        ],
        [
            "LOAD_ATTR",
            "_time.localtime"
        ],
        [
            "LOAD_FAST",
            "u"
        ],
        [
            "CALL",
            "_time.localtime(u)"
        ],
        [
            "BINARY_SUBSCR",
            "_time.localtime(u)[:6]"
        ],
        [
            "STORE_FAST",
            "y"
        ],
        [
            "STORE_FAST",
            "m"
        ],
        [
            "STORE_FAST",
            "d"
        ],
        [
            "STORE_FAST",
            "hh"
        ],
        [
            "STORE_FAST",
            "mm"
        ],
        [
            "STORE_FAST",
            "ss"
        ],
        [
            "LOAD_GLOBAL",
            "datetime"
        ],
        [
            "LOAD_FAST",
            "y"
        ],
        [
            "LOAD_FAST",
            "m"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "LOAD_FAST",
            "hh"
        ],
        [
            "LOAD_FAST",
            "mm"
        ],
        [
            "LOAD_FAST",
            "ss"
        ],
        [
            "CALL",
            "datetime(y, m, d, hh, mm, ss)"
        ],
        [
            "LOAD_DEREF",
            "epoch"
        ],
        [
            "BINARY_OP",
            "datetime(y, m, d, hh, mm, ss) - epoch"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "timedelta(0, 1)"
        ],
        [
            "BINARY_OP",
            "(datetime(y, m, d, hh, mm, ss) - epoch) // timedelta(0, 1)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._tzinfo"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._mktime"
        ],
        [
            "CALL",
            "self._mktime()"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.microsecond"
        ],
        [
            "BINARY_OP",
            "self.microsecond / 1e6"
        ],
        [
            "BINARY_OP",
            "s + self.microsecond / 1e6"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_GLOBAL",
            "_EPOCH"
        ],
        [
            "BINARY_OP",
            "self - _EPOCH"
        ],
        [
            "LOAD_METHOD",
            "(self - _EPOCH).total_seconds"
        ],
        [
            "CALL",
            "(self - _EPOCH).total_seconds()"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.utcoffset"
        ],
        [
            "CALL",
            "self.utcoffset()"
        ],
        [
            "STORE_FAST",
            "offset"
        ],
        [
            "LOAD_FAST",
            "offset"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "offset"
        ],
        [
            "BINARY_OP",
            "self -= offset"
        ],
        [
            "STORE_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.year"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.month"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.day"
        ],
        [
            "STORE_FAST",
            "d"
        ],
        [
            "STORE_FAST",
            "m"
        ],
        [
            "STORE_FAST",
            "y"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.hour"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.minute"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.second"
        ],
        [
            "STORE_FAST",
            "ss"
        ],
        [
            "STORE_FAST",
            "mm"
        ],
        [
            "STORE_FAST",
            "hh"
        ],
        [
            "LOAD_GLOBAL",
            "_build_struct_time"
        ],
        [
            "LOAD_FAST",
            "y"
        ],
        [
            "LOAD_FAST",
            "m"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "LOAD_FAST",
            "hh"
        ],
        [
            "LOAD_FAST",
            "mm"
        ],
        [
            "LOAD_FAST",
            "ss"
        ],
        [
            "CALL",
            "_build_struct_time(y, m, d, hh, mm, ss, 0)"
        ],
        [
            "LOAD_GLOBAL",
            "date"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._year"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._month"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._day"
        ],
        [
            "CALL",
            "date(self._year, self._month, self._day)"
        ],
        [
            "LOAD_GLOBAL",
            "time"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.hour"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.minute"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.second"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.microsecond"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.fold"
        ],
        [
            "CALL",
            "time(self.hour, self.minute, self.second, self.microsecond, fold=self.fold)"
        ],
        [
            "LOAD_GLOBAL",
            "time"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.hour"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.minute"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.second"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.microsecond"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._tzinfo"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.fold"
        ],
        [
            "CALL",
            "time(self.hour, self.minute, self.second, self.microsecond,\n                    self._tzinfo, fold=self.fold)"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.year"
        ],
        [
            "STORE_FAST",
            "year"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.month"
        ],
        [
            "STORE_FAST",
            "month"
        ],
        [
            "LOAD_FAST",
            "day"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.day"
        ],
        [
            "STORE_FAST",
            "day"
        ],
        [
            "LOAD_FAST",
            "hour"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.hour"
        ],
        [
            "STORE_FAST",
            "hour"
        ],
        [
            "LOAD_FAST",
            "minute"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.minute"
        ],
        [
            "STORE_FAST",
            "minute"
        ],
        [
            "LOAD_FAST",
            "second"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.second"
        ],
        [
            "STORE_FAST",
            "second"
        ],
        [
            "LOAD_FAST",
            "microsecond"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.microsecond"
        ],
        [
            "STORE_FAST",
            "microsecond"
        ],
        [
            "LOAD_FAST",
            "tzinfo"
        ],
        [
            "IS_OP",
            "tzinfo is True"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.tzinfo"
        ],
        [
            "STORE_FAST",
            "tzinfo"
        ],
        [
            "LOAD_FAST",
            "fold"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.fold"
        ],
        [
            "STORE_FAST",
            "fold"
        ],
        [
            "LOAD_GLOBAL",
            "type"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "type(self)"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "LOAD_FAST",
            "month"
        ],
        [
            "LOAD_FAST",
            "day"
        ],
        [
            "LOAD_FAST",
            "hour"
        ],
        [
            "LOAD_FAST",
            "minute"
        ],
        [
            "LOAD_FAST",
            "second"
        ],
        [
            "LOAD_FAST",
            "microsecond"
        ],
        [
            "LOAD_FAST",
            "tzinfo"
        ],
        [
            "LOAD_FAST",
            "fold"
        ],
        [
            "CALL",
            "type(self)(year, month, day, hour, minute, second,\n                          microsecond, tzinfo, fold=fold)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.tzinfo"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._mktime"
        ],
        [
            "CALL",
            "self._mktime()"
        ],
        [
            "STORE_FAST",
            "ts"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_GLOBAL",
            "_EPOCH"
        ],
        [
            "BINARY_OP",
            "self - _EPOCH"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "timedelta(seconds=1)"
        ],
        [
            "BINARY_OP",
            "(self - _EPOCH) // timedelta(seconds=1)"
        ],
        [
            "STORE_FAST",
            "ts"
        ],
        [
            "LOAD_GLOBAL",
            "_time"
        ],
        [
            "LOAD_ATTR",
            "_time.localtime"
        ],
        [
            "LOAD_FAST",
            "ts"
        ],
        [
            "CALL",
            "_time.localtime(ts)"
        ],
        [
            "STORE_FAST",
            "localtm"
        ],
        [
            "LOAD_GLOBAL",
            "datetime"
        ],
        [
            "LOAD_FAST",
            "localtm"
        ],
        [
            "BINARY_SUBSCR",
            "localtm[:6]"
        ],
        [
            "CALL_FUNCTION_EX",
            "datetime(*localtm[:6])"
        ],
        [
            "STORE_FAST",
            "local"
        ],
        [
            "LOAD_FAST",
            "localtm"
        ],
        [
            "LOAD_ATTR",
            "localtm.tm_gmtoff"
        ],
        [
            "STORE_FAST",
            "gmtoff"
        ],
        [
            "LOAD_FAST",
            "localtm"
        ],
        [
            "LOAD_ATTR",
            "localtm.tm_zone"
        ],
        [
            "STORE_FAST",
            "zone"
        ],
        [
            "LOAD_GLOBAL",
            "timezone"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "LOAD_FAST",
            "gmtoff"
        ],
        [
            "CALL",
            "timedelta(seconds=gmtoff)"
        ],
        [
            "LOAD_FAST",
            "zone"
        ],
        [
            "CALL",
            "timezone(timedelta(seconds=gmtoff), zone)"
        ],
        [
            "LOAD_FAST",
            "tz"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._local_timezone"
        ],
        [
            "CALL",
            "self._local_timezone()"
        ],
        [
            "STORE_FAST",
            "tz"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "tz"
        ],
        [
            "LOAD_GLOBAL",
            "tzinfo"
        ],
        [
            "CALL",
            "isinstance(tz, tzinfo)"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "CALL",
            "TypeError(\"tz argument must be an instance of tzinfo\")"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.tzinfo"
        ],
        [
            "STORE_FAST",
            "mytz"
        ],
        [
            "LOAD_FAST",
            "mytz"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._local_timezone"
        ],
        [
            "CALL",
            "self._local_timezone()"
        ],
        [
            "STORE_FAST",
            "mytz"
        ],
        [
            "LOAD_FAST",
            "mytz"
        ],
        [
            "LOAD_METHOD",
            "mytz.utcoffset"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "mytz.utcoffset(self)"
        ],
        [
            "STORE_FAST",
            "myoffset"
        ],
        [
            "LOAD_FAST",
            "mytz"
        ],
        [
            "LOAD_METHOD",
            "mytz.utcoffset"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "mytz.utcoffset(self)"
        ],
        [
            "STORE_FAST",
            "myoffset"
        ],
        [
            "LOAD_FAST",
            "myoffset"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.replace"
        ],
        [
            "CALL",
            "self.replace(tzinfo=None)"
        ],
        [
            "LOAD_METHOD",
            "self.replace(tzinfo=None)._local_timezone"
        ],
        [
            "CALL",
            "self.replace(tzinfo=None)._local_timezone()"
        ],
        [
            "STORE_FAST",
            "mytz"
        ],
        [
            "LOAD_FAST",
            "mytz"
        ],
        [
            "LOAD_METHOD",
            "mytz.utcoffset"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "mytz.utcoffset(self)"
        ],
        [
            "STORE_FAST",
            "myoffset"
        ],
        [
            "LOAD_FAST",
            "tz"
        ],
        [
            "LOAD_FAST",
            "mytz"
        ],
        [
            "IS_OP",
            "tz is mytz"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "myoffset"
        ],
        [
            "BINARY_OP",
            "self - myoffset"
        ],
        [
            "LOAD_METHOD",
            "(self - myoffset).replace"
        ],
        [
            "LOAD_FAST",
            "tz"
        ],
        [
            "CALL",
            "(self - myoffset).replace(tzinfo=tz)"
        ],
        [
            "STORE_FAST",
            "utc"
        ],
        [
            "LOAD_FAST",
            "tz"
        ],
        [
            "LOAD_METHOD",
            "tz.fromutc"
        ],
        [
            "LOAD_FAST",
            "utc"
        ],
        [
            "CALL",
            "tz.fromutc(utc)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.toordinal"
        ],
        [
            "CALL",
            "self.toordinal()"
        ],
        [
            "BINARY_OP",
            "self.toordinal() % 7"
        ],
        [
            "STORE_FAST",
            "weekday"
        ],
        [
            "LOAD_GLOBAL",
            "_DAYNAMES"
        ],
        [
            "LOAD_FAST",
            "weekday"
        ],
        [
            "BINARY_SUBSCR",
            "_DAYNAMES[weekday]"
        ],
        [
            "LOAD_GLOBAL",
            "_MONTHNAMES"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._month"
        ],
        [
            "BINARY_SUBSCR",
            "_MONTHNAMES[self._month]"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._day"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._hour"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._minute"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._second"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._year"
        ],
        [
            "BINARY_OP",
            "\"%s %s %2d %02d:%02d:%02d %04d\" % (\n            _DAYNAMES[weekday],\n            _MONTHNAMES[self._month],\n            self._day,\n            self._hour, self._minute, self._second,\n            self._year)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._year"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._month"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._day"
        ],
        [
            "LOAD_FAST",
            "sep"
        ],
        [
            "BINARY_OP",
            "\"%04d-%02d-%02d%c\" % (self._year, self._month, self._day, sep)"
        ],
        [
            "LOAD_GLOBAL",
            "_format_time"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._hour"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._minute"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._second"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._microsecond"
        ],
        [
            "LOAD_FAST",
            "timespec"
        ],
        [
            "CALL",
            "_format_time(self._hour, self._minute, self._second,\n                          self._microsecond, timespec)"
        ],
        [
            "BINARY_OP",
            "\"%04d-%02d-%02d%c\" % (self._year, self._month, self._day, sep) +\n             _format_time(self._hour, self._minute, self._second,\n                          self._microsecond, timespec)"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.utcoffset"
        ],
        [
            "CALL",
            "self.utcoffset()"
        ],
        [
            "STORE_FAST",
            "off"
        ],
        [
            "LOAD_GLOBAL",
            "_format_offset"
        ],
        [
            "LOAD_FAST",
            "off"
        ],
        [
            "CALL",
            "_format_offset(off)"
        ],
        [
            "STORE_FAST",
            "tz"
        ],
        [
            "LOAD_FAST",
            "tz"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "tz"
        ],
        [
            "BINARY_OP",
            "s += tz"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._year"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._month"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._day"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._hour"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._minute"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._second"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._microsecond"
        ],
        [
            "STORE_FAST",
            "L"
        ],
        [
            "LOAD_FAST",
            "L"
        ],
        [
            "BINARY_SUBSCR",
            "L[-1]"
        ],
        [
            "COMPARE_OP",
            "L[-1] == 0"
        ],
        [
            "LOAD_FAST",
            "L"
        ],
        [
            "DELETE_SUBSCR",
            "L[-1]"
        ],
        [
            "LOAD_FAST",
            "L"
        ],
        [
            "BINARY_SUBSCR",
            "L[-1]"
        ],
        [
            "COMPARE_OP",
            "L[-1] == 0"
        ],
        [
            "LOAD_FAST",
            "L"
        ],
        [
            "DELETE_SUBSCR",
            "L[-1]"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.__class__"
        ],
        [
            "LOAD_ATTR",
            "self.__class__.__module__"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.__class__"
        ],
        [
            "LOAD_ATTR",
            "self.__class__.__qualname__"
        ],
        [
            "LOAD_METHOD",
            "\", \".join"
        ],
        [
            "LOAD_GLOBAL",
            "map"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_FAST",
            "L"
        ],
        [
            "CALL",
            "map(str, L)"
        ],
        [
            "CALL",
            "\", \".join(map(str, L))"
        ],
        [
            "BUILD_STRING",
            "\"%s.%s(%s)\" % (self.__class__.__module__,\n                           self.__class__.__qualname__,\n                           \", \".join(map(str, L)))"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._tzinfo"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "BINARY_SUBSCR",
            "s[-1:]"
        ],
        [
            "COMPARE_OP",
            "s[-1:] == \")\""
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "BINARY_SUBSCR",
            "s[:-1]"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._tzinfo"
        ],
        [
            "BINARY_OP",
            "\", tzinfo=%r\" % self._tzinfo"
        ],
        [
            "BINARY_OP",
            "s[:-1] + \", tzinfo=%r\" % self._tzinfo"
        ],
        [
            "BINARY_OP",
            "s[:-1] + \", tzinfo=%r\" % self._tzinfo + \")\""
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._fold"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "BINARY_SUBSCR",
            "s[-1:]"
        ],
        [
            "COMPARE_OP",
            "s[-1:] == \")\""
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "BINARY_SUBSCR",
            "s[:-1]"
        ],
        [
            "BINARY_OP",
            "s[:-1] + \", fold=1)\""
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.isoformat"
        ],
        [
            "CALL",
            "self.isoformat(sep=' ')"
        ],
        [
            "STORE_FAST",
            "import _strptime"
        ],
        [
            "LOAD_FAST",
            "_strptime"
        ],
        [
            "LOAD_METHOD",
            "_strptime._strptime_datetime"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_FAST",
            "date_string"
        ],
        [
            "LOAD_FAST",
            "format"
        ],
        [
            "CALL",
            "_strptime._strptime_datetime(cls, date_string, format)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._tzinfo"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._tzinfo"
        ],
        [
            "LOAD_METHOD",
            "self._tzinfo.utcoffset"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "self._tzinfo.utcoffset(self)"
        ],
        [
            "STORE_FAST",
            "offset"
        ],
        [
            "LOAD_GLOBAL",
            "_check_utc_offset"
        ],
        [
            "LOAD_FAST",
            "offset"
        ],
        [
            "CALL",
            "_check_utc_offset(\"utcoffset\", offset)"
        ],
        [
            "LOAD_FAST",
            "offset"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._tzinfo"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._tzinfo"
        ],
        [
            "LOAD_METHOD",
            "self._tzinfo.tzname"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "self._tzinfo.tzname(self)"
        ],
        [
            "STORE_FAST",
            "name"
        ],
        [
            "LOAD_GLOBAL",
            "_check_tzname"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "CALL",
            "_check_tzname(name)"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._tzinfo"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._tzinfo"
        ],
        [
            "LOAD_METHOD",
            "self._tzinfo.dst"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "self._tzinfo.dst(self)"
        ],
        [
            "STORE_FAST",
            "offset"
        ],
        [
            "LOAD_GLOBAL",
            "_check_utc_offset"
        ],
        [
            "LOAD_FAST",
            "offset"
        ],
        [
            "CALL",
            "_check_utc_offset(\"dst\", offset)"
        ],
        [
            "LOAD_FAST",
            "offset"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "datetime"
        ],
        [
            "CALL",
            "isinstance(other, datetime)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._cmp"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "CALL",
            "self._cmp(other, allow_mixed=True)"
        ],
        [
            "COMPARE_OP",
            "self._cmp(other, allow_mixed=True) == 0"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "date"
        ],
        [
            "CALL",
            "isinstance(other, date)"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "datetime"
        ],
        [
            "CALL",
            "isinstance(other, datetime)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._cmp"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "CALL",
            "self._cmp(other)"
        ],
        [
            "COMPARE_OP",
            "self._cmp(other) <= 0"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "date"
        ],
        [
            "CALL",
            "isinstance(other, date)"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_GLOBAL",
            "_cmperror"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "CALL",
            "_cmperror(self, other)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "datetime"
        ],
        [
            "CALL",
            "isinstance(other, datetime)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._cmp"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "CALL",
            "self._cmp(other)"
        ],
        [
            "COMPARE_OP",
            "self._cmp(other) < 0"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "date"
        ],
        [
            "CALL",
            "isinstance(other, date)"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_GLOBAL",
            "_cmperror"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "CALL",
            "_cmperror(self, other)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "datetime"
        ],
        [
            "CALL",
            "isinstance(other, datetime)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._cmp"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "CALL",
            "self._cmp(other)"
        ],
        [
            "COMPARE_OP",
            "self._cmp(other) >= 0"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "date"
        ],
        [
            "CALL",
            "isinstance(other, date)"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_GLOBAL",
            "_cmperror"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "CALL",
            "_cmperror(self, other)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "datetime"
        ],
        [
            "CALL",
            "isinstance(other, datetime)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._cmp"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "CALL",
            "self._cmp(other)"
        ],
        [
            "COMPARE_OP",
            "self._cmp(other) > 0"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "date"
        ],
        [
            "CALL",
            "isinstance(other, date)"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_GLOBAL",
            "_cmperror"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "CALL",
            "_cmperror(self, other)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "datetime"
        ],
        [
            "CALL",
            "isinstance(other, datetime)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._tzinfo"
        ],
        [
            "STORE_FAST",
            "mytz"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._tzinfo"
        ],
        [
            "STORE_FAST",
            "ottz"
        ],
        [
            "STORE_FAST",
            "myoff"
        ],
        [
            "STORE_FAST",
            "otoff"
        ],
        [
            "LOAD_FAST",
            "mytz"
        ],
        [
            "LOAD_FAST",
            "ottz"
        ],
        [
            "IS_OP",
            "mytz is ottz"
        ],
        [
            "STORE_FAST",
            "base_compare"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.utcoffset"
        ],
        [
            "CALL",
            "self.utcoffset()"
        ],
        [
            "STORE_FAST",
            "myoff"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_METHOD",
            "other.utcoffset"
        ],
        [
            "CALL",
            "other.utcoffset()"
        ],
        [
            "STORE_FAST",
            "otoff"
        ],
        [
            "LOAD_FAST",
            "allow_mixed"
        ],
        [
            "LOAD_FAST",
            "myoff"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.replace"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.fold"
        ],
        [
            "UNARY_NOT",
            "not self.fold"
        ],
        [
            "CALL",
            "self.replace(fold=not self.fold)"
        ],
        [
            "LOAD_METHOD",
            "self.replace(fold=not self.fold).utcoffset"
        ],
        [
            "CALL",
            "self.replace(fold=not self.fold).utcoffset()"
        ],
        [
            "COMPARE_OP",
            "myoff != self.replace(fold=not self.fold).utcoffset()"
        ],
        [
            "LOAD_FAST",
            "otoff"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_METHOD",
            "other.replace"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other.fold"
        ],
        [
            "UNARY_NOT",
            "not other.fold"
        ],
        [
            "CALL",
            "other.replace(fold=not other.fold)"
        ],
        [
            "LOAD_METHOD",
            "other.replace(fold=not other.fold).utcoffset"
        ],
        [
            "CALL",
            "other.replace(fold=not other.fold).utcoffset()"
        ],
        [
            "COMPARE_OP",
            "otoff != other.replace(fold=not other.fold).utcoffset()"
        ],
        [
            "LOAD_FAST",
            "myoff"
        ],
        [
            "LOAD_FAST",
            "otoff"
        ],
        [
            "COMPARE_OP",
            "myoff == otoff"
        ],
        [
            "STORE_FAST",
            "base_compare"
        ],
        [
            "LOAD_FAST",
            "base_compare"
        ],
        [
            "LOAD_GLOBAL",
            "_cmp"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._year"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._month"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._day"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._hour"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._minute"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._second"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._microsecond"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._year"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._month"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._day"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._hour"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._minute"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._second"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._microsecond"
        ],
        [
            "CALL",
            "_cmp((self._year, self._month, self._day,\n                         self._hour, self._minute, self._second,\n                         self._microsecond),\n                        (other._year, other._month, other._day,\n                         other._hour, other._minute, other._second,\n                         other._microsecond))"
        ],
        [
            "LOAD_FAST",
            "myoff"
        ],
        [
            "LOAD_FAST",
            "otoff"
        ],
        [
            "LOAD_FAST",
            "allow_mixed"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "CALL",
            "TypeError(\"cannot compare naive and aware datetimes\")"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "BINARY_OP",
            "self - other"
        ],
        [
            "STORE_FAST",
            "diff"
        ],
        [
            "LOAD_FAST",
            "diff"
        ],
        [
            "LOAD_ATTR",
            "diff.days"
        ],
        [
            "COMPARE_OP",
            "diff.days < 0"
        ],
        [
            "LOAD_FAST",
            "diff"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "isinstance(other, timedelta)"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.toordinal"
        ],
        [
            "CALL",
            "self.toordinal()"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._hour"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._minute"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._second"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._microsecond"
        ],
        [
            "CALL",
            "timedelta(self.toordinal(),\n                          hours=self._hour,\n                          minutes=self._minute,\n                          seconds=self._second,\n                          microseconds=self._microsecond)"
        ],
        [
            "STORE_FAST",
            "delta"
        ],
        [
            "LOAD_FAST",
            "delta"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "BINARY_OP",
            "delta += other"
        ],
        [
            "STORE_FAST",
            "delta"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "delta"
        ],
        [
            "LOAD_ATTR",
            "delta.seconds"
        ],
        [
            "CALL",
            "divmod(delta.seconds, 3600)"
        ],
        [
            "STORE_FAST",
            "hour"
        ],
        [
            "STORE_FAST",
            "rem"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "rem"
        ],
        [
            "CALL",
            "divmod(rem, 60)"
        ],
        [
            "STORE_FAST",
            "minute"
        ],
        [
            "STORE_FAST",
            "second"
        ],
        [
            "LOAD_FAST",
            "delta"
        ],
        [
            "LOAD_ATTR",
            "delta.days"
        ],
        [
            "COMPARE_OP",
            "0 < delta.days <= _MAXORDINAL"
        ],
        [
            "LOAD_GLOBAL",
            "_MAXORDINAL"
        ],
        [
            "COMPARE_OP",
            "0 < delta.days <= _MAXORDINAL"
        ],
        [
            "LOAD_GLOBAL",
            "type"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "type(self)"
        ],
        [
            "LOAD_METHOD",
            "type(self).combine"
        ],
        [
            "LOAD_GLOBAL",
            "date"
        ],
        [
            "LOAD_METHOD",
            "date.fromordinal"
        ],
        [
            "LOAD_FAST",
            "delta"
        ],
        [
            "LOAD_ATTR",
            "delta.days"
        ],
        [
            "CALL",
            "date.fromordinal(delta.days)"
        ],
        [
            "LOAD_GLOBAL",
            "time"
        ],
        [
            "LOAD_FAST",
            "hour"
        ],
        [
            "LOAD_FAST",
            "minute"
        ],
        [
            "LOAD_FAST",
            "second"
        ],
        [
            "LOAD_FAST",
            "delta"
        ],
        [
            "LOAD_ATTR",
            "delta.microseconds"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._tzinfo"
        ],
        [
            "CALL",
            "time(hour, minute, second,\n                                           delta.microseconds,\n                                           tzinfo=self._tzinfo)"
        ],
        [
            "CALL",
            "type(self).combine(date.fromordinal(delta.days),\n                                      time(hour, minute, second,\n                                           delta.microseconds,\n                                           tzinfo=self._tzinfo))"
        ],
        [
            "LOAD_GLOBAL",
            "OverflowError"
        ],
        [
            "CALL",
            "OverflowError(\"result out of range\")"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "datetime"
        ],
        [
            "CALL",
            "isinstance(other, datetime)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "isinstance(other, timedelta)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "UNARY_NEGATIVE",
            "-other"
        ],
        [
            "BINARY_OP",
            "self + -other"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.toordinal"
        ],
        [
            "CALL",
            "self.toordinal()"
        ],
        [
            "STORE_FAST",
            "days1"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_METHOD",
            "other.toordinal"
        ],
        [
            "CALL",
            "other.toordinal()"
        ],
        [
            "STORE_FAST",
            "days2"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._second"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._minute"
        ],
        [
            "BINARY_OP",
            "self._minute * 60"
        ],
        [
            "BINARY_OP",
            "self._second + self._minute * 60"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._hour"
        ],
        [
            "BINARY_OP",
            "self._hour * 3600"
        ],
        [
            "BINARY_OP",
            "self._second + self._minute * 60 + self._hour * 3600"
        ],
        [
            "STORE_FAST",
            "secs1"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._second"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._minute"
        ],
        [
            "BINARY_OP",
            "other._minute * 60"
        ],
        [
            "BINARY_OP",
            "other._second + other._minute * 60"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._hour"
        ],
        [
            "BINARY_OP",
            "other._hour * 3600"
        ],
        [
            "BINARY_OP",
            "other._second + other._minute * 60 + other._hour * 3600"
        ],
        [
            "STORE_FAST",
            "secs2"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "LOAD_FAST",
            "days1"
        ],
        [
            "LOAD_FAST",
            "days2"
        ],
        [
            "BINARY_OP",
            "days1 - days2"
        ],
        [
            "LOAD_FAST",
            "secs1"
        ],
        [
            "LOAD_FAST",
            "secs2"
        ],
        [
            "BINARY_OP",
            "secs1 - secs2"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._microsecond"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._microsecond"
        ],
        [
            "BINARY_OP",
            "self._microsecond - other._microsecond"
        ],
        [
            "CALL",
            "timedelta(days1 - days2,\n                         secs1 - secs2,\n                         self._microsecond - other._microsecond)"
        ],
        [
            "STORE_FAST",
            "base"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._tzinfo"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._tzinfo"
        ],
        [
            "IS_OP",
            "self._tzinfo is other._tzinfo"
        ],
        [
            "LOAD_FAST",
            "base"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.utcoffset"
        ],
        [
            "CALL",
            "self.utcoffset()"
        ],
        [
            "STORE_FAST",
            "myoff"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_METHOD",
            "other.utcoffset"
        ],
        [
            "CALL",
            "other.utcoffset()"
        ],
        [
            "STORE_FAST",
            "otoff"
        ],
        [
            "LOAD_FAST",
            "myoff"
        ],
        [
            "LOAD_FAST",
            "otoff"
        ],
        [
            "COMPARE_OP",
            "myoff == otoff"
        ],
        [
            "LOAD_FAST",
            "base"
        ],
        [
            "LOAD_FAST",
            "myoff"
        ],
        [
            "LOAD_FAST",
            "otoff"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "CALL",
            "TypeError(\"cannot mix naive and timezone-aware time\")"
        ],
        [
            "LOAD_FAST",
            "base"
        ],
        [
            "LOAD_FAST",
            "otoff"
        ],
        [
            "BINARY_OP",
            "base + otoff"
        ],
        [
            "LOAD_FAST",
            "myoff"
        ],
        [
            "BINARY_OP",
            "base + otoff - myoff"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._hashcode"
        ],
        [
            "COMPARE_OP",
            "self._hashcode == -1"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.fold"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.replace"
        ],
        [
            "CALL",
            "self.replace(fold=0)"
        ],
        [
            "STORE_FAST",
            "t"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_FAST",
            "t"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "LOAD_METHOD",
            "t.utcoffset"
        ],
        [
            "CALL",
            "t.utcoffset()"
        ],
        [
            "STORE_FAST",
            "tzoff"
        ],
        [
            "LOAD_FAST",
            "tzoff"
        ],
        [
            "LOAD_GLOBAL",
            "hash"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "LOAD_METHOD",
            "t._getstate"
        ],
        [
            "CALL",
            "t._getstate()"
        ],
        [
            "BINARY_SUBSCR",
            "t._getstate()[0]"
        ],
        [
            "CALL",
            "hash(t._getstate()[0])"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._hashcode"
        ],
        [
            "LOAD_GLOBAL",
            "_ymd2ord"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.year"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.month"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.day"
        ],
        [
            "CALL",
            "_ymd2ord(self.year, self.month, self.day)"
        ],
        [
            "STORE_FAST",
            "days"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.hour"
        ],
        [
            "BINARY_OP",
            "self.hour * 3600"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.minute"
        ],
        [
            "BINARY_OP",
            "self.minute * 60"
        ],
        [
            "BINARY_OP",
            "self.hour * 3600 + self.minute * 60"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.second"
        ],
        [
            "BINARY_OP",
            "self.hour * 3600 + self.minute * 60 + self.second"
        ],
        [
            "STORE_FAST",
            "seconds"
        ],
        [
            "LOAD_GLOBAL",
            "hash"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "LOAD_FAST",
            "days"
        ],
        [
            "LOAD_FAST",
            "seconds"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.microsecond"
        ],
        [
            "CALL",
            "timedelta(days, seconds, self.microsecond)"
        ],
        [
            "LOAD_FAST",
            "tzoff"
        ],
        [
            "BINARY_OP",
            "timedelta(days, seconds, self.microsecond) - tzoff"
        ],
        [
            "CALL",
            "hash(timedelta(days, seconds, self.microsecond) - tzoff)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._hashcode"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._hashcode"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._year"
        ],
        [
            "CALL",
            "divmod(self._year, 256)"
        ],
        [
            "STORE_FAST",
            "yhi"
        ],
        [
            "STORE_FAST",
            "ylo"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._microsecond"
        ],
        [
            "CALL",
            "divmod(self._microsecond, 256)"
        ],
        [
            "STORE_FAST",
            "us2"
        ],
        [
            "STORE_FAST",
            "us3"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "us2"
        ],
        [
            "CALL",
            "divmod(us2, 256)"
        ],
        [
            "STORE_FAST",
            "us1"
        ],
        [
            "STORE_FAST",
            "us2"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._month"
        ],
        [
            "STORE_FAST",
            "m"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._fold"
        ],
        [
            "LOAD_FAST",
            "protocol"
        ],
        [
            "COMPARE_OP",
            "protocol > 3"
        ],
        [
            "LOAD_FAST",
            "m"
        ],
        [
            "BINARY_OP",
            "m += 128"
        ],
        [
            "STORE_FAST",
            "m"
        ],
        [
            "LOAD_GLOBAL",
            "bytes"
        ],
        [
            "LOAD_FAST",
            "yhi"
        ],
        [
            "LOAD_FAST",
            "ylo"
        ],
        [
            "LOAD_FAST",
            "m"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._day"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._hour"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._minute"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._second"
        ],
        [
            "LOAD_FAST",
            "us1"
        ],
        [
            "LOAD_FAST",
            "us2"
        ],
        [
            "LOAD_FAST",
            "us3"
        ],
        [
            "CALL",
            "bytes([yhi, ylo, m, self._day,\n                           self._hour, self._minute, self._second,\n                           us1, us2, us3])"
        ],
        [
            "STORE_FAST",
            "basestate"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._tzinfo"
        ],
        [
            "LOAD_FAST",
            "basestate"
        ],
        [
            "LOAD_FAST",
            "basestate"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._tzinfo"
        ],
        [
            "LOAD_FAST",
            "tzinfo"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "tzinfo"
        ],
        [
            "LOAD_GLOBAL",
            "_tzinfo_class"
        ],
        [
            "CALL",
            "isinstance(tzinfo, _tzinfo_class)"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "CALL",
            "TypeError(\"bad tzinfo state arg\")"
        ],
        [
            "LOAD_FAST",
            "string"
        ],
        [
            "STORE_FAST",
            "yhi"
        ],
        [
            "STORE_FAST",
            "ylo"
        ],
        [
            "STORE_FAST",
            "m"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._day"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._hour"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._minute"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._second"
        ],
        [
            "STORE_FAST",
            "us1"
        ],
        [
            "STORE_FAST",
            "us2"
        ],
        [
            "STORE_FAST",
            "us3"
        ],
        [
            "LOAD_FAST",
            "m"
        ],
        [
            "COMPARE_OP",
            "m > 127"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._fold"
        ],
        [
            "LOAD_FAST",
            "m"
        ],
        [
            "BINARY_OP",
            "m - 128"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._month"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._fold"
        ],
        [
            "LOAD_FAST",
            "m"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._month"
        ],
        [
            "LOAD_FAST",
            "yhi"
        ],
        [
            "BINARY_OP",
            "yhi * 256"
        ],
        [
            "LOAD_FAST",
            "ylo"
        ],
        [
            "BINARY_OP",
            "yhi * 256 + ylo"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._year"
        ],
        [
            "LOAD_FAST",
            "us1"
        ],
        [
            "BINARY_OP",
            "us1 << 8"
        ],
        [
            "LOAD_FAST",
            "us2"
        ],
        [
            "BINARY_OP",
            "(us1 << 8) | us2"
        ],
        [
            "BINARY_OP",
            "((us1 << 8) | us2) << 8"
        ],
        [
            "LOAD_FAST",
            "us3"
        ],
        [
            "BINARY_OP",
            "(((us1 << 8) | us2) << 8) | us3"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._microsecond"
        ],
        [
            "LOAD_FAST",
            "tzinfo"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._tzinfo"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.__class__"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._getstate"
        ],
        [
            "LOAD_FAST",
            "protocol"
        ],
        [
            "CALL",
            "self._getstate(protocol)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.__reduce_ex__"
        ],
        [
            "CALL",
            "self.__reduce_ex__(2)"
        ],
        [
            "STORE_FAST",
            "THURSDAY"
        ],
        [
            "LOAD_GLOBAL",
            "_ymd2ord"
        ],
        [
            "LOAD_FAST",
            "year"
        ],
        [
            "CALL",
            "_ymd2ord(year, 1, 1)"
        ],
        [
            "STORE_FAST",
            "firstday"
        ],
        [
            "LOAD_FAST",
            "firstday"
        ],
        [
            "BINARY_OP",
            "firstday + 6"
        ],
        [
            "BINARY_OP",
            "(firstday + 6) % 7"
        ],
        [
            "STORE_FAST",
            "firstweekday"
        ],
        [
            "LOAD_FAST",
            "firstday"
        ],
        [
            "LOAD_FAST",
            "firstweekday"
        ],
        [
            "BINARY_OP",
            "firstday - firstweekday"
        ],
        [
            "STORE_FAST",
            "week1monday"
        ],
        [
            "LOAD_FAST",
            "firstweekday"
        ],
        [
            "LOAD_FAST",
            "THURSDAY"
        ],
        [
            "COMPARE_OP",
            "firstweekday > THURSDAY"
        ],
        [
            "LOAD_FAST",
            "week1monday"
        ],
        [
            "BINARY_OP",
            "week1monday += 7"
        ],
        [
            "STORE_FAST",
            "week1monday"
        ],
        [
            "LOAD_FAST",
            "week1monday"
        ],
        [
            "STORE_NAME",
            "__slots__"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "object()"
        ],
        [
            "STORE_NAME",
            "_Omitted"
        ],
        [
            "LOAD_NAME",
            "_Omitted"
        ],
        [
            "STORE_NAME",
            "    def __new__(cls, offset, name=_Omitted):\n        if not isinstance(offset, timedelta):\n            raise TypeError(\"offset must be a timedelta\")\n        if name is cls._Omitted:\n            if not offset:\n                return cls.utc\n            name = None\n        elif not isinstance(name, str):\n            raise TypeError(\"name must be a string\")\n        if not cls._minoffset <= offset <= cls._maxoffset:\n            raise ValueError(\"offset must be a timedelta \"\n                             \"strictly between -timedelta(hours=24) and \"\n                             \"timedelta(hours=24).\")\n        return cls._create(offset, name)"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def _create(cls, offset, name=None):\n        self = tzinfo.__new__(cls)\n        self._offset = offset\n        self._name = name\n        return self"
        ],
        [
            "STORE_NAME",
            "    def __getinitargs__(self):\n        \"\"\"pickle support\"\"\"\n        if self._name is None:\n            return (self._offset,)\n        return (self._offset, self._name)"
        ],
        [
            "STORE_NAME",
            "    def __eq__(self, other):\n        if isinstance(other, timezone):\n            return self._offset == other._offset\n        return NotImplemented"
        ],
        [
            "STORE_NAME",
            "    def __hash__(self):\n        return hash(self._offset)"
        ],
        [
            "STORE_NAME",
            "    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\n\n        >>> tz = timezone.utc\n        >>> repr(tz)\n        'datetime.timezone.utc'\n        >>> tz = timezone(timedelta(hours=-5), 'EST')\n        >>> repr(tz)\n        \"datetime.timezone(datetime.timedelta(-1, 68400), 'EST')\"\n        \"\"\"\n        if self is self.utc:\n            return 'datetime.timezone.utc'\n        if self._name is None:\n            return \"%s.%s(%r)\" % (self.__class__.__module__,\n                                  self.__class__.__qualname__,\n                                  self._offset)\n        return \"%s.%s(%r, %r)\" % (self.__class__.__module__,\n                                  self.__class__.__qualname__,\n                                  self._offset, self._name)"
        ],
        [
            "STORE_NAME",
            "    def __str__(self):\n        return self.tzname(None)"
        ],
        [
            "STORE_NAME",
            "    def utcoffset(self, dt):\n        if isinstance(dt, datetime) or dt is None:\n            return self._offset\n        raise TypeError(\"utcoffset() argument must be a datetime instance\"\n                        \" or None\")"
        ],
        [
            "STORE_NAME",
            "    def tzname(self, dt):\n        if isinstance(dt, datetime) or dt is None:\n            if self._name is None:\n                return self._name_from_offset(self._offset)\n            return self._name\n        raise TypeError(\"tzname() argument must be a datetime instance\"\n                        \" or None\")"
        ],
        [
            "STORE_NAME",
            "    def dst(self, dt):\n        if isinstance(dt, datetime) or dt is None:\n            return None\n        raise TypeError(\"dst() argument must be a datetime instance\"\n                        \" or None\")"
        ],
        [
            "STORE_NAME",
            "    def fromutc(self, dt):\n        if isinstance(dt, datetime):\n            if dt.tzinfo is not self:\n                raise ValueError(\"fromutc: dt.tzinfo \"\n                                 \"is not self\")\n            return dt + self._offset\n        raise TypeError(\"fromutc() argument must be a datetime instance\"\n                        \" or None\")"
        ],
        [
            "LOAD_NAME",
            "timedelta"
        ],
        [
            "CALL",
            "timedelta(hours=24, microseconds=-1)"
        ],
        [
            "STORE_NAME",
            "_maxoffset"
        ],
        [
            "LOAD_NAME",
            "_maxoffset"
        ],
        [
            "UNARY_NEGATIVE",
            "-_maxoffset"
        ],
        [
            "STORE_NAME",
            "_minoffset"
        ],
        [
            "LOAD_NAME",
            "staticmethod"
        ],
        [
            "CALL",
            "staticmethod"
        ],
        [
            "STORE_NAME",
            "    @staticmethod\n    def _name_from_offset(delta):\n        if not delta:\n            return 'UTC'\n        if delta < timedelta(0):\n            sign = '-'\n            delta = -delta\n        else:\n            sign = '+'\n        hours, rest = divmod(delta, timedelta(hours=1))\n        minutes, rest = divmod(rest, timedelta(minutes=1))\n        seconds = rest.seconds\n        microseconds = rest.microseconds\n        if microseconds:\n            return (f'UTC{sign}{hours:02d}:{minutes:02d}:{seconds:02d}'\n                    f'.{microseconds:06d}')\n        if seconds:\n            return f'UTC{sign}{hours:02d}:{minutes:02d}:{seconds:02d}'\n        return f'UTC{sign}{hours:02d}:{minutes:02d}'"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "offset"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "isinstance(offset, timedelta)"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "CALL",
            "TypeError(\"offset must be a timedelta\")"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_ATTR",
            "cls._Omitted"
        ],
        [
            "IS_OP",
            "name is cls._Omitted"
        ],
        [
            "LOAD_FAST",
            "offset"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_ATTR",
            "cls.utc"
        ],
        [
            "STORE_FAST",
            "name"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "CALL",
            "isinstance(name, str)"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "CALL",
            "TypeError(\"name must be a string\")"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_ATTR",
            "cls._minoffset"
        ],
        [
            "LOAD_FAST",
            "offset"
        ],
        [
            "COMPARE_OP",
            "cls._minoffset <= offset <= cls._maxoffset"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_ATTR",
            "cls._maxoffset"
        ],
        [
            "COMPARE_OP",
            "cls._minoffset <= offset <= cls._maxoffset"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError(\"offset must be a timedelta \"\n                             \"strictly between -timedelta(hours=24) and \"\n                             \"timedelta(hours=24).\")"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_METHOD",
            "cls._create"
        ],
        [
            "LOAD_FAST",
            "offset"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "CALL",
            "cls._create(offset, name)"
        ],
        [
            "LOAD_GLOBAL",
            "tzinfo"
        ],
        [
            "LOAD_METHOD",
            "tzinfo.__new__"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "CALL",
            "tzinfo.__new__(cls)"
        ],
        [
            "STORE_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "offset"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._offset"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._name"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._name"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._offset"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._offset"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._name"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_GLOBAL",
            "timezone"
        ],
        [
            "CALL",
            "isinstance(other, timezone)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._offset"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "LOAD_ATTR",
            "other._offset"
        ],
        [
            "COMPARE_OP",
            "self._offset == other._offset"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplemented"
        ],
        [
            "LOAD_GLOBAL",
            "hash"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._offset"
        ],
        [
            "CALL",
            "hash(self._offset)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.utc"
        ],
        [
            "IS_OP",
            "self is self.utc"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._name"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.__class__"
        ],
        [
            "LOAD_ATTR",
            "self.__class__.__module__"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.__class__"
        ],
        [
            "LOAD_ATTR",
            "self.__class__.__qualname__"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._offset"
        ],
        [
            "BUILD_STRING",
            "\"%s.%s(%r)\" % (self.__class__.__module__,\n                                  self.__class__.__qualname__,\n                                  self._offset)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.__class__"
        ],
        [
            "LOAD_ATTR",
            "self.__class__.__module__"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.__class__"
        ],
        [
            "LOAD_ATTR",
            "self.__class__.__qualname__"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._offset"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._name"
        ],
        [
            "BUILD_STRING",
            "\"%s.%s(%r, %r)\" % (self.__class__.__module__,\n                                  self.__class__.__qualname__,\n                                  self._offset, self._name)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.tzname"
        ],
        [
            "CALL",
            "self.tzname(None)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "dt"
        ],
        [
            "LOAD_GLOBAL",
            "datetime"
        ],
        [
            "CALL",
            "isinstance(dt, datetime)"
        ],
        [
            "LOAD_FAST",
            "dt"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._offset"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "CALL",
            "TypeError(\"utcoffset() argument must be a datetime instance\"\n                        \" or None\")"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "dt"
        ],
        [
            "LOAD_GLOBAL",
            "datetime"
        ],
        [
            "CALL",
            "isinstance(dt, datetime)"
        ],
        [
            "LOAD_FAST",
            "dt"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._name"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._name_from_offset"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._offset"
        ],
        [
            "CALL",
            "self._name_from_offset(self._offset)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._name"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "CALL",
            "TypeError(\"tzname() argument must be a datetime instance\"\n                        \" or None\")"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "dt"
        ],
        [
            "LOAD_GLOBAL",
            "datetime"
        ],
        [
            "CALL",
            "isinstance(dt, datetime)"
        ],
        [
            "LOAD_FAST",
            "dt"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "CALL",
            "TypeError(\"dst() argument must be a datetime instance\"\n                        \" or None\")"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "dt"
        ],
        [
            "LOAD_GLOBAL",
            "datetime"
        ],
        [
            "CALL",
            "isinstance(dt, datetime)"
        ],
        [
            "LOAD_FAST",
            "dt"
        ],
        [
            "LOAD_ATTR",
            "dt.tzinfo"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "IS_OP",
            "dt.tzinfo is not self"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError(\"fromutc: dt.tzinfo \"\n                                 \"is not self\")"
        ],
        [
            "LOAD_FAST",
            "dt"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._offset"
        ],
        [
            "BINARY_OP",
            "dt + self._offset"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "CALL",
            "TypeError(\"fromutc() argument must be a datetime instance\"\n                        \" or None\")"
        ],
        [
            "LOAD_FAST",
            "delta"
        ],
        [
            "LOAD_FAST",
            "delta"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "timedelta(0)"
        ],
        [
            "COMPARE_OP",
            "delta < timedelta(0)"
        ],
        [
            "STORE_FAST",
            "sign"
        ],
        [
            "LOAD_FAST",
            "delta"
        ],
        [
            "UNARY_NEGATIVE",
            "-delta"
        ],
        [
            "STORE_FAST",
            "delta"
        ],
        [
            "STORE_FAST",
            "sign"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "delta"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "timedelta(hours=1)"
        ],
        [
            "CALL",
            "divmod(delta, timedelta(hours=1))"
        ],
        [
            "STORE_FAST",
            "hours"
        ],
        [
            "STORE_FAST",
            "rest"
        ],
        [
            "LOAD_GLOBAL",
            "divmod"
        ],
        [
            "LOAD_FAST",
            "rest"
        ],
        [
            "LOAD_GLOBAL",
            "timedelta"
        ],
        [
            "CALL",
            "timedelta(minutes=1)"
        ],
        [
            "CALL",
            "divmod(rest, timedelta(minutes=1))"
        ],
        [
            "STORE_FAST",
            "minutes"
        ],
        [
            "STORE_FAST",
            "rest"
        ],
        [
            "LOAD_FAST",
            "rest"
        ],
        [
            "LOAD_ATTR",
            "rest.seconds"
        ],
        [
            "STORE_FAST",
            "seconds"
        ],
        [
            "LOAD_FAST",
            "rest"
        ],
        [
            "LOAD_ATTR",
            "rest.microseconds"
        ],
        [
            "STORE_FAST",
            "microseconds"
        ],
        [
            "LOAD_FAST",
            "microseconds"
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "LOAD_FAST",
            "seconds"
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "LOAD_FAST",
            ""
        ],
        [
            "LOAD_FAST",
            ""
        ]
    ],
    "db.py": [
        [
            "STORE_NAME",
            "from __future__ import print_function, division, absolute_import"
        ],
        [
            "STORE_NAME",
            "from __future__ import print_function, division, absolute_import"
        ],
        [
            "STORE_NAME",
            "from __future__ import print_function, division, absolute_import"
        ],
        [
            "STORE_NAME",
            "import functools"
        ],
        [
            "STORE_NAME",
            "import sys"
        ],
        [
            "STORE_NAME",
            "from future import standard_library"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy.exc import OperationalError, InterfaceError, InternalError, ProgrammingError, ArgumentError"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy.exc import OperationalError, InterfaceError, InternalError, ProgrammingError, ArgumentError"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy.exc import OperationalError, InterfaceError, InternalError, ProgrammingError, ArgumentError"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy.exc import OperationalError, InterfaceError, InternalError, ProgrammingError, ArgumentError"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy.exc import OperationalError, InterfaceError, InternalError, ProgrammingError, ArgumentError"
        ],
        [
            "LOAD_NAME",
            "standard_library"
        ],
        [
            "LOAD_ATTR",
            "standard_library.install_aliases"
        ],
        [
            "CALL",
            "standard_library.install_aliases()"
        ],
        [
            "STORE_NAME",
            "import json"
        ],
        [
            "STORE_NAME",
            "import os"
        ],
        [
            "STORE_NAME",
            "from typing import List"
        ],
        [
            "STORE_NAME",
            "from contextlib import contextmanager"
        ],
        [
            "STORE_NAME",
            "from humanize import naturaltime"
        ],
        [
            "STORE_NAME",
            "from markupsafe import Markup"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy import Sequence, UniqueConstraint, create_engine, Column, Integer, Text, ForeignKey, DateTime, String, \\\n    Index"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy import Sequence, UniqueConstraint, create_engine, Column, Integer, Text, ForeignKey, DateTime, String, \\\n    Index"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy import Sequence, UniqueConstraint, create_engine, Column, Integer, Text, ForeignKey, DateTime, String, \\\n    Index"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy import Sequence, UniqueConstraint, create_engine, Column, Integer, Text, ForeignKey, DateTime, String, \\\n    Index"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy import Sequence, UniqueConstraint, create_engine, Column, Integer, Text, ForeignKey, DateTime, String, \\\n    Index"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy import Sequence, UniqueConstraint, create_engine, Column, Integer, Text, ForeignKey, DateTime, String, \\\n    Index"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy import Sequence, UniqueConstraint, create_engine, Column, Integer, Text, ForeignKey, DateTime, String, \\\n    Index"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy import Sequence, UniqueConstraint, create_engine, Column, Integer, Text, ForeignKey, DateTime, String, \\\n    Index"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy import Sequence, UniqueConstraint, create_engine, Column, Integer, Text, ForeignKey, DateTime, String, \\\n    Index"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy import Sequence, UniqueConstraint, create_engine, Column, Integer, Text, ForeignKey, DateTime, String, \\\n    Index"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy.ext.declarative import declarative_base, declared_attr"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy.ext.declarative import declarative_base, declared_attr"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy.orm import backref, relationship, sessionmaker"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy.orm import backref, relationship, sessionmaker"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy.orm import backref, relationship, sessionmaker"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy.dialects.mysql import LONGTEXT"
        ],
        [
            "STORE_NAME",
            "from littleutils import select_attrs, retry"
        ],
        [
            "STORE_NAME",
            "from littleutils import select_attrs, retry"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import IPYTHON_FILE_PATH, is_ipython_cell"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import IPYTHON_FILE_PATH, is_ipython_cell"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy.dialects.mysql.base import RESERVED_WORDS"
        ],
        [
            "LOAD_NAME",
            "RESERVED_WORDS"
        ],
        [
            "LOAD_ATTR",
            "RESERVED_WORDS.add"
        ],
        [
            "CALL",
            "RESERVED_WORDS.add('function')"
        ],
        [
            "STORE_NAME",
            "DB_VERSION"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class Database(object):\n    def __init__(self, db_uri=None, _skip_version_check=False):\n        self.db_uri = db_uri = (\n                db_uri\n                or os.environ.get('BIRDSEYE_DB')\n                or os.path.join(os.path.expanduser('~'),\n                                '.birdseye.db'))\n\n        kwargs = dict(\n            pool_recycle=280,\n            echo=False,  # for convenience when debugging\n        )\n\n        try:\n            engine = create_engine(db_uri, **kwargs)\n        except ArgumentError:\n            db_uri = 'sqlite:///' + db_uri\n            engine = create_engine(db_uri, **kwargs)\n\n        self.engine = engine\n\n        self.Session = sessionmaker(bind=engine)\n\n        class Base(object):\n            @declared_attr\n            def __tablename__(cls):\n                return cls.__name__.lower()\n\n        Base = declarative_base(cls=Base)  # type: ignore\n\n        class KeyValue(Base):\n            key = Column(String(50), primary_key=True)\n            value = Column(Text)\n\n        db_self = self\n\n        class KeyValueStore(object):\n            def __getitem__(self, item):\n                with db_self.session_scope() as session:\n                    return (session\n                            .query(KeyValue.value)\n                            .filter_by(key=item)\n                            .scalar())\n\n            def __setitem__(self, key, value):\n                with db_self.session_scope() as session:\n                    session.query(KeyValue).filter_by(key=key).delete()\n                    session.add(KeyValue(key=key, value=str(value)))\n\n            __getattr__ = __getitem__\n            __setattr__ = __setitem__\n\n        LongText = LONGTEXT if engine.name == 'mysql' else Text\n\n        class Call(Base):\n            id = Column(String(length=32), primary_key=True)\n            function_id = Column(Integer, ForeignKey('function.id'), index=True)\n            function = relationship('Function', backref=backref('calls', lazy='dynamic'))\n            arguments = Column(Text)\n            return_value = Column(Text)\n            exception = Column(Text)\n            traceback = Column(Text)\n            data = Column(LongText)\n            start_time = Column(DateTime, index=True)\n\n            @property\n            def pretty_start_time(self):\n                return self._pretty_time(self.start_time)\n\n            @staticmethod\n            def _pretty_time(dt):\n                if not dt:\n                    return ''\n                return Markup('%s (%s)' % (\n                    dt.strftime('%Y-%m-%d&nbsp;%H:%M:%S'),\n                    naturaltime(dt)))\n\n            @property\n            def state_icon(self):\n                return Markup('<span class=\"glyphicon glyphicon-%s\" '\n                              'style=\"color: %s\"></span>' % (\n                                  ('ok', 'green') if self.success else\n                                  ('remove', 'red')))\n\n            @property\n            def success(self):\n                if self.exception:\n                    assert self.traceback\n                    assert self.return_value == 'None'\n                    return False\n                else:\n                    assert not self.traceback\n                    return True\n\n            @property\n            def result(self):\n                if self.success:\n                    return str(self.return_value)\n                else:\n                    return str(self.exception)\n\n            @property\n            def arguments_list(self):\n                return json.loads(self.arguments)\n\n            @property\n            def parsed_data(self):\n                return json.loads(self.data)\n\n            @staticmethod\n            def basic_dict(call):\n                return dict(arguments=call.arguments_list,\n                            **select_attrs(call, 'id function_id return_value traceback '\n                                                 'exception start_time'))\n\n            basic_columns = (id, function_id, return_value,\n                             traceback, exception, start_time, arguments)\n\n        class Function(Base):\n            id = Column(Integer, Sequence('function_id_seq'), primary_key=True)\n            file = Column(Text)\n            name = Column(Text)\n            type = Column(Text)  # function or module\n            html_body = Column(LongText)\n            lineno = Column(Integer)\n            data = Column(LongText)\n            hash = Column(String(length=64), index=True)\n            body_hash = Column(String(length=64), index=True)\n\n            __table_args__ = (\n                UniqueConstraint('hash',\n                                 name='everything_unique'),\n                Index('idx_file', 'file', mysql_length=256),\n                Index('idx_name', 'name', mysql_length=32),\n            )\n\n            @property\n            def parsed_data(self):\n                return json.loads(self.data)\n\n            @staticmethod\n            def basic_dict(func):\n                return select_attrs(func, 'file name lineno hash body_hash type')\n\n            basic_columns = (file, name, lineno, hash, body_hash, type)\n\n        self.Call = Call\n        self.Function = Function\n        self._KeyValue = KeyValue\n\n        self.key_value_store = kv = KeyValueStore()\n\n        if _skip_version_check:\n            return\n\n        if not self.table_exists(Function):\n            Base.metadata.create_all(engine)\n            kv.version = DB_VERSION\n        elif not self.table_exists(KeyValue) or int(kv.version) < DB_VERSION:\n            sys.exit('The birdseye database schema is out of date. '\n                     'Run \"python -m birdseye.clear_db\" to delete the existing tables.')\n\n    def table_exists(self, table):\n        return self.engine.dialect.has_table(self.engine, table.__name__)\n\n    def all_file_paths(self):\n        # type: () -> List[str]\n        with self.session_scope() as session:\n            paths = [f[0] for f in session.query(self.Function.file).distinct()\n                     if not is_ipython_cell(f[0])]\n        paths.sort()\n        if IPYTHON_FILE_PATH in paths:\n            paths.remove(IPYTHON_FILE_PATH)\n            paths.insert(0, IPYTHON_FILE_PATH)\n        return paths\n\n    def clear(self):\n        for model in [self.Call, self.Function, self._KeyValue]:\n            if self.table_exists(model):\n                model.__table__.drop(self.engine)\n\n    @contextmanager\n    def session_scope(self):\n        \"\"\"Provide a transactional scope around a series of operations.\"\"\"\n        session = self.Session()\n        try:\n            yield session\n            session.commit()\n        except:\n            session.rollback()\n            raise\n        finally:\n            session.close()\n\n    def provide_session(self, func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            with self.session_scope() as session:\n                return func(session, *args, **kwargs)\n\n        return retry_db(wrapper)"
        ],
        [
            "STORE_NAME",
            "class Database(object):\n    def __init__(self, db_uri=None, _skip_version_check=False):\n        self.db_uri = db_uri = (\n                db_uri\n                or os.environ.get('BIRDSEYE_DB')\n                or os.path.join(os.path.expanduser('~'),\n                                '.birdseye.db'))\n\n        kwargs = dict(\n            pool_recycle=280,\n            echo=False,  # for convenience when debugging\n        )\n\n        try:\n            engine = create_engine(db_uri, **kwargs)\n        except ArgumentError:\n            db_uri = 'sqlite:///' + db_uri\n            engine = create_engine(db_uri, **kwargs)\n\n        self.engine = engine\n\n        self.Session = sessionmaker(bind=engine)\n\n        class Base(object):\n            @declared_attr\n            def __tablename__(cls):\n                return cls.__name__.lower()\n\n        Base = declarative_base(cls=Base)  # type: ignore\n\n        class KeyValue(Base):\n            key = Column(String(50), primary_key=True)\n            value = Column(Text)\n\n        db_self = self\n\n        class KeyValueStore(object):\n            def __getitem__(self, item):\n                with db_self.session_scope() as session:\n                    return (session\n                            .query(KeyValue.value)\n                            .filter_by(key=item)\n                            .scalar())\n\n            def __setitem__(self, key, value):\n                with db_self.session_scope() as session:\n                    session.query(KeyValue).filter_by(key=key).delete()\n                    session.add(KeyValue(key=key, value=str(value)))\n\n            __getattr__ = __getitem__\n            __setattr__ = __setitem__\n\n        LongText = LONGTEXT if engine.name == 'mysql' else Text\n\n        class Call(Base):\n            id = Column(String(length=32), primary_key=True)\n            function_id = Column(Integer, ForeignKey('function.id'), index=True)\n            function = relationship('Function', backref=backref('calls', lazy='dynamic'))\n            arguments = Column(Text)\n            return_value = Column(Text)\n            exception = Column(Text)\n            traceback = Column(Text)\n            data = Column(LongText)\n            start_time = Column(DateTime, index=True)\n\n            @property\n            def pretty_start_time(self):\n                return self._pretty_time(self.start_time)\n\n            @staticmethod\n            def _pretty_time(dt):\n                if not dt:\n                    return ''\n                return Markup('%s (%s)' % (\n                    dt.strftime('%Y-%m-%d&nbsp;%H:%M:%S'),\n                    naturaltime(dt)))\n\n            @property\n            def state_icon(self):\n                return Markup('<span class=\"glyphicon glyphicon-%s\" '\n                              'style=\"color: %s\"></span>' % (\n                                  ('ok', 'green') if self.success else\n                                  ('remove', 'red')))\n\n            @property\n            def success(self):\n                if self.exception:\n                    assert self.traceback\n                    assert self.return_value == 'None'\n                    return False\n                else:\n                    assert not self.traceback\n                    return True\n\n            @property\n            def result(self):\n                if self.success:\n                    return str(self.return_value)\n                else:\n                    return str(self.exception)\n\n            @property\n            def arguments_list(self):\n                return json.loads(self.arguments)\n\n            @property\n            def parsed_data(self):\n                return json.loads(self.data)\n\n            @staticmethod\n            def basic_dict(call):\n                return dict(arguments=call.arguments_list,\n                            **select_attrs(call, 'id function_id return_value traceback '\n                                                 'exception start_time'))\n\n            basic_columns = (id, function_id, return_value,\n                             traceback, exception, start_time, arguments)\n\n        class Function(Base):\n            id = Column(Integer, Sequence('function_id_seq'), primary_key=True)\n            file = Column(Text)\n            name = Column(Text)\n            type = Column(Text)  # function or module\n            html_body = Column(LongText)\n            lineno = Column(Integer)\n            data = Column(LongText)\n            hash = Column(String(length=64), index=True)\n            body_hash = Column(String(length=64), index=True)\n\n            __table_args__ = (\n                UniqueConstraint('hash',\n                                 name='everything_unique'),\n                Index('idx_file', 'file', mysql_length=256),\n                Index('idx_name', 'name', mysql_length=32),\n            )\n\n            @property\n            def parsed_data(self):\n                return json.loads(self.data)\n\n            @staticmethod\n            def basic_dict(func):\n                return select_attrs(func, 'file name lineno hash body_hash type')\n\n            basic_columns = (file, name, lineno, hash, body_hash, type)\n\n        self.Call = Call\n        self.Function = Function\n        self._KeyValue = KeyValue\n\n        self.key_value_store = kv = KeyValueStore()\n\n        if _skip_version_check:\n            return\n\n        if not self.table_exists(Function):\n            Base.metadata.create_all(engine)\n            kv.version = DB_VERSION\n        elif not self.table_exists(KeyValue) or int(kv.version) < DB_VERSION:\n            sys.exit('The birdseye database schema is out of date. '\n                     'Run \"python -m birdseye.clear_db\" to delete the existing tables.')\n\n    def table_exists(self, table):\n        return self.engine.dialect.has_table(self.engine, table.__name__)\n\n    def all_file_paths(self):\n        # type: () -> List[str]\n        with self.session_scope() as session:\n            paths = [f[0] for f in session.query(self.Function.file).distinct()\n                     if not is_ipython_cell(f[0])]\n        paths.sort()\n        if IPYTHON_FILE_PATH in paths:\n            paths.remove(IPYTHON_FILE_PATH)\n            paths.insert(0, IPYTHON_FILE_PATH)\n        return paths\n\n    def clear(self):\n        for model in [self.Call, self.Function, self._KeyValue]:\n            if self.table_exists(model):\n                model.__table__.drop(self.engine)\n\n    @contextmanager\n    def session_scope(self):\n        \"\"\"Provide a transactional scope around a series of operations.\"\"\"\n        session = self.Session()\n        try:\n            yield session\n            session.commit()\n        except:\n            session.rollback()\n            raise\n        finally:\n            session.close()\n\n    def provide_session(self, func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            with self.session_scope() as session:\n                return func(session, *args, **kwargs)\n\n        return retry_db(wrapper)"
        ],
        [
            "LOAD_NAME",
            "retry"
        ],
        [
            "LOAD_NAME",
            "InterfaceError"
        ],
        [
            "LOAD_NAME",
            "OperationalError"
        ],
        [
            "LOAD_NAME",
            "InternalError"
        ],
        [
            "LOAD_NAME",
            "ProgrammingError"
        ],
        [
            "CALL",
            "retry(3, (InterfaceError, OperationalError, InternalError, ProgrammingError))"
        ],
        [
            "STORE_NAME",
            "retry_db"
        ],
        [
            "STORE_NAME",
            "    def __init__(self, db_uri=None, _skip_version_check=False):\n        self.db_uri = db_uri = (\n                db_uri\n                or os.environ.get('BIRDSEYE_DB')\n                or os.path.join(os.path.expanduser('~'),\n                                '.birdseye.db'))\n\n        kwargs = dict(\n            pool_recycle=280,\n            echo=False,  # for convenience when debugging\n        )\n\n        try:\n            engine = create_engine(db_uri, **kwargs)\n        except ArgumentError:\n            db_uri = 'sqlite:///' + db_uri\n            engine = create_engine(db_uri, **kwargs)\n\n        self.engine = engine\n\n        self.Session = sessionmaker(bind=engine)\n\n        class Base(object):\n            @declared_attr\n            def __tablename__(cls):\n                return cls.__name__.lower()\n\n        Base = declarative_base(cls=Base)  # type: ignore\n\n        class KeyValue(Base):\n            key = Column(String(50), primary_key=True)\n            value = Column(Text)\n\n        db_self = self\n\n        class KeyValueStore(object):\n            def __getitem__(self, item):\n                with db_self.session_scope() as session:\n                    return (session\n                            .query(KeyValue.value)\n                            .filter_by(key=item)\n                            .scalar())\n\n            def __setitem__(self, key, value):\n                with db_self.session_scope() as session:\n                    session.query(KeyValue).filter_by(key=key).delete()\n                    session.add(KeyValue(key=key, value=str(value)))\n\n            __getattr__ = __getitem__\n            __setattr__ = __setitem__\n\n        LongText = LONGTEXT if engine.name == 'mysql' else Text\n\n        class Call(Base):\n            id = Column(String(length=32), primary_key=True)\n            function_id = Column(Integer, ForeignKey('function.id'), index=True)\n            function = relationship('Function', backref=backref('calls', lazy='dynamic'))\n            arguments = Column(Text)\n            return_value = Column(Text)\n            exception = Column(Text)\n            traceback = Column(Text)\n            data = Column(LongText)\n            start_time = Column(DateTime, index=True)\n\n            @property\n            def pretty_start_time(self):\n                return self._pretty_time(self.start_time)\n\n            @staticmethod\n            def _pretty_time(dt):\n                if not dt:\n                    return ''\n                return Markup('%s (%s)' % (\n                    dt.strftime('%Y-%m-%d&nbsp;%H:%M:%S'),\n                    naturaltime(dt)))\n\n            @property\n            def state_icon(self):\n                return Markup('<span class=\"glyphicon glyphicon-%s\" '\n                              'style=\"color: %s\"></span>' % (\n                                  ('ok', 'green') if self.success else\n                                  ('remove', 'red')))\n\n            @property\n            def success(self):\n                if self.exception:\n                    assert self.traceback\n                    assert self.return_value == 'None'\n                    return False\n                else:\n                    assert not self.traceback\n                    return True\n\n            @property\n            def result(self):\n                if self.success:\n                    return str(self.return_value)\n                else:\n                    return str(self.exception)\n\n            @property\n            def arguments_list(self):\n                return json.loads(self.arguments)\n\n            @property\n            def parsed_data(self):\n                return json.loads(self.data)\n\n            @staticmethod\n            def basic_dict(call):\n                return dict(arguments=call.arguments_list,\n                            **select_attrs(call, 'id function_id return_value traceback '\n                                                 'exception start_time'))\n\n            basic_columns = (id, function_id, return_value,\n                             traceback, exception, start_time, arguments)\n\n        class Function(Base):\n            id = Column(Integer, Sequence('function_id_seq'), primary_key=True)\n            file = Column(Text)\n            name = Column(Text)\n            type = Column(Text)  # function or module\n            html_body = Column(LongText)\n            lineno = Column(Integer)\n            data = Column(LongText)\n            hash = Column(String(length=64), index=True)\n            body_hash = Column(String(length=64), index=True)\n\n            __table_args__ = (\n                UniqueConstraint('hash',\n                                 name='everything_unique'),\n                Index('idx_file', 'file', mysql_length=256),\n                Index('idx_name', 'name', mysql_length=32),\n            )\n\n            @property\n            def parsed_data(self):\n                return json.loads(self.data)\n\n            @staticmethod\n            def basic_dict(func):\n                return select_attrs(func, 'file name lineno hash body_hash type')\n\n            basic_columns = (file, name, lineno, hash, body_hash, type)\n\n        self.Call = Call\n        self.Function = Function\n        self._KeyValue = KeyValue\n\n        self.key_value_store = kv = KeyValueStore()\n\n        if _skip_version_check:\n            return\n\n        if not self.table_exists(Function):\n            Base.metadata.create_all(engine)\n            kv.version = DB_VERSION\n        elif not self.table_exists(KeyValue) or int(kv.version) < DB_VERSION:\n            sys.exit('The birdseye database schema is out of date. '\n                     'Run \"python -m birdseye.clear_db\" to delete the existing tables.')"
        ],
        [
            "STORE_NAME",
            "    def table_exists(self, table):\n        return self.engine.dialect.has_table(self.engine, table.__name__)"
        ],
        [
            "STORE_NAME",
            "    def all_file_paths(self):\n        # type: () -> List[str]\n        with self.session_scope() as session:\n            paths = [f[0] for f in session.query(self.Function.file).distinct()\n                     if not is_ipython_cell(f[0])]\n        paths.sort()\n        if IPYTHON_FILE_PATH in paths:\n            paths.remove(IPYTHON_FILE_PATH)\n            paths.insert(0, IPYTHON_FILE_PATH)\n        return paths"
        ],
        [
            "STORE_NAME",
            "    def clear(self):\n        for model in [self.Call, self.Function, self._KeyValue]:\n            if self.table_exists(model):\n                model.__table__.drop(self.engine)"
        ],
        [
            "LOAD_NAME",
            "contextmanager"
        ],
        [
            "CALL",
            "contextmanager"
        ],
        [
            "STORE_NAME",
            "    @contextmanager\n    def session_scope(self):\n        \"\"\"Provide a transactional scope around a series of operations.\"\"\"\n        session = self.Session()\n        try:\n            yield session\n            session.commit()\n        except:\n            session.rollback()\n            raise\n        finally:\n            session.close()"
        ],
        [
            "STORE_NAME",
            "    def provide_session(self, func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            with self.session_scope() as session:\n                return func(session, *args, **kwargs)\n\n        return retry_db(wrapper)"
        ],
        [
            "LOAD_FAST",
            "db_uri"
        ],
        [
            "LOAD_GLOBAL",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.environ"
        ],
        [
            "LOAD_METHOD",
            "os.environ.get"
        ],
        [
            "CALL",
            "os.environ.get('BIRDSEYE_DB')"
        ],
        [
            "LOAD_GLOBAL",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.join"
        ],
        [
            "LOAD_GLOBAL",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.expanduser"
        ],
        [
            "CALL",
            "os.path.expanduser('~')"
        ],
        [
            "CALL",
            "os.path.join(os.path.expanduser('~'),\n                                '.birdseye.db')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.db_uri"
        ],
        [
            "STORE_FAST",
            "db_uri"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "CALL",
            "dict(\n            pool_recycle=280,\n            echo=False,  # for convenience when debugging\n        )"
        ],
        [
            "STORE_FAST",
            "kwargs"
        ],
        [
            "LOAD_GLOBAL",
            "create_engine"
        ],
        [
            "LOAD_FAST",
            "db_uri"
        ],
        [
            "LOAD_FAST",
            "kwargs"
        ],
        [
            "CALL_FUNCTION_EX",
            "create_engine(db_uri, **kwargs)"
        ],
        [
            "STORE_FAST",
            "engine"
        ],
        [
            "LOAD_GLOBAL",
            "ArgumentError"
        ],
        [
            "LOAD_FAST",
            "db_uri"
        ],
        [
            "BINARY_OP",
            "'sqlite:///' + db_uri"
        ],
        [
            "STORE_FAST",
            "db_uri"
        ],
        [
            "LOAD_GLOBAL",
            "create_engine"
        ],
        [
            "LOAD_FAST",
            "db_uri"
        ],
        [
            "LOAD_FAST",
            "kwargs"
        ],
        [
            "CALL_FUNCTION_EX",
            "create_engine(db_uri, **kwargs)"
        ],
        [
            "STORE_FAST",
            "engine"
        ],
        [
            "LOAD_FAST",
            "engine"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.engine"
        ],
        [
            "LOAD_GLOBAL",
            "sessionmaker"
        ],
        [
            "LOAD_FAST",
            "engine"
        ],
        [
            "CALL",
            "sessionmaker(bind=engine)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.Session"
        ],
        [
            "LOAD_GLOBAL",
            "object"
        ],
        [
            "CALL",
            "        class Base(object):\n            @declared_attr\n            def __tablename__(cls):\n                return cls.__name__.lower()"
        ],
        [
            "STORE_FAST",
            "        class Base(object):\n            @declared_attr\n            def __tablename__(cls):\n                return cls.__name__.lower()"
        ],
        [
            "LOAD_GLOBAL",
            "declarative_base"
        ],
        [
            "LOAD_FAST",
            "Base"
        ],
        [
            "CALL",
            "declarative_base(cls=Base)"
        ],
        [
            "STORE_FAST",
            "Base"
        ],
        [
            "LOAD_FAST",
            "Base"
        ],
        [
            "CALL",
            "        class KeyValue(Base):\n            key = Column(String(50), primary_key=True)\n            value = Column(Text)"
        ],
        [
            "STORE_DEREF",
            "        class KeyValue(Base):\n            key = Column(String(50), primary_key=True)\n            value = Column(Text)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_DEREF",
            "db_self"
        ],
        [
            "LOAD_GLOBAL",
            "object"
        ],
        [
            "CALL",
            "        class KeyValueStore(object):\n            def __getitem__(self, item):\n                with db_self.session_scope() as session:\n                    return (session\n                            .query(KeyValue.value)\n                            .filter_by(key=item)\n                            .scalar())\n\n            def __setitem__(self, key, value):\n                with db_self.session_scope() as session:\n                    session.query(KeyValue).filter_by(key=key).delete()\n                    session.add(KeyValue(key=key, value=str(value)))\n\n            __getattr__ = __getitem__\n            __setattr__ = __setitem__"
        ],
        [
            "STORE_FAST",
            "        class KeyValueStore(object):\n            def __getitem__(self, item):\n                with db_self.session_scope() as session:\n                    return (session\n                            .query(KeyValue.value)\n                            .filter_by(key=item)\n                            .scalar())\n\n            def __setitem__(self, key, value):\n                with db_self.session_scope() as session:\n                    session.query(KeyValue).filter_by(key=key).delete()\n                    session.add(KeyValue(key=key, value=str(value)))\n\n            __getattr__ = __getitem__\n            __setattr__ = __setitem__"
        ],
        [
            "LOAD_FAST",
            "engine"
        ],
        [
            "LOAD_ATTR",
            "engine.name"
        ],
        [
            "COMPARE_OP",
            "engine.name == 'mysql'"
        ],
        [
            "LOAD_GLOBAL",
            "LONGTEXT"
        ],
        [
            "LOAD_GLOBAL",
            "Text"
        ],
        [
            "STORE_DEREF",
            "LongText"
        ],
        [
            "LOAD_FAST",
            "Base"
        ],
        [
            "CALL",
            "        class Call(Base):\n            id = Column(String(length=32), primary_key=True)\n            function_id = Column(Integer, ForeignKey('function.id'), index=True)\n            function = relationship('Function', backref=backref('calls', lazy='dynamic'))\n            arguments = Column(Text)\n            return_value = Column(Text)\n            exception = Column(Text)\n            traceback = Column(Text)\n            data = Column(LongText)\n            start_time = Column(DateTime, index=True)\n\n            @property\n            def pretty_start_time(self):\n                return self._pretty_time(self.start_time)\n\n            @staticmethod\n            def _pretty_time(dt):\n                if not dt:\n                    return ''\n                return Markup('%s (%s)' % (\n                    dt.strftime('%Y-%m-%d&nbsp;%H:%M:%S'),\n                    naturaltime(dt)))\n\n            @property\n            def state_icon(self):\n                return Markup('<span class=\"glyphicon glyphicon-%s\" '\n                              'style=\"color: %s\"></span>' % (\n                                  ('ok', 'green') if self.success else\n                                  ('remove', 'red')))\n\n            @property\n            def success(self):\n                if self.exception:\n                    assert self.traceback\n                    assert self.return_value == 'None'\n                    return False\n                else:\n                    assert not self.traceback\n                    return True\n\n            @property\n            def result(self):\n                if self.success:\n                    return str(self.return_value)\n                else:\n                    return str(self.exception)\n\n            @property\n            def arguments_list(self):\n                return json.loads(self.arguments)\n\n            @property\n            def parsed_data(self):\n                return json.loads(self.data)\n\n            @staticmethod\n            def basic_dict(call):\n                return dict(arguments=call.arguments_list,\n                            **select_attrs(call, 'id function_id return_value traceback '\n                                                 'exception start_time'))\n\n            basic_columns = (id, function_id, return_value,\n                             traceback, exception, start_time, arguments)"
        ],
        [
            "STORE_FAST",
            "        class Call(Base):\n            id = Column(String(length=32), primary_key=True)\n            function_id = Column(Integer, ForeignKey('function.id'), index=True)\n            function = relationship('Function', backref=backref('calls', lazy='dynamic'))\n            arguments = Column(Text)\n            return_value = Column(Text)\n            exception = Column(Text)\n            traceback = Column(Text)\n            data = Column(LongText)\n            start_time = Column(DateTime, index=True)\n\n            @property\n            def pretty_start_time(self):\n                return self._pretty_time(self.start_time)\n\n            @staticmethod\n            def _pretty_time(dt):\n                if not dt:\n                    return ''\n                return Markup('%s (%s)' % (\n                    dt.strftime('%Y-%m-%d&nbsp;%H:%M:%S'),\n                    naturaltime(dt)))\n\n            @property\n            def state_icon(self):\n                return Markup('<span class=\"glyphicon glyphicon-%s\" '\n                              'style=\"color: %s\"></span>' % (\n                                  ('ok', 'green') if self.success else\n                                  ('remove', 'red')))\n\n            @property\n            def success(self):\n                if self.exception:\n                    assert self.traceback\n                    assert self.return_value == 'None'\n                    return False\n                else:\n                    assert not self.traceback\n                    return True\n\n            @property\n            def result(self):\n                if self.success:\n                    return str(self.return_value)\n                else:\n                    return str(self.exception)\n\n            @property\n            def arguments_list(self):\n                return json.loads(self.arguments)\n\n            @property\n            def parsed_data(self):\n                return json.loads(self.data)\n\n            @staticmethod\n            def basic_dict(call):\n                return dict(arguments=call.arguments_list,\n                            **select_attrs(call, 'id function_id return_value traceback '\n                                                 'exception start_time'))\n\n            basic_columns = (id, function_id, return_value,\n                             traceback, exception, start_time, arguments)"
        ],
        [
            "LOAD_FAST",
            "Base"
        ],
        [
            "CALL",
            "        class Function(Base):\n            id = Column(Integer, Sequence('function_id_seq'), primary_key=True)\n            file = Column(Text)\n            name = Column(Text)\n            type = Column(Text)  # function or module\n            html_body = Column(LongText)\n            lineno = Column(Integer)\n            data = Column(LongText)\n            hash = Column(String(length=64), index=True)\n            body_hash = Column(String(length=64), index=True)\n\n            __table_args__ = (\n                UniqueConstraint('hash',\n                                 name='everything_unique'),\n                Index('idx_file', 'file', mysql_length=256),\n                Index('idx_name', 'name', mysql_length=32),\n            )\n\n            @property\n            def parsed_data(self):\n                return json.loads(self.data)\n\n            @staticmethod\n            def basic_dict(func):\n                return select_attrs(func, 'file name lineno hash body_hash type')\n\n            basic_columns = (file, name, lineno, hash, body_hash, type)"
        ],
        [
            "STORE_FAST",
            "        class Function(Base):\n            id = Column(Integer, Sequence('function_id_seq'), primary_key=True)\n            file = Column(Text)\n            name = Column(Text)\n            type = Column(Text)  # function or module\n            html_body = Column(LongText)\n            lineno = Column(Integer)\n            data = Column(LongText)\n            hash = Column(String(length=64), index=True)\n            body_hash = Column(String(length=64), index=True)\n\n            __table_args__ = (\n                UniqueConstraint('hash',\n                                 name='everything_unique'),\n                Index('idx_file', 'file', mysql_length=256),\n                Index('idx_name', 'name', mysql_length=32),\n            )\n\n            @property\n            def parsed_data(self):\n                return json.loads(self.data)\n\n            @staticmethod\n            def basic_dict(func):\n                return select_attrs(func, 'file name lineno hash body_hash type')\n\n            basic_columns = (file, name, lineno, hash, body_hash, type)"
        ],
        [
            "LOAD_FAST",
            "Call"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.Call"
        ],
        [
            "LOAD_FAST",
            "Function"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.Function"
        ],
        [
            "LOAD_DEREF",
            "KeyValue"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._KeyValue"
        ],
        [
            "LOAD_FAST",
            "KeyValueStore"
        ],
        [
            "CALL",
            "KeyValueStore()"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.key_value_store"
        ],
        [
            "STORE_FAST",
            "kv"
        ],
        [
            "LOAD_FAST",
            "_skip_version_check"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.table_exists"
        ],
        [
            "LOAD_FAST",
            "Function"
        ],
        [
            "CALL",
            "self.table_exists(Function)"
        ],
        [
            "LOAD_FAST",
            "Base"
        ],
        [
            "LOAD_ATTR",
            "Base.metadata"
        ],
        [
            "LOAD_METHOD",
            "Base.metadata.create_all"
        ],
        [
            "LOAD_FAST",
            "engine"
        ],
        [
            "CALL",
            "Base.metadata.create_all(engine)"
        ],
        [
            "LOAD_GLOBAL",
            "DB_VERSION"
        ],
        [
            "LOAD_FAST",
            "kv"
        ],
        [
            "STORE_ATTR",
            "kv.version"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.table_exists"
        ],
        [
            "LOAD_DEREF",
            "KeyValue"
        ],
        [
            "CALL",
            "self.table_exists(KeyValue)"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "LOAD_FAST",
            "kv"
        ],
        [
            "LOAD_ATTR",
            "kv.version"
        ],
        [
            "CALL",
            "int(kv.version)"
        ],
        [
            "LOAD_GLOBAL",
            "DB_VERSION"
        ],
        [
            "COMPARE_OP",
            "int(kv.version) < DB_VERSION"
        ],
        [
            "LOAD_GLOBAL",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.exit"
        ],
        [
            "CALL",
            "sys.exit('The birdseye database schema is out of date. '\n                     'Run \"python -m birdseye.clear_db\" to delete the existing tables.')"
        ],
        [
            "LOAD_NAME",
            "declared_attr"
        ],
        [
            "CALL",
            "declared_attr"
        ],
        [
            "STORE_NAME",
            "            @declared_attr\n            def __tablename__(cls):\n                return cls.__name__.lower()"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_ATTR",
            "cls.__name__"
        ],
        [
            "LOAD_METHOD",
            "cls.__name__.lower"
        ],
        [
            "CALL",
            "cls.__name__.lower()"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "String"
        ],
        [
            "CALL",
            "String(50)"
        ],
        [
            "CALL",
            "Column(String(50), primary_key=True)"
        ],
        [
            "STORE_NAME",
            "key"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "Text"
        ],
        [
            "CALL",
            "Column(Text)"
        ],
        [
            "STORE_NAME",
            "value"
        ],
        [
            "STORE_NAME",
            "            def __getitem__(self, item):\n                with db_self.session_scope() as session:\n                    return (session\n                            .query(KeyValue.value)\n                            .filter_by(key=item)\n                            .scalar())"
        ],
        [
            "STORE_NAME",
            "            def __setitem__(self, key, value):\n                with db_self.session_scope() as session:\n                    session.query(KeyValue).filter_by(key=key).delete()\n                    session.add(KeyValue(key=key, value=str(value)))"
        ],
        [
            "LOAD_NAME",
            "__getitem__"
        ],
        [
            "STORE_NAME",
            "__getattr__"
        ],
        [
            "LOAD_NAME",
            "__setitem__"
        ],
        [
            "STORE_NAME",
            "__setattr__"
        ],
        [
            "LOAD_DEREF",
            "db_self"
        ],
        [
            "LOAD_METHOD",
            "db_self.session_scope"
        ],
        [
            "CALL",
            "db_self.session_scope()"
        ],
        [
            "STORE_FAST",
            "session"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session\n                            .query"
        ],
        [
            "LOAD_DEREF",
            "KeyValue"
        ],
        [
            "LOAD_ATTR",
            "KeyValue.value"
        ],
        [
            "CALL",
            "session\n                            .query(KeyValue.value)"
        ],
        [
            "LOAD_METHOD",
            "session\n                            .query(KeyValue.value)\n                            .filter_by"
        ],
        [
            "LOAD_FAST",
            "item"
        ],
        [
            "CALL",
            "session\n                            .query(KeyValue.value)\n                            .filter_by(key=item)"
        ],
        [
            "LOAD_METHOD",
            "session\n                            .query(KeyValue.value)\n                            .filter_by(key=item)\n                            .scalar"
        ],
        [
            "CALL",
            "session\n                            .query(KeyValue.value)\n                            .filter_by(key=item)\n                            .scalar()"
        ],
        [
            "CALL",
            "                with db_self.session_scope() as session:\n                    return (session\n                            .query(KeyValue.value)\n                            .filter_by(key=item)\n                            .scalar())"
        ],
        [
            "LOAD_DEREF",
            "db_self"
        ],
        [
            "LOAD_METHOD",
            "db_self.session_scope"
        ],
        [
            "CALL",
            "db_self.session_scope()"
        ],
        [
            "STORE_FAST",
            "session"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "LOAD_DEREF",
            "KeyValue"
        ],
        [
            "CALL",
            "session.query(KeyValue)"
        ],
        [
            "LOAD_METHOD",
            "session.query(KeyValue).filter_by"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "CALL",
            "session.query(KeyValue).filter_by(key=key)"
        ],
        [
            "LOAD_METHOD",
            "session.query(KeyValue).filter_by(key=key).delete"
        ],
        [
            "CALL",
            "session.query(KeyValue).filter_by(key=key).delete()"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.add"
        ],
        [
            "LOAD_DEREF",
            "KeyValue"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "CALL",
            "str(value)"
        ],
        [
            "CALL",
            "KeyValue(key=key, value=str(value))"
        ],
        [
            "CALL",
            "session.add(KeyValue(key=key, value=str(value)))"
        ],
        [
            "CALL",
            "                with db_self.session_scope() as session:\n                    session.query(KeyValue).filter_by(key=key).delete()\n                    session.add(KeyValue(key=key, value=str(value)))"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "String"
        ],
        [
            "CALL",
            "String(length=32)"
        ],
        [
            "CALL",
            "Column(String(length=32), primary_key=True)"
        ],
        [
            "STORE_NAME",
            "id"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "Integer"
        ],
        [
            "LOAD_NAME",
            "ForeignKey"
        ],
        [
            "CALL",
            "ForeignKey('function.id')"
        ],
        [
            "CALL",
            "Column(Integer, ForeignKey('function.id'), index=True)"
        ],
        [
            "STORE_NAME",
            "function_id"
        ],
        [
            "LOAD_NAME",
            "relationship"
        ],
        [
            "LOAD_NAME",
            "backref"
        ],
        [
            "CALL",
            "backref('calls', lazy='dynamic')"
        ],
        [
            "CALL",
            "relationship('Function', backref=backref('calls', lazy='dynamic'))"
        ],
        [
            "STORE_NAME",
            "function"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "Text"
        ],
        [
            "CALL",
            "Column(Text)"
        ],
        [
            "STORE_NAME",
            "arguments"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "Text"
        ],
        [
            "CALL",
            "Column(Text)"
        ],
        [
            "STORE_NAME",
            "return_value"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "Text"
        ],
        [
            "CALL",
            "Column(Text)"
        ],
        [
            "STORE_NAME",
            "exception"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "Text"
        ],
        [
            "CALL",
            "Column(Text)"
        ],
        [
            "STORE_NAME",
            "traceback"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_CLASSDEREF",
            "LongText"
        ],
        [
            "CALL",
            "Column(LongText)"
        ],
        [
            "STORE_NAME",
            "data"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "DateTime"
        ],
        [
            "CALL",
            "Column(DateTime, index=True)"
        ],
        [
            "STORE_NAME",
            "start_time"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "            @property\n            def pretty_start_time(self):\n                return self._pretty_time(self.start_time)"
        ],
        [
            "LOAD_NAME",
            "staticmethod"
        ],
        [
            "CALL",
            "staticmethod"
        ],
        [
            "STORE_NAME",
            "            @staticmethod\n            def _pretty_time(dt):\n                if not dt:\n                    return ''\n                return Markup('%s (%s)' % (\n                    dt.strftime('%Y-%m-%d&nbsp;%H:%M:%S'),\n                    naturaltime(dt)))"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "            @property\n            def state_icon(self):\n                return Markup('<span class=\"glyphicon glyphicon-%s\" '\n                              'style=\"color: %s\"></span>' % (\n                                  ('ok', 'green') if self.success else\n                                  ('remove', 'red')))"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "            @property\n            def success(self):\n                if self.exception:\n                    assert self.traceback\n                    assert self.return_value == 'None'\n                    return False\n                else:\n                    assert not self.traceback\n                    return True"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "            @property\n            def result(self):\n                if self.success:\n                    return str(self.return_value)\n                else:\n                    return str(self.exception)"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "            @property\n            def arguments_list(self):\n                return json.loads(self.arguments)"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "            @property\n            def parsed_data(self):\n                return json.loads(self.data)"
        ],
        [
            "LOAD_NAME",
            "staticmethod"
        ],
        [
            "CALL",
            "staticmethod"
        ],
        [
            "STORE_NAME",
            "            @staticmethod\n            def basic_dict(call):\n                return dict(arguments=call.arguments_list,\n                            **select_attrs(call, 'id function_id return_value traceback '\n                                                 'exception start_time'))"
        ],
        [
            "LOAD_NAME",
            "id"
        ],
        [
            "LOAD_NAME",
            "function_id"
        ],
        [
            "LOAD_NAME",
            "return_value"
        ],
        [
            "LOAD_NAME",
            "traceback"
        ],
        [
            "LOAD_NAME",
            "exception"
        ],
        [
            "LOAD_NAME",
            "start_time"
        ],
        [
            "LOAD_NAME",
            "arguments"
        ],
        [
            "STORE_NAME",
            "basic_columns"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._pretty_time"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.start_time"
        ],
        [
            "CALL",
            "self._pretty_time(self.start_time)"
        ],
        [
            "LOAD_FAST",
            "dt"
        ],
        [
            "LOAD_GLOBAL",
            "Markup"
        ],
        [
            "LOAD_FAST",
            "dt"
        ],
        [
            "LOAD_METHOD",
            "dt.strftime"
        ],
        [
            "CALL",
            "dt.strftime('%Y-%m-%d&nbsp;%H:%M:%S')"
        ],
        [
            "LOAD_GLOBAL",
            "naturaltime"
        ],
        [
            "LOAD_FAST",
            "dt"
        ],
        [
            "CALL",
            "naturaltime(dt)"
        ],
        [
            "BUILD_STRING",
            "'%s (%s)' % (\n                    dt.strftime('%Y-%m-%d&nbsp;%H:%M:%S'),\n                    naturaltime(dt))"
        ],
        [
            "CALL",
            "Markup('%s (%s)' % (\n                    dt.strftime('%Y-%m-%d&nbsp;%H:%M:%S'),\n                    naturaltime(dt)))"
        ],
        [
            "LOAD_GLOBAL",
            "Markup"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.success"
        ],
        [
            "BINARY_OP",
            "'<span class=\"glyphicon glyphicon-%s\" '\n                              'style=\"color: %s\"></span>' % (\n                                  ('ok', 'green') if self.success else\n                                  ('remove', 'red'))"
        ],
        [
            "CALL",
            "Markup('<span class=\"glyphicon glyphicon-%s\" '\n                              'style=\"color: %s\"></span>' % (\n                                  ('ok', 'green') if self.success else\n                                  ('remove', 'red')))"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.exception"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.traceback"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.return_value"
        ],
        [
            "COMPARE_OP",
            "self.return_value == 'None'"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.traceback"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.success"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.return_value"
        ],
        [
            "CALL",
            "str(self.return_value)"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.exception"
        ],
        [
            "CALL",
            "str(self.exception)"
        ],
        [
            "LOAD_GLOBAL",
            "json"
        ],
        [
            "LOAD_ATTR",
            "json.loads"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.arguments"
        ],
        [
            "CALL",
            "json.loads(self.arguments)"
        ],
        [
            "LOAD_GLOBAL",
            "json"
        ],
        [
            "LOAD_ATTR",
            "json.loads"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.data"
        ],
        [
            "CALL",
            "json.loads(self.data)"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_FAST",
            "call"
        ],
        [
            "LOAD_ATTR",
            "call.arguments_list"
        ],
        [
            "LOAD_GLOBAL",
            "select_attrs"
        ],
        [
            "LOAD_FAST",
            "call"
        ],
        [
            "CALL",
            "select_attrs(call, 'id function_id return_value traceback '\n                                                 'exception start_time')"
        ],
        [
            "CALL_FUNCTION_EX",
            "dict(arguments=call.arguments_list,\n                            **select_attrs(call, 'id function_id return_value traceback '\n                                                 'exception start_time'))"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "Integer"
        ],
        [
            "LOAD_NAME",
            "Sequence"
        ],
        [
            "CALL",
            "Sequence('function_id_seq')"
        ],
        [
            "CALL",
            "Column(Integer, Sequence('function_id_seq'), primary_key=True)"
        ],
        [
            "STORE_NAME",
            "id"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "Text"
        ],
        [
            "CALL",
            "Column(Text)"
        ],
        [
            "STORE_NAME",
            "file"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "Text"
        ],
        [
            "CALL",
            "Column(Text)"
        ],
        [
            "STORE_NAME",
            "name"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "Text"
        ],
        [
            "CALL",
            "Column(Text)"
        ],
        [
            "STORE_NAME",
            "type"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_CLASSDEREF",
            "LongText"
        ],
        [
            "CALL",
            "Column(LongText)"
        ],
        [
            "STORE_NAME",
            "html_body"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "Integer"
        ],
        [
            "CALL",
            "Column(Integer)"
        ],
        [
            "STORE_NAME",
            "lineno"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_CLASSDEREF",
            "LongText"
        ],
        [
            "CALL",
            "Column(LongText)"
        ],
        [
            "STORE_NAME",
            "data"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "String"
        ],
        [
            "CALL",
            "String(length=64)"
        ],
        [
            "CALL",
            "Column(String(length=64), index=True)"
        ],
        [
            "STORE_NAME",
            "hash"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "String"
        ],
        [
            "CALL",
            "String(length=64)"
        ],
        [
            "CALL",
            "Column(String(length=64), index=True)"
        ],
        [
            "STORE_NAME",
            "body_hash"
        ],
        [
            "LOAD_NAME",
            "UniqueConstraint"
        ],
        [
            "CALL",
            "UniqueConstraint('hash',\n                                 name='everything_unique')"
        ],
        [
            "LOAD_NAME",
            "Index"
        ],
        [
            "CALL",
            "Index('idx_file', 'file', mysql_length=256)"
        ],
        [
            "LOAD_NAME",
            "Index"
        ],
        [
            "CALL",
            "Index('idx_name', 'name', mysql_length=32)"
        ],
        [
            "STORE_NAME",
            "__table_args__"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "            @property\n            def parsed_data(self):\n                return json.loads(self.data)"
        ],
        [
            "LOAD_NAME",
            "staticmethod"
        ],
        [
            "CALL",
            "staticmethod"
        ],
        [
            "STORE_NAME",
            "            @staticmethod\n            def basic_dict(func):\n                return select_attrs(func, 'file name lineno hash body_hash type')"
        ],
        [
            "LOAD_NAME",
            "file"
        ],
        [
            "LOAD_NAME",
            "name"
        ],
        [
            "LOAD_NAME",
            "lineno"
        ],
        [
            "LOAD_NAME",
            "hash"
        ],
        [
            "LOAD_NAME",
            "body_hash"
        ],
        [
            "LOAD_NAME",
            "type"
        ],
        [
            "STORE_NAME",
            "basic_columns"
        ],
        [
            "LOAD_GLOBAL",
            "json"
        ],
        [
            "LOAD_ATTR",
            "json.loads"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.data"
        ],
        [
            "CALL",
            "json.loads(self.data)"
        ],
        [
            "LOAD_GLOBAL",
            "select_attrs"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "CALL",
            "select_attrs(func, 'file name lineno hash body_hash type')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.engine"
        ],
        [
            "LOAD_ATTR",
            "self.engine.dialect"
        ],
        [
            "LOAD_METHOD",
            "self.engine.dialect.has_table"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.engine"
        ],
        [
            "LOAD_FAST",
            "table"
        ],
        [
            "LOAD_ATTR",
            "table.__name__"
        ],
        [
            "CALL",
            "self.engine.dialect.has_table(self.engine, table.__name__)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.session_scope"
        ],
        [
            "CALL",
            "self.session_scope()"
        ],
        [
            "STORE_FAST",
            "session"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.Function"
        ],
        [
            "LOAD_ATTR",
            "self.Function.file"
        ],
        [
            "CALL",
            "session.query(self.Function.file)"
        ],
        [
            "LOAD_METHOD",
            "session.query(self.Function.file).distinct"
        ],
        [
            "CALL",
            "session.query(self.Function.file).distinct()"
        ],
        [
            "CALL",
            "[f[0] for f in session.query(self.Function.file).distinct()\n                     if not is_ipython_cell(f[0])]"
        ],
        [
            "STORE_FAST",
            "paths"
        ],
        [
            "CALL",
            "        with self.session_scope() as session:\n            paths = [f[0] for f in session.query(self.Function.file).distinct()\n                     if not is_ipython_cell(f[0])]"
        ],
        [
            "LOAD_FAST",
            "paths"
        ],
        [
            "LOAD_METHOD",
            "paths.sort"
        ],
        [
            "CALL",
            "paths.sort()"
        ],
        [
            "LOAD_GLOBAL",
            "IPYTHON_FILE_PATH"
        ],
        [
            "LOAD_FAST",
            "paths"
        ],
        [
            "CONTAINS_OP",
            "IPYTHON_FILE_PATH in paths"
        ],
        [
            "LOAD_FAST",
            "paths"
        ],
        [
            "LOAD_METHOD",
            "paths.remove"
        ],
        [
            "LOAD_GLOBAL",
            "IPYTHON_FILE_PATH"
        ],
        [
            "CALL",
            "paths.remove(IPYTHON_FILE_PATH)"
        ],
        [
            "LOAD_FAST",
            "paths"
        ],
        [
            "LOAD_METHOD",
            "paths.insert"
        ],
        [
            "LOAD_GLOBAL",
            "IPYTHON_FILE_PATH"
        ],
        [
            "CALL",
            "paths.insert(0, IPYTHON_FILE_PATH)"
        ],
        [
            "LOAD_FAST",
            "paths"
        ],
        [
            "LOAD_FAST",
            "[f[0] for f in session.query(self.Function.file).distinct()\n                     if not is_ipython_cell(f[0])]"
        ],
        [
            "STORE_FAST",
            "f"
        ],
        [
            "LOAD_GLOBAL",
            "is_ipython_cell"
        ],
        [
            "LOAD_FAST",
            "f"
        ],
        [
            "BINARY_SUBSCR",
            "f[0]"
        ],
        [
            "CALL",
            "is_ipython_cell(f[0])"
        ],
        [
            "LOAD_FAST",
            "f"
        ],
        [
            "BINARY_SUBSCR",
            "f[0]"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.Call"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.Function"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._KeyValue"
        ],
        [
            "STORE_FAST",
            "model"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.table_exists"
        ],
        [
            "LOAD_FAST",
            "model"
        ],
        [
            "CALL",
            "self.table_exists(model)"
        ],
        [
            "LOAD_FAST",
            "model"
        ],
        [
            "LOAD_ATTR",
            "model.__table__"
        ],
        [
            "LOAD_METHOD",
            "model.__table__.drop"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.engine"
        ],
        [
            "CALL",
            "model.__table__.drop(self.engine)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.Session"
        ],
        [
            "CALL",
            "self.Session()"
        ],
        [
            "STORE_FAST",
            "session"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.commit"
        ],
        [
            "CALL",
            "session.commit()"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.rollback"
        ],
        [
            "CALL",
            "session.rollback()"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.close"
        ],
        [
            "CALL",
            "session.close()"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.close"
        ],
        [
            "CALL",
            "session.close()"
        ],
        [
            "LOAD_GLOBAL",
            "functools"
        ],
        [
            "LOAD_ATTR",
            "functools.wraps"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "CALL",
            "functools.wraps(func)"
        ],
        [
            "CALL",
            "functools.wraps(func)"
        ],
        [
            "STORE_FAST",
            "        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            with self.session_scope() as session:\n                return func(session, *args, **kwargs)"
        ],
        [
            "LOAD_GLOBAL",
            "retry_db"
        ],
        [
            "LOAD_FAST",
            "wrapper"
        ],
        [
            "CALL",
            "retry_db(wrapper)"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.session_scope"
        ],
        [
            "CALL",
            "self.session_scope()"
        ],
        [
            "STORE_FAST",
            "session"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_FAST",
            "kwargs"
        ],
        [
            "CALL_FUNCTION_EX",
            "func(session, *args, **kwargs)"
        ],
        [
            "CALL",
            "            with self.session_scope() as session:\n                return func(session, *args, **kwargs)"
        ]
    ],
    "executing.py": [
        [
            "STORE_NAME",
            "\"\"\"\nGet information about what a frame is currently doing. Typical usage:\n\n    import executing\n\n    node = executing.Source.executing(frame).node\n    # node will be an AST node or None\n\"\"\""
        ],
        [
            "STORE_NAME",
            "import __future__"
        ],
        [
            "STORE_NAME",
            "import ast"
        ],
        [
            "STORE_NAME",
            "import dis"
        ],
        [
            "STORE_NAME",
            "import functools"
        ],
        [
            "STORE_NAME",
            "import inspect"
        ],
        [
            "STORE_NAME",
            "import io"
        ],
        [
            "STORE_NAME",
            "import linecache"
        ],
        [
            "STORE_NAME",
            "import sys"
        ],
        [
            "STORE_NAME",
            "from collections import defaultdict, namedtuple, Sized"
        ],
        [
            "STORE_NAME",
            "from collections import defaultdict, namedtuple, Sized"
        ],
        [
            "STORE_NAME",
            "from collections import defaultdict, namedtuple, Sized"
        ],
        [
            "STORE_NAME",
            "from itertools import islice"
        ],
        [
            "STORE_NAME",
            "from lib2to3.pgen2.tokenize import cookie_re as encoding_pattern"
        ],
        [
            "STORE_NAME",
            "from operator import attrgetter"
        ],
        [
            "STORE_NAME",
            "from threading import RLock"
        ],
        [
            "STORE_NAME",
            "__all__"
        ],
        [
            "LOAD_NAME",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.version_info"
        ],
        [
            "BINARY_SUBSCR",
            "sys.version_info[0]"
        ],
        [
            "COMPARE_OP",
            "sys.version_info[0] == 3"
        ],
        [
            "STORE_NAME",
            "PY3"
        ],
        [
            "LOAD_NAME",
            "PY3"
        ],
        [
            "STORE_NAME",
            "from functools import lru_cache"
        ],
        [
            "STORE_NAME",
            "from tokenize import detect_encoding"
        ],
        [
            "LOAD_NAME",
            "lru_cache"
        ],
        [
            "CALL",
            "lru_cache(maxsize=None)"
        ],
        [
            "STORE_NAME",
            "cache"
        ],
        [
            "LOAD_NAME",
            "str"
        ],
        [
            "STORE_NAME",
            "text_type"
        ],
        [
            "STORE_NAME",
            "from lib2to3.pgen2.tokenize import detect_encoding"
        ],
        [
            "STORE_NAME",
            "    def cache(func):\n        d = {}\n\n        @functools.wraps(func)\n        def wrapper(*args):\n            if args in d:\n                return d[args]\n            result = d[args] = func(*args)\n            return result\n\n        return wrapper"
        ],
        [
            "LOAD_NAME",
            "unicode"
        ],
        [
            "STORE_NAME",
            "text_type"
        ],
        [
            "LOAD_NAME",
            "dis"
        ],
        [
            "LOAD_ATTR",
            "dis.get_instructions"
        ],
        [
            "STORE_NAME",
            "get_instructions"
        ],
        [
            "LOAD_NAME",
            "AttributeError"
        ],
        [
            "LOAD_NAME",
            "namedtuple"
        ],
        [
            "CALL",
            "namedtuple('Instruction', 'offset argval opname')"
        ],
        [
            "STORE_NAME",
            "Instruction"
        ],
        [
            "STORE_NAME",
            "from dis import HAVE_ARGUMENT, EXTENDED_ARG, hasconst, opname"
        ],
        [
            "STORE_NAME",
            "from dis import HAVE_ARGUMENT, EXTENDED_ARG, hasconst, opname"
        ],
        [
            "STORE_NAME",
            "from dis import HAVE_ARGUMENT, EXTENDED_ARG, hasconst, opname"
        ],
        [
            "STORE_NAME",
            "from dis import HAVE_ARGUMENT, EXTENDED_ARG, hasconst, opname"
        ],
        [
            "STORE_NAME",
            "    def get_instructions(co):\n        code = co.co_code\n        n = len(code)\n        i = 0\n        extended_arg = 0\n        while i < n:\n            offset = i\n            c = code[i]\n            op = ord(c)\n            argval = None\n            i = i + 1\n            if op >= HAVE_ARGUMENT:\n                oparg = ord(code[i]) + ord(code[i + 1]) * 256 + extended_arg\n                extended_arg = 0\n                i = i + 2\n                if op == EXTENDED_ARG:\n                    extended_arg = oparg * 65536\n\n                if op in hasconst:\n                    argval = co.co_consts[oparg]\n            yield Instruction(offset, argval, opname[op])"
        ],
        [
            "LOAD_NAME",
            "Exception"
        ],
        [
            "CALL",
            "class NotOneValueFound(Exception):\n    pass"
        ],
        [
            "STORE_NAME",
            "class NotOneValueFound(Exception):\n    pass"
        ],
        [
            "STORE_NAME",
            "def only(it):\n    if isinstance(it, Sized):\n        if len(it) != 1:\n            raise NotOneValueFound('Expected one value, found %s' % len(it))\n        # noinspection PyTypeChecker\n        return list(it)[0]\n\n    lst = tuple(islice(it, 2))\n    if len(lst) == 0:\n        raise NotOneValueFound('Expected one value, found 0')\n    if len(lst) > 1:\n        raise NotOneValueFound('Expected one value, found several')\n    return lst[0]"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class Source(object):\n    \"\"\"\n    The source code of a single file and associated metadata.\n\n    The main method of interest is the classmethod `executing(frame)`.\n\n    If you want an instance of this class, don't construct it.\n    Ideally use the classmethod `for_frame(frame)`.\n    If you don't have a frame, use `for_filename(filename [, module_globals])`.\n    These methods cache instances by filename, so at most one instance exists per filename.\n\n    Attributes:\n        - filename\n        - text\n        - tree: AST parsed from text, or None if text is not valid Python\n            All nodes in the tree have an extra `parent` attribute\n\n    Other methods of interest:\n        - statements_at_line\n        - asttokens\n        - code_qualname\n    \"\"\"\n\n    def __init__(self, filename, text):\n        \"\"\"\n        Don't call this constructor, see the class docstring.\n        \"\"\"\n\n        self.filename = filename\n\n        if not isinstance(text, text_type):\n            text = self.decode_source(text)\n        self.text = text\n\n        if PY3:\n            ast_text = text\n        else:\n            # In python 2 it's a syntax error to parse unicode\n            # with an encoding declaration, so we remove it but\n            # leave empty lines in its place to keep line numbers the same\n            ast_text = ''.join([\n                '\\n' if i < 2 and encoding_pattern.match(line)\n                else line\n                for i, line in enumerate(text.splitlines(True))\n            ])\n\n        self._nodes_by_line = defaultdict(list)\n        self.tree = None\n        self._qualnames = {}\n\n        if text:\n            try:\n                self.tree = ast.parse(ast_text, filename=filename)\n            except SyntaxError:\n                pass\n            else:\n                for node in ast.walk(self.tree):\n                    for child in ast.iter_child_nodes(node):\n                        child.parent = node\n                    if hasattr(node, 'lineno'):\n                        self._nodes_by_line[node.lineno].append(node)\n\n                visitor = QualnameVisitor()\n                visitor.visit(self.tree)\n                self._qualnames = visitor.qualnames\n\n    @classmethod\n    def for_frame(cls, frame):\n        \"\"\"\n        Returns the `Source` object corresponding to the file the frame is executing in.\n        \"\"\"\n        return cls.for_filename(frame.f_code.co_filename, frame.f_globals or {})\n\n    @classmethod\n    def for_filename(cls, filename, module_globals=None):\n        source_cache = cls._class_local('__source_cache', {})\n        try:\n            return source_cache[filename]\n        except KeyError:\n            pass\n\n        lines = linecache.getlines(filename, module_globals)\n        result = source_cache[filename] = cls(filename, ''.join(lines))\n        return result\n\n    @classmethod\n    def lazycache(cls, frame):\n        if hasattr(linecache, 'lazycache'):\n            linecache.lazycache(frame.f_code.co_filename, frame.f_globals)\n\n    @classmethod\n    def executing(cls, frame):\n        \"\"\"\n        Returns an `Executing` object representing the operation\n        currently executing in the given frame.\n        \"\"\"\n        key = (frame.f_code, frame.f_lasti)\n        executing_cache = cls._class_local('__executing_cache', {})\n\n        try:\n            args = executing_cache[key]\n        except KeyError:\n            source = cls.for_frame(frame)\n            node = stmts = None\n            if source.tree:\n                stmts = source.statements_at_line(frame.f_lineno)\n                try:\n                    node = NodeFinder(frame, stmts, source.tree).result\n                except Exception:\n                    raise\n                else:\n                    new_stmts = {statement_containing_node(node)}\n                    assert new_stmts <= stmts\n                    stmts = new_stmts\n\n            args = source, node, stmts\n            executing_cache[key] = args\n\n        return Executing(frame, *args)\n\n    @classmethod\n    def _class_local(cls, name, default):\n        \"\"\"\n        Returns an attribute directly associated with this class\n        (as opposed to subclasses), setting default if necessary\n        \"\"\"\n        # classes have a mappingproxy preventing us from using setdefault\n        result = cls.__dict__.get(name, default)\n        setattr(cls, name, result)\n        return result\n\n    @cache\n    def statements_at_line(self, lineno):\n        \"\"\"\n        Returns the statement nodes overlapping the given line.\n\n        Returns at most one statement unless semicolons are present.\n\n        If the `text` attribute is not valid python, meaning\n        `tree` is None, returns an empty set.\n\n        Otherwise, `Source.for_frame(frame).statements_at_line(frame.f_lineno)`\n        should return at least one statement.\n        \"\"\"\n\n        return {\n            statement_containing_node(node)\n            for node in\n            self._nodes_by_line[lineno]\n        }\n\n    @cache\n    def asttokens(self):\n        \"\"\"\n        Returns an ASTTokens object for getting the source of specific AST nodes.\n\n        See http://asttokens.readthedocs.io/en/latest/api-index.html\n        \"\"\"\n        from asttokens import ASTTokens  # must be installed separately\n        return ASTTokens(\n            self.text,\n            tree=self.tree,\n            filename=self.filename,\n        )\n\n    @staticmethod\n    def decode_source(source):\n        if isinstance(source, bytes):\n            encoding, _ = detect_encoding(io.BytesIO(source).readline)\n            source = source.decode(encoding)\n        return source\n\n    def code_qualname(self, code):\n        \"\"\"\n        Imitates the __qualname__ attribute of functions for code objects.\n        Given:\n\n            - A function `func`\n            - A frame `frame` for an execution of `func`, meaning:\n                `frame.f_code is func.__code__`\n\n        `Source.for_frame(frame).code_qualname(frame.f_code)`\n        will be equal to `func.__qualname__`*. Works for Python 2 as well,\n        where of course no `__qualname__` attribute exists.\n\n        Falls back to `code.co_name` if there is no appropriate qualname.\n\n        Based on https://github.com/wbolster/qualname\n\n        (* unless `func` is a lambda\n        nested inside another lambda on the same line, in which case\n        the outer lambda's qualname will be returned for the codes\n        of both lambdas)\n        \"\"\"\n        assert code.co_filename == self.filename\n        return self._qualnames.get((code.co_name, code.co_firstlineno), code.co_name)"
        ],
        [
            "STORE_NAME",
            "class Source(object):\n    \"\"\"\n    The source code of a single file and associated metadata.\n\n    The main method of interest is the classmethod `executing(frame)`.\n\n    If you want an instance of this class, don't construct it.\n    Ideally use the classmethod `for_frame(frame)`.\n    If you don't have a frame, use `for_filename(filename [, module_globals])`.\n    These methods cache instances by filename, so at most one instance exists per filename.\n\n    Attributes:\n        - filename\n        - text\n        - tree: AST parsed from text, or None if text is not valid Python\n            All nodes in the tree have an extra `parent` attribute\n\n    Other methods of interest:\n        - statements_at_line\n        - asttokens\n        - code_qualname\n    \"\"\"\n\n    def __init__(self, filename, text):\n        \"\"\"\n        Don't call this constructor, see the class docstring.\n        \"\"\"\n\n        self.filename = filename\n\n        if not isinstance(text, text_type):\n            text = self.decode_source(text)\n        self.text = text\n\n        if PY3:\n            ast_text = text\n        else:\n            # In python 2 it's a syntax error to parse unicode\n            # with an encoding declaration, so we remove it but\n            # leave empty lines in its place to keep line numbers the same\n            ast_text = ''.join([\n                '\\n' if i < 2 and encoding_pattern.match(line)\n                else line\n                for i, line in enumerate(text.splitlines(True))\n            ])\n\n        self._nodes_by_line = defaultdict(list)\n        self.tree = None\n        self._qualnames = {}\n\n        if text:\n            try:\n                self.tree = ast.parse(ast_text, filename=filename)\n            except SyntaxError:\n                pass\n            else:\n                for node in ast.walk(self.tree):\n                    for child in ast.iter_child_nodes(node):\n                        child.parent = node\n                    if hasattr(node, 'lineno'):\n                        self._nodes_by_line[node.lineno].append(node)\n\n                visitor = QualnameVisitor()\n                visitor.visit(self.tree)\n                self._qualnames = visitor.qualnames\n\n    @classmethod\n    def for_frame(cls, frame):\n        \"\"\"\n        Returns the `Source` object corresponding to the file the frame is executing in.\n        \"\"\"\n        return cls.for_filename(frame.f_code.co_filename, frame.f_globals or {})\n\n    @classmethod\n    def for_filename(cls, filename, module_globals=None):\n        source_cache = cls._class_local('__source_cache', {})\n        try:\n            return source_cache[filename]\n        except KeyError:\n            pass\n\n        lines = linecache.getlines(filename, module_globals)\n        result = source_cache[filename] = cls(filename, ''.join(lines))\n        return result\n\n    @classmethod\n    def lazycache(cls, frame):\n        if hasattr(linecache, 'lazycache'):\n            linecache.lazycache(frame.f_code.co_filename, frame.f_globals)\n\n    @classmethod\n    def executing(cls, frame):\n        \"\"\"\n        Returns an `Executing` object representing the operation\n        currently executing in the given frame.\n        \"\"\"\n        key = (frame.f_code, frame.f_lasti)\n        executing_cache = cls._class_local('__executing_cache', {})\n\n        try:\n            args = executing_cache[key]\n        except KeyError:\n            source = cls.for_frame(frame)\n            node = stmts = None\n            if source.tree:\n                stmts = source.statements_at_line(frame.f_lineno)\n                try:\n                    node = NodeFinder(frame, stmts, source.tree).result\n                except Exception:\n                    raise\n                else:\n                    new_stmts = {statement_containing_node(node)}\n                    assert new_stmts <= stmts\n                    stmts = new_stmts\n\n            args = source, node, stmts\n            executing_cache[key] = args\n\n        return Executing(frame, *args)\n\n    @classmethod\n    def _class_local(cls, name, default):\n        \"\"\"\n        Returns an attribute directly associated with this class\n        (as opposed to subclasses), setting default if necessary\n        \"\"\"\n        # classes have a mappingproxy preventing us from using setdefault\n        result = cls.__dict__.get(name, default)\n        setattr(cls, name, result)\n        return result\n\n    @cache\n    def statements_at_line(self, lineno):\n        \"\"\"\n        Returns the statement nodes overlapping the given line.\n\n        Returns at most one statement unless semicolons are present.\n\n        If the `text` attribute is not valid python, meaning\n        `tree` is None, returns an empty set.\n\n        Otherwise, `Source.for_frame(frame).statements_at_line(frame.f_lineno)`\n        should return at least one statement.\n        \"\"\"\n\n        return {\n            statement_containing_node(node)\n            for node in\n            self._nodes_by_line[lineno]\n        }\n\n    @cache\n    def asttokens(self):\n        \"\"\"\n        Returns an ASTTokens object for getting the source of specific AST nodes.\n\n        See http://asttokens.readthedocs.io/en/latest/api-index.html\n        \"\"\"\n        from asttokens import ASTTokens  # must be installed separately\n        return ASTTokens(\n            self.text,\n            tree=self.tree,\n            filename=self.filename,\n        )\n\n    @staticmethod\n    def decode_source(source):\n        if isinstance(source, bytes):\n            encoding, _ = detect_encoding(io.BytesIO(source).readline)\n            source = source.decode(encoding)\n        return source\n\n    def code_qualname(self, code):\n        \"\"\"\n        Imitates the __qualname__ attribute of functions for code objects.\n        Given:\n\n            - A function `func`\n            - A frame `frame` for an execution of `func`, meaning:\n                `frame.f_code is func.__code__`\n\n        `Source.for_frame(frame).code_qualname(frame.f_code)`\n        will be equal to `func.__qualname__`*. Works for Python 2 as well,\n        where of course no `__qualname__` attribute exists.\n\n        Falls back to `code.co_name` if there is no appropriate qualname.\n\n        Based on https://github.com/wbolster/qualname\n\n        (* unless `func` is a lambda\n        nested inside another lambda on the same line, in which case\n        the outer lambda's qualname will be returned for the codes\n        of both lambdas)\n        \"\"\"\n        assert code.co_filename == self.filename\n        return self._qualnames.get((code.co_name, code.co_firstlineno), code.co_name)"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class Executing(object):\n    \"\"\"\n    Information about the operation a frame is currently executing.\n\n    Generally you will just want `node`, which is the AST node being executed,\n    or None if it's unknown.\n    Currently `node` can only be an `ast.Call` object, other operations\n    will be supported in future.\n    \"\"\"\n\n    def __init__(self, frame, source, node, stmts):\n        self.frame = frame\n        self.source = source\n        self.node = node\n        self.statements = stmts\n\n    def code_qualname(self):\n        return self.source.code_qualname(self.frame.f_code)\n\n    def text(self):\n        return self.source.asttokens().get_text(self.node)\n\n    def text_range(self):\n        return self.source.asttokens().get_text_range(self.node)"
        ],
        [
            "STORE_NAME",
            "class Executing(object):\n    \"\"\"\n    Information about the operation a frame is currently executing.\n\n    Generally you will just want `node`, which is the AST node being executed,\n    or None if it's unknown.\n    Currently `node` can only be an `ast.Call` object, other operations\n    will be supported in future.\n    \"\"\"\n\n    def __init__(self, frame, source, node, stmts):\n        self.frame = frame\n        self.source = source\n        self.node = node\n        self.statements = stmts\n\n    def code_qualname(self):\n        return self.source.code_qualname(self.frame.f_code)\n\n    def text(self):\n        return self.source.asttokens().get_text(self.node)\n\n    def text_range(self):\n        return self.source.asttokens().get_text_range(self.node)"
        ],
        [
            "LOAD_NAME",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.NodeVisitor"
        ],
        [
            "CALL",
            "class QualnameVisitor(ast.NodeVisitor):\n    def __init__(self):\n        super(QualnameVisitor, self).__init__()\n        self.stack = []\n        self.qualnames = {}\n\n    def visit_FunctionDef(self, node, name=None):\n        name = name or node.name\n        self.stack.append(name)\n        self.qualnames.setdefault((name, node.lineno), \".\".join(self.stack))\n\n        self.stack.append('<locals>')\n        if isinstance(node, ast.Lambda):\n            children = [node.body]\n        else:\n            children = node.body\n        for child in children:\n            self.visit(child)\n        self.stack.pop()\n        self.stack.pop()\n\n        # Find lambdas in the function definition outside the body,\n        # e.g. decorators or default arguments\n        # Based on iter_child_nodes\n        for field, child in ast.iter_fields(node):\n            if field == 'body':\n                continue\n            if isinstance(child, ast.AST):\n                self.visit(child)\n            elif isinstance(child, list):\n                for grandchild in child:\n                    if isinstance(grandchild, ast.AST):\n                        self.visit(grandchild)\n\n    def visit_Lambda(self, node):\n        self.visit_FunctionDef(node, '<lambda>')\n\n    def visit_ClassDef(self, node):\n        self.stack.append(node.name)\n        self.generic_visit(node)\n        self.stack.pop()"
        ],
        [
            "STORE_NAME",
            "class QualnameVisitor(ast.NodeVisitor):\n    def __init__(self):\n        super(QualnameVisitor, self).__init__()\n        self.stack = []\n        self.qualnames = {}\n\n    def visit_FunctionDef(self, node, name=None):\n        name = name or node.name\n        self.stack.append(name)\n        self.qualnames.setdefault((name, node.lineno), \".\".join(self.stack))\n\n        self.stack.append('<locals>')\n        if isinstance(node, ast.Lambda):\n            children = [node.body]\n        else:\n            children = node.body\n        for child in children:\n            self.visit(child)\n        self.stack.pop()\n        self.stack.pop()\n\n        # Find lambdas in the function definition outside the body,\n        # e.g. decorators or default arguments\n        # Based on iter_child_nodes\n        for field, child in ast.iter_fields(node):\n            if field == 'body':\n                continue\n            if isinstance(child, ast.AST):\n                self.visit(child)\n            elif isinstance(child, list):\n                for grandchild in child:\n                    if isinstance(grandchild, ast.AST):\n                        self.visit(grandchild)\n\n    def visit_Lambda(self, node):\n        self.visit_FunctionDef(node, '<lambda>')\n\n    def visit_ClassDef(self, node):\n        self.stack.append(node.name)\n        self.generic_visit(node)\n        self.stack.pop()"
        ],
        [
            "LOAD_NAME",
            "sum"
        ],
        [
            "LOAD_NAME",
            "__future__"
        ],
        [
            "LOAD_ATTR",
            "__future__.all_feature_names"
        ],
        [
            "CALL",
            "(\n    getattr(__future__, fname).compiler_flag\n    for fname in __future__.all_feature_names\n)"
        ],
        [
            "CALL",
            "sum(\n    getattr(__future__, fname).compiler_flag\n    for fname in __future__.all_feature_names\n)"
        ],
        [
            "STORE_NAME",
            "future_flags"
        ],
        [
            "STORE_NAME",
            "def compile_similar_to(source, matching_code):\n    return compile(\n        source,\n        matching_code.co_filename,\n        'exec',\n        flags=future_flags & matching_code.co_flags,\n        dont_inherit=True,\n    )"
        ],
        [
            "STORE_NAME",
            "sentinel"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class NodeFinder(object):\n    def __init__(self, frame, stmts, tree):\n        self.frame = frame\n        self.tree = tree\n\n        b = frame.f_code.co_code[frame.f_lasti]\n        if not PY3:\n            b = ord(b)\n        op_name = dis.opname[b]\n\n        if op_name.startswith('CALL_'):\n            typ = ast.Call\n        elif op_name == 'BINARY_SUBSCR':\n            typ = ast.Subscript\n        elif op_name.startswith('BINARY_'):\n            typ = ast.BinOp\n        elif op_name.startswith('UNARY_'):\n            typ = ast.UnaryOp\n        elif op_name in ('LOAD_ATTR', 'LOAD_METHOD', 'LOOKUP_METHOD'):\n            typ = ast.Attribute\n        elif op_name == 'COMPARE_OP':\n            typ = ast.Compare\n        else:\n            raise RuntimeError(op_name)\n\n        with lock:\n            exprs = {\n                node\n                for stmt in stmts\n                for node in ast.walk(stmt)\n                if isinstance(node, typ)\n                if not (hasattr(node, \"ctx\") and not isinstance(node.ctx, ast.Load))\n            }\n\n            self.result = only(list(self.matching_nodes(exprs)))\n\n    def matching_nodes(self, exprs):\n        for i, expr in enumerate(exprs):\n            setter = get_setter(expr)\n            replacement = ast.BinOp(\n                left=expr,\n                op=ast.Pow(),\n                right=ast.Str(s=sentinel),\n            )\n            ast.fix_missing_locations(replacement)\n            setter(replacement)\n            try:\n                instructions = self.compile_instructions()\n            except SyntaxError:\n                continue\n            finally:\n                setter(expr)\n            indices = [\n                i\n                for i, instruction in enumerate(instructions)\n                if instruction.argval == sentinel\n            ]\n            if not indices:\n                continue\n            arg_index = only(indices) - 1\n            while instructions[arg_index].opname == 'EXTENDED_ARG':\n                arg_index -= 1\n\n            if instructions[arg_index].offset == self.frame.f_lasti:\n                yield expr\n\n    def compile_instructions(self):\n        module_code = compile_similar_to(self.tree, self.frame.f_code)\n        code = only(find_codes(module_code, self.frame.f_code))\n        return list(get_instructions(code))"
        ],
        [
            "STORE_NAME",
            "class NodeFinder(object):\n    def __init__(self, frame, stmts, tree):\n        self.frame = frame\n        self.tree = tree\n\n        b = frame.f_code.co_code[frame.f_lasti]\n        if not PY3:\n            b = ord(b)\n        op_name = dis.opname[b]\n\n        if op_name.startswith('CALL_'):\n            typ = ast.Call\n        elif op_name == 'BINARY_SUBSCR':\n            typ = ast.Subscript\n        elif op_name.startswith('BINARY_'):\n            typ = ast.BinOp\n        elif op_name.startswith('UNARY_'):\n            typ = ast.UnaryOp\n        elif op_name in ('LOAD_ATTR', 'LOAD_METHOD', 'LOOKUP_METHOD'):\n            typ = ast.Attribute\n        elif op_name == 'COMPARE_OP':\n            typ = ast.Compare\n        else:\n            raise RuntimeError(op_name)\n\n        with lock:\n            exprs = {\n                node\n                for stmt in stmts\n                for node in ast.walk(stmt)\n                if isinstance(node, typ)\n                if not (hasattr(node, \"ctx\") and not isinstance(node.ctx, ast.Load))\n            }\n\n            self.result = only(list(self.matching_nodes(exprs)))\n\n    def matching_nodes(self, exprs):\n        for i, expr in enumerate(exprs):\n            setter = get_setter(expr)\n            replacement = ast.BinOp(\n                left=expr,\n                op=ast.Pow(),\n                right=ast.Str(s=sentinel),\n            )\n            ast.fix_missing_locations(replacement)\n            setter(replacement)\n            try:\n                instructions = self.compile_instructions()\n            except SyntaxError:\n                continue\n            finally:\n                setter(expr)\n            indices = [\n                i\n                for i, instruction in enumerate(instructions)\n                if instruction.argval == sentinel\n            ]\n            if not indices:\n                continue\n            arg_index = only(indices) - 1\n            while instructions[arg_index].opname == 'EXTENDED_ARG':\n                arg_index -= 1\n\n            if instructions[arg_index].offset == self.frame.f_lasti:\n                yield expr\n\n    def compile_instructions(self):\n        module_code = compile_similar_to(self.tree, self.frame.f_code)\n        code = only(find_codes(module_code, self.frame.f_code))\n        return list(get_instructions(code))"
        ],
        [
            "STORE_NAME",
            "def get_setter(node):\n    parent = node.parent\n    for name, field in ast.iter_fields(parent):\n        if field is node:\n            return lambda new_node: setattr(parent, name, new_node)\n        elif isinstance(field, list):\n            for i, item in enumerate(field):\n                if item is node:\n                    def setter(new_node):\n                        field[i] = new_node\n\n                    return setter"
        ],
        [
            "LOAD_NAME",
            "RLock"
        ],
        [
            "CALL",
            "RLock()"
        ],
        [
            "STORE_NAME",
            "lock"
        ],
        [
            "STORE_NAME",
            "def find_codes(root_code, matching):\n    def matches(c):\n        return all(\n            f(c) == f(matching)\n            for f in [\n                attrgetter('co_firstlineno'),\n                attrgetter('co_name'),\n                code_names,\n            ]\n        )\n\n    code_options = []\n    if matches(root_code):\n        code_options.append(root_code)\n\n    def finder(code):\n        for const in code.co_consts:\n            if not inspect.iscode(const):\n                continue\n\n            if matches(const):\n                code_options.append(const)\n            finder(const)\n\n    finder(root_code)\n    return code_options"
        ],
        [
            "STORE_NAME",
            "def code_names(code):\n    return frozenset().union(\n        code.co_names,\n        code.co_varnames,\n        code.co_freevars,\n        code.co_cellvars,\n    )"
        ],
        [
            "LOAD_NAME",
            "cache"
        ],
        [
            "CALL",
            "cache"
        ],
        [
            "STORE_NAME",
            "@cache\ndef statement_containing_node(node):\n    while not isinstance(node, ast.stmt):\n        node = node.parent\n    return node"
        ],
        [
            "STORE_DEREF",
            "d"
        ],
        [
            "LOAD_GLOBAL",
            "functools"
        ],
        [
            "LOAD_ATTR",
            "functools.wraps"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "CALL",
            "functools.wraps(func)"
        ],
        [
            "CALL",
            "functools.wraps(func)"
        ],
        [
            "STORE_FAST",
            "        @functools.wraps(func)\n        def wrapper(*args):\n            if args in d:\n                return d[args]\n            result = d[args] = func(*args)\n            return result"
        ],
        [
            "LOAD_FAST",
            "wrapper"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_DEREF",
            "d"
        ],
        [
            "CONTAINS_OP",
            "args in d"
        ],
        [
            "LOAD_DEREF",
            "d"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "BINARY_SUBSCR",
            "d[args]"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "CALL_FUNCTION_EX",
            "func(*args)"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_DEREF",
            "d"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "STORE_SUBSCR",
            "d[args]"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "co"
        ],
        [
            "LOAD_ATTR",
            "co.co_code"
        ],
        [
            "STORE_FAST",
            "code"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "CALL",
            "len(code)"
        ],
        [
            "STORE_FAST",
            "n"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "STORE_FAST",
            "extended_arg"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "COMPARE_OP",
            "i < n"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "STORE_FAST",
            "offset"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_SUBSCR",
            "code[i]"
        ],
        [
            "STORE_FAST",
            "c"
        ],
        [
            "LOAD_GLOBAL",
            "ord"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "CALL",
            "ord(c)"
        ],
        [
            "STORE_FAST",
            "op"
        ],
        [
            "STORE_FAST",
            "argval"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_OP",
            "i + 1"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "op"
        ],
        [
            "LOAD_GLOBAL",
            "HAVE_ARGUMENT"
        ],
        [
            "COMPARE_OP",
            "op >= HAVE_ARGUMENT"
        ],
        [
            "LOAD_GLOBAL",
            "ord"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_SUBSCR",
            "code[i]"
        ],
        [
            "CALL",
            "ord(code[i])"
        ],
        [
            "LOAD_GLOBAL",
            "ord"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_OP",
            "i + 1"
        ],
        [
            "BINARY_SUBSCR",
            "code[i + 1]"
        ],
        [
            "CALL",
            "ord(code[i + 1])"
        ],
        [
            "BINARY_OP",
            "ord(code[i + 1]) * 256"
        ],
        [
            "BINARY_OP",
            "ord(code[i]) + ord(code[i + 1]) * 256"
        ],
        [
            "LOAD_FAST",
            "extended_arg"
        ],
        [
            "BINARY_OP",
            "ord(code[i]) + ord(code[i + 1]) * 256 + extended_arg"
        ],
        [
            "STORE_FAST",
            "oparg"
        ],
        [
            "STORE_FAST",
            "extended_arg"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_OP",
            "i + 2"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "op"
        ],
        [
            "LOAD_GLOBAL",
            "EXTENDED_ARG"
        ],
        [
            "COMPARE_OP",
            "op == EXTENDED_ARG"
        ],
        [
            "LOAD_FAST",
            "oparg"
        ],
        [
            "BINARY_OP",
            "oparg * 65536"
        ],
        [
            "STORE_FAST",
            "extended_arg"
        ],
        [
            "LOAD_FAST",
            "op"
        ],
        [
            "LOAD_GLOBAL",
            "hasconst"
        ],
        [
            "CONTAINS_OP",
            "op in hasconst"
        ],
        [
            "LOAD_FAST",
            "co"
        ],
        [
            "LOAD_ATTR",
            "co.co_consts"
        ],
        [
            "LOAD_FAST",
            "oparg"
        ],
        [
            "BINARY_SUBSCR",
            "co.co_consts[oparg]"
        ],
        [
            "STORE_FAST",
            "argval"
        ],
        [
            "LOAD_GLOBAL",
            "Instruction"
        ],
        [
            "LOAD_FAST",
            "offset"
        ],
        [
            "LOAD_FAST",
            "argval"
        ],
        [
            "LOAD_GLOBAL",
            "opname"
        ],
        [
            "LOAD_FAST",
            "op"
        ],
        [
            "BINARY_SUBSCR",
            "opname[op]"
        ],
        [
            "CALL",
            "Instruction(offset, argval, opname[op])"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "COMPARE_OP",
            "i < n"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "it"
        ],
        [
            "LOAD_GLOBAL",
            "Sized"
        ],
        [
            "CALL",
            "isinstance(it, Sized)"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "it"
        ],
        [
            "CALL",
            "len(it)"
        ],
        [
            "COMPARE_OP",
            "len(it) != 1"
        ],
        [
            "LOAD_GLOBAL",
            "NotOneValueFound"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "it"
        ],
        [
            "CALL",
            "len(it)"
        ],
        [
            "BINARY_OP",
            "'Expected one value, found %s' % len(it)"
        ],
        [
            "CALL",
            "NotOneValueFound('Expected one value, found %s' % len(it))"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_FAST",
            "it"
        ],
        [
            "CALL",
            "list(it)"
        ],
        [
            "BINARY_SUBSCR",
            "list(it)[0]"
        ],
        [
            "LOAD_GLOBAL",
            "tuple"
        ],
        [
            "LOAD_GLOBAL",
            "islice"
        ],
        [
            "LOAD_FAST",
            "it"
        ],
        [
            "CALL",
            "islice(it, 2)"
        ],
        [
            "CALL",
            "tuple(islice(it, 2))"
        ],
        [
            "STORE_FAST",
            "lst"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "lst"
        ],
        [
            "CALL",
            "len(lst)"
        ],
        [
            "COMPARE_OP",
            "len(lst) == 0"
        ],
        [
            "LOAD_GLOBAL",
            "NotOneValueFound"
        ],
        [
            "CALL",
            "NotOneValueFound('Expected one value, found 0')"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "lst"
        ],
        [
            "CALL",
            "len(lst)"
        ],
        [
            "COMPARE_OP",
            "len(lst) > 1"
        ],
        [
            "LOAD_GLOBAL",
            "NotOneValueFound"
        ],
        [
            "CALL",
            "NotOneValueFound('Expected one value, found several')"
        ],
        [
            "LOAD_FAST",
            "lst"
        ],
        [
            "BINARY_SUBSCR",
            "lst[0]"
        ],
        [
            "STORE_NAME",
            "\"\"\"\n    The source code of a single file and associated metadata.\n\n    The main method of interest is the classmethod `executing(frame)`.\n\n    If you want an instance of this class, don't construct it.\n    Ideally use the classmethod `for_frame(frame)`.\n    If you don't have a frame, use `for_filename(filename [, module_globals])`.\n    These methods cache instances by filename, so at most one instance exists per filename.\n\n    Attributes:\n        - filename\n        - text\n        - tree: AST parsed from text, or None if text is not valid Python\n            All nodes in the tree have an extra `parent` attribute\n\n    Other methods of interest:\n        - statements_at_line\n        - asttokens\n        - code_qualname\n    \"\"\""
        ],
        [
            "STORE_NAME",
            "    def __init__(self, filename, text):\n        \"\"\"\n        Don't call this constructor, see the class docstring.\n        \"\"\"\n\n        self.filename = filename\n\n        if not isinstance(text, text_type):\n            text = self.decode_source(text)\n        self.text = text\n\n        if PY3:\n            ast_text = text\n        else:\n            # In python 2 it's a syntax error to parse unicode\n            # with an encoding declaration, so we remove it but\n            # leave empty lines in its place to keep line numbers the same\n            ast_text = ''.join([\n                '\\n' if i < 2 and encoding_pattern.match(line)\n                else line\n                for i, line in enumerate(text.splitlines(True))\n            ])\n\n        self._nodes_by_line = defaultdict(list)\n        self.tree = None\n        self._qualnames = {}\n\n        if text:\n            try:\n                self.tree = ast.parse(ast_text, filename=filename)\n            except SyntaxError:\n                pass\n            else:\n                for node in ast.walk(self.tree):\n                    for child in ast.iter_child_nodes(node):\n                        child.parent = node\n                    if hasattr(node, 'lineno'):\n                        self._nodes_by_line[node.lineno].append(node)\n\n                visitor = QualnameVisitor()\n                visitor.visit(self.tree)\n                self._qualnames = visitor.qualnames"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def for_frame(cls, frame):\n        \"\"\"\n        Returns the `Source` object corresponding to the file the frame is executing in.\n        \"\"\"\n        return cls.for_filename(frame.f_code.co_filename, frame.f_globals or {})"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def for_filename(cls, filename, module_globals=None):\n        source_cache = cls._class_local('__source_cache', {})\n        try:\n            return source_cache[filename]\n        except KeyError:\n            pass\n\n        lines = linecache.getlines(filename, module_globals)\n        result = source_cache[filename] = cls(filename, ''.join(lines))\n        return result"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def lazycache(cls, frame):\n        if hasattr(linecache, 'lazycache'):\n            linecache.lazycache(frame.f_code.co_filename, frame.f_globals)"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def executing(cls, frame):\n        \"\"\"\n        Returns an `Executing` object representing the operation\n        currently executing in the given frame.\n        \"\"\"\n        key = (frame.f_code, frame.f_lasti)\n        executing_cache = cls._class_local('__executing_cache', {})\n\n        try:\n            args = executing_cache[key]\n        except KeyError:\n            source = cls.for_frame(frame)\n            node = stmts = None\n            if source.tree:\n                stmts = source.statements_at_line(frame.f_lineno)\n                try:\n                    node = NodeFinder(frame, stmts, source.tree).result\n                except Exception:\n                    raise\n                else:\n                    new_stmts = {statement_containing_node(node)}\n                    assert new_stmts <= stmts\n                    stmts = new_stmts\n\n            args = source, node, stmts\n            executing_cache[key] = args\n\n        return Executing(frame, *args)"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def _class_local(cls, name, default):\n        \"\"\"\n        Returns an attribute directly associated with this class\n        (as opposed to subclasses), setting default if necessary\n        \"\"\"\n        # classes have a mappingproxy preventing us from using setdefault\n        result = cls.__dict__.get(name, default)\n        setattr(cls, name, result)\n        return result"
        ],
        [
            "LOAD_NAME",
            "cache"
        ],
        [
            "CALL",
            "cache"
        ],
        [
            "STORE_NAME",
            "    @cache\n    def statements_at_line(self, lineno):\n        \"\"\"\n        Returns the statement nodes overlapping the given line.\n\n        Returns at most one statement unless semicolons are present.\n\n        If the `text` attribute is not valid python, meaning\n        `tree` is None, returns an empty set.\n\n        Otherwise, `Source.for_frame(frame).statements_at_line(frame.f_lineno)`\n        should return at least one statement.\n        \"\"\"\n\n        return {\n            statement_containing_node(node)\n            for node in\n            self._nodes_by_line[lineno]\n        }"
        ],
        [
            "LOAD_NAME",
            "cache"
        ],
        [
            "CALL",
            "cache"
        ],
        [
            "STORE_NAME",
            "    @cache\n    def asttokens(self):\n        \"\"\"\n        Returns an ASTTokens object for getting the source of specific AST nodes.\n\n        See http://asttokens.readthedocs.io/en/latest/api-index.html\n        \"\"\"\n        from asttokens import ASTTokens  # must be installed separately\n        return ASTTokens(\n            self.text,\n            tree=self.tree,\n            filename=self.filename,\n        )"
        ],
        [
            "LOAD_NAME",
            "staticmethod"
        ],
        [
            "CALL",
            "staticmethod"
        ],
        [
            "STORE_NAME",
            "    @staticmethod\n    def decode_source(source):\n        if isinstance(source, bytes):\n            encoding, _ = detect_encoding(io.BytesIO(source).readline)\n            source = source.decode(encoding)\n        return source"
        ],
        [
            "STORE_NAME",
            "    def code_qualname(self, code):\n        \"\"\"\n        Imitates the __qualname__ attribute of functions for code objects.\n        Given:\n\n            - A function `func`\n            - A frame `frame` for an execution of `func`, meaning:\n                `frame.f_code is func.__code__`\n\n        `Source.for_frame(frame).code_qualname(frame.f_code)`\n        will be equal to `func.__qualname__`*. Works for Python 2 as well,\n        where of course no `__qualname__` attribute exists.\n\n        Falls back to `code.co_name` if there is no appropriate qualname.\n\n        Based on https://github.com/wbolster/qualname\n\n        (* unless `func` is a lambda\n        nested inside another lambda on the same line, in which case\n        the outer lambda's qualname will be returned for the codes\n        of both lambdas)\n        \"\"\"\n        assert code.co_filename == self.filename\n        return self._qualnames.get((code.co_name, code.co_firstlineno), code.co_name)"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.filename"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "text"
        ],
        [
            "LOAD_GLOBAL",
            "text_type"
        ],
        [
            "CALL",
            "isinstance(text, text_type)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.decode_source"
        ],
        [
            "LOAD_FAST",
            "text"
        ],
        [
            "CALL",
            "self.decode_source(text)"
        ],
        [
            "STORE_FAST",
            "text"
        ],
        [
            "LOAD_FAST",
            "text"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.text"
        ],
        [
            "LOAD_GLOBAL",
            "PY3"
        ],
        [
            "LOAD_FAST",
            "text"
        ],
        [
            "STORE_FAST",
            "ast_text"
        ],
        [
            "LOAD_METHOD",
            "''.join"
        ],
        [
            "LOAD_GLOBAL",
            "enumerate"
        ],
        [
            "LOAD_FAST",
            "text"
        ],
        [
            "LOAD_METHOD",
            "text.splitlines"
        ],
        [
            "CALL",
            "text.splitlines(True)"
        ],
        [
            "CALL",
            "enumerate(text.splitlines(True))"
        ],
        [
            "CALL",
            "[\n                '\\n' if i < 2 and encoding_pattern.match(line)\n                else line\n                for i, line in enumerate(text.splitlines(True))\n            ]"
        ],
        [
            "CALL",
            "''.join([\n                '\\n' if i < 2 and encoding_pattern.match(line)\n                else line\n                for i, line in enumerate(text.splitlines(True))\n            ])"
        ],
        [
            "STORE_FAST",
            "ast_text"
        ],
        [
            "LOAD_GLOBAL",
            "defaultdict"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "CALL",
            "defaultdict(list)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._nodes_by_line"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.tree"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._qualnames"
        ],
        [
            "LOAD_FAST",
            "text"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.parse"
        ],
        [
            "LOAD_FAST",
            "ast_text"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "CALL",
            "ast.parse(ast_text, filename=filename)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.tree"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.walk"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.tree"
        ],
        [
            "CALL",
            "ast.walk(self.tree)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.iter_child_nodes"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "ast.iter_child_nodes(node)"
        ],
        [
            "STORE_FAST",
            "child"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "child"
        ],
        [
            "STORE_ATTR",
            "child.parent"
        ],
        [
            "LOAD_GLOBAL",
            "hasattr"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "hasattr(node, 'lineno')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._nodes_by_line"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.lineno"
        ],
        [
            "BINARY_SUBSCR",
            "self._nodes_by_line[node.lineno]"
        ],
        [
            "LOAD_METHOD",
            "self._nodes_by_line[node.lineno].append"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "self._nodes_by_line[node.lineno].append(node)"
        ],
        [
            "LOAD_GLOBAL",
            "QualnameVisitor"
        ],
        [
            "CALL",
            "QualnameVisitor()"
        ],
        [
            "STORE_FAST",
            "visitor"
        ],
        [
            "LOAD_FAST",
            "visitor"
        ],
        [
            "LOAD_METHOD",
            "visitor.visit"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.tree"
        ],
        [
            "CALL",
            "visitor.visit(self.tree)"
        ],
        [
            "LOAD_FAST",
            "visitor"
        ],
        [
            "LOAD_ATTR",
            "visitor.qualnames"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._qualnames"
        ],
        [
            "LOAD_GLOBAL",
            "SyntaxError"
        ],
        [
            "LOAD_FAST",
            "[\n                '\\n' if i < 2 and encoding_pattern.match(line)\n                else line\n                for i, line in enumerate(text.splitlines(True))\n            ]"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "STORE_FAST",
            "line"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "COMPARE_OP",
            "i < 2"
        ],
        [
            "LOAD_GLOBAL",
            "encoding_pattern"
        ],
        [
            "LOAD_ATTR",
            "encoding_pattern.match"
        ],
        [
            "LOAD_FAST",
            "line"
        ],
        [
            "CALL",
            "encoding_pattern.match(line)"
        ],
        [
            "LOAD_FAST",
            "line"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_METHOD",
            "cls.for_filename"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_filename"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_globals"
        ],
        [
            "CALL",
            "cls.for_filename(frame.f_code.co_filename, frame.f_globals or {})"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_METHOD",
            "cls._class_local"
        ],
        [
            "CALL",
            "cls._class_local('__source_cache', {})"
        ],
        [
            "STORE_FAST",
            "source_cache"
        ],
        [
            "LOAD_FAST",
            "source_cache"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "BINARY_SUBSCR",
            "source_cache[filename]"
        ],
        [
            "LOAD_GLOBAL",
            "KeyError"
        ],
        [
            "LOAD_GLOBAL",
            "linecache"
        ],
        [
            "LOAD_ATTR",
            "linecache.getlines"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "module_globals"
        ],
        [
            "CALL",
            "linecache.getlines(filename, module_globals)"
        ],
        [
            "STORE_FAST",
            "lines"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_METHOD",
            "''.join"
        ],
        [
            "LOAD_FAST",
            "lines"
        ],
        [
            "CALL",
            "''.join(lines)"
        ],
        [
            "CALL",
            "cls(filename, ''.join(lines))"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "source_cache"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "STORE_SUBSCR",
            "source_cache[filename]"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_GLOBAL",
            "hasattr"
        ],
        [
            "LOAD_GLOBAL",
            "linecache"
        ],
        [
            "CALL",
            "hasattr(linecache, 'lazycache')"
        ],
        [
            "LOAD_GLOBAL",
            "linecache"
        ],
        [
            "LOAD_ATTR",
            "linecache.lazycache"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_filename"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_globals"
        ],
        [
            "CALL",
            "linecache.lazycache(frame.f_code.co_filename, frame.f_globals)"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_lasti"
        ],
        [
            "STORE_FAST",
            "key"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_METHOD",
            "cls._class_local"
        ],
        [
            "CALL",
            "cls._class_local('__executing_cache', {})"
        ],
        [
            "STORE_FAST",
            "executing_cache"
        ],
        [
            "LOAD_FAST",
            "executing_cache"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "BINARY_SUBSCR",
            "executing_cache[key]"
        ],
        [
            "STORE_FAST",
            "args"
        ],
        [
            "LOAD_GLOBAL",
            "KeyError"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_METHOD",
            "cls.for_frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "cls.for_frame(frame)"
        ],
        [
            "STORE_FAST",
            "source"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "STORE_FAST",
            "stmts"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_ATTR",
            "source.tree"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_METHOD",
            "source.statements_at_line"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_lineno"
        ],
        [
            "CALL",
            "source.statements_at_line(frame.f_lineno)"
        ],
        [
            "STORE_FAST",
            "stmts"
        ],
        [
            "LOAD_GLOBAL",
            "NodeFinder"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "stmts"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_ATTR",
            "source.tree"
        ],
        [
            "CALL",
            "NodeFinder(frame, stmts, source.tree)"
        ],
        [
            "LOAD_ATTR",
            "NodeFinder(frame, stmts, source.tree).result"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "statement_containing_node"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "statement_containing_node(node)"
        ],
        [
            "STORE_FAST",
            "new_stmts"
        ],
        [
            "LOAD_FAST",
            "new_stmts"
        ],
        [
            "LOAD_FAST",
            "stmts"
        ],
        [
            "COMPARE_OP",
            "new_stmts <= stmts"
        ],
        [
            "LOAD_FAST",
            "new_stmts"
        ],
        [
            "STORE_FAST",
            "stmts"
        ],
        [
            "LOAD_GLOBAL",
            "Exception"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "stmts"
        ],
        [
            "STORE_FAST",
            "args"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_FAST",
            "executing_cache"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "STORE_SUBSCR",
            "executing_cache[key]"
        ],
        [
            "LOAD_GLOBAL",
            "Executing"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "CALL_FUNCTION_EX",
            "Executing(frame, *args)"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_ATTR",
            "cls.__dict__"
        ],
        [
            "LOAD_METHOD",
            "cls.__dict__.get"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "default"
        ],
        [
            "CALL",
            "cls.__dict__.get(name, default)"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_GLOBAL",
            "setattr"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "CALL",
            "setattr(cls, name, result)"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._nodes_by_line"
        ],
        [
            "LOAD_FAST",
            "lineno"
        ],
        [
            "BINARY_SUBSCR",
            "self._nodes_by_line[lineno]"
        ],
        [
            "CALL",
            "{\n            statement_containing_node(node)\n            for node in\n            self._nodes_by_line[lineno]\n        }"
        ],
        [
            "LOAD_FAST",
            "{\n            statement_containing_node(node)\n            for node in\n            self._nodes_by_line[lineno]\n        }"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "statement_containing_node"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "statement_containing_node(node)"
        ],
        [
            "STORE_FAST",
            "from asttokens import ASTTokens"
        ],
        [
            "LOAD_FAST",
            "ASTTokens"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.text"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.tree"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.filename"
        ],
        [
            "CALL",
            "ASTTokens(\n            self.text,\n            tree=self.tree,\n            filename=self.filename,\n        )"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_GLOBAL",
            "bytes"
        ],
        [
            "CALL",
            "isinstance(source, bytes)"
        ],
        [
            "LOAD_GLOBAL",
            "detect_encoding"
        ],
        [
            "LOAD_GLOBAL",
            "io"
        ],
        [
            "LOAD_ATTR",
            "io.BytesIO"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CALL",
            "io.BytesIO(source)"
        ],
        [
            "LOAD_ATTR",
            "io.BytesIO(source).readline"
        ],
        [
            "CALL",
            "detect_encoding(io.BytesIO(source).readline)"
        ],
        [
            "STORE_FAST",
            "encoding"
        ],
        [
            "STORE_FAST",
            "_"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_METHOD",
            "source.decode"
        ],
        [
            "LOAD_FAST",
            "encoding"
        ],
        [
            "CALL",
            "source.decode(encoding)"
        ],
        [
            "STORE_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_filename"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.filename"
        ],
        [
            "COMPARE_OP",
            "code.co_filename == self.filename"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._qualnames"
        ],
        [
            "LOAD_METHOD",
            "self._qualnames.get"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_name"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_firstlineno"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_name"
        ],
        [
            "CALL",
            "self._qualnames.get((code.co_name, code.co_firstlineno), code.co_name)"
        ],
        [
            "STORE_NAME",
            "\"\"\"\n    Information about the operation a frame is currently executing.\n\n    Generally you will just want `node`, which is the AST node being executed,\n    or None if it's unknown.\n    Currently `node` can only be an `ast.Call` object, other operations\n    will be supported in future.\n    \"\"\""
        ],
        [
            "STORE_NAME",
            "    def __init__(self, frame, source, node, stmts):\n        self.frame = frame\n        self.source = source\n        self.node = node\n        self.statements = stmts"
        ],
        [
            "STORE_NAME",
            "    def code_qualname(self):\n        return self.source.code_qualname(self.frame.f_code)"
        ],
        [
            "STORE_NAME",
            "    def text(self):\n        return self.source.asttokens().get_text(self.node)"
        ],
        [
            "STORE_NAME",
            "    def text_range(self):\n        return self.source.asttokens().get_text_range(self.node)"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.frame"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.source"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.node"
        ],
        [
            "LOAD_FAST",
            "stmts"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.statements"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.source"
        ],
        [
            "LOAD_METHOD",
            "self.source.code_qualname"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.frame"
        ],
        [
            "LOAD_ATTR",
            "self.frame.f_code"
        ],
        [
            "CALL",
            "self.source.code_qualname(self.frame.f_code)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.source"
        ],
        [
            "LOAD_METHOD",
            "self.source.asttokens"
        ],
        [
            "CALL",
            "self.source.asttokens()"
        ],
        [
            "LOAD_METHOD",
            "self.source.asttokens().get_text"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.node"
        ],
        [
            "CALL",
            "self.source.asttokens().get_text(self.node)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.source"
        ],
        [
            "LOAD_METHOD",
            "self.source.asttokens"
        ],
        [
            "CALL",
            "self.source.asttokens()"
        ],
        [
            "LOAD_METHOD",
            "self.source.asttokens().get_text_range"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.node"
        ],
        [
            "CALL",
            "self.source.asttokens().get_text_range(self.node)"
        ],
        [
            "STORE_NAME",
            "    def __init__(self):\n        super(QualnameVisitor, self).__init__()\n        self.stack = []\n        self.qualnames = {}"
        ],
        [
            "STORE_NAME",
            "    def visit_FunctionDef(self, node, name=None):\n        name = name or node.name\n        self.stack.append(name)\n        self.qualnames.setdefault((name, node.lineno), \".\".join(self.stack))\n\n        self.stack.append('<locals>')\n        if isinstance(node, ast.Lambda):\n            children = [node.body]\n        else:\n            children = node.body\n        for child in children:\n            self.visit(child)\n        self.stack.pop()\n        self.stack.pop()\n\n        # Find lambdas in the function definition outside the body,\n        # e.g. decorators or default arguments\n        # Based on iter_child_nodes\n        for field, child in ast.iter_fields(node):\n            if field == 'body':\n                continue\n            if isinstance(child, ast.AST):\n                self.visit(child)\n            elif isinstance(child, list):\n                for grandchild in child:\n                    if isinstance(grandchild, ast.AST):\n                        self.visit(grandchild)"
        ],
        [
            "STORE_NAME",
            "    def visit_Lambda(self, node):\n        self.visit_FunctionDef(node, '<lambda>')"
        ],
        [
            "STORE_NAME",
            "    def visit_ClassDef(self, node):\n        self.stack.append(node.name)\n        self.generic_visit(node)\n        self.stack.pop()"
        ],
        [
            "STORE_NAME",
            "    def visit_ClassDef(self, node):\n        self.stack.append(node.name)\n        self.generic_visit(node)\n        self.stack.pop()"
        ],
        [
            "LOAD_GLOBAL",
            "super"
        ],
        [
            "LOAD_GLOBAL",
            "QualnameVisitor"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "super(QualnameVisitor, self)"
        ],
        [
            "LOAD_METHOD",
            "super(QualnameVisitor, self).__init__"
        ],
        [
            "CALL",
            "super(QualnameVisitor, self).__init__()"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.stack"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.qualnames"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.name"
        ],
        [
            "STORE_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_METHOD",
            "self.stack.append"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "CALL",
            "self.stack.append(name)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.qualnames"
        ],
        [
            "LOAD_METHOD",
            "self.qualnames.setdefault"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.lineno"
        ],
        [
            "LOAD_METHOD",
            "\".\".join"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "CALL",
            "\".\".join(self.stack)"
        ],
        [
            "CALL",
            "self.qualnames.setdefault((name, node.lineno), \".\".join(self.stack))"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_METHOD",
            "self.stack.append"
        ],
        [
            "CALL",
            "self.stack.append('<locals>')"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Lambda"
        ],
        [
            "CALL",
            "isinstance(node, ast.Lambda)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.body"
        ],
        [
            "STORE_FAST",
            "children"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.body"
        ],
        [
            "STORE_FAST",
            "children"
        ],
        [
            "LOAD_FAST",
            "children"
        ],
        [
            "STORE_FAST",
            "child"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.visit"
        ],
        [
            "LOAD_FAST",
            "child"
        ],
        [
            "CALL",
            "self.visit(child)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_METHOD",
            "self.stack.pop"
        ],
        [
            "CALL",
            "self.stack.pop()"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_METHOD",
            "self.stack.pop"
        ],
        [
            "CALL",
            "self.stack.pop()"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.iter_fields"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "ast.iter_fields(node)"
        ],
        [
            "STORE_FAST",
            "field"
        ],
        [
            "STORE_FAST",
            "child"
        ],
        [
            "LOAD_FAST",
            "field"
        ],
        [
            "COMPARE_OP",
            "field == 'body'"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "child"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.AST"
        ],
        [
            "CALL",
            "isinstance(child, ast.AST)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.visit"
        ],
        [
            "LOAD_FAST",
            "child"
        ],
        [
            "CALL",
            "self.visit(child)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "child"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "CALL",
            "isinstance(child, list)"
        ],
        [
            "LOAD_FAST",
            "child"
        ],
        [
            "STORE_FAST",
            "grandchild"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "grandchild"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.AST"
        ],
        [
            "CALL",
            "isinstance(grandchild, ast.AST)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.visit"
        ],
        [
            "LOAD_FAST",
            "grandchild"
        ],
        [
            "CALL",
            "self.visit(grandchild)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.visit_FunctionDef"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "self.visit_FunctionDef(node, '<lambda>')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_METHOD",
            "self.stack.append"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.name"
        ],
        [
            "CALL",
            "self.stack.append(node.name)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.generic_visit"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "self.generic_visit(node)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_METHOD",
            "self.stack.pop"
        ],
        [
            "CALL",
            "self.stack.pop()"
        ],
        [
            "LOAD_FAST",
            "(\n    getattr(__future__, fname).compiler_flag\n    for fname in __future__.all_feature_names\n)"
        ],
        [
            "STORE_FAST",
            "fname"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_GLOBAL",
            "__future__"
        ],
        [
            "LOAD_FAST",
            "fname"
        ],
        [
            "CALL",
            "getattr(__future__, fname)"
        ],
        [
            "LOAD_ATTR",
            "getattr(__future__, fname).compiler_flag"
        ],
        [
            "LOAD_GLOBAL",
            "compile"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "matching_code"
        ],
        [
            "LOAD_ATTR",
            "matching_code.co_filename"
        ],
        [
            "LOAD_GLOBAL",
            "future_flags"
        ],
        [
            "LOAD_FAST",
            "matching_code"
        ],
        [
            "LOAD_ATTR",
            "matching_code.co_flags"
        ],
        [
            "BINARY_OP",
            "future_flags & matching_code.co_flags"
        ],
        [
            "CALL",
            "compile(\n        source,\n        matching_code.co_filename,\n        'exec',\n        flags=future_flags & matching_code.co_flags,\n        dont_inherit=True,\n    )"
        ],
        [
            "STORE_NAME",
            "    def __init__(self, frame, stmts, tree):\n        self.frame = frame\n        self.tree = tree\n\n        b = frame.f_code.co_code[frame.f_lasti]\n        if not PY3:\n            b = ord(b)\n        op_name = dis.opname[b]\n\n        if op_name.startswith('CALL_'):\n            typ = ast.Call\n        elif op_name == 'BINARY_SUBSCR':\n            typ = ast.Subscript\n        elif op_name.startswith('BINARY_'):\n            typ = ast.BinOp\n        elif op_name.startswith('UNARY_'):\n            typ = ast.UnaryOp\n        elif op_name in ('LOAD_ATTR', 'LOAD_METHOD', 'LOOKUP_METHOD'):\n            typ = ast.Attribute\n        elif op_name == 'COMPARE_OP':\n            typ = ast.Compare\n        else:\n            raise RuntimeError(op_name)\n\n        with lock:\n            exprs = {\n                node\n                for stmt in stmts\n                for node in ast.walk(stmt)\n                if isinstance(node, typ)\n                if not (hasattr(node, \"ctx\") and not isinstance(node.ctx, ast.Load))\n            }\n\n            self.result = only(list(self.matching_nodes(exprs)))"
        ],
        [
            "STORE_NAME",
            "    def matching_nodes(self, exprs):\n        for i, expr in enumerate(exprs):\n            setter = get_setter(expr)\n            replacement = ast.BinOp(\n                left=expr,\n                op=ast.Pow(),\n                right=ast.Str(s=sentinel),\n            )\n            ast.fix_missing_locations(replacement)\n            setter(replacement)\n            try:\n                instructions = self.compile_instructions()\n            except SyntaxError:\n                continue\n            finally:\n                setter(expr)\n            indices = [\n                i\n                for i, instruction in enumerate(instructions)\n                if instruction.argval == sentinel\n            ]\n            if not indices:\n                continue\n            arg_index = only(indices) - 1\n            while instructions[arg_index].opname == 'EXTENDED_ARG':\n                arg_index -= 1\n\n            if instructions[arg_index].offset == self.frame.f_lasti:\n                yield expr"
        ],
        [
            "STORE_NAME",
            "    def compile_instructions(self):\n        module_code = compile_similar_to(self.tree, self.frame.f_code)\n        code = only(find_codes(module_code, self.frame.f_code))\n        return list(get_instructions(code))"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.frame"
        ],
        [
            "LOAD_FAST",
            "tree"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.tree"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_code"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_lasti"
        ],
        [
            "BINARY_SUBSCR",
            "frame.f_code.co_code[frame.f_lasti]"
        ],
        [
            "STORE_FAST",
            "b"
        ],
        [
            "LOAD_GLOBAL",
            "PY3"
        ],
        [
            "LOAD_GLOBAL",
            "ord"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "CALL",
            "ord(b)"
        ],
        [
            "STORE_FAST",
            "b"
        ],
        [
            "LOAD_GLOBAL",
            "dis"
        ],
        [
            "LOAD_ATTR",
            "dis.opname"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "BINARY_SUBSCR",
            "dis.opname[b]"
        ],
        [
            "STORE_FAST",
            "op_name"
        ],
        [
            "LOAD_FAST",
            "op_name"
        ],
        [
            "LOAD_METHOD",
            "op_name.startswith"
        ],
        [
            "CALL",
            "op_name.startswith('CALL_')"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Call"
        ],
        [
            "STORE_DEREF",
            "typ"
        ],
        [
            "LOAD_FAST",
            "op_name"
        ],
        [
            "COMPARE_OP",
            "op_name == 'BINARY_SUBSCR'"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Subscript"
        ],
        [
            "STORE_DEREF",
            "typ"
        ],
        [
            "LOAD_FAST",
            "op_name"
        ],
        [
            "LOAD_METHOD",
            "op_name.startswith"
        ],
        [
            "CALL",
            "op_name.startswith('BINARY_')"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.BinOp"
        ],
        [
            "STORE_DEREF",
            "typ"
        ],
        [
            "LOAD_FAST",
            "op_name"
        ],
        [
            "LOAD_METHOD",
            "op_name.startswith"
        ],
        [
            "CALL",
            "op_name.startswith('UNARY_')"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.UnaryOp"
        ],
        [
            "STORE_DEREF",
            "typ"
        ],
        [
            "LOAD_FAST",
            "op_name"
        ],
        [
            "CONTAINS_OP",
            "op_name in ('LOAD_ATTR', 'LOAD_METHOD', 'LOOKUP_METHOD')"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Attribute"
        ],
        [
            "STORE_DEREF",
            "typ"
        ],
        [
            "LOAD_FAST",
            "op_name"
        ],
        [
            "COMPARE_OP",
            "op_name == 'COMPARE_OP'"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Compare"
        ],
        [
            "STORE_DEREF",
            "typ"
        ],
        [
            "LOAD_GLOBAL",
            "RuntimeError"
        ],
        [
            "LOAD_FAST",
            "op_name"
        ],
        [
            "CALL",
            "RuntimeError(op_name)"
        ],
        [
            "LOAD_GLOBAL",
            "lock"
        ],
        [
            "LOAD_FAST",
            "stmts"
        ],
        [
            "CALL",
            "{\n                node\n                for stmt in stmts\n                for node in ast.walk(stmt)\n                if isinstance(node, typ)\n                if not (hasattr(node, \"ctx\") and not isinstance(node.ctx, ast.Load))\n            }"
        ],
        [
            "STORE_FAST",
            "exprs"
        ],
        [
            "LOAD_GLOBAL",
            "only"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.matching_nodes"
        ],
        [
            "LOAD_FAST",
            "exprs"
        ],
        [
            "CALL",
            "self.matching_nodes(exprs)"
        ],
        [
            "CALL",
            "list(self.matching_nodes(exprs))"
        ],
        [
            "CALL",
            "only(list(self.matching_nodes(exprs)))"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.result"
        ],
        [
            "CALL",
            "        with lock:\n            exprs = {\n                node\n                for stmt in stmts\n                for node in ast.walk(stmt)\n                if isinstance(node, typ)\n                if not (hasattr(node, \"ctx\") and not isinstance(node.ctx, ast.Load))\n            }\n\n            self.result = only(list(self.matching_nodes(exprs)))"
        ],
        [
            "LOAD_FAST",
            "{\n                node\n                for stmt in stmts\n                for node in ast.walk(stmt)\n                if isinstance(node, typ)\n                if not (hasattr(node, \"ctx\") and not isinstance(node.ctx, ast.Load))\n            }"
        ],
        [
            "STORE_FAST",
            "stmt"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.walk"
        ],
        [
            "LOAD_FAST",
            "stmt"
        ],
        [
            "CALL",
            "ast.walk(stmt)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_DEREF",
            "typ"
        ],
        [
            "CALL",
            "isinstance(node, typ)"
        ],
        [
            "LOAD_GLOBAL",
            "hasattr"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "hasattr(node, \"ctx\")"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.ctx"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Load"
        ],
        [
            "CALL",
            "isinstance(node.ctx, ast.Load)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "enumerate"
        ],
        [
            "LOAD_FAST",
            "exprs"
        ],
        [
            "CALL",
            "enumerate(exprs)"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "STORE_FAST",
            "expr"
        ],
        [
            "LOAD_GLOBAL",
            "get_setter"
        ],
        [
            "LOAD_FAST",
            "expr"
        ],
        [
            "CALL",
            "get_setter(expr)"
        ],
        [
            "STORE_FAST",
            "setter"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.BinOp"
        ],
        [
            "LOAD_FAST",
            "expr"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Pow"
        ],
        [
            "CALL",
            "ast.Pow()"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Str"
        ],
        [
            "LOAD_GLOBAL",
            "sentinel"
        ],
        [
            "CALL",
            "ast.Str(s=sentinel)"
        ],
        [
            "CALL",
            "ast.BinOp(\n                left=expr,\n                op=ast.Pow(),\n                right=ast.Str(s=sentinel),\n            )"
        ],
        [
            "STORE_FAST",
            "replacement"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.fix_missing_locations"
        ],
        [
            "LOAD_FAST",
            "replacement"
        ],
        [
            "CALL",
            "ast.fix_missing_locations(replacement)"
        ],
        [
            "LOAD_FAST",
            "setter"
        ],
        [
            "LOAD_FAST",
            "replacement"
        ],
        [
            "CALL",
            "setter(replacement)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.compile_instructions"
        ],
        [
            "CALL",
            "self.compile_instructions()"
        ],
        [
            "STORE_FAST",
            "instructions"
        ],
        [
            "LOAD_GLOBAL",
            "SyntaxError"
        ],
        [
            "LOAD_FAST",
            "setter"
        ],
        [
            "LOAD_FAST",
            "expr"
        ],
        [
            "CALL",
            "setter(expr)"
        ],
        [
            "LOAD_FAST",
            "setter"
        ],
        [
            "LOAD_FAST",
            "expr"
        ],
        [
            "CALL",
            "setter(expr)"
        ],
        [
            "LOAD_FAST",
            "setter"
        ],
        [
            "LOAD_FAST",
            "expr"
        ],
        [
            "CALL",
            "setter(expr)"
        ],
        [
            "LOAD_GLOBAL",
            "enumerate"
        ],
        [
            "LOAD_FAST",
            "instructions"
        ],
        [
            "CALL",
            "enumerate(instructions)"
        ],
        [
            "CALL",
            "[\n                i\n                for i, instruction in enumerate(instructions)\n                if instruction.argval == sentinel\n            ]"
        ],
        [
            "STORE_FAST",
            "indices"
        ],
        [
            "LOAD_FAST",
            "indices"
        ],
        [
            "LOAD_GLOBAL",
            "only"
        ],
        [
            "LOAD_FAST",
            "indices"
        ],
        [
            "CALL",
            "only(indices)"
        ],
        [
            "BINARY_OP",
            "only(indices) - 1"
        ],
        [
            "STORE_FAST",
            "arg_index"
        ],
        [
            "LOAD_FAST",
            "instructions"
        ],
        [
            "LOAD_FAST",
            "arg_index"
        ],
        [
            "BINARY_SUBSCR",
            "instructions[arg_index]"
        ],
        [
            "LOAD_ATTR",
            "instructions[arg_index].opname"
        ],
        [
            "COMPARE_OP",
            "instructions[arg_index].opname == 'EXTENDED_ARG'"
        ],
        [
            "LOAD_FAST",
            "arg_index"
        ],
        [
            "BINARY_OP",
            "arg_index -= 1"
        ],
        [
            "STORE_FAST",
            "arg_index"
        ],
        [
            "LOAD_FAST",
            "instructions"
        ],
        [
            "LOAD_FAST",
            "arg_index"
        ],
        [
            "BINARY_SUBSCR",
            "instructions[arg_index]"
        ],
        [
            "LOAD_ATTR",
            "instructions[arg_index].opname"
        ],
        [
            "COMPARE_OP",
            "instructions[arg_index].opname == 'EXTENDED_ARG'"
        ],
        [
            "LOAD_FAST",
            "instructions"
        ],
        [
            "LOAD_FAST",
            "arg_index"
        ],
        [
            "BINARY_SUBSCR",
            "instructions[arg_index]"
        ],
        [
            "LOAD_ATTR",
            "instructions[arg_index].offset"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.frame"
        ],
        [
            "LOAD_ATTR",
            "self.frame.f_lasti"
        ],
        [
            "COMPARE_OP",
            "instructions[arg_index].offset == self.frame.f_lasti"
        ],
        [
            "LOAD_FAST",
            "expr"
        ],
        [
            "LOAD_FAST",
            "[\n                i\n                for i, instruction in enumerate(instructions)\n                if instruction.argval == sentinel\n            ]"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "STORE_FAST",
            "instruction"
        ],
        [
            "LOAD_FAST",
            "instruction"
        ],
        [
            "LOAD_ATTR",
            "instruction.argval"
        ],
        [
            "LOAD_GLOBAL",
            "sentinel"
        ],
        [
            "COMPARE_OP",
            "instruction.argval == sentinel"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "LOAD_GLOBAL",
            "compile_similar_to"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.tree"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.frame"
        ],
        [
            "LOAD_ATTR",
            "self.frame.f_code"
        ],
        [
            "CALL",
            "compile_similar_to(self.tree, self.frame.f_code)"
        ],
        [
            "STORE_FAST",
            "module_code"
        ],
        [
            "LOAD_GLOBAL",
            "only"
        ],
        [
            "LOAD_GLOBAL",
            "find_codes"
        ],
        [
            "LOAD_FAST",
            "module_code"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.frame"
        ],
        [
            "LOAD_ATTR",
            "self.frame.f_code"
        ],
        [
            "CALL",
            "find_codes(module_code, self.frame.f_code)"
        ],
        [
            "CALL",
            "only(find_codes(module_code, self.frame.f_code))"
        ],
        [
            "STORE_FAST",
            "code"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_GLOBAL",
            "get_instructions"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "CALL",
            "get_instructions(code)"
        ],
        [
            "CALL",
            "list(get_instructions(code))"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "STORE_DEREF",
            "parent"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.iter_fields"
        ],
        [
            "LOAD_DEREF",
            "parent"
        ],
        [
            "CALL",
            "ast.iter_fields(parent)"
        ],
        [
            "STORE_DEREF",
            "name"
        ],
        [
            "STORE_DEREF",
            "field"
        ],
        [
            "LOAD_DEREF",
            "field"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "IS_OP",
            "field is node"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_DEREF",
            "field"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "CALL",
            "isinstance(field, list)"
        ],
        [
            "LOAD_GLOBAL",
            "enumerate"
        ],
        [
            "LOAD_DEREF",
            "field"
        ],
        [
            "CALL",
            "enumerate(field)"
        ],
        [
            "STORE_DEREF",
            "i"
        ],
        [
            "STORE_FAST",
            "item"
        ],
        [
            "LOAD_FAST",
            "item"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "IS_OP",
            "item is node"
        ],
        [
            "STORE_FAST",
            "                    def setter(new_node):\n                        field[i] = new_node"
        ],
        [
            "LOAD_FAST",
            "setter"
        ],
        [
            "LOAD_GLOBAL",
            "setattr"
        ],
        [
            "LOAD_DEREF",
            "parent"
        ],
        [
            "LOAD_DEREF",
            "name"
        ],
        [
            "LOAD_FAST",
            "new_node"
        ],
        [
            "CALL",
            "setattr(parent, name, new_node)"
        ],
        [
            "LOAD_FAST",
            "new_node"
        ],
        [
            "LOAD_DEREF",
            "field"
        ],
        [
            "LOAD_DEREF",
            "i"
        ],
        [
            "STORE_SUBSCR",
            "field[i]"
        ],
        [
            "STORE_DEREF",
            "    def matches(c):\n        return all(\n            f(c) == f(matching)\n            for f in [\n                attrgetter('co_firstlineno'),\n                attrgetter('co_name'),\n                code_names,\n            ]\n        )"
        ],
        [
            "STORE_DEREF",
            "code_options"
        ],
        [
            "LOAD_DEREF",
            "matches"
        ],
        [
            "LOAD_FAST",
            "root_code"
        ],
        [
            "CALL",
            "matches(root_code)"
        ],
        [
            "LOAD_DEREF",
            "code_options"
        ],
        [
            "LOAD_METHOD",
            "code_options.append"
        ],
        [
            "LOAD_FAST",
            "root_code"
        ],
        [
            "CALL",
            "code_options.append(root_code)"
        ],
        [
            "STORE_DEREF",
            "    def finder(code):\n        for const in code.co_consts:\n            if not inspect.iscode(const):\n                continue\n\n            if matches(const):\n                code_options.append(const)\n            finder(const)"
        ],
        [
            "LOAD_DEREF",
            "finder"
        ],
        [
            "LOAD_FAST",
            "root_code"
        ],
        [
            "CALL",
            "finder(root_code)"
        ],
        [
            "LOAD_DEREF",
            "code_options"
        ],
        [
            "LOAD_GLOBAL",
            "all"
        ],
        [
            "LOAD_GLOBAL",
            "attrgetter"
        ],
        [
            "CALL",
            "attrgetter('co_firstlineno')"
        ],
        [
            "LOAD_GLOBAL",
            "attrgetter"
        ],
        [
            "CALL",
            "attrgetter('co_name')"
        ],
        [
            "LOAD_GLOBAL",
            "code_names"
        ],
        [
            "CALL",
            "(\n            f(c) == f(matching)\n            for f in [\n                attrgetter('co_firstlineno'),\n                attrgetter('co_name'),\n                code_names,\n            ]\n        )"
        ],
        [
            "CALL",
            "all(\n            f(c) == f(matching)\n            for f in [\n                attrgetter('co_firstlineno'),\n                attrgetter('co_name'),\n                code_names,\n            ]\n        )"
        ],
        [
            "LOAD_FAST",
            "(\n            f(c) == f(matching)\n            for f in [\n                attrgetter('co_firstlineno'),\n                attrgetter('co_name'),\n                code_names,\n            ]\n        )"
        ],
        [
            "STORE_FAST",
            "f"
        ],
        [
            "LOAD_FAST",
            "f"
        ],
        [
            "LOAD_DEREF",
            "c"
        ],
        [
            "CALL",
            "f(c)"
        ],
        [
            "LOAD_FAST",
            "f"
        ],
        [
            "LOAD_DEREF",
            "matching"
        ],
        [
            "CALL",
            "f(matching)"
        ],
        [
            "COMPARE_OP",
            "f(c) == f(matching)"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_consts"
        ],
        [
            "STORE_FAST",
            "const"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.iscode"
        ],
        [
            "LOAD_FAST",
            "const"
        ],
        [
            "CALL",
            "inspect.iscode(const)"
        ],
        [
            "LOAD_DEREF",
            "matches"
        ],
        [
            "LOAD_FAST",
            "const"
        ],
        [
            "CALL",
            "matches(const)"
        ],
        [
            "LOAD_DEREF",
            "code_options"
        ],
        [
            "LOAD_METHOD",
            "code_options.append"
        ],
        [
            "LOAD_FAST",
            "const"
        ],
        [
            "CALL",
            "code_options.append(const)"
        ],
        [
            "LOAD_DEREF",
            "finder"
        ],
        [
            "LOAD_FAST",
            "const"
        ],
        [
            "CALL",
            "finder(const)"
        ],
        [
            "LOAD_GLOBAL",
            "frozenset"
        ],
        [
            "CALL",
            "frozenset()"
        ],
        [
            "LOAD_METHOD",
            "frozenset().union"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_names"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_varnames"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_freevars"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_cellvars"
        ],
        [
            "CALL",
            "frozenset().union(\n        code.co_names,\n        code.co_varnames,\n        code.co_freevars,\n        code.co_cellvars,\n    )"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.stmt"
        ],
        [
            "CALL",
            "isinstance(node, ast.stmt)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.stmt"
        ],
        [
            "CALL",
            "isinstance(node, ast.stmt)"
        ],
        [
            "LOAD_FAST",
            "node"
        ]
    ],
    "import_hook.py": [
        [
            "STORE_NAME",
            "import logging"
        ],
        [
            "STORE_NAME",
            "import sys"
        ],
        [
            "STORE_NAME",
            "from importlib.util import spec_from_loader"
        ],
        [
            "STORE_NAME",
            "import ast"
        ],
        [
            "CALL",
            "class BirdsEyeLoader:\n\n    def __init__(self, spec, source, deep):\n        self._spec = spec\n        self.source = source\n        self.deep = deep\n\n    def create_module(self, spec):\n        pass\n\n    def exec_module(self, module):\n        from birdseye.bird import eye\n        eye.exec_string(\n            source=self.source,\n            filename=self._spec.origin,\n            globs=module.__dict__,\n            locs=module.__dict__,\n            deep=self.deep,\n        )\n\n    def get_filename(self, fullname):\n        return self._spec.loader.get_filename(fullname)\n\n    def is_package(self, fullname):\n        return self._spec.loader.is_package(fullname)"
        ],
        [
            "STORE_NAME",
            "class BirdsEyeLoader:\n\n    def __init__(self, spec, source, deep):\n        self._spec = spec\n        self.source = source\n        self.deep = deep\n\n    def create_module(self, spec):\n        pass\n\n    def exec_module(self, module):\n        from birdseye.bird import eye\n        eye.exec_string(\n            source=self.source,\n            filename=self._spec.origin,\n            globs=module.__dict__,\n            locs=module.__dict__,\n            deep=self.deep,\n        )\n\n    def get_filename(self, fullname):\n        return self._spec.loader.get_filename(fullname)\n\n    def is_package(self, fullname):\n        return self._spec.loader.is_package(fullname)"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class BirdsEyeFinder(object):\n    \"\"\"Loads a module and looks for tracing inside, only providing a loader\n    if it finds some.\n    \"\"\"\n\n    def _find_plain_spec(self, fullname, path, target):\n        \"\"\"Try to find the original module using all the\n        remaining meta_path finders.\"\"\"\n        spec = None\n        for finder in sys.meta_path:\n            # when testing with pytest, it installs a finder that for\n            # some yet unknown reasons makes birdseye\n            # fail. For now it will just avoid using it and pass to\n            # the next one\n            if finder is self or 'pytest' in finder.__module__:\n                continue\n            if hasattr(finder, 'find_spec'):\n                spec = finder.find_spec(fullname, path, target=target)\n            elif hasattr(finder, 'load_module'):\n                spec = spec_from_loader(fullname, finder)\n\n            if spec is not None and spec.origin != 'builtin':\n                return spec\n\n    def find_spec(self, fullname, path, target=None):\n        spec = self._find_plain_spec(fullname, path, target)\n        if spec is None or not (hasattr(spec.loader, 'get_source') and\n                                callable(spec.loader.get_source)):  # noqa: E128\n            if fullname != 'org':\n                # stdlib pickle.py at line 94 contains a ``from\n                # org.python.core for Jython which is always failing,\n                # of course\n                logging.debug('Failed finding spec for %s', fullname)\n            return\n\n        try:\n            source = spec.loader.get_source(fullname)\n        except ImportError:\n            logging.debug('Loader for %s was unable to find the sources',\n                          fullname)\n            return\n        except Exception:\n            logging.exception('Loader for %s raised an error', fullname)\n            return\n\n        if not source or 'birdseye' not in source:\n            return\n\n        deep, trace_stmt = should_trace(source)\n\n        if not trace_stmt:\n            return\n\n        loader = BirdsEyeLoader(spec, source, deep)\n        return spec_from_loader(fullname, loader)"
        ],
        [
            "STORE_NAME",
            "class BirdsEyeFinder(object):\n    \"\"\"Loads a module and looks for tracing inside, only providing a loader\n    if it finds some.\n    \"\"\"\n\n    def _find_plain_spec(self, fullname, path, target):\n        \"\"\"Try to find the original module using all the\n        remaining meta_path finders.\"\"\"\n        spec = None\n        for finder in sys.meta_path:\n            # when testing with pytest, it installs a finder that for\n            # some yet unknown reasons makes birdseye\n            # fail. For now it will just avoid using it and pass to\n            # the next one\n            if finder is self or 'pytest' in finder.__module__:\n                continue\n            if hasattr(finder, 'find_spec'):\n                spec = finder.find_spec(fullname, path, target=target)\n            elif hasattr(finder, 'load_module'):\n                spec = spec_from_loader(fullname, finder)\n\n            if spec is not None and spec.origin != 'builtin':\n                return spec\n\n    def find_spec(self, fullname, path, target=None):\n        spec = self._find_plain_spec(fullname, path, target)\n        if spec is None or not (hasattr(spec.loader, 'get_source') and\n                                callable(spec.loader.get_source)):  # noqa: E128\n            if fullname != 'org':\n                # stdlib pickle.py at line 94 contains a ``from\n                # org.python.core for Jython which is always failing,\n                # of course\n                logging.debug('Failed finding spec for %s', fullname)\n            return\n\n        try:\n            source = spec.loader.get_source(fullname)\n        except ImportError:\n            logging.debug('Loader for %s was unable to find the sources',\n                          fullname)\n            return\n        except Exception:\n            logging.exception('Loader for %s raised an error', fullname)\n            return\n\n        if not source or 'birdseye' not in source:\n            return\n\n        deep, trace_stmt = should_trace(source)\n\n        if not trace_stmt:\n            return\n\n        loader = BirdsEyeLoader(spec, source, deep)\n        return spec_from_loader(fullname, loader)"
        ],
        [
            "STORE_NAME",
            "def should_trace(source):\n    trace_stmt = None\n    deep = False\n    for stmt in ast.parse(source).body:\n        if isinstance(stmt, ast.Import):\n            for alias in stmt.names:\n                if alias.name.startswith('birdseye.trace_module'):\n                    trace_stmt = stmt\n                    if alias.name.endswith('deep'):\n                        deep = True\n\n        if isinstance(stmt, ast.ImportFrom) and stmt.module == 'birdseye':\n            for alias in stmt.names:\n                if alias.name.startswith('trace_module'):\n                    trace_stmt = stmt\n                    if alias.name.endswith('deep'):\n                        deep = True\n    return deep, trace_stmt"
        ],
        [
            "STORE_NAME",
            "    def __init__(self, spec, source, deep):\n        self._spec = spec\n        self.source = source\n        self.deep = deep"
        ],
        [
            "STORE_NAME",
            "    def create_module(self, spec):\n        pass"
        ],
        [
            "STORE_NAME",
            "    def exec_module(self, module):\n        from birdseye.bird import eye\n        eye.exec_string(\n            source=self.source,\n            filename=self._spec.origin,\n            globs=module.__dict__,\n            locs=module.__dict__,\n            deep=self.deep,\n        )"
        ],
        [
            "STORE_NAME",
            "    def get_filename(self, fullname):\n        return self._spec.loader.get_filename(fullname)"
        ],
        [
            "STORE_NAME",
            "    def is_package(self, fullname):\n        return self._spec.loader.is_package(fullname)"
        ],
        [
            "LOAD_FAST",
            "spec"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._spec"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.source"
        ],
        [
            "LOAD_FAST",
            "deep"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.deep"
        ],
        [
            "STORE_FAST",
            "from birdseye.bird import eye"
        ],
        [
            "LOAD_FAST",
            "eye"
        ],
        [
            "LOAD_METHOD",
            "eye.exec_string"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.source"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._spec"
        ],
        [
            "LOAD_ATTR",
            "self._spec.origin"
        ],
        [
            "LOAD_FAST",
            "module"
        ],
        [
            "LOAD_ATTR",
            "module.__dict__"
        ],
        [
            "LOAD_FAST",
            "module"
        ],
        [
            "LOAD_ATTR",
            "module.__dict__"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.deep"
        ],
        [
            "CALL",
            "eye.exec_string(\n            source=self.source,\n            filename=self._spec.origin,\n            globs=module.__dict__,\n            locs=module.__dict__,\n            deep=self.deep,\n        )"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._spec"
        ],
        [
            "LOAD_ATTR",
            "self._spec.loader"
        ],
        [
            "LOAD_METHOD",
            "self._spec.loader.get_filename"
        ],
        [
            "LOAD_FAST",
            "fullname"
        ],
        [
            "CALL",
            "self._spec.loader.get_filename(fullname)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._spec"
        ],
        [
            "LOAD_ATTR",
            "self._spec.loader"
        ],
        [
            "LOAD_METHOD",
            "self._spec.loader.is_package"
        ],
        [
            "LOAD_FAST",
            "fullname"
        ],
        [
            "CALL",
            "self._spec.loader.is_package(fullname)"
        ],
        [
            "STORE_NAME",
            "\"\"\"Loads a module and looks for tracing inside, only providing a loader\n    if it finds some.\n    \"\"\""
        ],
        [
            "STORE_NAME",
            "    def _find_plain_spec(self, fullname, path, target):\n        \"\"\"Try to find the original module using all the\n        remaining meta_path finders.\"\"\"\n        spec = None\n        for finder in sys.meta_path:\n            # when testing with pytest, it installs a finder that for\n            # some yet unknown reasons makes birdseye\n            # fail. For now it will just avoid using it and pass to\n            # the next one\n            if finder is self or 'pytest' in finder.__module__:\n                continue\n            if hasattr(finder, 'find_spec'):\n                spec = finder.find_spec(fullname, path, target=target)\n            elif hasattr(finder, 'load_module'):\n                spec = spec_from_loader(fullname, finder)\n\n            if spec is not None and spec.origin != 'builtin':\n                return spec"
        ],
        [
            "STORE_NAME",
            "    def find_spec(self, fullname, path, target=None):\n        spec = self._find_plain_spec(fullname, path, target)\n        if spec is None or not (hasattr(spec.loader, 'get_source') and\n                                callable(spec.loader.get_source)):  # noqa: E128\n            if fullname != 'org':\n                # stdlib pickle.py at line 94 contains a ``from\n                # org.python.core for Jython which is always failing,\n                # of course\n                logging.debug('Failed finding spec for %s', fullname)\n            return\n\n        try:\n            source = spec.loader.get_source(fullname)\n        except ImportError:\n            logging.debug('Loader for %s was unable to find the sources',\n                          fullname)\n            return\n        except Exception:\n            logging.exception('Loader for %s raised an error', fullname)\n            return\n\n        if not source or 'birdseye' not in source:\n            return\n\n        deep, trace_stmt = should_trace(source)\n\n        if not trace_stmt:\n            return\n\n        loader = BirdsEyeLoader(spec, source, deep)\n        return spec_from_loader(fullname, loader)"
        ],
        [
            "STORE_FAST",
            "spec"
        ],
        [
            "LOAD_GLOBAL",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.meta_path"
        ],
        [
            "STORE_FAST",
            "finder"
        ],
        [
            "LOAD_FAST",
            "finder"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "IS_OP",
            "finder is self"
        ],
        [
            "LOAD_FAST",
            "finder"
        ],
        [
            "LOAD_ATTR",
            "finder.__module__"
        ],
        [
            "CONTAINS_OP",
            "'pytest' in finder.__module__"
        ],
        [
            "LOAD_GLOBAL",
            "hasattr"
        ],
        [
            "LOAD_FAST",
            "finder"
        ],
        [
            "CALL",
            "hasattr(finder, 'find_spec')"
        ],
        [
            "LOAD_FAST",
            "finder"
        ],
        [
            "LOAD_METHOD",
            "finder.find_spec"
        ],
        [
            "LOAD_FAST",
            "fullname"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_FAST",
            "target"
        ],
        [
            "CALL",
            "finder.find_spec(fullname, path, target=target)"
        ],
        [
            "STORE_FAST",
            "spec"
        ],
        [
            "LOAD_GLOBAL",
            "hasattr"
        ],
        [
            "LOAD_FAST",
            "finder"
        ],
        [
            "CALL",
            "hasattr(finder, 'load_module')"
        ],
        [
            "LOAD_GLOBAL",
            "spec_from_loader"
        ],
        [
            "LOAD_FAST",
            "fullname"
        ],
        [
            "LOAD_FAST",
            "finder"
        ],
        [
            "CALL",
            "spec_from_loader(fullname, finder)"
        ],
        [
            "STORE_FAST",
            "spec"
        ],
        [
            "LOAD_FAST",
            "spec"
        ],
        [
            "LOAD_FAST",
            "spec"
        ],
        [
            "LOAD_ATTR",
            "spec.origin"
        ],
        [
            "COMPARE_OP",
            "spec.origin != 'builtin'"
        ],
        [
            "LOAD_FAST",
            "spec"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._find_plain_spec"
        ],
        [
            "LOAD_FAST",
            "fullname"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_FAST",
            "target"
        ],
        [
            "CALL",
            "self._find_plain_spec(fullname, path, target)"
        ],
        [
            "STORE_FAST",
            "spec"
        ],
        [
            "LOAD_FAST",
            "spec"
        ],
        [
            "LOAD_GLOBAL",
            "hasattr"
        ],
        [
            "LOAD_FAST",
            "spec"
        ],
        [
            "LOAD_ATTR",
            "spec.loader"
        ],
        [
            "CALL",
            "hasattr(spec.loader, 'get_source')"
        ],
        [
            "LOAD_GLOBAL",
            "callable"
        ],
        [
            "LOAD_FAST",
            "spec"
        ],
        [
            "LOAD_ATTR",
            "spec.loader"
        ],
        [
            "LOAD_ATTR",
            "spec.loader.get_source"
        ],
        [
            "CALL",
            "callable(spec.loader.get_source)"
        ],
        [
            "LOAD_FAST",
            "fullname"
        ],
        [
            "COMPARE_OP",
            "fullname != 'org'"
        ],
        [
            "LOAD_GLOBAL",
            "logging"
        ],
        [
            "LOAD_ATTR",
            "logging.debug"
        ],
        [
            "LOAD_FAST",
            "fullname"
        ],
        [
            "CALL",
            "logging.debug('Failed finding spec for %s', fullname)"
        ],
        [
            "LOAD_FAST",
            "spec"
        ],
        [
            "LOAD_ATTR",
            "spec.loader"
        ],
        [
            "LOAD_METHOD",
            "spec.loader.get_source"
        ],
        [
            "LOAD_FAST",
            "fullname"
        ],
        [
            "CALL",
            "spec.loader.get_source(fullname)"
        ],
        [
            "STORE_FAST",
            "source"
        ],
        [
            "LOAD_GLOBAL",
            "ImportError"
        ],
        [
            "LOAD_GLOBAL",
            "logging"
        ],
        [
            "LOAD_ATTR",
            "logging.debug"
        ],
        [
            "LOAD_FAST",
            "fullname"
        ],
        [
            "CALL",
            "logging.debug('Loader for %s was unable to find the sources',\n                          fullname)"
        ],
        [
            "LOAD_GLOBAL",
            "Exception"
        ],
        [
            "LOAD_GLOBAL",
            "logging"
        ],
        [
            "LOAD_ATTR",
            "logging.exception"
        ],
        [
            "LOAD_FAST",
            "fullname"
        ],
        [
            "CALL",
            "logging.exception('Loader for %s raised an error', fullname)"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CONTAINS_OP",
            "'birdseye' not in source"
        ],
        [
            "LOAD_GLOBAL",
            "should_trace"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CALL",
            "should_trace(source)"
        ],
        [
            "STORE_FAST",
            "deep"
        ],
        [
            "STORE_FAST",
            "trace_stmt"
        ],
        [
            "LOAD_FAST",
            "trace_stmt"
        ],
        [
            "LOAD_GLOBAL",
            "BirdsEyeLoader"
        ],
        [
            "LOAD_FAST",
            "spec"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "deep"
        ],
        [
            "CALL",
            "BirdsEyeLoader(spec, source, deep)"
        ],
        [
            "STORE_FAST",
            "loader"
        ],
        [
            "LOAD_GLOBAL",
            "spec_from_loader"
        ],
        [
            "LOAD_FAST",
            "fullname"
        ],
        [
            "LOAD_FAST",
            "loader"
        ],
        [
            "CALL",
            "spec_from_loader(fullname, loader)"
        ],
        [
            "STORE_FAST",
            "trace_stmt"
        ],
        [
            "STORE_FAST",
            "deep"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.parse"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CALL",
            "ast.parse(source)"
        ],
        [
            "LOAD_ATTR",
            "ast.parse(source).body"
        ],
        [
            "STORE_FAST",
            "stmt"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "stmt"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Import"
        ],
        [
            "CALL",
            "isinstance(stmt, ast.Import)"
        ],
        [
            "LOAD_FAST",
            "stmt"
        ],
        [
            "LOAD_ATTR",
            "stmt.names"
        ],
        [
            "STORE_FAST",
            "alias"
        ],
        [
            "LOAD_FAST",
            "alias"
        ],
        [
            "LOAD_ATTR",
            "alias.name"
        ],
        [
            "LOAD_METHOD",
            "alias.name.startswith"
        ],
        [
            "CALL",
            "alias.name.startswith('birdseye.trace_module')"
        ],
        [
            "LOAD_FAST",
            "stmt"
        ],
        [
            "STORE_FAST",
            "trace_stmt"
        ],
        [
            "LOAD_FAST",
            "alias"
        ],
        [
            "LOAD_ATTR",
            "alias.name"
        ],
        [
            "LOAD_METHOD",
            "alias.name.endswith"
        ],
        [
            "CALL",
            "alias.name.endswith('deep')"
        ],
        [
            "STORE_FAST",
            "deep"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "stmt"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.ImportFrom"
        ],
        [
            "CALL",
            "isinstance(stmt, ast.ImportFrom)"
        ],
        [
            "LOAD_FAST",
            "stmt"
        ],
        [
            "LOAD_ATTR",
            "stmt.module"
        ],
        [
            "COMPARE_OP",
            "stmt.module == 'birdseye'"
        ],
        [
            "LOAD_FAST",
            "stmt"
        ],
        [
            "LOAD_ATTR",
            "stmt.names"
        ],
        [
            "STORE_FAST",
            "alias"
        ],
        [
            "LOAD_FAST",
            "alias"
        ],
        [
            "LOAD_ATTR",
            "alias.name"
        ],
        [
            "LOAD_METHOD",
            "alias.name.startswith"
        ],
        [
            "CALL",
            "alias.name.startswith('trace_module')"
        ],
        [
            "LOAD_FAST",
            "stmt"
        ],
        [
            "STORE_FAST",
            "trace_stmt"
        ],
        [
            "LOAD_FAST",
            "alias"
        ],
        [
            "LOAD_ATTR",
            "alias.name"
        ],
        [
            "LOAD_METHOD",
            "alias.name.endswith"
        ],
        [
            "CALL",
            "alias.name.endswith('deep')"
        ],
        [
            "STORE_FAST",
            "deep"
        ],
        [
            "LOAD_FAST",
            "deep"
        ],
        [
            "LOAD_FAST",
            "trace_stmt"
        ]
    ],
    "ipython.py": [
        [
            "STORE_NAME",
            "import inspect"
        ],
        [
            "STORE_NAME",
            "import socket"
        ],
        [
            "STORE_NAME",
            "import sys"
        ],
        [
            "STORE_NAME",
            "from io import BytesIO, StringIO"
        ],
        [
            "STORE_NAME",
            "from io import BytesIO, StringIO"
        ],
        [
            "STORE_NAME",
            "from threading import current_thread, Thread"
        ],
        [
            "STORE_NAME",
            "from threading import current_thread, Thread"
        ],
        [
            "STORE_NAME",
            "from uuid import uuid4"
        ],
        [
            "STORE_NAME",
            "from IPython.core.display import HTML, display"
        ],
        [
            "STORE_NAME",
            "from IPython.core.display import HTML, display"
        ],
        [
            "STORE_NAME",
            "from IPython.core.magic import Magics, cell_magic, magics_class"
        ],
        [
            "STORE_NAME",
            "from IPython.core.magic import Magics, cell_magic, magics_class"
        ],
        [
            "STORE_NAME",
            "from IPython.core.magic import Magics, cell_magic, magics_class"
        ],
        [
            "STORE_NAME",
            "from jinja2 import Environment, PackageLoader, select_autoescape"
        ],
        [
            "STORE_NAME",
            "from jinja2 import Environment, PackageLoader, select_autoescape"
        ],
        [
            "STORE_NAME",
            "from jinja2 import Environment, PackageLoader, select_autoescape"
        ],
        [
            "STORE_NAME",
            "from traitlets import Unicode, Int, Bool"
        ],
        [
            "STORE_NAME",
            "from traitlets import Unicode, Int, Bool"
        ],
        [
            "STORE_NAME",
            "from traitlets import Unicode, Int, Bool"
        ],
        [
            "STORE_NAME",
            "from werkzeug.local import LocalProxy"
        ],
        [
            "STORE_NAME",
            "from werkzeug.serving import ThreadingMixIn"
        ],
        [
            "STORE_NAME",
            "from birdseye.bird import PY2, Database"
        ],
        [
            "STORE_NAME",
            "from birdseye.bird import PY2, Database"
        ],
        [
            "STORE_NAME",
            "from birdseye import server, eye"
        ],
        [
            "STORE_NAME",
            "from birdseye import server, eye"
        ],
        [
            "LOAD_NAME",
            "PY2"
        ],
        [
            "LOAD_NAME",
            "BytesIO"
        ],
        [
            "LOAD_NAME",
            "StringIO"
        ],
        [
            "STORE_NAME",
            "fake_stream"
        ],
        [
            "STORE_NAME",
            "thread_proxies"
        ],
        [
            "STORE_NAME",
            "def stream_proxy(original):\n    def p():\n        frame = inspect.currentframe()\n        while frame:\n            if frame.f_code == ThreadingMixIn.process_request_thread.__code__:\n                return fake_stream()\n            frame = frame.f_back\n        return thread_proxies.get(current_thread().ident,\n                                  original)\n\n    return LocalProxy(p)"
        ],
        [
            "LOAD_NAME",
            "stream_proxy"
        ],
        [
            "LOAD_NAME",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.stderr"
        ],
        [
            "CALL",
            "stream_proxy(sys.stderr)"
        ],
        [
            "LOAD_NAME",
            "sys"
        ],
        [
            "STORE_ATTR",
            "sys.stderr"
        ],
        [
            "LOAD_NAME",
            "stream_proxy"
        ],
        [
            "LOAD_NAME",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.stdout"
        ],
        [
            "CALL",
            "stream_proxy(sys.stdout)"
        ],
        [
            "LOAD_NAME",
            "sys"
        ],
        [
            "STORE_ATTR",
            "sys.stdout"
        ],
        [
            "STORE_NAME",
            "def run_server(port, bind_host, show_server_output):\n    if not show_server_output:\n        thread_proxies[current_thread().ident] = fake_stream()\n    try:\n        server.app.run(\n            debug=True,\n            port=port,\n            host=bind_host,\n            use_reloader=False,\n        )\n    except socket.error:\n        pass"
        ],
        [
            "LOAD_NAME",
            "Environment"
        ],
        [
            "LOAD_NAME",
            "PackageLoader"
        ],
        [
            "CALL",
            "PackageLoader('birdseye', 'templates')"
        ],
        [
            "LOAD_NAME",
            "select_autoescape"
        ],
        [
            "CALL",
            "select_autoescape(['html', 'xml'])"
        ],
        [
            "CALL",
            "Environment(\n    loader=PackageLoader('birdseye', 'templates'),\n    autoescape=select_autoescape(['html', 'xml'])\n)"
        ],
        [
            "STORE_NAME",
            "templates_env"
        ],
        [
            "LOAD_NAME",
            "magics_class"
        ],
        [
            "LOAD_NAME",
            "Magics"
        ],
        [
            "CALL",
            "@magics_class\nclass BirdsEyeMagics(Magics):\n    server_url = Unicode(\n        u'', config=True,\n        help='If set, a server will not be automatically started by %%eye. '\n             'The iframe containing birdseye output will use this value as the base '\n             'of its URL.'\n    )\n\n    port = Int(\n        7777, config=True,\n        help='Port number for the server started by %%eye.'\n    )\n\n    bind_host = Unicode(\n        '127.0.0.1', config=True,\n        help='Host that the server started by %%eye listens on. '\n             'Set to 0.0.0.0 to make it accessible anywhere.'\n    )\n\n    show_server_output = Bool(\n        False, config=True,\n        help='Set to True to show stdout and stderr from the server started by %%eye.'\n    )\n\n    db_url = Unicode(\n        u'', config=True,\n        help='The database URL that the server started by %%eye reads from. '\n             'Equivalent to the environment variable BIRDSEYE_DB.'\n    )\n\n    @cell_magic\n    def eye(self, _line, cell):\n        if not self.server_url:\n            server.db = Database(self.db_url)\n            server.Function = server.db.Function\n            server.Call = server.db.Call\n            server.Session = server.db.Session\n            Thread(\n                target=run_server,\n                args=(\n                    self.port,\n                    self.bind_host,\n                    self.show_server_output,\n                ),\n            ).start()\n\n        eye.db = Database(self.db_url)\n\n        def callback(call_id):\n            \"\"\"\n            Always executes after the cell, whether or not an exception is raised\n            in the user code.\n            \"\"\"\n            if call_id is None:  # probably means a bug\n                return\n\n            html = HTML(templates_env.get_template('ipython_iframe.html').render(\n                call_id=call_id,\n                url=self.server_url.rstrip('/'),\n                port=self.port,\n                container_id=uuid4().hex,\n            ))\n\n            # noinspection PyTypeChecker\n            display(html)\n\n        value = eye.exec_ipython_cell(cell, callback)\n        # Display the value as would happen if the %eye magic wasn't there\n        return value"
        ],
        [
            "CALL",
            "magics_class"
        ],
        [
            "STORE_NAME",
            "@magics_class\nclass BirdsEyeMagics(Magics):\n    server_url = Unicode(\n        u'', config=True,\n        help='If set, a server will not be automatically started by %%eye. '\n             'The iframe containing birdseye output will use this value as the base '\n             'of its URL.'\n    )\n\n    port = Int(\n        7777, config=True,\n        help='Port number for the server started by %%eye.'\n    )\n\n    bind_host = Unicode(\n        '127.0.0.1', config=True,\n        help='Host that the server started by %%eye listens on. '\n             'Set to 0.0.0.0 to make it accessible anywhere.'\n    )\n\n    show_server_output = Bool(\n        False, config=True,\n        help='Set to True to show stdout and stderr from the server started by %%eye.'\n    )\n\n    db_url = Unicode(\n        u'', config=True,\n        help='The database URL that the server started by %%eye reads from. '\n             'Equivalent to the environment variable BIRDSEYE_DB.'\n    )\n\n    @cell_magic\n    def eye(self, _line, cell):\n        if not self.server_url:\n            server.db = Database(self.db_url)\n            server.Function = server.db.Function\n            server.Call = server.db.Call\n            server.Session = server.db.Session\n            Thread(\n                target=run_server,\n                args=(\n                    self.port,\n                    self.bind_host,\n                    self.show_server_output,\n                ),\n            ).start()\n\n        eye.db = Database(self.db_url)\n\n        def callback(call_id):\n            \"\"\"\n            Always executes after the cell, whether or not an exception is raised\n            in the user code.\n            \"\"\"\n            if call_id is None:  # probably means a bug\n                return\n\n            html = HTML(templates_env.get_template('ipython_iframe.html').render(\n                call_id=call_id,\n                url=self.server_url.rstrip('/'),\n                port=self.port,\n                container_id=uuid4().hex,\n            ))\n\n            # noinspection PyTypeChecker\n            display(html)\n\n        value = eye.exec_ipython_cell(cell, callback)\n        # Display the value as would happen if the %eye magic wasn't there\n        return value"
        ],
        [
            "STORE_FAST",
            "    def p():\n        frame = inspect.currentframe()\n        while frame:\n            if frame.f_code == ThreadingMixIn.process_request_thread.__code__:\n                return fake_stream()\n            frame = frame.f_back\n        return thread_proxies.get(current_thread().ident,\n                                  original)"
        ],
        [
            "LOAD_GLOBAL",
            "LocalProxy"
        ],
        [
            "LOAD_FAST",
            "p"
        ],
        [
            "CALL",
            "LocalProxy(p)"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.currentframe"
        ],
        [
            "CALL",
            "inspect.currentframe()"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_GLOBAL",
            "ThreadingMixIn"
        ],
        [
            "LOAD_ATTR",
            "ThreadingMixIn.process_request_thread"
        ],
        [
            "LOAD_ATTR",
            "ThreadingMixIn.process_request_thread.__code__"
        ],
        [
            "COMPARE_OP",
            "frame.f_code == ThreadingMixIn.process_request_thread.__code__"
        ],
        [
            "LOAD_GLOBAL",
            "fake_stream"
        ],
        [
            "CALL",
            "fake_stream()"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_back"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_GLOBAL",
            "thread_proxies"
        ],
        [
            "LOAD_METHOD",
            "thread_proxies.get"
        ],
        [
            "LOAD_GLOBAL",
            "current_thread"
        ],
        [
            "CALL",
            "current_thread()"
        ],
        [
            "LOAD_ATTR",
            "current_thread().ident"
        ],
        [
            "LOAD_DEREF",
            "original"
        ],
        [
            "CALL",
            "thread_proxies.get(current_thread().ident,\n                                  original)"
        ],
        [
            "LOAD_FAST",
            "show_server_output"
        ],
        [
            "LOAD_GLOBAL",
            "fake_stream"
        ],
        [
            "CALL",
            "fake_stream()"
        ],
        [
            "LOAD_GLOBAL",
            "thread_proxies"
        ],
        [
            "LOAD_GLOBAL",
            "current_thread"
        ],
        [
            "CALL",
            "current_thread()"
        ],
        [
            "LOAD_ATTR",
            "current_thread().ident"
        ],
        [
            "STORE_SUBSCR",
            "thread_proxies[current_thread().ident]"
        ],
        [
            "LOAD_GLOBAL",
            "server"
        ],
        [
            "LOAD_ATTR",
            "server.app"
        ],
        [
            "LOAD_METHOD",
            "server.app.run"
        ],
        [
            "LOAD_FAST",
            "port"
        ],
        [
            "LOAD_FAST",
            "bind_host"
        ],
        [
            "CALL",
            "server.app.run(\n            debug=True,\n            port=port,\n            host=bind_host,\n            use_reloader=False,\n        )"
        ],
        [
            "LOAD_GLOBAL",
            "socket"
        ],
        [
            "LOAD_ATTR",
            "socket.error"
        ],
        [
            "LOAD_NAME",
            "Unicode"
        ],
        [
            "CALL",
            "Unicode(\n        u'', config=True,\n        help='If set, a server will not be automatically started by %%eye. '\n             'The iframe containing birdseye output will use this value as the base '\n             'of its URL.'\n    )"
        ],
        [
            "STORE_NAME",
            "server_url"
        ],
        [
            "LOAD_NAME",
            "Int"
        ],
        [
            "CALL",
            "Int(\n        7777, config=True,\n        help='Port number for the server started by %%eye.'\n    )"
        ],
        [
            "STORE_NAME",
            "port"
        ],
        [
            "LOAD_NAME",
            "Unicode"
        ],
        [
            "CALL",
            "Unicode(\n        '127.0.0.1', config=True,\n        help='Host that the server started by %%eye listens on. '\n             'Set to 0.0.0.0 to make it accessible anywhere.'\n    )"
        ],
        [
            "STORE_NAME",
            "bind_host"
        ],
        [
            "LOAD_NAME",
            "Bool"
        ],
        [
            "CALL",
            "Bool(\n        False, config=True,\n        help='Set to True to show stdout and stderr from the server started by %%eye.'\n    )"
        ],
        [
            "STORE_NAME",
            "show_server_output"
        ],
        [
            "LOAD_NAME",
            "Unicode"
        ],
        [
            "CALL",
            "Unicode(\n        u'', config=True,\n        help='The database URL that the server started by %%eye reads from. '\n             'Equivalent to the environment variable BIRDSEYE_DB.'\n    )"
        ],
        [
            "STORE_NAME",
            "db_url"
        ],
        [
            "LOAD_NAME",
            "cell_magic"
        ],
        [
            "CALL",
            "cell_magic"
        ],
        [
            "STORE_NAME",
            "    @cell_magic\n    def eye(self, _line, cell):\n        if not self.server_url:\n            server.db = Database(self.db_url)\n            server.Function = server.db.Function\n            server.Call = server.db.Call\n            server.Session = server.db.Session\n            Thread(\n                target=run_server,\n                args=(\n                    self.port,\n                    self.bind_host,\n                    self.show_server_output,\n                ),\n            ).start()\n\n        eye.db = Database(self.db_url)\n\n        def callback(call_id):\n            \"\"\"\n            Always executes after the cell, whether or not an exception is raised\n            in the user code.\n            \"\"\"\n            if call_id is None:  # probably means a bug\n                return\n\n            html = HTML(templates_env.get_template('ipython_iframe.html').render(\n                call_id=call_id,\n                url=self.server_url.rstrip('/'),\n                port=self.port,\n                container_id=uuid4().hex,\n            ))\n\n            # noinspection PyTypeChecker\n            display(html)\n\n        value = eye.exec_ipython_cell(cell, callback)\n        # Display the value as would happen if the %eye magic wasn't there\n        return value"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.server_url"
        ],
        [
            "LOAD_GLOBAL",
            "Database"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.db_url"
        ],
        [
            "CALL",
            "Database(self.db_url)"
        ],
        [
            "LOAD_GLOBAL",
            "server"
        ],
        [
            "STORE_ATTR",
            "server.db"
        ],
        [
            "LOAD_GLOBAL",
            "server"
        ],
        [
            "LOAD_ATTR",
            "server.db"
        ],
        [
            "LOAD_ATTR",
            "server.db.Function"
        ],
        [
            "LOAD_GLOBAL",
            "server"
        ],
        [
            "STORE_ATTR",
            "server.Function"
        ],
        [
            "LOAD_GLOBAL",
            "server"
        ],
        [
            "LOAD_ATTR",
            "server.db"
        ],
        [
            "LOAD_ATTR",
            "server.db.Call"
        ],
        [
            "LOAD_GLOBAL",
            "server"
        ],
        [
            "STORE_ATTR",
            "server.Call"
        ],
        [
            "LOAD_GLOBAL",
            "server"
        ],
        [
            "LOAD_ATTR",
            "server.db"
        ],
        [
            "LOAD_ATTR",
            "server.db.Session"
        ],
        [
            "LOAD_GLOBAL",
            "server"
        ],
        [
            "STORE_ATTR",
            "server.Session"
        ],
        [
            "LOAD_GLOBAL",
            "Thread"
        ],
        [
            "LOAD_GLOBAL",
            "run_server"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.port"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.bind_host"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.show_server_output"
        ],
        [
            "CALL",
            "Thread(\n                target=run_server,\n                args=(\n                    self.port,\n                    self.bind_host,\n                    self.show_server_output,\n                ),\n            )"
        ],
        [
            "LOAD_METHOD",
            "Thread(\n                target=run_server,\n                args=(\n                    self.port,\n                    self.bind_host,\n                    self.show_server_output,\n                ),\n            ).start"
        ],
        [
            "CALL",
            "Thread(\n                target=run_server,\n                args=(\n                    self.port,\n                    self.bind_host,\n                    self.show_server_output,\n                ),\n            ).start()"
        ],
        [
            "LOAD_GLOBAL",
            "Database"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.db_url"
        ],
        [
            "CALL",
            "Database(self.db_url)"
        ],
        [
            "LOAD_GLOBAL",
            "eye"
        ],
        [
            "STORE_ATTR",
            "eye.db"
        ],
        [
            "STORE_FAST",
            "        def callback(call_id):\n            \"\"\"\n            Always executes after the cell, whether or not an exception is raised\n            in the user code.\n            \"\"\"\n            if call_id is None:  # probably means a bug\n                return\n\n            html = HTML(templates_env.get_template('ipython_iframe.html').render(\n                call_id=call_id,\n                url=self.server_url.rstrip('/'),\n                port=self.port,\n                container_id=uuid4().hex,\n            ))\n\n            # noinspection PyTypeChecker\n            display(html)"
        ],
        [
            "LOAD_GLOBAL",
            "eye"
        ],
        [
            "LOAD_ATTR",
            "eye.exec_ipython_cell"
        ],
        [
            "LOAD_FAST",
            "cell"
        ],
        [
            "LOAD_FAST",
            "callback"
        ],
        [
            "CALL",
            "eye.exec_ipython_cell(cell, callback)"
        ],
        [
            "STORE_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "call_id"
        ],
        [
            "LOAD_GLOBAL",
            "HTML"
        ],
        [
            "LOAD_GLOBAL",
            "templates_env"
        ],
        [
            "LOAD_METHOD",
            "templates_env.get_template"
        ],
        [
            "CALL",
            "templates_env.get_template('ipython_iframe.html')"
        ],
        [
            "LOAD_METHOD",
            "templates_env.get_template('ipython_iframe.html').render"
        ],
        [
            "LOAD_FAST",
            "call_id"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.server_url"
        ],
        [
            "LOAD_METHOD",
            "self.server_url.rstrip"
        ],
        [
            "CALL",
            "self.server_url.rstrip('/')"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.port"
        ],
        [
            "LOAD_GLOBAL",
            "uuid4"
        ],
        [
            "CALL",
            "uuid4()"
        ],
        [
            "LOAD_ATTR",
            "uuid4().hex"
        ],
        [
            "CALL",
            "templates_env.get_template('ipython_iframe.html').render(\n                call_id=call_id,\n                url=self.server_url.rstrip('/'),\n                port=self.port,\n                container_id=uuid4().hex,\n            )"
        ],
        [
            "CALL",
            "HTML(templates_env.get_template('ipython_iframe.html').render(\n                call_id=call_id,\n                url=self.server_url.rstrip('/'),\n                port=self.port,\n                container_id=uuid4().hex,\n            ))"
        ],
        [
            "STORE_FAST",
            "html"
        ],
        [
            "LOAD_GLOBAL",
            "display"
        ],
        [
            "LOAD_FAST",
            "html"
        ],
        [
            "CALL",
            "display(html)"
        ]
    ],
    "server.py": [
        [
            "STORE_NAME",
            "from __future__ import print_function, division, absolute_import"
        ],
        [
            "STORE_NAME",
            "from __future__ import print_function, division, absolute_import"
        ],
        [
            "STORE_NAME",
            "from __future__ import print_function, division, absolute_import"
        ],
        [
            "STORE_NAME",
            "import json"
        ],
        [
            "STORE_NAME",
            "from collections import OrderedDict"
        ],
        [
            "STORE_NAME",
            "from functools import partial"
        ],
        [
            "STORE_NAME",
            "from os.path import basename"
        ],
        [
            "STORE_NAME",
            "from future import standard_library"
        ],
        [
            "STORE_NAME",
            "from littleutils import DecentJSONEncoder, withattrs, group_by_attr"
        ],
        [
            "STORE_NAME",
            "from littleutils import DecentJSONEncoder, withattrs, group_by_attr"
        ],
        [
            "STORE_NAME",
            "from littleutils import DecentJSONEncoder, withattrs, group_by_attr"
        ],
        [
            "LOAD_NAME",
            "standard_library"
        ],
        [
            "LOAD_ATTR",
            "standard_library.install_aliases"
        ],
        [
            "CALL",
            "standard_library.install_aliases()"
        ],
        [
            "STORE_NAME",
            "import argparse"
        ],
        [
            "STORE_NAME",
            "import os"
        ],
        [
            "STORE_NAME",
            "import sys"
        ],
        [
            "STORE_NAME",
            "from flask import Flask, request, jsonify, url_for"
        ],
        [
            "STORE_NAME",
            "from flask import Flask, request, jsonify, url_for"
        ],
        [
            "STORE_NAME",
            "from flask import Flask, request, jsonify, url_for"
        ],
        [
            "STORE_NAME",
            "from flask import Flask, request, jsonify, url_for"
        ],
        [
            "STORE_NAME",
            "from flask.templating import render_template"
        ],
        [
            "STORE_NAME",
            "from flask_humanize import Humanize"
        ],
        [
            "STORE_NAME",
            "from werkzeug.routing import PathConverter"
        ],
        [
            "STORE_NAME",
            "import sqlalchemy"
        ],
        [
            "STORE_NAME",
            "from birdseye.db import Database"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import short_path, IPYTHON_FILE_PATH, fix_abs_path, is_ipython_cell"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import short_path, IPYTHON_FILE_PATH, fix_abs_path, is_ipython_cell"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import short_path, IPYTHON_FILE_PATH, fix_abs_path, is_ipython_cell"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import short_path, IPYTHON_FILE_PATH, fix_abs_path, is_ipython_cell"
        ],
        [
            "LOAD_NAME",
            "Flask"
        ],
        [
            "CALL",
            "Flask('birdseye')"
        ],
        [
            "STORE_NAME",
            "app"
        ],
        [
            "LOAD_NAME",
            "app"
        ],
        [
            "LOAD_ATTR",
            "app.jinja_env"
        ],
        [
            "STORE_ATTR",
            "app.jinja_env.auto_reload"
        ],
        [
            "LOAD_NAME",
            "Humanize"
        ],
        [
            "LOAD_NAME",
            "app"
        ],
        [
            "CALL",
            "Humanize(app)"
        ],
        [
            "LOAD_NAME",
            "PathConverter"
        ],
        [
            "CALL",
            "class FileConverter(PathConverter):\n    regex = '.*?'"
        ],
        [
            "STORE_NAME",
            "class FileConverter(PathConverter):\n    regex = '.*?'"
        ],
        [
            "LOAD_NAME",
            "FileConverter"
        ],
        [
            "LOAD_NAME",
            "app"
        ],
        [
            "LOAD_ATTR",
            "app.url_map"
        ],
        [
            "LOAD_ATTR",
            "app.url_map.converters"
        ],
        [
            "STORE_SUBSCR",
            "app.url_map.converters['file']"
        ],
        [
            "LOAD_NAME",
            "Database"
        ],
        [
            "CALL",
            "Database()"
        ],
        [
            "STORE_NAME",
            "db"
        ],
        [
            "LOAD_NAME",
            "db"
        ],
        [
            "LOAD_ATTR",
            "db.Session"
        ],
        [
            "STORE_NAME",
            "Session"
        ],
        [
            "LOAD_NAME",
            "db"
        ],
        [
            "LOAD_ATTR",
            "db.Function"
        ],
        [
            "STORE_NAME",
            "Function"
        ],
        [
            "LOAD_NAME",
            "db"
        ],
        [
            "LOAD_ATTR",
            "db.Call"
        ],
        [
            "STORE_NAME",
            "Call"
        ],
        [
            "LOAD_NAME",
            "app"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL",
            "app.route('/')"
        ],
        [
            "LOAD_NAME",
            "db"
        ],
        [
            "LOAD_ATTR",
            "db.provide_session"
        ],
        [
            "CALL",
            "db.provide_session"
        ],
        [
            "CALL",
            "app.route('/')"
        ],
        [
            "STORE_NAME",
            "@app.route('/')\n@db.provide_session\ndef index(session):\n    all_paths = db.all_file_paths()\n\n    recent_calls = (session.query(*(Call.basic_columns + Function.basic_columns))\n                        .join(Function)\n                        .order_by(Call.start_time.desc())[:100])\n\n    files = OrderedDict()\n\n    for row in recent_calls:\n        if is_ipython_cell(row.file):\n            continue\n        files.setdefault(\n            row.file, OrderedDict()\n        ).setdefault(\n            row.name, row\n        )\n\n    for path in all_paths:\n        files.setdefault(\n            path, OrderedDict()\n        )\n\n    short = partial(short_path, all_paths=all_paths)\n\n    return render_template('index.html',\n                           short=short,\n                           files=files)"
        ],
        [
            "LOAD_NAME",
            "app"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL",
            "app.route('/file/<file:path>')"
        ],
        [
            "LOAD_NAME",
            "db"
        ],
        [
            "LOAD_ATTR",
            "db.provide_session"
        ],
        [
            "CALL",
            "db.provide_session"
        ],
        [
            "CALL",
            "app.route('/file/<file:path>')"
        ],
        [
            "STORE_NAME",
            "@app.route('/file/<file:path>')\n@db.provide_session\ndef file_view(session, path):\n    path = fix_abs_path(path)\n\n    # Get all calls and functions in this file\n    filtered_calls = (session.query(*(Call.basic_columns + Function.basic_columns))\n                      .join(Function)\n                      .filter_by(file=path)\n                      .subquery('filtered_calls'))\n\n    # Get the latest call *time* for each function in the file\n    latest_calls = session.query(\n        filtered_calls.c.name,\n        sqlalchemy.func.max(filtered_calls.c.start_time).label('maxtime')\n    ).group_by(\n        filtered_calls.c.name,\n    ).subquery('latest_calls')\n\n    # Get the latest call for each function\n    query = session.query(filtered_calls).join(\n        latest_calls,\n        sqlalchemy.and_(\n            filtered_calls.c.name == latest_calls.c.name,\n            filtered_calls.c.start_time == latest_calls.c.maxtime,\n        )\n    ).order_by(filtered_calls.c.start_time.desc())\n    funcs = group_by_attr(query, 'type')\n\n    # Add any functions which were never called\n    all_funcs = sorted(session.query(Function.name, Function.type)\n                       .filter_by(file=path)\n                       .distinct())\n    func_names = {row.name for row in query}\n    for func in all_funcs:\n        if func.name not in func_names:\n            funcs[func.type].append(func)\n\n    return render_template('file.html',\n                           funcs=funcs,\n                           is_ipython=path == IPYTHON_FILE_PATH,\n                           full_path=path,\n                           short_path=basename(path))"
        ],
        [
            "LOAD_NAME",
            "app"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL",
            "app.route('/file/<file:path>/__function__/<func_name>')"
        ],
        [
            "LOAD_NAME",
            "db"
        ],
        [
            "LOAD_ATTR",
            "db.provide_session"
        ],
        [
            "CALL",
            "db.provide_session"
        ],
        [
            "CALL",
            "app.route('/file/<file:path>/__function__/<func_name>')"
        ],
        [
            "STORE_NAME",
            "@app.route('/file/<file:path>/__function__/<func_name>')\n@db.provide_session\ndef func_view(session, path, func_name):\n    path = fix_abs_path(path)\n    query = get_calls(session, path, func_name, 200)\n    if query:\n        func = query[0]\n        calls = [withattrs(Call(), **row._asdict()) for row in query]\n    else:\n        func = session.query(Function).filter_by(file=path, name=func_name)[0]\n        calls = None\n\n    return render_template('function.html',\n                           func=func,\n                           short_path=basename(path),\n                           calls=calls)"
        ],
        [
            "LOAD_NAME",
            "app"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL",
            "app.route('/api/file/<file:path>/__function__/<func_name>/latest_call/')"
        ],
        [
            "LOAD_NAME",
            "db"
        ],
        [
            "LOAD_ATTR",
            "db.provide_session"
        ],
        [
            "CALL",
            "db.provide_session"
        ],
        [
            "CALL",
            "app.route('/api/file/<file:path>/__function__/<func_name>/latest_call/')"
        ],
        [
            "STORE_NAME",
            "@app.route('/api/file/<file:path>/__function__/<func_name>/latest_call/')\n@db.provide_session\ndef latest_call(session, path, func_name):\n    path = fix_abs_path(path)\n    call = get_calls(session, path, func_name, 1)[0]\n    return jsonify(dict(\n        id=call.id,\n        url=url_for(call_view.__name__,\n                    call_id=call.id),\n    ))"
        ],
        [
            "STORE_NAME",
            "def get_calls(session, path, func_name, limit):\n    return (session.query(*(Call.basic_columns + Function.basic_columns))\n                .join(Function)\n                .filter_by(file=path, name=func_name)\n                .order_by(Call.start_time.desc())[:limit])"
        ],
        [
            "LOAD_NAME",
            "db"
        ],
        [
            "LOAD_ATTR",
            "db.provide_session"
        ],
        [
            "CALL",
            "db.provide_session"
        ],
        [
            "STORE_NAME",
            "@db.provide_session\ndef base_call_view(session, call_id, template):\n    call = session.query(Call).filter_by(id=call_id).one()\n    func = call.function\n    return render_template(template,\n                           short_path=basename(func.file),\n                           call=call,\n                           func=func)"
        ],
        [
            "LOAD_NAME",
            "app"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL",
            "app.route('/call/<call_id>')"
        ],
        [
            "CALL",
            "app.route('/call/<call_id>')"
        ],
        [
            "STORE_NAME",
            "@app.route('/call/<call_id>')\ndef call_view(call_id):\n    return base_call_view(call_id, 'call.html')"
        ],
        [
            "LOAD_NAME",
            "app"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL",
            "app.route('/ipython_call/<call_id>')"
        ],
        [
            "CALL",
            "app.route('/ipython_call/<call_id>')"
        ],
        [
            "STORE_NAME",
            "@app.route('/ipython_call/<call_id>')\ndef ipython_call_view(call_id):\n    return base_call_view(call_id, 'ipython_call.html')"
        ],
        [
            "LOAD_NAME",
            "app"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL",
            "app.route('/ipython_iframe/<call_id>')"
        ],
        [
            "CALL",
            "app.route('/ipython_iframe/<call_id>')"
        ],
        [
            "STORE_NAME",
            "@app.route('/ipython_iframe/<call_id>')\ndef ipython_iframe_view(call_id):\n    \"\"\"\n    This view isn't generally used, it's just an easy way to play with the template\n    without a notebook.\n    \"\"\"\n    return render_template('ipython_iframe.html',\n                           container_id='1234',\n                           port=7777,\n                           call_id=call_id)"
        ],
        [
            "LOAD_NAME",
            "app"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL",
            "app.route('/kill', methods=['POST'])"
        ],
        [
            "CALL",
            "app.route('/kill', methods=['POST'])"
        ],
        [
            "STORE_NAME",
            "@app.route('/kill', methods=['POST'])\ndef kill():\n    func = request.environ.get('werkzeug.server.shutdown')\n    if func is None:\n        raise RuntimeError('Not running with the Werkzeug Server')\n    func()\n    return 'Server shutting down...'"
        ],
        [
            "LOAD_NAME",
            "app"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL",
            "app.route('/api/call/<call_id>')"
        ],
        [
            "LOAD_NAME",
            "db"
        ],
        [
            "LOAD_ATTR",
            "db.provide_session"
        ],
        [
            "CALL",
            "db.provide_session"
        ],
        [
            "CALL",
            "app.route('/api/call/<call_id>')"
        ],
        [
            "STORE_NAME",
            "@app.route('/api/call/<call_id>')\n@db.provide_session\ndef api_call_view(session, call_id):\n    call = session.query(Call).filter_by(id=call_id).one()\n    func = call.function\n    return DecentJSONEncoder().encode(dict(\n        call=dict(data=call.parsed_data, **Call.basic_dict(call)),\n        function=dict(data=func.parsed_data, **Function.basic_dict(func))))"
        ],
        [
            "LOAD_NAME",
            "app"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL",
            "app.route('/api/calls_by_body_hash/<body_hash>')"
        ],
        [
            "LOAD_NAME",
            "db"
        ],
        [
            "LOAD_ATTR",
            "db.provide_session"
        ],
        [
            "CALL",
            "db.provide_session"
        ],
        [
            "CALL",
            "app.route('/api/calls_by_body_hash/<body_hash>')"
        ],
        [
            "STORE_NAME",
            "@app.route('/api/calls_by_body_hash/<body_hash>')\n@db.provide_session\ndef calls_by_body_hash(session, body_hash):\n    query = (session.query(*Call.basic_columns + (Function.data,))\n                 .join(Function)\n                 .filter_by(body_hash=body_hash)\n                 .order_by(Call.start_time.desc())[:200])\n\n    calls = [Call.basic_dict(withattrs(Call(), **row._asdict()))\n             for row in query]\n\n    function_data_set = {row.data for row in query}\n    ranges = set()\n    loop_ranges = set()\n    for function_data in function_data_set:\n        function_data = json.loads(function_data)\n\n        def add(key, ranges_set):\n            for node in function_data[key]:\n                ranges_set.add((node['start'], node['end']))\n\n        add('node_ranges', ranges)\n\n        # All functions are expected to have the same set\n        # of loop nodes\n        current_loop_ranges = set()\n        add('loop_ranges', current_loop_ranges)\n        assert loop_ranges in (set(), current_loop_ranges)\n        loop_ranges = current_loop_ranges\n\n    ranges = [dict(start=start, end=end) for start, end in ranges]\n    loop_ranges = [dict(start=start, end=end) for start, end in loop_ranges]\n\n    return DecentJSONEncoder().encode(dict(\n        calls=calls, ranges=ranges, loop_ranges=loop_ranges))"
        ],
        [
            "LOAD_NAME",
            "app"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL",
            "app.route('/api/body_hashes_present/', methods=['POST'])"
        ],
        [
            "LOAD_NAME",
            "db"
        ],
        [
            "LOAD_ATTR",
            "db.provide_session"
        ],
        [
            "CALL",
            "db.provide_session"
        ],
        [
            "CALL",
            "app.route('/api/body_hashes_present/', methods=['POST'])"
        ],
        [
            "STORE_NAME",
            "@app.route('/api/body_hashes_present/', methods=['POST'])\n@db.provide_session\ndef body_hashes_present(session):\n    hashes = request.get_json()\n    query = (session.query(Function.body_hash, sqlalchemy.func.count(Call.id))\n             .outerjoin(Call)\n             .filter(Function.body_hash.in_(hashes))\n             .group_by(Function.body_hash))\n    return DecentJSONEncoder().encode([\n        dict(hash=h, count=count)\n        for h, count in query\n    ])"
        ],
        [
            "LOAD_NAME",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.argv"
        ],
        [
            "BINARY_SUBSCR",
            "sys.argv[1:]"
        ],
        [
            "STORE_NAME",
            "def main(argv=sys.argv[1:]):\n    # Support legacy CLI where there was just one positional argument: the port\n    if len(argv) == 1 and argv[0].isdigit():\n        argv.insert(0, '--port')\n\n    parser = argparse.ArgumentParser(description=\"Bird's Eye: A graphical Python debugger\")\n    parser.add_argument('-p', '--port', help='HTTP port, default is 7777', default=7777, type=int)\n    parser.add_argument('--host', help=\"HTTP host, default is 'localhost'\", default='localhost')\n\n    args = parser.parse_args(argv)\n    app.run(\n        port=args.port,\n        host=args.host,\n        use_reloader=os.environ.get('BIRDSEYE_RELOADER') == '1',\n    )"
        ],
        [
            "LOAD_NAME",
            "__name__"
        ],
        [
            "COMPARE_OP",
            "__name__ == '__main__'"
        ],
        [
            "LOAD_NAME",
            "main"
        ],
        [
            "CALL",
            "main()"
        ],
        [
            "STORE_NAME",
            "regex"
        ],
        [
            "LOAD_GLOBAL",
            "db"
        ],
        [
            "LOAD_METHOD",
            "db.all_file_paths"
        ],
        [
            "CALL",
            "db.all_file_paths()"
        ],
        [
            "STORE_FAST",
            "all_paths"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_ATTR",
            "session.query"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "LOAD_ATTR",
            "Call.basic_columns"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "LOAD_ATTR",
            "Function.basic_columns"
        ],
        [
            "BINARY_OP",
            "Call.basic_columns + Function.basic_columns"
        ],
        [
            "CALL_FUNCTION_EX",
            "session.query(*(Call.basic_columns + Function.basic_columns))"
        ],
        [
            "LOAD_METHOD",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                        .join"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "CALL",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                        .join(Function)"
        ],
        [
            "LOAD_METHOD",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                        .join(Function)\n                        .order_by"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "LOAD_ATTR",
            "Call.start_time"
        ],
        [
            "LOAD_METHOD",
            "Call.start_time.desc"
        ],
        [
            "CALL",
            "Call.start_time.desc()"
        ],
        [
            "CALL",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                        .join(Function)\n                        .order_by(Call.start_time.desc())"
        ],
        [
            "BINARY_SUBSCR",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                        .join(Function)\n                        .order_by(Call.start_time.desc())[:100]"
        ],
        [
            "STORE_FAST",
            "recent_calls"
        ],
        [
            "LOAD_GLOBAL",
            "OrderedDict"
        ],
        [
            "CALL",
            "OrderedDict()"
        ],
        [
            "STORE_FAST",
            "files"
        ],
        [
            "LOAD_FAST",
            "recent_calls"
        ],
        [
            "STORE_FAST",
            "row"
        ],
        [
            "LOAD_GLOBAL",
            "is_ipython_cell"
        ],
        [
            "LOAD_FAST",
            "row"
        ],
        [
            "LOAD_ATTR",
            "row.file"
        ],
        [
            "CALL",
            "is_ipython_cell(row.file)"
        ],
        [
            "LOAD_FAST",
            "files"
        ],
        [
            "LOAD_METHOD",
            "files.setdefault"
        ],
        [
            "LOAD_FAST",
            "row"
        ],
        [
            "LOAD_ATTR",
            "row.file"
        ],
        [
            "LOAD_GLOBAL",
            "OrderedDict"
        ],
        [
            "CALL",
            "OrderedDict()"
        ],
        [
            "CALL",
            "files.setdefault(\n            row.file, OrderedDict()\n        )"
        ],
        [
            "LOAD_METHOD",
            "files.setdefault(\n            row.file, OrderedDict()\n        ).setdefault"
        ],
        [
            "LOAD_FAST",
            "row"
        ],
        [
            "LOAD_ATTR",
            "row.name"
        ],
        [
            "LOAD_FAST",
            "row"
        ],
        [
            "CALL",
            "files.setdefault(\n            row.file, OrderedDict()\n        ).setdefault(\n            row.name, row\n        )"
        ],
        [
            "LOAD_FAST",
            "all_paths"
        ],
        [
            "STORE_FAST",
            "path"
        ],
        [
            "LOAD_FAST",
            "files"
        ],
        [
            "LOAD_METHOD",
            "files.setdefault"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_GLOBAL",
            "OrderedDict"
        ],
        [
            "CALL",
            "OrderedDict()"
        ],
        [
            "CALL",
            "files.setdefault(\n            path, OrderedDict()\n        )"
        ],
        [
            "LOAD_GLOBAL",
            "partial"
        ],
        [
            "LOAD_GLOBAL",
            "short_path"
        ],
        [
            "LOAD_FAST",
            "all_paths"
        ],
        [
            "CALL",
            "partial(short_path, all_paths=all_paths)"
        ],
        [
            "STORE_FAST",
            "short"
        ],
        [
            "LOAD_GLOBAL",
            "render_template"
        ],
        [
            "LOAD_FAST",
            "short"
        ],
        [
            "LOAD_FAST",
            "files"
        ],
        [
            "CALL",
            "render_template('index.html',\n                           short=short,\n                           files=files)"
        ],
        [
            "LOAD_GLOBAL",
            "fix_abs_path"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "CALL",
            "fix_abs_path(path)"
        ],
        [
            "STORE_FAST",
            "path"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_ATTR",
            "session.query"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "LOAD_ATTR",
            "Call.basic_columns"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "LOAD_ATTR",
            "Function.basic_columns"
        ],
        [
            "BINARY_OP",
            "Call.basic_columns + Function.basic_columns"
        ],
        [
            "CALL_FUNCTION_EX",
            "session.query(*(Call.basic_columns + Function.basic_columns))"
        ],
        [
            "LOAD_METHOD",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                      .join"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "CALL",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                      .join(Function)"
        ],
        [
            "LOAD_METHOD",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                      .join(Function)\n                      .filter_by"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "CALL",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                      .join(Function)\n                      .filter_by(file=path)"
        ],
        [
            "LOAD_METHOD",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                      .join(Function)\n                      .filter_by(file=path)\n                      .subquery"
        ],
        [
            "CALL",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                      .join(Function)\n                      .filter_by(file=path)\n                      .subquery('filtered_calls')"
        ],
        [
            "STORE_FAST",
            "filtered_calls"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "LOAD_FAST",
            "filtered_calls"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c.name"
        ],
        [
            "LOAD_GLOBAL",
            "sqlalchemy"
        ],
        [
            "LOAD_ATTR",
            "sqlalchemy.func"
        ],
        [
            "LOAD_METHOD",
            "sqlalchemy.func.max"
        ],
        [
            "LOAD_FAST",
            "filtered_calls"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c.start_time"
        ],
        [
            "CALL",
            "sqlalchemy.func.max(filtered_calls.c.start_time)"
        ],
        [
            "LOAD_METHOD",
            "sqlalchemy.func.max(filtered_calls.c.start_time).label"
        ],
        [
            "CALL",
            "sqlalchemy.func.max(filtered_calls.c.start_time).label('maxtime')"
        ],
        [
            "CALL",
            "session.query(\n        filtered_calls.c.name,\n        sqlalchemy.func.max(filtered_calls.c.start_time).label('maxtime')\n    )"
        ],
        [
            "LOAD_METHOD",
            "session.query(\n        filtered_calls.c.name,\n        sqlalchemy.func.max(filtered_calls.c.start_time).label('maxtime')\n    ).group_by"
        ],
        [
            "LOAD_FAST",
            "filtered_calls"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c.name"
        ],
        [
            "CALL",
            "session.query(\n        filtered_calls.c.name,\n        sqlalchemy.func.max(filtered_calls.c.start_time).label('maxtime')\n    ).group_by(\n        filtered_calls.c.name,\n    )"
        ],
        [
            "LOAD_METHOD",
            "session.query(\n        filtered_calls.c.name,\n        sqlalchemy.func.max(filtered_calls.c.start_time).label('maxtime')\n    ).group_by(\n        filtered_calls.c.name,\n    ).subquery"
        ],
        [
            "CALL",
            "session.query(\n        filtered_calls.c.name,\n        sqlalchemy.func.max(filtered_calls.c.start_time).label('maxtime')\n    ).group_by(\n        filtered_calls.c.name,\n    ).subquery('latest_calls')"
        ],
        [
            "STORE_FAST",
            "latest_calls"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "LOAD_FAST",
            "filtered_calls"
        ],
        [
            "CALL",
            "session.query(filtered_calls)"
        ],
        [
            "LOAD_METHOD",
            "session.query(filtered_calls).join"
        ],
        [
            "LOAD_FAST",
            "latest_calls"
        ],
        [
            "LOAD_GLOBAL",
            "sqlalchemy"
        ],
        [
            "LOAD_ATTR",
            "sqlalchemy.and_"
        ],
        [
            "LOAD_FAST",
            "filtered_calls"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c.name"
        ],
        [
            "LOAD_FAST",
            "latest_calls"
        ],
        [
            "LOAD_ATTR",
            "latest_calls.c"
        ],
        [
            "LOAD_ATTR",
            "latest_calls.c.name"
        ],
        [
            "COMPARE_OP",
            "filtered_calls.c.name == latest_calls.c.name"
        ],
        [
            "LOAD_FAST",
            "filtered_calls"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c.start_time"
        ],
        [
            "LOAD_FAST",
            "latest_calls"
        ],
        [
            "LOAD_ATTR",
            "latest_calls.c"
        ],
        [
            "LOAD_ATTR",
            "latest_calls.c.maxtime"
        ],
        [
            "COMPARE_OP",
            "filtered_calls.c.start_time == latest_calls.c.maxtime"
        ],
        [
            "CALL",
            "sqlalchemy.and_(\n            filtered_calls.c.name == latest_calls.c.name,\n            filtered_calls.c.start_time == latest_calls.c.maxtime,\n        )"
        ],
        [
            "CALL",
            "session.query(filtered_calls).join(\n        latest_calls,\n        sqlalchemy.and_(\n            filtered_calls.c.name == latest_calls.c.name,\n            filtered_calls.c.start_time == latest_calls.c.maxtime,\n        )\n    )"
        ],
        [
            "LOAD_METHOD",
            "session.query(filtered_calls).join(\n        latest_calls,\n        sqlalchemy.and_(\n            filtered_calls.c.name == latest_calls.c.name,\n            filtered_calls.c.start_time == latest_calls.c.maxtime,\n        )\n    ).order_by"
        ],
        [
            "LOAD_FAST",
            "filtered_calls"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c.start_time"
        ],
        [
            "LOAD_METHOD",
            "filtered_calls.c.start_time.desc"
        ],
        [
            "CALL",
            "filtered_calls.c.start_time.desc()"
        ],
        [
            "CALL",
            "session.query(filtered_calls).join(\n        latest_calls,\n        sqlalchemy.and_(\n            filtered_calls.c.name == latest_calls.c.name,\n            filtered_calls.c.start_time == latest_calls.c.maxtime,\n        )\n    ).order_by(filtered_calls.c.start_time.desc())"
        ],
        [
            "STORE_FAST",
            "query"
        ],
        [
            "LOAD_GLOBAL",
            "group_by_attr"
        ],
        [
            "LOAD_FAST",
            "query"
        ],
        [
            "CALL",
            "group_by_attr(query, 'type')"
        ],
        [
            "STORE_FAST",
            "funcs"
        ],
        [
            "LOAD_GLOBAL",
            "sorted"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "LOAD_ATTR",
            "Function.name"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "LOAD_ATTR",
            "Function.type"
        ],
        [
            "CALL",
            "session.query(Function.name, Function.type)"
        ],
        [
            "LOAD_METHOD",
            "session.query(Function.name, Function.type)\n                       .filter_by"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "CALL",
            "session.query(Function.name, Function.type)\n                       .filter_by(file=path)"
        ],
        [
            "LOAD_METHOD",
            "session.query(Function.name, Function.type)\n                       .filter_by(file=path)\n                       .distinct"
        ],
        [
            "CALL",
            "session.query(Function.name, Function.type)\n                       .filter_by(file=path)\n                       .distinct()"
        ],
        [
            "CALL",
            "sorted(session.query(Function.name, Function.type)\n                       .filter_by(file=path)\n                       .distinct())"
        ],
        [
            "STORE_FAST",
            "all_funcs"
        ],
        [
            "LOAD_FAST",
            "query"
        ],
        [
            "CALL",
            "{row.name for row in query}"
        ],
        [
            "STORE_FAST",
            "func_names"
        ],
        [
            "LOAD_FAST",
            "all_funcs"
        ],
        [
            "STORE_FAST",
            "func"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.name"
        ],
        [
            "LOAD_FAST",
            "func_names"
        ],
        [
            "CONTAINS_OP",
            "func.name not in func_names"
        ],
        [
            "LOAD_FAST",
            "funcs"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.type"
        ],
        [
            "BINARY_SUBSCR",
            "funcs[func.type]"
        ],
        [
            "LOAD_METHOD",
            "funcs[func.type].append"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "CALL",
            "funcs[func.type].append(func)"
        ],
        [
            "LOAD_GLOBAL",
            "render_template"
        ],
        [
            "LOAD_FAST",
            "funcs"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_GLOBAL",
            "IPYTHON_FILE_PATH"
        ],
        [
            "COMPARE_OP",
            "path == IPYTHON_FILE_PATH"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_GLOBAL",
            "basename"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "CALL",
            "basename(path)"
        ],
        [
            "CALL",
            "render_template('file.html',\n                           funcs=funcs,\n                           is_ipython=path == IPYTHON_FILE_PATH,\n                           full_path=path,\n                           short_path=basename(path))"
        ],
        [
            "LOAD_FAST",
            "{row.name for row in query}"
        ],
        [
            "STORE_FAST",
            "row"
        ],
        [
            "LOAD_FAST",
            "row"
        ],
        [
            "LOAD_ATTR",
            "row.name"
        ],
        [
            "LOAD_GLOBAL",
            "fix_abs_path"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "CALL",
            "fix_abs_path(path)"
        ],
        [
            "STORE_FAST",
            "path"
        ],
        [
            "LOAD_GLOBAL",
            "get_calls"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_FAST",
            "func_name"
        ],
        [
            "CALL",
            "get_calls(session, path, func_name, 200)"
        ],
        [
            "STORE_FAST",
            "query"
        ],
        [
            "LOAD_FAST",
            "query"
        ],
        [
            "LOAD_FAST",
            "query"
        ],
        [
            "BINARY_SUBSCR",
            "query[0]"
        ],
        [
            "STORE_FAST",
            "func"
        ],
        [
            "LOAD_FAST",
            "query"
        ],
        [
            "CALL",
            "[withattrs(Call(), **row._asdict()) for row in query]"
        ],
        [
            "STORE_FAST",
            "calls"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "CALL",
            "session.query(Function)"
        ],
        [
            "LOAD_METHOD",
            "session.query(Function).filter_by"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_FAST",
            "func_name"
        ],
        [
            "CALL",
            "session.query(Function).filter_by(file=path, name=func_name)"
        ],
        [
            "BINARY_SUBSCR",
            "session.query(Function).filter_by(file=path, name=func_name)[0]"
        ],
        [
            "STORE_FAST",
            "func"
        ],
        [
            "STORE_FAST",
            "calls"
        ],
        [
            "LOAD_GLOBAL",
            "render_template"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "LOAD_GLOBAL",
            "basename"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "CALL",
            "basename(path)"
        ],
        [
            "LOAD_FAST",
            "calls"
        ],
        [
            "CALL",
            "render_template('function.html',\n                           func=func,\n                           short_path=basename(path),\n                           calls=calls)"
        ],
        [
            "LOAD_FAST",
            "[withattrs(Call(), **row._asdict()) for row in query]"
        ],
        [
            "STORE_FAST",
            "row"
        ],
        [
            "LOAD_GLOBAL",
            "withattrs"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "CALL",
            "Call()"
        ],
        [
            "LOAD_FAST",
            "row"
        ],
        [
            "LOAD_METHOD",
            "row._asdict"
        ],
        [
            "CALL",
            "row._asdict()"
        ],
        [
            "CALL_FUNCTION_EX",
            "withattrs(Call(), **row._asdict())"
        ],
        [
            "LOAD_GLOBAL",
            "fix_abs_path"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "CALL",
            "fix_abs_path(path)"
        ],
        [
            "STORE_FAST",
            "path"
        ],
        [
            "LOAD_GLOBAL",
            "get_calls"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_FAST",
            "func_name"
        ],
        [
            "CALL",
            "get_calls(session, path, func_name, 1)"
        ],
        [
            "BINARY_SUBSCR",
            "get_calls(session, path, func_name, 1)[0]"
        ],
        [
            "STORE_FAST",
            "call"
        ],
        [
            "LOAD_GLOBAL",
            "jsonify"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_FAST",
            "call"
        ],
        [
            "LOAD_ATTR",
            "call.id"
        ],
        [
            "LOAD_GLOBAL",
            "url_for"
        ],
        [
            "LOAD_GLOBAL",
            "call_view"
        ],
        [
            "LOAD_ATTR",
            "call_view.__name__"
        ],
        [
            "LOAD_FAST",
            "call"
        ],
        [
            "LOAD_ATTR",
            "call.id"
        ],
        [
            "CALL",
            "url_for(call_view.__name__,\n                    call_id=call.id)"
        ],
        [
            "CALL",
            "dict(\n        id=call.id,\n        url=url_for(call_view.__name__,\n                    call_id=call.id),\n    )"
        ],
        [
            "CALL",
            "jsonify(dict(\n        id=call.id,\n        url=url_for(call_view.__name__,\n                    call_id=call.id),\n    ))"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_ATTR",
            "session.query"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "LOAD_ATTR",
            "Call.basic_columns"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "LOAD_ATTR",
            "Function.basic_columns"
        ],
        [
            "BINARY_OP",
            "Call.basic_columns + Function.basic_columns"
        ],
        [
            "CALL_FUNCTION_EX",
            "session.query(*(Call.basic_columns + Function.basic_columns))"
        ],
        [
            "LOAD_METHOD",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                .join"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "CALL",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                .join(Function)"
        ],
        [
            "LOAD_METHOD",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                .join(Function)\n                .filter_by"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_FAST",
            "func_name"
        ],
        [
            "CALL",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                .join(Function)\n                .filter_by(file=path, name=func_name)"
        ],
        [
            "LOAD_METHOD",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                .join(Function)\n                .filter_by(file=path, name=func_name)\n                .order_by"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "LOAD_ATTR",
            "Call.start_time"
        ],
        [
            "LOAD_METHOD",
            "Call.start_time.desc"
        ],
        [
            "CALL",
            "Call.start_time.desc()"
        ],
        [
            "CALL",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                .join(Function)\n                .filter_by(file=path, name=func_name)\n                .order_by(Call.start_time.desc())"
        ],
        [
            "LOAD_FAST",
            "limit"
        ],
        [
            "BINARY_SUBSCR",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                .join(Function)\n                .filter_by(file=path, name=func_name)\n                .order_by(Call.start_time.desc())[:limit]"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "CALL",
            "session.query(Call)"
        ],
        [
            "LOAD_METHOD",
            "session.query(Call).filter_by"
        ],
        [
            "LOAD_FAST",
            "call_id"
        ],
        [
            "CALL",
            "session.query(Call).filter_by(id=call_id)"
        ],
        [
            "LOAD_METHOD",
            "session.query(Call).filter_by(id=call_id).one"
        ],
        [
            "CALL",
            "session.query(Call).filter_by(id=call_id).one()"
        ],
        [
            "STORE_FAST",
            "call"
        ],
        [
            "LOAD_FAST",
            "call"
        ],
        [
            "LOAD_ATTR",
            "call.function"
        ],
        [
            "STORE_FAST",
            "func"
        ],
        [
            "LOAD_GLOBAL",
            "render_template"
        ],
        [
            "LOAD_FAST",
            "template"
        ],
        [
            "LOAD_GLOBAL",
            "basename"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.file"
        ],
        [
            "CALL",
            "basename(func.file)"
        ],
        [
            "LOAD_FAST",
            "call"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "CALL",
            "render_template(template,\n                           short_path=basename(func.file),\n                           call=call,\n                           func=func)"
        ],
        [
            "LOAD_GLOBAL",
            "base_call_view"
        ],
        [
            "LOAD_FAST",
            "call_id"
        ],
        [
            "CALL",
            "base_call_view(call_id, 'call.html')"
        ],
        [
            "LOAD_GLOBAL",
            "base_call_view"
        ],
        [
            "LOAD_FAST",
            "call_id"
        ],
        [
            "CALL",
            "base_call_view(call_id, 'ipython_call.html')"
        ],
        [
            "LOAD_GLOBAL",
            "render_template"
        ],
        [
            "LOAD_FAST",
            "call_id"
        ],
        [
            "CALL",
            "render_template('ipython_iframe.html',\n                           container_id='1234',\n                           port=7777,\n                           call_id=call_id)"
        ],
        [
            "LOAD_GLOBAL",
            "request"
        ],
        [
            "LOAD_ATTR",
            "request.environ"
        ],
        [
            "LOAD_METHOD",
            "request.environ.get"
        ],
        [
            "CALL",
            "request.environ.get('werkzeug.server.shutdown')"
        ],
        [
            "STORE_FAST",
            "func"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "LOAD_GLOBAL",
            "RuntimeError"
        ],
        [
            "CALL",
            "RuntimeError('Not running with the Werkzeug Server')"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "CALL",
            "func()"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "CALL",
            "session.query(Call)"
        ],
        [
            "LOAD_METHOD",
            "session.query(Call).filter_by"
        ],
        [
            "LOAD_FAST",
            "call_id"
        ],
        [
            "CALL",
            "session.query(Call).filter_by(id=call_id)"
        ],
        [
            "LOAD_METHOD",
            "session.query(Call).filter_by(id=call_id).one"
        ],
        [
            "CALL",
            "session.query(Call).filter_by(id=call_id).one()"
        ],
        [
            "STORE_FAST",
            "call"
        ],
        [
            "LOAD_FAST",
            "call"
        ],
        [
            "LOAD_ATTR",
            "call.function"
        ],
        [
            "STORE_FAST",
            "func"
        ],
        [
            "LOAD_GLOBAL",
            "DecentJSONEncoder"
        ],
        [
            "CALL",
            "DecentJSONEncoder()"
        ],
        [
            "LOAD_METHOD",
            "DecentJSONEncoder().encode"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_FAST",
            "call"
        ],
        [
            "LOAD_ATTR",
            "call.parsed_data"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "LOAD_METHOD",
            "Call.basic_dict"
        ],
        [
            "LOAD_FAST",
            "call"
        ],
        [
            "CALL",
            "Call.basic_dict(call)"
        ],
        [
            "CALL_FUNCTION_EX",
            "dict(data=call.parsed_data, **Call.basic_dict(call))"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.parsed_data"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "LOAD_METHOD",
            "Function.basic_dict"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "CALL",
            "Function.basic_dict(func)"
        ],
        [
            "CALL_FUNCTION_EX",
            "dict(data=func.parsed_data, **Function.basic_dict(func))"
        ],
        [
            "CALL",
            "dict(\n        call=dict(data=call.parsed_data, **Call.basic_dict(call)),\n        function=dict(data=func.parsed_data, **Function.basic_dict(func)))"
        ],
        [
            "CALL",
            "DecentJSONEncoder().encode(dict(\n        call=dict(data=call.parsed_data, **Call.basic_dict(call)),\n        function=dict(data=func.parsed_data, **Function.basic_dict(func))))"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_ATTR",
            "session.query"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "LOAD_ATTR",
            "Call.basic_columns"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "LOAD_ATTR",
            "Function.data"
        ],
        [
            "BINARY_OP",
            "Call.basic_columns + (Function.data,)"
        ],
        [
            "CALL_FUNCTION_EX",
            "session.query(*Call.basic_columns + (Function.data,))"
        ],
        [
            "LOAD_METHOD",
            "session.query(*Call.basic_columns + (Function.data,))\n                 .join"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "CALL",
            "session.query(*Call.basic_columns + (Function.data,))\n                 .join(Function)"
        ],
        [
            "LOAD_METHOD",
            "session.query(*Call.basic_columns + (Function.data,))\n                 .join(Function)\n                 .filter_by"
        ],
        [
            "LOAD_FAST",
            "body_hash"
        ],
        [
            "CALL",
            "session.query(*Call.basic_columns + (Function.data,))\n                 .join(Function)\n                 .filter_by(body_hash=body_hash)"
        ],
        [
            "LOAD_METHOD",
            "session.query(*Call.basic_columns + (Function.data,))\n                 .join(Function)\n                 .filter_by(body_hash=body_hash)\n                 .order_by"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "LOAD_ATTR",
            "Call.start_time"
        ],
        [
            "LOAD_METHOD",
            "Call.start_time.desc"
        ],
        [
            "CALL",
            "Call.start_time.desc()"
        ],
        [
            "CALL",
            "session.query(*Call.basic_columns + (Function.data,))\n                 .join(Function)\n                 .filter_by(body_hash=body_hash)\n                 .order_by(Call.start_time.desc())"
        ],
        [
            "BINARY_SUBSCR",
            "session.query(*Call.basic_columns + (Function.data,))\n                 .join(Function)\n                 .filter_by(body_hash=body_hash)\n                 .order_by(Call.start_time.desc())[:200]"
        ],
        [
            "STORE_FAST",
            "query"
        ],
        [
            "LOAD_FAST",
            "query"
        ],
        [
            "CALL",
            "[Call.basic_dict(withattrs(Call(), **row._asdict()))\n             for row in query]"
        ],
        [
            "STORE_FAST",
            "calls"
        ],
        [
            "LOAD_FAST",
            "query"
        ],
        [
            "CALL",
            "{row.data for row in query}"
        ],
        [
            "STORE_FAST",
            "function_data_set"
        ],
        [
            "LOAD_GLOBAL",
            "set"
        ],
        [
            "CALL",
            "set()"
        ],
        [
            "STORE_FAST",
            "ranges"
        ],
        [
            "LOAD_GLOBAL",
            "set"
        ],
        [
            "CALL",
            "set()"
        ],
        [
            "STORE_FAST",
            "loop_ranges"
        ],
        [
            "LOAD_FAST",
            "function_data_set"
        ],
        [
            "STORE_DEREF",
            "function_data"
        ],
        [
            "LOAD_GLOBAL",
            "json"
        ],
        [
            "LOAD_ATTR",
            "json.loads"
        ],
        [
            "LOAD_DEREF",
            "function_data"
        ],
        [
            "CALL",
            "json.loads(function_data)"
        ],
        [
            "STORE_DEREF",
            "function_data"
        ],
        [
            "STORE_FAST",
            "        def add(key, ranges_set):\n            for node in function_data[key]:\n                ranges_set.add((node['start'], node['end']))"
        ],
        [
            "LOAD_FAST",
            "add"
        ],
        [
            "LOAD_FAST",
            "ranges"
        ],
        [
            "CALL",
            "add('node_ranges', ranges)"
        ],
        [
            "LOAD_GLOBAL",
            "set"
        ],
        [
            "CALL",
            "set()"
        ],
        [
            "STORE_FAST",
            "current_loop_ranges"
        ],
        [
            "LOAD_FAST",
            "add"
        ],
        [
            "LOAD_FAST",
            "current_loop_ranges"
        ],
        [
            "CALL",
            "add('loop_ranges', current_loop_ranges)"
        ],
        [
            "LOAD_FAST",
            "loop_ranges"
        ],
        [
            "LOAD_GLOBAL",
            "set"
        ],
        [
            "CALL",
            "set()"
        ],
        [
            "LOAD_FAST",
            "current_loop_ranges"
        ],
        [
            "CONTAINS_OP",
            "loop_ranges in (set(), current_loop_ranges)"
        ],
        [
            "LOAD_FAST",
            "current_loop_ranges"
        ],
        [
            "STORE_FAST",
            "loop_ranges"
        ],
        [
            "LOAD_FAST",
            "ranges"
        ],
        [
            "CALL",
            "[dict(start=start, end=end) for start, end in ranges]"
        ],
        [
            "STORE_FAST",
            "ranges"
        ],
        [
            "LOAD_FAST",
            "loop_ranges"
        ],
        [
            "CALL",
            "[dict(start=start, end=end) for start, end in loop_ranges]"
        ],
        [
            "STORE_FAST",
            "loop_ranges"
        ],
        [
            "LOAD_GLOBAL",
            "DecentJSONEncoder"
        ],
        [
            "CALL",
            "DecentJSONEncoder()"
        ],
        [
            "LOAD_METHOD",
            "DecentJSONEncoder().encode"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_FAST",
            "calls"
        ],
        [
            "LOAD_FAST",
            "ranges"
        ],
        [
            "LOAD_FAST",
            "loop_ranges"
        ],
        [
            "CALL",
            "dict(\n        calls=calls, ranges=ranges, loop_ranges=loop_ranges)"
        ],
        [
            "CALL",
            "DecentJSONEncoder().encode(dict(\n        calls=calls, ranges=ranges, loop_ranges=loop_ranges))"
        ],
        [
            "LOAD_FAST",
            "[Call.basic_dict(withattrs(Call(), **row._asdict()))\n             for row in query]"
        ],
        [
            "STORE_FAST",
            "row"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "LOAD_METHOD",
            "Call.basic_dict"
        ],
        [
            "LOAD_GLOBAL",
            "withattrs"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "CALL",
            "Call()"
        ],
        [
            "LOAD_FAST",
            "row"
        ],
        [
            "LOAD_METHOD",
            "row._asdict"
        ],
        [
            "CALL",
            "row._asdict()"
        ],
        [
            "CALL_FUNCTION_EX",
            "withattrs(Call(), **row._asdict())"
        ],
        [
            "CALL",
            "Call.basic_dict(withattrs(Call(), **row._asdict()))"
        ],
        [
            "LOAD_FAST",
            "{row.data for row in query}"
        ],
        [
            "STORE_FAST",
            "row"
        ],
        [
            "LOAD_FAST",
            "row"
        ],
        [
            "LOAD_ATTR",
            "row.data"
        ],
        [
            "LOAD_DEREF",
            "function_data"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "BINARY_SUBSCR",
            "function_data[key]"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "ranges_set"
        ],
        [
            "LOAD_METHOD",
            "ranges_set.add"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "BINARY_SUBSCR",
            "node['start']"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "BINARY_SUBSCR",
            "node['end']"
        ],
        [
            "CALL",
            "ranges_set.add((node['start'], node['end']))"
        ],
        [
            "LOAD_FAST",
            "[dict(start=start, end=end) for start, end in ranges]"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "STORE_FAST",
            "end"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "end"
        ],
        [
            "CALL",
            "dict(start=start, end=end)"
        ],
        [
            "LOAD_FAST",
            "[dict(start=start, end=end) for start, end in loop_ranges]"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "STORE_FAST",
            "end"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "end"
        ],
        [
            "CALL",
            "dict(start=start, end=end)"
        ],
        [
            "LOAD_GLOBAL",
            "request"
        ],
        [
            "LOAD_ATTR",
            "request.get_json"
        ],
        [
            "CALL",
            "request.get_json()"
        ],
        [
            "STORE_FAST",
            "hashes"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "LOAD_ATTR",
            "Function.body_hash"
        ],
        [
            "LOAD_GLOBAL",
            "sqlalchemy"
        ],
        [
            "LOAD_ATTR",
            "sqlalchemy.func"
        ],
        [
            "LOAD_METHOD",
            "sqlalchemy.func.count"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "LOAD_ATTR",
            "Call.id"
        ],
        [
            "CALL",
            "sqlalchemy.func.count(Call.id)"
        ],
        [
            "CALL",
            "session.query(Function.body_hash, sqlalchemy.func.count(Call.id))"
        ],
        [
            "LOAD_METHOD",
            "session.query(Function.body_hash, sqlalchemy.func.count(Call.id))\n             .outerjoin"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "CALL",
            "session.query(Function.body_hash, sqlalchemy.func.count(Call.id))\n             .outerjoin(Call)"
        ],
        [
            "LOAD_METHOD",
            "session.query(Function.body_hash, sqlalchemy.func.count(Call.id))\n             .outerjoin(Call)\n             .filter"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "LOAD_ATTR",
            "Function.body_hash"
        ],
        [
            "LOAD_METHOD",
            "Function.body_hash.in_"
        ],
        [
            "LOAD_FAST",
            "hashes"
        ],
        [
            "CALL",
            "Function.body_hash.in_(hashes)"
        ],
        [
            "CALL",
            "session.query(Function.body_hash, sqlalchemy.func.count(Call.id))\n             .outerjoin(Call)\n             .filter(Function.body_hash.in_(hashes))"
        ],
        [
            "LOAD_METHOD",
            "session.query(Function.body_hash, sqlalchemy.func.count(Call.id))\n             .outerjoin(Call)\n             .filter(Function.body_hash.in_(hashes))\n             .group_by"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "LOAD_ATTR",
            "Function.body_hash"
        ],
        [
            "CALL",
            "session.query(Function.body_hash, sqlalchemy.func.count(Call.id))\n             .outerjoin(Call)\n             .filter(Function.body_hash.in_(hashes))\n             .group_by(Function.body_hash)"
        ],
        [
            "STORE_FAST",
            "query"
        ],
        [
            "LOAD_GLOBAL",
            "DecentJSONEncoder"
        ],
        [
            "CALL",
            "DecentJSONEncoder()"
        ],
        [
            "LOAD_METHOD",
            "DecentJSONEncoder().encode"
        ],
        [
            "LOAD_FAST",
            "query"
        ],
        [
            "CALL",
            "[\n        dict(hash=h, count=count)\n        for h, count in query\n    ]"
        ],
        [
            "CALL",
            "DecentJSONEncoder().encode([\n        dict(hash=h, count=count)\n        for h, count in query\n    ])"
        ],
        [
            "LOAD_FAST",
            "[\n        dict(hash=h, count=count)\n        for h, count in query\n    ]"
        ],
        [
            "STORE_FAST",
            "h"
        ],
        [
            "STORE_FAST",
            "count"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_FAST",
            "h"
        ],
        [
            "LOAD_FAST",
            "count"
        ],
        [
            "CALL",
            "dict(hash=h, count=count)"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "argv"
        ],
        [
            "CALL",
            "len(argv)"
        ],
        [
            "COMPARE_OP",
            "len(argv) == 1"
        ],
        [
            "LOAD_FAST",
            "argv"
        ],
        [
            "BINARY_SUBSCR",
            "argv[0]"
        ],
        [
            "LOAD_METHOD",
            "argv[0].isdigit"
        ],
        [
            "CALL",
            "argv[0].isdigit()"
        ],
        [
            "LOAD_FAST",
            "argv"
        ],
        [
            "LOAD_METHOD",
            "argv.insert"
        ],
        [
            "CALL",
            "argv.insert(0, '--port')"
        ],
        [
            "LOAD_GLOBAL",
            "argparse"
        ],
        [
            "LOAD_ATTR",
            "argparse.ArgumentParser"
        ],
        [
            "CALL",
            "argparse.ArgumentParser(description=\"Bird's Eye: A graphical Python debugger\")"
        ],
        [
            "STORE_FAST",
            "parser"
        ],
        [
            "LOAD_FAST",
            "parser"
        ],
        [
            "LOAD_METHOD",
            "parser.add_argument"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "CALL",
            "parser.add_argument('-p', '--port', help='HTTP port, default is 7777', default=7777, type=int)"
        ],
        [
            "LOAD_FAST",
            "parser"
        ],
        [
            "LOAD_METHOD",
            "parser.add_argument"
        ],
        [
            "CALL",
            "parser.add_argument('--host', help=\"HTTP host, default is 'localhost'\", default='localhost')"
        ],
        [
            "LOAD_FAST",
            "parser"
        ],
        [
            "LOAD_METHOD",
            "parser.parse_args"
        ],
        [
            "LOAD_FAST",
            "argv"
        ],
        [
            "CALL",
            "parser.parse_args(argv)"
        ],
        [
            "STORE_FAST",
            "args"
        ],
        [
            "LOAD_GLOBAL",
            "app"
        ],
        [
            "LOAD_METHOD",
            "app.run"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_ATTR",
            "args.port"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_ATTR",
            "args.host"
        ],
        [
            "LOAD_GLOBAL",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.environ"
        ],
        [
            "LOAD_METHOD",
            "os.environ.get"
        ],
        [
            "CALL",
            "os.environ.get('BIRDSEYE_RELOADER')"
        ],
        [
            "COMPARE_OP",
            "os.environ.get('BIRDSEYE_RELOADER') == '1'"
        ],
        [
            "CALL",
            "app.run(\n        port=args.port,\n        host=args.host,\n        use_reloader=os.environ.get('BIRDSEYE_RELOADER') == '1',\n    )"
        ]
    ],
    "tests.py": [
        [
            "STORE_NAME",
            "from __future__ import print_function, division"
        ],
        [
            "STORE_NAME",
            "from __future__ import print_function, division"
        ],
        [
            "STORE_NAME",
            "import ast"
        ],
        [
            "STORE_NAME",
            "import inspect"
        ],
        [
            "STORE_NAME",
            "import os"
        ],
        [
            "STORE_NAME",
            "import sys"
        ],
        [
            "STORE_NAME",
            "import tempfile"
        ],
        [
            "STORE_NAME",
            "import time"
        ],
        [
            "STORE_NAME",
            "import unittest"
        ],
        [
            "STORE_NAME",
            "from executing import Source, only, PY3, NotOneValueFound, get_instructions"
        ],
        [
            "STORE_NAME",
            "from executing import Source, only, PY3, NotOneValueFound, get_instructions"
        ],
        [
            "STORE_NAME",
            "from executing import Source, only, PY3, NotOneValueFound, get_instructions"
        ],
        [
            "STORE_NAME",
            "from executing import Source, only, PY3, NotOneValueFound, get_instructions"
        ],
        [
            "STORE_NAME",
            "from executing import Source, only, PY3, NotOneValueFound, get_instructions"
        ],
        [
            "LOAD_NAME",
            "unittest"
        ],
        [
            "LOAD_ATTR",
            "unittest.TestCase"
        ],
        [
            "CALL",
            "class TestStuff(unittest.TestCase):\n\n    # noinspection PyTrailingSemicolon\n    def test_semicolons(self):\n        # @formatter:off\n        tester(1); tester(2); tester(3)\n        tester(9\n               ); tester(\n            8); tester(\n            99\n        ); tester(33); tester([4,\n                               5, 6, [\n                                7]])\n        # @formatter:on\n\n    def test_decorator(self):\n        @empty_decorator\n        @decorator_with_args(tester('123'), x=int())\n        @tester(list(tuple([1, 2])), returns=empty_decorator)\n        @tester(\n            list(\n                tuple(\n                    [3, 4])),\n            returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(\n            str(),\n            x=int())\n        @tester(list(tuple([5, 6])), returns=empty_decorator)\n        @tester(list(tuple([7, 8])), returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(tester('sdf'), x=tester('123234'))\n        def foo():\n            pass\n\n    def test_comprehensions(self):\n        # Comprehensions can be separated if they contain different names\n        str([{tester(x) for x in [1]}, {tester(y) for y in [1]}])\n        # or are on different lines\n        str([{tester(x) for x in [1]},\n             {tester(x) for x in [1]}])\n        # or are of different types\n        str([{tester(x) for x in [1]}, list(tester(x) for x in [1])])\n        # but not if everything is the same\n        # noinspection PyTypeChecker\n        # with self.assertRaises((AttributeError, NotOneValueFound)):\n        #     str([{tester(x) for x in [1]}, {tester(x) for x in [2]}])\n\n    def test_lambda(self):\n        self.assertEqual(\n            (lambda x: (tester(x), tester(x)))(tester(3)),\n            (3, 3),\n        )\n        (lambda: (lambda: tester(1))())()\n        self.assertEqual(\n            (lambda: [tester(x) for x in tester([1, 2])])(),\n            [1, 2],\n        )\n\n    def test_closures_and_nested_comprehensions(self):\n        x = 1\n        # @formatter:off\n        str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n        def foo():\n            y = 2\n            str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            def bar():\n                z = 3\n                str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y+z): {tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            bar()\n\n        foo()\n        # @formatter:on\n\n    def test_indirect_call(self):\n        dict(x=tester)['x'](tester)(3, check_func=False)\n\n    def test_compound_statements(self):\n        with self.assertRaises(TypeError):\n            try:\n                for _ in tester([1, 2, 3]):\n                    while tester(0):\n                        pass\n                    else:\n                        tester(4)\n                else:\n                    tester(5)\n                    raise ValueError\n            except tester(ValueError):\n                tester(9)\n                raise TypeError\n            finally:\n                tester(10)\n\n        # PyCharm getting confused somehow?\n        # noinspection PyUnreachableCode\n        str()\n\n        with self.assertRaises(tester(Exception)):\n            if tester(0):\n                pass\n            elif tester(0):\n                pass\n            elif tester(1 / 0):\n                pass\n\n    def test_generator(self):\n        def gen():\n            for x in [1, 2]:\n                yield tester(x)\n\n        gen2 = (tester(x) for x in tester([1, 2]))\n\n        assert list(gen()) == list(gen2) == [1, 2]\n\n    def test_future_import(self):\n        tester(4)\n\n    def test_many_calls(self):\n        node = None\n        start = time.time()\n        for i in range(10000):\n            new_node = Source.executing(inspect.currentframe()).node\n            if node is None:\n                node = new_node\n            else:\n                self.assertIs(node, new_node)\n        self.assertLess(time.time() - start, 1)\n\n    def test_decode_source(self):\n        def check(source, encoding, exception=None, matches=True):\n            encoded = source.encode(encoding)\n            if exception:\n                with self.assertRaises(exception):\n                    Source.decode_source(encoded)\n            else:\n                decoded = Source.decode_source(encoded)\n                if matches:\n                    self.assertEqual(decoded, source)\n                else:\n                    self.assertNotEqual(decoded, source)\n\n        check(u'# coding=utf8\\n\u00e9', 'utf8')\n        check(u'# coding=gbk\\n\u00e9', 'gbk')\n\n        check(u'# coding=utf8\\n\u00e9', 'gbk', exception=UnicodeDecodeError)\n        check(u'# coding=gbk\\n\u00e9', 'utf8', matches=False)\n\n        # In Python 3 the default encoding is assumed to be UTF8\n        if PY3:\n            check(u'\u00e9', 'utf8')\n            check(u'\u00e9', 'gbk', exception=SyntaxError)\n\n    def test_multiline_strings(self):\n        tester('a')\n        tester('''\n            ab''')\n        tester('''\n                    abc\n                    def\n                    '''\n               )\n        str([\n            tester(\n                '''\n                123\n                456\n                '''\n            ),\n            tester(\n                '''\n                345\n                456786\n                '''\n            ),\n        ])\n        tester(\n            [\n                '''\n                123\n                456\n                '''\n                '''\n                345\n                456786\n                '''\n                ,\n                '''\n                123\n                456\n                ''',\n                '''\n                345\n                456786\n                '''\n            ]\n        )\n\n    def test_multiple_statements_on_one_line(self):\n        if tester(1): tester(2)\n        for _ in tester([1, 2]): tester(3)\n\n    def assert_qualname(self, func, qn, check_actual_qualname=True):\n        qualname = Source.for_filename(__file__).code_qualname(func.__code__)\n        self.assertEqual(qn, qualname)\n        if PY3 and check_actual_qualname:\n            self.assertEqual(qn, func.__qualname__)\n        self.assertTrue(qn.endswith(func.__name__))\n\n    def test_qualname(self):\n        self.assert_qualname(C.f, 'C.f')\n        self.assert_qualname(C.D.g, 'C.D.g')\n        self.assert_qualname(f, 'f')\n        self.assert_qualname(f(), 'f.<locals>.g')\n        self.assert_qualname(C.D.h(), 'C.D.h.<locals>.i.<locals>.j')\n        self.assert_qualname(lamb, '<lambda>')\n        foo = lambda_maker()\n        self.assert_qualname(foo, 'lambda_maker.<locals>.foo')\n        self.assert_qualname(foo.x, 'lambda_maker.<locals>.<lambda>')\n        self.assert_qualname(foo(), 'lambda_maker.<locals>.foo.<locals>.<lambda>')\n        self.assert_qualname(foo()(), 'lambda_maker.<locals>.foo.<locals>.<lambda>', check_actual_qualname=False)\n\n    def test_extended_arg(self):\n        source = 'tester(6)\\n%s\\ntester(9)' % list(range(66000))\n        _, filename = tempfile.mkstemp()\n        code = compile(source, filename, 'exec')\n        with open(filename, 'w') as outfile:\n            outfile.write(source)\n        exec(code)\n\n    def test_only(self):\n        for n in range(5):\n            gen = (i for i in range(n))\n            if n == 1:\n                self.assertEqual(only(gen), 0)\n            else:\n                with self.assertRaises(NotOneValueFound):\n                    only(gen)\n\n    def test_invalid_python(self):\n        path = os.path.join(os.path.dirname(__file__), 'not_code.txt', )\n        source = Source.for_filename(path)\n        self.assertIsNone(source.tree)\n\n    def test_executing_methods(self):\n        frame = inspect.currentframe()\n        executing = Source.executing(frame)\n        self.assertEqual(executing.code_qualname(), 'TestStuff.test_executing_methods')\n        if 'pypy' not in sys.version.lower():\n            text = 'Source.executing(frame)'\n            self.assertEqual(executing.text(), text)\n            start, end = executing.text_range()\n            self.assertEqual(executing.source.text[start:end], text)\n\n    def test_attr(self):\n        c = C()\n        c.x = c.y = tester\n        str((c.x.x, c.x.y, c.y.x, c.y.y, c.x.asd, c.y.qwe))"
        ],
        [
            "STORE_NAME",
            "class TestStuff(unittest.TestCase):\n\n    # noinspection PyTrailingSemicolon\n    def test_semicolons(self):\n        # @formatter:off\n        tester(1); tester(2); tester(3)\n        tester(9\n               ); tester(\n            8); tester(\n            99\n        ); tester(33); tester([4,\n                               5, 6, [\n                                7]])\n        # @formatter:on\n\n    def test_decorator(self):\n        @empty_decorator\n        @decorator_with_args(tester('123'), x=int())\n        @tester(list(tuple([1, 2])), returns=empty_decorator)\n        @tester(\n            list(\n                tuple(\n                    [3, 4])),\n            returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(\n            str(),\n            x=int())\n        @tester(list(tuple([5, 6])), returns=empty_decorator)\n        @tester(list(tuple([7, 8])), returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(tester('sdf'), x=tester('123234'))\n        def foo():\n            pass\n\n    def test_comprehensions(self):\n        # Comprehensions can be separated if they contain different names\n        str([{tester(x) for x in [1]}, {tester(y) for y in [1]}])\n        # or are on different lines\n        str([{tester(x) for x in [1]},\n             {tester(x) for x in [1]}])\n        # or are of different types\n        str([{tester(x) for x in [1]}, list(tester(x) for x in [1])])\n        # but not if everything is the same\n        # noinspection PyTypeChecker\n        # with self.assertRaises((AttributeError, NotOneValueFound)):\n        #     str([{tester(x) for x in [1]}, {tester(x) for x in [2]}])\n\n    def test_lambda(self):\n        self.assertEqual(\n            (lambda x: (tester(x), tester(x)))(tester(3)),\n            (3, 3),\n        )\n        (lambda: (lambda: tester(1))())()\n        self.assertEqual(\n            (lambda: [tester(x) for x in tester([1, 2])])(),\n            [1, 2],\n        )\n\n    def test_closures_and_nested_comprehensions(self):\n        x = 1\n        # @formatter:off\n        str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n        def foo():\n            y = 2\n            str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            def bar():\n                z = 3\n                str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y+z): {tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            bar()\n\n        foo()\n        # @formatter:on\n\n    def test_indirect_call(self):\n        dict(x=tester)['x'](tester)(3, check_func=False)\n\n    def test_compound_statements(self):\n        with self.assertRaises(TypeError):\n            try:\n                for _ in tester([1, 2, 3]):\n                    while tester(0):\n                        pass\n                    else:\n                        tester(4)\n                else:\n                    tester(5)\n                    raise ValueError\n            except tester(ValueError):\n                tester(9)\n                raise TypeError\n            finally:\n                tester(10)\n\n        # PyCharm getting confused somehow?\n        # noinspection PyUnreachableCode\n        str()\n\n        with self.assertRaises(tester(Exception)):\n            if tester(0):\n                pass\n            elif tester(0):\n                pass\n            elif tester(1 / 0):\n                pass\n\n    def test_generator(self):\n        def gen():\n            for x in [1, 2]:\n                yield tester(x)\n\n        gen2 = (tester(x) for x in tester([1, 2]))\n\n        assert list(gen()) == list(gen2) == [1, 2]\n\n    def test_future_import(self):\n        tester(4)\n\n    def test_many_calls(self):\n        node = None\n        start = time.time()\n        for i in range(10000):\n            new_node = Source.executing(inspect.currentframe()).node\n            if node is None:\n                node = new_node\n            else:\n                self.assertIs(node, new_node)\n        self.assertLess(time.time() - start, 1)\n\n    def test_decode_source(self):\n        def check(source, encoding, exception=None, matches=True):\n            encoded = source.encode(encoding)\n            if exception:\n                with self.assertRaises(exception):\n                    Source.decode_source(encoded)\n            else:\n                decoded = Source.decode_source(encoded)\n                if matches:\n                    self.assertEqual(decoded, source)\n                else:\n                    self.assertNotEqual(decoded, source)\n\n        check(u'# coding=utf8\\n\u00e9', 'utf8')\n        check(u'# coding=gbk\\n\u00e9', 'gbk')\n\n        check(u'# coding=utf8\\n\u00e9', 'gbk', exception=UnicodeDecodeError)\n        check(u'# coding=gbk\\n\u00e9', 'utf8', matches=False)\n\n        # In Python 3 the default encoding is assumed to be UTF8\n        if PY3:\n            check(u'\u00e9', 'utf8')\n            check(u'\u00e9', 'gbk', exception=SyntaxError)\n\n    def test_multiline_strings(self):\n        tester('a')\n        tester('''\n            ab''')\n        tester('''\n                    abc\n                    def\n                    '''\n               )\n        str([\n            tester(\n                '''\n                123\n                456\n                '''\n            ),\n            tester(\n                '''\n                345\n                456786\n                '''\n            ),\n        ])\n        tester(\n            [\n                '''\n                123\n                456\n                '''\n                '''\n                345\n                456786\n                '''\n                ,\n                '''\n                123\n                456\n                ''',\n                '''\n                345\n                456786\n                '''\n            ]\n        )\n\n    def test_multiple_statements_on_one_line(self):\n        if tester(1): tester(2)\n        for _ in tester([1, 2]): tester(3)\n\n    def assert_qualname(self, func, qn, check_actual_qualname=True):\n        qualname = Source.for_filename(__file__).code_qualname(func.__code__)\n        self.assertEqual(qn, qualname)\n        if PY3 and check_actual_qualname:\n            self.assertEqual(qn, func.__qualname__)\n        self.assertTrue(qn.endswith(func.__name__))\n\n    def test_qualname(self):\n        self.assert_qualname(C.f, 'C.f')\n        self.assert_qualname(C.D.g, 'C.D.g')\n        self.assert_qualname(f, 'f')\n        self.assert_qualname(f(), 'f.<locals>.g')\n        self.assert_qualname(C.D.h(), 'C.D.h.<locals>.i.<locals>.j')\n        self.assert_qualname(lamb, '<lambda>')\n        foo = lambda_maker()\n        self.assert_qualname(foo, 'lambda_maker.<locals>.foo')\n        self.assert_qualname(foo.x, 'lambda_maker.<locals>.<lambda>')\n        self.assert_qualname(foo(), 'lambda_maker.<locals>.foo.<locals>.<lambda>')\n        self.assert_qualname(foo()(), 'lambda_maker.<locals>.foo.<locals>.<lambda>', check_actual_qualname=False)\n\n    def test_extended_arg(self):\n        source = 'tester(6)\\n%s\\ntester(9)' % list(range(66000))\n        _, filename = tempfile.mkstemp()\n        code = compile(source, filename, 'exec')\n        with open(filename, 'w') as outfile:\n            outfile.write(source)\n        exec(code)\n\n    def test_only(self):\n        for n in range(5):\n            gen = (i for i in range(n))\n            if n == 1:\n                self.assertEqual(only(gen), 0)\n            else:\n                with self.assertRaises(NotOneValueFound):\n                    only(gen)\n\n    def test_invalid_python(self):\n        path = os.path.join(os.path.dirname(__file__), 'not_code.txt', )\n        source = Source.for_filename(path)\n        self.assertIsNone(source.tree)\n\n    def test_executing_methods(self):\n        frame = inspect.currentframe()\n        executing = Source.executing(frame)\n        self.assertEqual(executing.code_qualname(), 'TestStuff.test_executing_methods')\n        if 'pypy' not in sys.version.lower():\n            text = 'Source.executing(frame)'\n            self.assertEqual(executing.text(), text)\n            start, end = executing.text_range()\n            self.assertEqual(executing.source.text[start:end], text)\n\n    def test_attr(self):\n        c = C()\n        c.x = c.y = tester\n        str((c.x.x, c.x.y, c.y.x, c.y.y, c.x.asd, c.y.qwe))"
        ],
        [
            "LOAD_NAME",
            "unittest"
        ],
        [
            "LOAD_ATTR",
            "unittest.TestCase"
        ],
        [
            "CALL",
            "class TestFile(unittest.TestCase):\n    def test_file(self):\n        source = Source.for_frame(inspect.currentframe())\n        code = compile(source.text, source.filename, 'exec')\n        instructions = get_instructions(code)\n        lineno = None\n        for inst in instructions:\n            if inst.starts_line is not None:\n                lineno = inst.starts_line\n            if not inst.opname.startswith(\n                    ('BINARY_', 'UNARY_', 'LOAD_ATTR', 'LOAD_METHOD', 'LOOKUP_METHOD', 'COMPARE_OP')):\n                continue\n            frame = C()\n            frame.f_lasti = inst.offset\n            frame.f_code = code\n            frame.f_globals = globals()\n            frame.f_lineno = lineno\n            print(inst.opname)\n            assert Source.executing(frame).node is not None"
        ],
        [
            "STORE_NAME",
            "class TestFile(unittest.TestCase):\n    def test_file(self):\n        source = Source.for_frame(inspect.currentframe())\n        code = compile(source.text, source.filename, 'exec')\n        instructions = get_instructions(code)\n        lineno = None\n        for inst in instructions:\n            if inst.starts_line is not None:\n                lineno = inst.starts_line\n            if not inst.opname.startswith(\n                    ('BINARY_', 'UNARY_', 'LOAD_ATTR', 'LOAD_METHOD', 'LOOKUP_METHOD', 'COMPARE_OP')):\n                continue\n            frame = C()\n            frame.f_lasti = inst.offset\n            frame.f_code = code\n            frame.f_globals = globals()\n            frame.f_lineno = lineno\n            print(inst.opname)\n            assert Source.executing(frame).node is not None"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class C(object):\n    @staticmethod\n    def f():\n        pass\n\n    class D(object):\n        @staticmethod\n        def g():\n            pass\n\n        @staticmethod\n        def h():\n            def i():\n                def j():\n                    pass\n\n                return j\n\n            return i()"
        ],
        [
            "STORE_NAME",
            "class C(object):\n    @staticmethod\n    def f():\n        pass\n\n    class D(object):\n        @staticmethod\n        def g():\n            pass\n\n        @staticmethod\n        def h():\n            def i():\n                def j():\n                    pass\n\n                return j\n\n            return i()"
        ],
        [
            "LOAD_NAME",
            "TestFile"
        ],
        [
            "CALL",
            "TestFile()"
        ],
        [
            "LOAD_METHOD",
            "TestFile().test_file"
        ],
        [
            "CALL",
            "TestFile().test_file()"
        ],
        [
            "STORE_NAME",
            "def f():\n    def g():\n        pass\n\n    return g"
        ],
        [
            "STORE_NAME",
            "def lambda_maker():\n    def assign(x):\n        def decorator(func):\n            func.x = x\n            return func\n\n        return decorator\n\n    @assign(lambda: 1)\n    def foo():\n        return lambda: lambda: 3\n\n    return foo"
        ],
        [
            "STORE_NAME",
            "lamb"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class Tester(object):\n    def get_node(self, typ):\n        frame = inspect.currentframe().f_back.f_back\n        Source.lazycache(frame)\n        node = Source.executing(frame).node\n        assert isinstance(node, typ), (node, typ)\n        return node\n\n    def check(self, node, value):\n        frame = inspect.currentframe().f_back.f_back\n        result = eval(\n            compile(ast.Expression(node), frame.f_code.co_filename, 'eval'),\n            frame.f_globals,\n            frame.f_locals,\n        )\n        assert result == value, (result, value)\n\n    def __call__(self, arg, check_func=True, returns=None):\n        call = self.get_node(ast.Call)\n        self.check(call.args[0], arg)\n        if check_func:\n            self.check(call.func, self)\n        if returns is None:\n            return arg\n        return returns\n\n    def __getattr__(self, item):\n        node = self.get_node(ast.Attribute)\n        self.check(node.value, self)\n        assert node.attr == item\n        return self\n\n    def __getitem__(self, item):\n        node = self.get_node(ast.Subscript)\n        self.check(node.value, self)\n        self.check(node.slice.value, item)\n        return self\n\n    def __add__(self, other):\n        node = self.get_node(ast.BinOp)\n        self.check(node.left, self)\n        self.check(node.right, other)\n        return self\n\n    __pow__ = __mul__ = __sub__ = __add__\n\n    def __invert__(self):\n        node = self.get_node(ast.UnaryOp)\n        self.check(node.operand, self)\n        return self\n\n    __neg__ = __pos__ = __invert__\n\n    def __lt__(self, other):\n        node = self.get_node(ast.Compare)\n        self.check(node.left, self)\n        self.check(node.comparators[0], other)\n        return self\n\n    __ne__ = __ge__ = __lt__"
        ],
        [
            "STORE_NAME",
            "class Tester(object):\n    def get_node(self, typ):\n        frame = inspect.currentframe().f_back.f_back\n        Source.lazycache(frame)\n        node = Source.executing(frame).node\n        assert isinstance(node, typ), (node, typ)\n        return node\n\n    def check(self, node, value):\n        frame = inspect.currentframe().f_back.f_back\n        result = eval(\n            compile(ast.Expression(node), frame.f_code.co_filename, 'eval'),\n            frame.f_globals,\n            frame.f_locals,\n        )\n        assert result == value, (result, value)\n\n    def __call__(self, arg, check_func=True, returns=None):\n        call = self.get_node(ast.Call)\n        self.check(call.args[0], arg)\n        if check_func:\n            self.check(call.func, self)\n        if returns is None:\n            return arg\n        return returns\n\n    def __getattr__(self, item):\n        node = self.get_node(ast.Attribute)\n        self.check(node.value, self)\n        assert node.attr == item\n        return self\n\n    def __getitem__(self, item):\n        node = self.get_node(ast.Subscript)\n        self.check(node.value, self)\n        self.check(node.slice.value, item)\n        return self\n\n    def __add__(self, other):\n        node = self.get_node(ast.BinOp)\n        self.check(node.left, self)\n        self.check(node.right, other)\n        return self\n\n    __pow__ = __mul__ = __sub__ = __add__\n\n    def __invert__(self):\n        node = self.get_node(ast.UnaryOp)\n        self.check(node.operand, self)\n        return self\n\n    __neg__ = __pos__ = __invert__\n\n    def __lt__(self, other):\n        node = self.get_node(ast.Compare)\n        self.check(node.left, self)\n        self.check(node.comparators[0], other)\n        return self\n\n    __ne__ = __ge__ = __lt__"
        ],
        [
            "LOAD_NAME",
            "Tester"
        ],
        [
            "CALL",
            "Tester()"
        ],
        [
            "STORE_NAME",
            "tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "CALL",
            "tester([1, 2, 3])"
        ],
        [
            "COMPARE_OP",
            "tester([1, 2, 3]) == [1, 2, 3]"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "LOAD_ATTR",
            "tester.asd"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "IS_OP",
            "tester.asd is tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "BINARY_SUBSCR",
            "tester[19]"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "IS_OP",
            "tester[19] is tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "BINARY_OP",
            "tester ** 4"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "IS_OP",
            "tester ** 4 is tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "BINARY_OP",
            "tester * 3"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "IS_OP",
            "tester * 3 is tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "BINARY_OP",
            "tester - 2"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "IS_OP",
            "tester - 2 is tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "BINARY_OP",
            "tester + 1"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "IS_OP",
            "tester + 1 is tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "UNARY_NEGATIVE",
            "-tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "IS_OP",
            "-tester is tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "UNARY_POSITIVE",
            "+tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "IS_OP",
            "+tester is tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "UNARY_INVERT",
            "~tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "IS_OP",
            "~tester is tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "COMPARE_OP",
            "tester < 7"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "IS_OP",
            "(tester < 7) is tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "COMPARE_OP",
            "tester >= 78"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "IS_OP",
            "(tester >= 78) is tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "COMPARE_OP",
            "tester != 79"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "IS_OP",
            "(tester != 79) is tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "LOAD_METHOD",
            "tester.foo"
        ],
        [
            "CALL",
            "tester.foo(45, False)"
        ],
        [
            "COMPARE_OP",
            "tester.foo(45, False) == 45"
        ],
        [
            "STORE_NAME",
            "def empty_decorator(func):\n    return func"
        ],
        [
            "STORE_NAME",
            "def decorator_with_args(*_, **__):\n    return empty_decorator"
        ],
        [
            "LOAD_NAME",
            "__name__"
        ],
        [
            "COMPARE_OP",
            "__name__ == '__main__'"
        ],
        [
            "LOAD_NAME",
            "unittest"
        ],
        [
            "LOAD_ATTR",
            "unittest.main"
        ],
        [
            "CALL",
            "unittest.main()"
        ],
        [
            "STORE_NAME",
            "    def test_semicolons(self):\n        # @formatter:off\n        tester(1); tester(2); tester(3)\n        tester(9\n               ); tester(\n            8); tester(\n            99\n        ); tester(33); tester([4,\n                               5, 6, [\n                                7]])"
        ],
        [
            "STORE_NAME",
            "    def test_decorator(self):\n        @empty_decorator\n        @decorator_with_args(tester('123'), x=int())\n        @tester(list(tuple([1, 2])), returns=empty_decorator)\n        @tester(\n            list(\n                tuple(\n                    [3, 4])),\n            returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(\n            str(),\n            x=int())\n        @tester(list(tuple([5, 6])), returns=empty_decorator)\n        @tester(list(tuple([7, 8])), returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(tester('sdf'), x=tester('123234'))\n        def foo():\n            pass"
        ],
        [
            "STORE_NAME",
            "    def test_comprehensions(self):\n        # Comprehensions can be separated if they contain different names\n        str([{tester(x) for x in [1]}, {tester(y) for y in [1]}])\n        # or are on different lines\n        str([{tester(x) for x in [1]},\n             {tester(x) for x in [1]}])\n        # or are of different types\n        str([{tester(x) for x in [1]}, list(tester(x) for x in [1])])"
        ],
        [
            "STORE_NAME",
            "    def test_lambda(self):\n        self.assertEqual(\n            (lambda x: (tester(x), tester(x)))(tester(3)),\n            (3, 3),\n        )\n        (lambda: (lambda: tester(1))())()\n        self.assertEqual(\n            (lambda: [tester(x) for x in tester([1, 2])])(),\n            [1, 2],\n        )"
        ],
        [
            "STORE_NAME",
            "    def test_closures_and_nested_comprehensions(self):\n        x = 1\n        # @formatter:off\n        str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n        def foo():\n            y = 2\n            str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            def bar():\n                z = 3\n                str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y+z): {tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            bar()\n\n        foo()"
        ],
        [
            "STORE_NAME",
            "    def test_indirect_call(self):\n        dict(x=tester)['x'](tester)(3, check_func=False)"
        ],
        [
            "STORE_NAME",
            "    def test_compound_statements(self):\n        with self.assertRaises(TypeError):\n            try:\n                for _ in tester([1, 2, 3]):\n                    while tester(0):\n                        pass\n                    else:\n                        tester(4)\n                else:\n                    tester(5)\n                    raise ValueError\n            except tester(ValueError):\n                tester(9)\n                raise TypeError\n            finally:\n                tester(10)\n\n        # PyCharm getting confused somehow?\n        # noinspection PyUnreachableCode\n        str()\n\n        with self.assertRaises(tester(Exception)):\n            if tester(0):\n                pass\n            elif tester(0):\n                pass\n            elif tester(1 / 0):\n                pass"
        ],
        [
            "STORE_NAME",
            "    def test_generator(self):\n        def gen():\n            for x in [1, 2]:\n                yield tester(x)\n\n        gen2 = (tester(x) for x in tester([1, 2]))\n\n        assert list(gen()) == list(gen2) == [1, 2]"
        ],
        [
            "STORE_NAME",
            "    def test_future_import(self):\n        tester(4)"
        ],
        [
            "STORE_NAME",
            "    def test_many_calls(self):\n        node = None\n        start = time.time()\n        for i in range(10000):\n            new_node = Source.executing(inspect.currentframe()).node\n            if node is None:\n                node = new_node\n            else:\n                self.assertIs(node, new_node)\n        self.assertLess(time.time() - start, 1)"
        ],
        [
            "STORE_NAME",
            "    def test_decode_source(self):\n        def check(source, encoding, exception=None, matches=True):\n            encoded = source.encode(encoding)\n            if exception:\n                with self.assertRaises(exception):\n                    Source.decode_source(encoded)\n            else:\n                decoded = Source.decode_source(encoded)\n                if matches:\n                    self.assertEqual(decoded, source)\n                else:\n                    self.assertNotEqual(decoded, source)\n\n        check(u'# coding=utf8\\n\u00e9', 'utf8')\n        check(u'# coding=gbk\\n\u00e9', 'gbk')\n\n        check(u'# coding=utf8\\n\u00e9', 'gbk', exception=UnicodeDecodeError)\n        check(u'# coding=gbk\\n\u00e9', 'utf8', matches=False)\n\n        # In Python 3 the default encoding is assumed to be UTF8\n        if PY3:\n            check(u'\u00e9', 'utf8')\n            check(u'\u00e9', 'gbk', exception=SyntaxError)"
        ],
        [
            "STORE_NAME",
            "    def test_multiline_strings(self):\n        tester('a')\n        tester('''\n            ab''')\n        tester('''\n                    abc\n                    def\n                    '''\n               )\n        str([\n            tester(\n                '''\n                123\n                456\n                '''\n            ),\n            tester(\n                '''\n                345\n                456786\n                '''\n            ),\n        ])\n        tester(\n            [\n                '''\n                123\n                456\n                '''\n                '''\n                345\n                456786\n                '''\n                ,\n                '''\n                123\n                456\n                ''',\n                '''\n                345\n                456786\n                '''\n            ]\n        )"
        ],
        [
            "STORE_NAME",
            "    def test_multiple_statements_on_one_line(self):\n        if tester(1): tester(2)\n        for _ in tester([1, 2]): tester(3)"
        ],
        [
            "STORE_NAME",
            "    def assert_qualname(self, func, qn, check_actual_qualname=True):\n        qualname = Source.for_filename(__file__).code_qualname(func.__code__)\n        self.assertEqual(qn, qualname)\n        if PY3 and check_actual_qualname:\n            self.assertEqual(qn, func.__qualname__)\n        self.assertTrue(qn.endswith(func.__name__))"
        ],
        [
            "STORE_NAME",
            "    def test_qualname(self):\n        self.assert_qualname(C.f, 'C.f')\n        self.assert_qualname(C.D.g, 'C.D.g')\n        self.assert_qualname(f, 'f')\n        self.assert_qualname(f(), 'f.<locals>.g')\n        self.assert_qualname(C.D.h(), 'C.D.h.<locals>.i.<locals>.j')\n        self.assert_qualname(lamb, '<lambda>')\n        foo = lambda_maker()\n        self.assert_qualname(foo, 'lambda_maker.<locals>.foo')\n        self.assert_qualname(foo.x, 'lambda_maker.<locals>.<lambda>')\n        self.assert_qualname(foo(), 'lambda_maker.<locals>.foo.<locals>.<lambda>')\n        self.assert_qualname(foo()(), 'lambda_maker.<locals>.foo.<locals>.<lambda>', check_actual_qualname=False)"
        ],
        [
            "STORE_NAME",
            "    def test_extended_arg(self):\n        source = 'tester(6)\\n%s\\ntester(9)' % list(range(66000))\n        _, filename = tempfile.mkstemp()\n        code = compile(source, filename, 'exec')\n        with open(filename, 'w') as outfile:\n            outfile.write(source)\n        exec(code)"
        ],
        [
            "STORE_NAME",
            "    def test_only(self):\n        for n in range(5):\n            gen = (i for i in range(n))\n            if n == 1:\n                self.assertEqual(only(gen), 0)\n            else:\n                with self.assertRaises(NotOneValueFound):\n                    only(gen)"
        ],
        [
            "STORE_NAME",
            "    def test_invalid_python(self):\n        path = os.path.join(os.path.dirname(__file__), 'not_code.txt', )\n        source = Source.for_filename(path)\n        self.assertIsNone(source.tree)"
        ],
        [
            "STORE_NAME",
            "    def test_executing_methods(self):\n        frame = inspect.currentframe()\n        executing = Source.executing(frame)\n        self.assertEqual(executing.code_qualname(), 'TestStuff.test_executing_methods')\n        if 'pypy' not in sys.version.lower():\n            text = 'Source.executing(frame)'\n            self.assertEqual(executing.text(), text)\n            start, end = executing.text_range()\n            self.assertEqual(executing.source.text[start:end], text)"
        ],
        [
            "STORE_NAME",
            "    def test_attr(self):\n        c = C()\n        c.x = c.y = tester\n        str((c.x.x, c.x.y, c.y.x, c.y.y, c.x.asd, c.y.qwe))"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(1)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(2)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(3)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(9\n               )"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(\n            8)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(\n            99\n        )"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(33)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([4,\n                               5, 6, [\n                                7]])"
        ],
        [
            "LOAD_GLOBAL",
            "empty_decorator"
        ],
        [
            "LOAD_GLOBAL",
            "decorator_with_args"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester('123')"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "CALL",
            "int()"
        ],
        [
            "CALL",
            "decorator_with_args(tester('123'), x=int())"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_GLOBAL",
            "tuple"
        ],
        [
            "CALL",
            "tuple([1, 2])"
        ],
        [
            "CALL",
            "list(tuple([1, 2]))"
        ],
        [
            "LOAD_GLOBAL",
            "empty_decorator"
        ],
        [
            "CALL",
            "tester(list(tuple([1, 2])), returns=empty_decorator)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_GLOBAL",
            "tuple"
        ],
        [
            "CALL",
            "tuple(\n                    [3, 4])"
        ],
        [
            "CALL",
            "list(\n                tuple(\n                    [3, 4]))"
        ],
        [
            "LOAD_GLOBAL",
            "empty_decorator"
        ],
        [
            "CALL",
            "tester(\n            list(\n                tuple(\n                    [3, 4])),\n            returns=empty_decorator)"
        ],
        [
            "LOAD_GLOBAL",
            "empty_decorator"
        ],
        [
            "LOAD_GLOBAL",
            "decorator_with_args"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "CALL",
            "str()"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "CALL",
            "int()"
        ],
        [
            "CALL",
            "decorator_with_args(\n            str(),\n            x=int())"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_GLOBAL",
            "tuple"
        ],
        [
            "CALL",
            "tuple([5, 6])"
        ],
        [
            "CALL",
            "list(tuple([5, 6]))"
        ],
        [
            "LOAD_GLOBAL",
            "empty_decorator"
        ],
        [
            "CALL",
            "tester(list(tuple([5, 6])), returns=empty_decorator)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_GLOBAL",
            "tuple"
        ],
        [
            "CALL",
            "tuple([7, 8])"
        ],
        [
            "CALL",
            "list(tuple([7, 8]))"
        ],
        [
            "LOAD_GLOBAL",
            "empty_decorator"
        ],
        [
            "CALL",
            "tester(list(tuple([7, 8])), returns=empty_decorator)"
        ],
        [
            "LOAD_GLOBAL",
            "empty_decorator"
        ],
        [
            "LOAD_GLOBAL",
            "decorator_with_args"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester('sdf')"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester('123234')"
        ],
        [
            "CALL",
            "decorator_with_args(tester('sdf'), x=tester('123234'))"
        ],
        [
            "CALL",
            "decorator_with_args(tester('sdf'), x=tester('123234'))"
        ],
        [
            "CALL",
            "empty_decorator"
        ],
        [
            "CALL",
            "tester(list(tuple([7, 8])), returns=empty_decorator)"
        ],
        [
            "CALL",
            "tester(list(tuple([5, 6])), returns=empty_decorator)"
        ],
        [
            "CALL",
            "decorator_with_args(\n            str(),\n            x=int())"
        ],
        [
            "CALL",
            "empty_decorator"
        ],
        [
            "CALL",
            "tester(\n            list(\n                tuple(\n                    [3, 4])),\n            returns=empty_decorator)"
        ],
        [
            "CALL",
            "tester(list(tuple([1, 2])), returns=empty_decorator)"
        ],
        [
            "CALL",
            "decorator_with_args(tester('123'), x=int())"
        ],
        [
            "CALL",
            "empty_decorator"
        ],
        [
            "STORE_FAST",
            "        @empty_decorator\n        @decorator_with_args(tester('123'), x=int())\n        @tester(list(tuple([1, 2])), returns=empty_decorator)\n        @tester(\n            list(\n                tuple(\n                    [3, 4])),\n            returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(\n            str(),\n            x=int())\n        @tester(list(tuple([5, 6])), returns=empty_decorator)\n        @tester(list(tuple([7, 8])), returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(tester('sdf'), x=tester('123234'))\n        def foo():\n            pass"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "CALL",
            "{tester(x) for x in [1]}"
        ],
        [
            "CALL",
            "{tester(y) for y in [1]}"
        ],
        [
            "CALL",
            "str([{tester(x) for x in [1]}, {tester(y) for y in [1]}])"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "CALL",
            "{tester(x) for x in [1]}"
        ],
        [
            "CALL",
            "{tester(x) for x in [1]}"
        ],
        [
            "CALL",
            "str([{tester(x) for x in [1]},\n             {tester(x) for x in [1]}])"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "CALL",
            "{tester(x) for x in [1]}"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "CALL",
            "(tester(x) for x in [1])"
        ],
        [
            "CALL",
            "list(tester(x) for x in [1])"
        ],
        [
            "CALL",
            "str([{tester(x) for x in [1]}, list(tester(x) for x in [1])])"
        ],
        [
            "LOAD_FAST",
            "{tester(x) for x in [1]}"
        ],
        [
            "STORE_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "tester(x)"
        ],
        [
            "LOAD_FAST",
            "{tester(y) for y in [1]}"
        ],
        [
            "STORE_FAST",
            "y"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "y"
        ],
        [
            "CALL",
            "tester(y)"
        ],
        [
            "LOAD_FAST",
            "{tester(x) for x in [1]}"
        ],
        [
            "STORE_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "tester(x)"
        ],
        [
            "LOAD_FAST",
            "{tester(x) for x in [1]}"
        ],
        [
            "STORE_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "tester(x)"
        ],
        [
            "LOAD_FAST",
            "{tester(x) for x in [1]}"
        ],
        [
            "STORE_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "tester(x)"
        ],
        [
            "LOAD_FAST",
            "(tester(x) for x in [1])"
        ],
        [
            "STORE_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "tester(x)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertEqual"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(3)"
        ],
        [
            "CALL",
            "(lambda x: (tester(x), tester(x)))(tester(3))"
        ],
        [
            "CALL",
            "self.assertEqual(\n            (lambda x: (tester(x), tester(x)))(tester(3)),\n            (3, 3),\n        )"
        ],
        [
            "CALL",
            "(lambda: (lambda: tester(1))())()"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertEqual"
        ],
        [
            "CALL",
            "(lambda: [tester(x) for x in tester([1, 2])])()"
        ],
        [
            "CALL",
            "self.assertEqual(\n            (lambda: [tester(x) for x in tester([1, 2])])(),\n            [1, 2],\n        )"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "tester(x)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "tester(x)"
        ],
        [
            "CALL",
            "(lambda: tester(1))()"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(1)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([1, 2])"
        ],
        [
            "CALL",
            "[tester(x) for x in tester([1, 2])]"
        ],
        [
            "LOAD_FAST",
            "[tester(x) for x in tester([1, 2])]"
        ],
        [
            "STORE_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "tester(x)"
        ],
        [
            "STORE_DEREF",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([5, 6])"
        ],
        [
            "CALL",
            "{tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "CALL",
            "str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
        ],
        [
            "STORE_FAST",
            "        def foo():\n            y = 2\n            str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            def bar():\n                z = 3\n                str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y+z): {tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            bar()"
        ],
        [
            "LOAD_FAST",
            "foo"
        ],
        [
            "CALL",
            "foo()"
        ],
        [
            "LOAD_FAST",
            "{tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "STORE_FAST",
            "a"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "a"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "a+x"
        ],
        [
            "CALL",
            "tester(a+x)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([3, 4])"
        ],
        [
            "CALL",
            "{tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "LOAD_FAST",
            "{tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "STORE_FAST",
            "b"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "b+x"
        ],
        [
            "CALL",
            "tester(b+x)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([1, 2])"
        ],
        [
            "CALL",
            "{tester(c+x) for c in tester([1, 2])}"
        ],
        [
            "LOAD_FAST",
            "{tester(c+x) for c in tester([1, 2])}"
        ],
        [
            "STORE_FAST",
            "c"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "c+x"
        ],
        [
            "CALL",
            "tester(c+x)"
        ],
        [
            "STORE_DEREF",
            "y"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([5, 6])"
        ],
        [
            "CALL",
            "{tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "CALL",
            "str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([5, 6])"
        ],
        [
            "CALL",
            "{tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "CALL",
            "str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([5, 6])"
        ],
        [
            "CALL",
            "{tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "CALL",
            "str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
        ],
        [
            "STORE_FAST",
            "            def bar():\n                z = 3\n                str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y+z): {tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
        ],
        [
            "LOAD_FAST",
            "bar"
        ],
        [
            "CALL",
            "bar()"
        ],
        [
            "LOAD_FAST",
            "{tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "STORE_FAST",
            "a"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "a"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "a+x"
        ],
        [
            "CALL",
            "tester(a+x)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([3, 4])"
        ],
        [
            "CALL",
            "{tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "LOAD_FAST",
            "{tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "STORE_FAST",
            "b"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "b+x"
        ],
        [
            "CALL",
            "tester(b+x)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([1, 2])"
        ],
        [
            "CALL",
            "{tester(c+x) for c in tester([1, 2])}"
        ],
        [
            "LOAD_FAST",
            "{tester(c+x) for c in tester([1, 2])}"
        ],
        [
            "STORE_FAST",
            "c"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "c+x"
        ],
        [
            "CALL",
            "tester(c+x)"
        ],
        [
            "LOAD_FAST",
            "{tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "STORE_FAST",
            "a"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "a"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "a+y"
        ],
        [
            "CALL",
            "tester(a+y)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([3, 4])"
        ],
        [
            "CALL",
            "{tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "LOAD_FAST",
            "{tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "STORE_FAST",
            "b"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "b+y"
        ],
        [
            "CALL",
            "tester(b+y)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([1, 2])"
        ],
        [
            "CALL",
            "{tester(c+y) for c in tester([1, 2])}"
        ],
        [
            "LOAD_FAST",
            "{tester(c+y) for c in tester([1, 2])}"
        ],
        [
            "STORE_FAST",
            "c"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "c+y"
        ],
        [
            "CALL",
            "tester(c+y)"
        ],
        [
            "LOAD_FAST",
            "{tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "STORE_FAST",
            "a"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "a"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "a+x"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "a+x+y"
        ],
        [
            "CALL",
            "tester(a+x+y)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([3, 4])"
        ],
        [
            "CALL",
            "{tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "LOAD_FAST",
            "{tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "STORE_FAST",
            "b"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "b+x"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "b+x+y"
        ],
        [
            "CALL",
            "tester(b+x+y)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([1, 2])"
        ],
        [
            "CALL",
            "{tester(c+x+y) for c in tester([1, 2])}"
        ],
        [
            "LOAD_FAST",
            "{tester(c+x+y) for c in tester([1, 2])}"
        ],
        [
            "STORE_FAST",
            "c"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "c+x"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "c+x+y"
        ],
        [
            "CALL",
            "tester(c+x+y)"
        ],
        [
            "STORE_DEREF",
            "z"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([5, 6])"
        ],
        [
            "CALL",
            "{tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "CALL",
            "str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([5, 6])"
        ],
        [
            "CALL",
            "{tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "CALL",
            "str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([5, 6])"
        ],
        [
            "CALL",
            "{tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "CALL",
            "str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([5, 6])"
        ],
        [
            "CALL",
            "{tester(a+x+y+z): {tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "CALL",
            "str({tester(a+x+y+z): {tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
        ],
        [
            "LOAD_FAST",
            "{tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "STORE_FAST",
            "a"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "a"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "a+x"
        ],
        [
            "CALL",
            "tester(a+x)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([3, 4])"
        ],
        [
            "CALL",
            "{tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "LOAD_FAST",
            "{tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "STORE_FAST",
            "b"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "b+x"
        ],
        [
            "CALL",
            "tester(b+x)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([1, 2])"
        ],
        [
            "CALL",
            "{tester(c+x) for c in tester([1, 2])}"
        ],
        [
            "LOAD_FAST",
            "{tester(c+x) for c in tester([1, 2])}"
        ],
        [
            "STORE_FAST",
            "c"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "c+x"
        ],
        [
            "CALL",
            "tester(c+x)"
        ],
        [
            "LOAD_FAST",
            "{tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "STORE_FAST",
            "a"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "a"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "a+y"
        ],
        [
            "CALL",
            "tester(a+y)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([3, 4])"
        ],
        [
            "CALL",
            "{tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "LOAD_FAST",
            "{tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "STORE_FAST",
            "b"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "b+y"
        ],
        [
            "CALL",
            "tester(b+y)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([1, 2])"
        ],
        [
            "CALL",
            "{tester(c+y) for c in tester([1, 2])}"
        ],
        [
            "LOAD_FAST",
            "{tester(c+y) for c in tester([1, 2])}"
        ],
        [
            "STORE_FAST",
            "c"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "c+y"
        ],
        [
            "CALL",
            "tester(c+y)"
        ],
        [
            "LOAD_FAST",
            "{tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "STORE_FAST",
            "a"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "a"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "a+x"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "a+x+y"
        ],
        [
            "CALL",
            "tester(a+x+y)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([3, 4])"
        ],
        [
            "CALL",
            "{tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "LOAD_FAST",
            "{tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "STORE_FAST",
            "b"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "b+x"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "b+x+y"
        ],
        [
            "CALL",
            "tester(b+x+y)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([1, 2])"
        ],
        [
            "CALL",
            "{tester(c+x+y) for c in tester([1, 2])}"
        ],
        [
            "LOAD_FAST",
            "{tester(c+x+y) for c in tester([1, 2])}"
        ],
        [
            "STORE_FAST",
            "c"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "c+x"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "c+x+y"
        ],
        [
            "CALL",
            "tester(c+x+y)"
        ],
        [
            "LOAD_FAST",
            "{tester(a+x+y+z): {tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "STORE_FAST",
            "a"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "a"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "a+x"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "a+x+y"
        ],
        [
            "LOAD_DEREF",
            "z"
        ],
        [
            "BINARY_OP",
            "a+x+y+z"
        ],
        [
            "CALL",
            "tester(a+x+y+z)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([3, 4])"
        ],
        [
            "CALL",
            "{tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "LOAD_FAST",
            "{tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "STORE_FAST",
            "b"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "b+x"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "b+x+y"
        ],
        [
            "LOAD_DEREF",
            "z"
        ],
        [
            "BINARY_OP",
            "b+x+y+z"
        ],
        [
            "CALL",
            "tester(b+x+y+z)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([1, 2])"
        ],
        [
            "CALL",
            "{tester(c+x+y+z) for c in tester([1, 2])}"
        ],
        [
            "LOAD_FAST",
            "{tester(c+x+y+z) for c in tester([1, 2])}"
        ],
        [
            "STORE_FAST",
            "c"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "c+x"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "c+x+y"
        ],
        [
            "LOAD_DEREF",
            "z"
        ],
        [
            "BINARY_OP",
            "c+x+y+z"
        ],
        [
            "CALL",
            "tester(c+x+y+z)"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "dict(x=tester)"
        ],
        [
            "BINARY_SUBSCR",
            "dict(x=tester)['x']"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "dict(x=tester)['x'](tester)"
        ],
        [
            "CALL",
            "dict(x=tester)['x'](tester)(3, check_func=False)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertRaises"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "CALL",
            "self.assertRaises(TypeError)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([1, 2, 3])"
        ],
        [
            "STORE_FAST",
            "_"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(0)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(0)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(4)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(5)"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "tester(ValueError)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(9)"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(10)"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "CALL",
            "str()"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertRaises"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_GLOBAL",
            "Exception"
        ],
        [
            "CALL",
            "tester(Exception)"
        ],
        [
            "CALL",
            "self.assertRaises(tester(Exception))"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(0)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(0)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "BINARY_OP",
            "1 / 0"
        ],
        [
            "CALL",
            "tester(1 / 0)"
        ],
        [
            "CALL",
            "        with self.assertRaises(tester(Exception)):\n            if tester(0):\n                pass\n            elif tester(0):\n                pass\n            elif tester(1 / 0):\n                pass"
        ],
        [
            "STORE_FAST",
            "        def gen():\n            for x in [1, 2]:\n                yield tester(x)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([1, 2])"
        ],
        [
            "CALL",
            "(tester(x) for x in tester([1, 2]))"
        ],
        [
            "STORE_FAST",
            "gen2"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_FAST",
            "gen"
        ],
        [
            "CALL",
            "gen()"
        ],
        [
            "CALL",
            "list(gen())"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_FAST",
            "gen2"
        ],
        [
            "CALL",
            "list(gen2)"
        ],
        [
            "COMPARE_OP",
            "list(gen()) == list(gen2) == [1, 2]"
        ],
        [
            "COMPARE_OP",
            "list(gen()) == list(gen2) == [1, 2]"
        ],
        [
            "STORE_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "tester(x)"
        ],
        [
            "LOAD_FAST",
            "(tester(x) for x in tester([1, 2]))"
        ],
        [
            "STORE_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "tester(x)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(4)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "time"
        ],
        [
            "LOAD_ATTR",
            "time.time"
        ],
        [
            "CALL",
            "time.time()"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "LOAD_GLOBAL",
            "range"
        ],
        [
            "CALL",
            "range(10000)"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "LOAD_GLOBAL",
            "Source"
        ],
        [
            "LOAD_ATTR",
            "Source.executing"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.currentframe"
        ],
        [
            "CALL",
            "inspect.currentframe()"
        ],
        [
            "CALL",
            "Source.executing(inspect.currentframe())"
        ],
        [
            "LOAD_ATTR",
            "Source.executing(inspect.currentframe()).node"
        ],
        [
            "STORE_FAST",
            "new_node"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "new_node"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertIs"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "new_node"
        ],
        [
            "CALL",
            "self.assertIs(node, new_node)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertLess"
        ],
        [
            "LOAD_GLOBAL",
            "time"
        ],
        [
            "LOAD_ATTR",
            "time.time"
        ],
        [
            "CALL",
            "time.time()"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "BINARY_OP",
            "time.time() - start"
        ],
        [
            "CALL",
            "self.assertLess(time.time() - start, 1)"
        ],
        [
            "STORE_FAST",
            "        def check(source, encoding, exception=None, matches=True):\n            encoded = source.encode(encoding)\n            if exception:\n                with self.assertRaises(exception):\n                    Source.decode_source(encoded)\n            else:\n                decoded = Source.decode_source(encoded)\n                if matches:\n                    self.assertEqual(decoded, source)\n                else:\n                    self.assertNotEqual(decoded, source)"
        ],
        [
            "LOAD_FAST",
            "check"
        ],
        [
            "CALL",
            "check(u'# coding=utf8\\n\u00e9', 'utf8')"
        ],
        [
            "LOAD_FAST",
            "check"
        ],
        [
            "CALL",
            "check(u'# coding=gbk\\n\u00e9', 'gbk')"
        ],
        [
            "LOAD_FAST",
            "check"
        ],
        [
            "LOAD_GLOBAL",
            "UnicodeDecodeError"
        ],
        [
            "CALL",
            "check(u'# coding=utf8\\n\u00e9', 'gbk', exception=UnicodeDecodeError)"
        ],
        [
            "LOAD_FAST",
            "check"
        ],
        [
            "CALL",
            "check(u'# coding=gbk\\n\u00e9', 'utf8', matches=False)"
        ],
        [
            "LOAD_GLOBAL",
            "PY3"
        ],
        [
            "LOAD_FAST",
            "check"
        ],
        [
            "CALL",
            "check(u'\u00e9', 'utf8')"
        ],
        [
            "LOAD_FAST",
            "check"
        ],
        [
            "LOAD_GLOBAL",
            "SyntaxError"
        ],
        [
            "CALL",
            "check(u'\u00e9', 'gbk', exception=SyntaxError)"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_METHOD",
            "source.encode"
        ],
        [
            "LOAD_FAST",
            "encoding"
        ],
        [
            "CALL",
            "source.encode(encoding)"
        ],
        [
            "STORE_FAST",
            "encoded"
        ],
        [
            "LOAD_FAST",
            "exception"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertRaises"
        ],
        [
            "LOAD_FAST",
            "exception"
        ],
        [
            "CALL",
            "self.assertRaises(exception)"
        ],
        [
            "LOAD_GLOBAL",
            "Source"
        ],
        [
            "LOAD_ATTR",
            "Source.decode_source"
        ],
        [
            "LOAD_FAST",
            "encoded"
        ],
        [
            "CALL",
            "Source.decode_source(encoded)"
        ],
        [
            "CALL",
            "                with self.assertRaises(exception):\n                    Source.decode_source(encoded)"
        ],
        [
            "LOAD_GLOBAL",
            "Source"
        ],
        [
            "LOAD_ATTR",
            "Source.decode_source"
        ],
        [
            "LOAD_FAST",
            "encoded"
        ],
        [
            "CALL",
            "Source.decode_source(encoded)"
        ],
        [
            "STORE_FAST",
            "decoded"
        ],
        [
            "LOAD_FAST",
            "matches"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertEqual"
        ],
        [
            "LOAD_FAST",
            "decoded"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CALL",
            "self.assertEqual(decoded, source)"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertNotEqual"
        ],
        [
            "LOAD_FAST",
            "decoded"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CALL",
            "self.assertNotEqual(decoded, source)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester('a')"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester('''\n            ab''')"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester('''\n                    abc\n                    def\n                    '''\n               )"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(\n                '''\n                123\n                456\n                '''\n            )"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(\n                '''\n                345\n                456786\n                '''\n            )"
        ],
        [
            "CALL",
            "str([\n            tester(\n                '''\n                123\n                456\n                '''\n            ),\n            tester(\n                '''\n                345\n                456786\n                '''\n            ),\n        ])"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(\n            [\n                '''\n                123\n                456\n                '''\n                '''\n                345\n                456786\n                '''\n                ,\n                '''\n                123\n                456\n                ''',\n                '''\n                345\n                456786\n                '''\n            ]\n        )"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(1)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(2)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([1, 2])"
        ],
        [
            "STORE_FAST",
            "_"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(3)"
        ],
        [
            "LOAD_GLOBAL",
            "Source"
        ],
        [
            "LOAD_ATTR",
            "Source.for_filename"
        ],
        [
            "LOAD_GLOBAL",
            "__file__"
        ],
        [
            "CALL",
            "Source.for_filename(__file__)"
        ],
        [
            "LOAD_METHOD",
            "Source.for_filename(__file__).code_qualname"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.__code__"
        ],
        [
            "CALL",
            "Source.for_filename(__file__).code_qualname(func.__code__)"
        ],
        [
            "STORE_FAST",
            "qualname"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertEqual"
        ],
        [
            "LOAD_FAST",
            "qn"
        ],
        [
            "LOAD_FAST",
            "qualname"
        ],
        [
            "CALL",
            "self.assertEqual(qn, qualname)"
        ],
        [
            "LOAD_GLOBAL",
            "PY3"
        ],
        [
            "LOAD_FAST",
            "check_actual_qualname"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertEqual"
        ],
        [
            "LOAD_FAST",
            "qn"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.__qualname__"
        ],
        [
            "CALL",
            "self.assertEqual(qn, func.__qualname__)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertTrue"
        ],
        [
            "LOAD_FAST",
            "qn"
        ],
        [
            "LOAD_METHOD",
            "qn.endswith"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.__name__"
        ],
        [
            "CALL",
            "qn.endswith(func.__name__)"
        ],
        [
            "CALL",
            "self.assertTrue(qn.endswith(func.__name__))"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assert_qualname"
        ],
        [
            "LOAD_GLOBAL",
            "C"
        ],
        [
            "LOAD_ATTR",
            "C.f"
        ],
        [
            "CALL",
            "self.assert_qualname(C.f, 'C.f')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assert_qualname"
        ],
        [
            "LOAD_GLOBAL",
            "C"
        ],
        [
            "LOAD_ATTR",
            "C.D"
        ],
        [
            "LOAD_ATTR",
            "C.D.g"
        ],
        [
            "CALL",
            "self.assert_qualname(C.D.g, 'C.D.g')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assert_qualname"
        ],
        [
            "LOAD_GLOBAL",
            "f"
        ],
        [
            "CALL",
            "self.assert_qualname(f, 'f')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assert_qualname"
        ],
        [
            "LOAD_GLOBAL",
            "f"
        ],
        [
            "CALL",
            "f()"
        ],
        [
            "CALL",
            "self.assert_qualname(f(), 'f.<locals>.g')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assert_qualname"
        ],
        [
            "LOAD_GLOBAL",
            "C"
        ],
        [
            "LOAD_ATTR",
            "C.D"
        ],
        [
            "LOAD_METHOD",
            "C.D.h"
        ],
        [
            "CALL",
            "C.D.h()"
        ],
        [
            "CALL",
            "self.assert_qualname(C.D.h(), 'C.D.h.<locals>.i.<locals>.j')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assert_qualname"
        ],
        [
            "LOAD_GLOBAL",
            "lamb"
        ],
        [
            "CALL",
            "self.assert_qualname(lamb, '<lambda>')"
        ],
        [
            "LOAD_GLOBAL",
            "lambda_maker"
        ],
        [
            "CALL",
            "lambda_maker()"
        ],
        [
            "STORE_FAST",
            "foo"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assert_qualname"
        ],
        [
            "LOAD_FAST",
            "foo"
        ],
        [
            "CALL",
            "self.assert_qualname(foo, 'lambda_maker.<locals>.foo')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assert_qualname"
        ],
        [
            "LOAD_FAST",
            "foo"
        ],
        [
            "LOAD_ATTR",
            "foo.x"
        ],
        [
            "CALL",
            "self.assert_qualname(foo.x, 'lambda_maker.<locals>.<lambda>')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assert_qualname"
        ],
        [
            "LOAD_FAST",
            "foo"
        ],
        [
            "CALL",
            "foo()"
        ],
        [
            "CALL",
            "self.assert_qualname(foo(), 'lambda_maker.<locals>.foo.<locals>.<lambda>')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assert_qualname"
        ],
        [
            "LOAD_FAST",
            "foo"
        ],
        [
            "CALL",
            "foo()"
        ],
        [
            "CALL",
            "foo()()"
        ],
        [
            "CALL",
            "self.assert_qualname(foo()(), 'lambda_maker.<locals>.foo.<locals>.<lambda>', check_actual_qualname=False)"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_GLOBAL",
            "range"
        ],
        [
            "CALL",
            "range(66000)"
        ],
        [
            "CALL",
            "list(range(66000))"
        ],
        [
            "BINARY_OP",
            "'tester(6)\\n%s\\ntester(9)' % list(range(66000))"
        ],
        [
            "STORE_FAST",
            "source"
        ],
        [
            "LOAD_GLOBAL",
            "tempfile"
        ],
        [
            "LOAD_ATTR",
            "tempfile.mkstemp"
        ],
        [
            "CALL",
            "tempfile.mkstemp()"
        ],
        [
            "STORE_FAST",
            "_"
        ],
        [
            "STORE_FAST",
            "filename"
        ],
        [
            "LOAD_GLOBAL",
            "compile"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "CALL",
            "compile(source, filename, 'exec')"
        ],
        [
            "STORE_FAST",
            "code"
        ],
        [
            "LOAD_GLOBAL",
            "open"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "CALL",
            "open(filename, 'w')"
        ],
        [
            "STORE_FAST",
            "outfile"
        ],
        [
            "LOAD_FAST",
            "outfile"
        ],
        [
            "LOAD_METHOD",
            "outfile.write"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CALL",
            "outfile.write(source)"
        ],
        [
            "CALL",
            "        with open(filename, 'w') as outfile:\n            outfile.write(source)"
        ],
        [
            "LOAD_GLOBAL",
            "exec"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "CALL",
            "exec(code)"
        ],
        [
            "LOAD_GLOBAL",
            "range"
        ],
        [
            "CALL",
            "range(5)"
        ],
        [
            "STORE_FAST",
            "n"
        ],
        [
            "LOAD_GLOBAL",
            "range"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "CALL",
            "range(n)"
        ],
        [
            "CALL",
            "(i for i in range(n))"
        ],
        [
            "STORE_FAST",
            "gen"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "COMPARE_OP",
            "n == 1"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertEqual"
        ],
        [
            "LOAD_GLOBAL",
            "only"
        ],
        [
            "LOAD_FAST",
            "gen"
        ],
        [
            "CALL",
            "only(gen)"
        ],
        [
            "CALL",
            "self.assertEqual(only(gen), 0)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertRaises"
        ],
        [
            "LOAD_GLOBAL",
            "NotOneValueFound"
        ],
        [
            "CALL",
            "self.assertRaises(NotOneValueFound)"
        ],
        [
            "LOAD_GLOBAL",
            "only"
        ],
        [
            "LOAD_FAST",
            "gen"
        ],
        [
            "CALL",
            "only(gen)"
        ],
        [
            "CALL",
            "                with self.assertRaises(NotOneValueFound):\n                    only(gen)"
        ],
        [
            "LOAD_FAST",
            "(i for i in range(n))"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "LOAD_GLOBAL",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.join"
        ],
        [
            "LOAD_GLOBAL",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.dirname"
        ],
        [
            "LOAD_GLOBAL",
            "__file__"
        ],
        [
            "CALL",
            "os.path.dirname(__file__)"
        ],
        [
            "CALL",
            "os.path.join(os.path.dirname(__file__), 'not_code.txt', )"
        ],
        [
            "STORE_FAST",
            "path"
        ],
        [
            "LOAD_GLOBAL",
            "Source"
        ],
        [
            "LOAD_ATTR",
            "Source.for_filename"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "CALL",
            "Source.for_filename(path)"
        ],
        [
            "STORE_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertIsNone"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_ATTR",
            "source.tree"
        ],
        [
            "CALL",
            "self.assertIsNone(source.tree)"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.currentframe"
        ],
        [
            "CALL",
            "inspect.currentframe()"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_GLOBAL",
            "Source"
        ],
        [
            "LOAD_ATTR",
            "Source.executing"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "Source.executing(frame)"
        ],
        [
            "STORE_FAST",
            "executing"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertEqual"
        ],
        [
            "LOAD_FAST",
            "executing"
        ],
        [
            "LOAD_METHOD",
            "executing.code_qualname"
        ],
        [
            "CALL",
            "executing.code_qualname()"
        ],
        [
            "CALL",
            "self.assertEqual(executing.code_qualname(), 'TestStuff.test_executing_methods')"
        ],
        [
            "LOAD_GLOBAL",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.version"
        ],
        [
            "LOAD_METHOD",
            "sys.version.lower"
        ],
        [
            "CALL",
            "sys.version.lower()"
        ],
        [
            "CONTAINS_OP",
            "'pypy' not in sys.version.lower()"
        ],
        [
            "STORE_FAST",
            "text"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertEqual"
        ],
        [
            "LOAD_FAST",
            "executing"
        ],
        [
            "LOAD_METHOD",
            "executing.text"
        ],
        [
            "CALL",
            "executing.text()"
        ],
        [
            "LOAD_FAST",
            "text"
        ],
        [
            "CALL",
            "self.assertEqual(executing.text(), text)"
        ],
        [
            "LOAD_FAST",
            "executing"
        ],
        [
            "LOAD_METHOD",
            "executing.text_range"
        ],
        [
            "CALL",
            "executing.text_range()"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "STORE_FAST",
            "end"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertEqual"
        ],
        [
            "LOAD_FAST",
            "executing"
        ],
        [
            "LOAD_ATTR",
            "executing.source"
        ],
        [
            "LOAD_ATTR",
            "executing.source.text"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "end"
        ],
        [
            "BINARY_SUBSCR",
            "executing.source.text[start:end]"
        ],
        [
            "LOAD_FAST",
            "text"
        ],
        [
            "CALL",
            "self.assertEqual(executing.source.text[start:end], text)"
        ],
        [
            "LOAD_GLOBAL",
            "C"
        ],
        [
            "CALL",
            "C()"
        ],
        [
            "STORE_FAST",
            "c"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "STORE_ATTR",
            "c.x"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "STORE_ATTR",
            "c.y"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_ATTR",
            "c.x"
        ],
        [
            "LOAD_ATTR",
            "c.x.x"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_ATTR",
            "c.x"
        ],
        [
            "LOAD_ATTR",
            "c.x.y"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_ATTR",
            "c.y"
        ],
        [
            "LOAD_ATTR",
            "c.y.x"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_ATTR",
            "c.y"
        ],
        [
            "LOAD_ATTR",
            "c.y.y"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_ATTR",
            "c.x"
        ],
        [
            "LOAD_ATTR",
            "c.x.asd"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_ATTR",
            "c.y"
        ],
        [
            "LOAD_ATTR",
            "c.y.qwe"
        ],
        [
            "CALL",
            "str((c.x.x, c.x.y, c.y.x, c.y.y, c.x.asd, c.y.qwe))"
        ],
        [
            "STORE_NAME",
            "    def test_file(self):\n        source = Source.for_frame(inspect.currentframe())\n        code = compile(source.text, source.filename, 'exec')\n        instructions = get_instructions(code)\n        lineno = None\n        for inst in instructions:\n            if inst.starts_line is not None:\n                lineno = inst.starts_line\n            if not inst.opname.startswith(\n                    ('BINARY_', 'UNARY_', 'LOAD_ATTR', 'LOAD_METHOD', 'LOOKUP_METHOD', 'COMPARE_OP')):\n                continue\n            frame = C()\n            frame.f_lasti = inst.offset\n            frame.f_code = code\n            frame.f_globals = globals()\n            frame.f_lineno = lineno\n            print(inst.opname)\n            assert Source.executing(frame).node is not None"
        ],
        [
            "LOAD_GLOBAL",
            "Source"
        ],
        [
            "LOAD_ATTR",
            "Source.for_frame"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.currentframe"
        ],
        [
            "CALL",
            "inspect.currentframe()"
        ],
        [
            "CALL",
            "Source.for_frame(inspect.currentframe())"
        ],
        [
            "STORE_FAST",
            "source"
        ],
        [
            "LOAD_GLOBAL",
            "compile"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_ATTR",
            "source.text"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_ATTR",
            "source.filename"
        ],
        [
            "CALL",
            "compile(source.text, source.filename, 'exec')"
        ],
        [
            "STORE_FAST",
            "code"
        ],
        [
            "LOAD_GLOBAL",
            "get_instructions"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "CALL",
            "get_instructions(code)"
        ],
        [
            "STORE_FAST",
            "instructions"
        ],
        [
            "STORE_FAST",
            "lineno"
        ],
        [
            "LOAD_FAST",
            "instructions"
        ],
        [
            "STORE_FAST",
            "inst"
        ],
        [
            "LOAD_FAST",
            "inst"
        ],
        [
            "LOAD_ATTR",
            "inst.starts_line"
        ],
        [
            "LOAD_FAST",
            "inst"
        ],
        [
            "LOAD_ATTR",
            "inst.starts_line"
        ],
        [
            "STORE_FAST",
            "lineno"
        ],
        [
            "LOAD_FAST",
            "inst"
        ],
        [
            "LOAD_ATTR",
            "inst.opname"
        ],
        [
            "LOAD_METHOD",
            "inst.opname.startswith"
        ],
        [
            "CALL",
            "inst.opname.startswith(\n                    ('BINARY_', 'UNARY_', 'LOAD_ATTR', 'LOAD_METHOD', 'LOOKUP_METHOD', 'COMPARE_OP'))"
        ],
        [
            "LOAD_GLOBAL",
            "C"
        ],
        [
            "CALL",
            "C()"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "inst"
        ],
        [
            "LOAD_ATTR",
            "inst.offset"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "STORE_ATTR",
            "frame.f_lasti"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "STORE_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_GLOBAL",
            "globals"
        ],
        [
            "CALL",
            "globals()"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "STORE_ATTR",
            "frame.f_globals"
        ],
        [
            "LOAD_FAST",
            "lineno"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "STORE_ATTR",
            "frame.f_lineno"
        ],
        [
            "LOAD_GLOBAL",
            "print"
        ],
        [
            "LOAD_FAST",
            "inst"
        ],
        [
            "LOAD_ATTR",
            "inst.opname"
        ],
        [
            "CALL",
            "print(inst.opname)"
        ],
        [
            "LOAD_GLOBAL",
            "Source"
        ],
        [
            "LOAD_ATTR",
            "Source.executing"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "Source.executing(frame)"
        ],
        [
            "LOAD_ATTR",
            "Source.executing(frame).node"
        ],
        [
            "LOAD_NAME",
            "staticmethod"
        ],
        [
            "CALL",
            "staticmethod"
        ],
        [
            "STORE_NAME",
            "    @staticmethod\n    def f():\n        pass"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "    class D(object):\n        @staticmethod\n        def g():\n            pass\n\n        @staticmethod\n        def h():\n            def i():\n                def j():\n                    pass\n\n                return j\n\n            return i()"
        ],
        [
            "STORE_NAME",
            "    class D(object):\n        @staticmethod\n        def g():\n            pass\n\n        @staticmethod\n        def h():\n            def i():\n                def j():\n                    pass\n\n                return j\n\n            return i()"
        ],
        [
            "LOAD_NAME",
            "staticmethod"
        ],
        [
            "CALL",
            "staticmethod"
        ],
        [
            "STORE_NAME",
            "        @staticmethod\n        def g():\n            pass"
        ],
        [
            "LOAD_NAME",
            "staticmethod"
        ],
        [
            "CALL",
            "staticmethod"
        ],
        [
            "STORE_NAME",
            "        @staticmethod\n        def h():\n            def i():\n                def j():\n                    pass\n\n                return j\n\n            return i()"
        ],
        [
            "STORE_FAST",
            "            def i():\n                def j():\n                    pass\n\n                return j"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "CALL",
            "i()"
        ],
        [
            "STORE_FAST",
            "                def j():\n                    pass"
        ],
        [
            "LOAD_FAST",
            "j"
        ],
        [
            "STORE_FAST",
            "    def g():\n        pass"
        ],
        [
            "LOAD_FAST",
            "g"
        ],
        [
            "STORE_FAST",
            "    def assign(x):\n        def decorator(func):\n            func.x = x\n            return func\n\n        return decorator"
        ],
        [
            "LOAD_FAST",
            "assign"
        ],
        [
            "CALL",
            "assign(lambda: 1)"
        ],
        [
            "CALL",
            "assign(lambda: 1)"
        ],
        [
            "STORE_FAST",
            "    @assign(lambda: 1)\n    def foo():\n        return lambda: lambda: 3"
        ],
        [
            "LOAD_FAST",
            "foo"
        ],
        [
            "STORE_FAST",
            "        def decorator(func):\n            func.x = x\n            return func"
        ],
        [
            "LOAD_FAST",
            "decorator"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "STORE_ATTR",
            "func.x"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "STORE_NAME",
            "    def get_node(self, typ):\n        frame = inspect.currentframe().f_back.f_back\n        Source.lazycache(frame)\n        node = Source.executing(frame).node\n        assert isinstance(node, typ), (node, typ)\n        return node"
        ],
        [
            "STORE_NAME",
            "    def check(self, node, value):\n        frame = inspect.currentframe().f_back.f_back\n        result = eval(\n            compile(ast.Expression(node), frame.f_code.co_filename, 'eval'),\n            frame.f_globals,\n            frame.f_locals,\n        )\n        assert result == value, (result, value)"
        ],
        [
            "STORE_NAME",
            "    def __call__(self, arg, check_func=True, returns=None):\n        call = self.get_node(ast.Call)\n        self.check(call.args[0], arg)\n        if check_func:\n            self.check(call.func, self)\n        if returns is None:\n            return arg\n        return returns"
        ],
        [
            "STORE_NAME",
            "    def __getattr__(self, item):\n        node = self.get_node(ast.Attribute)\n        self.check(node.value, self)\n        assert node.attr == item\n        return self"
        ],
        [
            "STORE_NAME",
            "    def __getitem__(self, item):\n        node = self.get_node(ast.Subscript)\n        self.check(node.value, self)\n        self.check(node.slice.value, item)\n        return self"
        ],
        [
            "STORE_NAME",
            "    def __add__(self, other):\n        node = self.get_node(ast.BinOp)\n        self.check(node.left, self)\n        self.check(node.right, other)\n        return self"
        ],
        [
            "LOAD_NAME",
            "__add__"
        ],
        [
            "STORE_NAME",
            "__pow__"
        ],
        [
            "STORE_NAME",
            "__mul__"
        ],
        [
            "STORE_NAME",
            "__sub__"
        ],
        [
            "STORE_NAME",
            "    def __invert__(self):\n        node = self.get_node(ast.UnaryOp)\n        self.check(node.operand, self)\n        return self"
        ],
        [
            "LOAD_NAME",
            "__invert__"
        ],
        [
            "STORE_NAME",
            "__neg__"
        ],
        [
            "STORE_NAME",
            "__pos__"
        ],
        [
            "STORE_NAME",
            "    def __lt__(self, other):\n        node = self.get_node(ast.Compare)\n        self.check(node.left, self)\n        self.check(node.comparators[0], other)\n        return self"
        ],
        [
            "LOAD_NAME",
            "__lt__"
        ],
        [
            "STORE_NAME",
            "__ne__"
        ],
        [
            "STORE_NAME",
            "__ge__"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.currentframe"
        ],
        [
            "CALL",
            "inspect.currentframe()"
        ],
        [
            "LOAD_ATTR",
            "inspect.currentframe().f_back"
        ],
        [
            "LOAD_ATTR",
            "inspect.currentframe().f_back.f_back"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_GLOBAL",
            "Source"
        ],
        [
            "LOAD_ATTR",
            "Source.lazycache"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "Source.lazycache(frame)"
        ],
        [
            "LOAD_GLOBAL",
            "Source"
        ],
        [
            "LOAD_ATTR",
            "Source.executing"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "Source.executing(frame)"
        ],
        [
            "LOAD_ATTR",
            "Source.executing(frame).node"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "typ"
        ],
        [
            "CALL",
            "isinstance(node, typ)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "typ"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.currentframe"
        ],
        [
            "CALL",
            "inspect.currentframe()"
        ],
        [
            "LOAD_ATTR",
            "inspect.currentframe().f_back"
        ],
        [
            "LOAD_ATTR",
            "inspect.currentframe().f_back.f_back"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_GLOBAL",
            "eval"
        ],
        [
            "LOAD_GLOBAL",
            "compile"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Expression"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "ast.Expression(node)"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_filename"
        ],
        [
            "CALL",
            "compile(ast.Expression(node), frame.f_code.co_filename, 'eval')"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_globals"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_locals"
        ],
        [
            "CALL",
            "eval(\n            compile(ast.Expression(node), frame.f_code.co_filename, 'eval'),\n            frame.f_globals,\n            frame.f_locals,\n        )"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "COMPARE_OP",
            "result == value"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.get_node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Call"
        ],
        [
            "CALL",
            "self.get_node(ast.Call)"
        ],
        [
            "STORE_FAST",
            "call"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_FAST",
            "call"
        ],
        [
            "LOAD_ATTR",
            "call.args"
        ],
        [
            "BINARY_SUBSCR",
            "call.args[0]"
        ],
        [
            "LOAD_FAST",
            "arg"
        ],
        [
            "CALL",
            "self.check(call.args[0], arg)"
        ],
        [
            "LOAD_FAST",
            "check_func"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_FAST",
            "call"
        ],
        [
            "LOAD_ATTR",
            "call.func"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "self.check(call.func, self)"
        ],
        [
            "LOAD_FAST",
            "returns"
        ],
        [
            "LOAD_FAST",
            "arg"
        ],
        [
            "LOAD_FAST",
            "returns"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.get_node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Attribute"
        ],
        [
            "CALL",
            "self.get_node(ast.Attribute)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.value"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "self.check(node.value, self)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.attr"
        ],
        [
            "LOAD_FAST",
            "item"
        ],
        [
            "COMPARE_OP",
            "node.attr == item"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.get_node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Subscript"
        ],
        [
            "CALL",
            "self.get_node(ast.Subscript)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.value"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "self.check(node.value, self)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.slice"
        ],
        [
            "LOAD_ATTR",
            "node.slice.value"
        ],
        [
            "LOAD_FAST",
            "item"
        ],
        [
            "CALL",
            "self.check(node.slice.value, item)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.get_node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.BinOp"
        ],
        [
            "CALL",
            "self.get_node(ast.BinOp)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.left"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "self.check(node.left, self)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.right"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "CALL",
            "self.check(node.right, other)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.get_node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.UnaryOp"
        ],
        [
            "CALL",
            "self.get_node(ast.UnaryOp)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.operand"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "self.check(node.operand, self)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.get_node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Compare"
        ],
        [
            "CALL",
            "self.get_node(ast.Compare)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.left"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "self.check(node.left, self)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.comparators"
        ],
        [
            "BINARY_SUBSCR",
            "node.comparators[0]"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "CALL",
            "self.check(node.comparators[0], other)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "LOAD_GLOBAL",
            "empty_decorator"
        ]
    ],
    "tracer.py": [
        [
            "STORE_NAME",
            "\"\"\"\nThis module provides the generic functionality of tracing code by\nmodifying its AST. Eventually this will become a separate package.\nThis is similar to the standard library module bdb, while birdseye\nitself would correspond to pdb.\nMost of the work is in TreeTracerBase.\n\"\"\""
        ],
        [
            "STORE_NAME",
            "from __future__ import print_function, division, absolute_import"
        ],
        [
            "STORE_NAME",
            "from __future__ import print_function, division, absolute_import"
        ],
        [
            "STORE_NAME",
            "from __future__ import print_function, division, absolute_import"
        ],
        [
            "STORE_NAME",
            "from future import standard_library"
        ],
        [
            "LOAD_NAME",
            "standard_library"
        ],
        [
            "LOAD_ATTR",
            "standard_library.install_aliases"
        ],
        [
            "CALL",
            "standard_library.install_aliases()"
        ],
        [
            "STORE_NAME",
            "import ast"
        ],
        [
            "STORE_NAME",
            "import inspect"
        ],
        [
            "STORE_NAME",
            "import sys"
        ],
        [
            "STORE_NAME",
            "from collections import namedtuple, defaultdict"
        ],
        [
            "STORE_NAME",
            "from collections import namedtuple, defaultdict"
        ],
        [
            "STORE_NAME",
            "from copy import deepcopy"
        ],
        [
            "STORE_NAME",
            "from functools import partial, update_wrapper, wraps"
        ],
        [
            "STORE_NAME",
            "from functools import partial, update_wrapper, wraps"
        ],
        [
            "STORE_NAME",
            "from functools import partial, update_wrapper, wraps"
        ],
        [
            "STORE_NAME",
            "from itertools import takewhile"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
        ],
        [
            "STORE_NAME",
            "from types import FrameType, TracebackType, CodeType, FunctionType"
        ],
        [
            "STORE_NAME",
            "from types import FrameType, TracebackType, CodeType, FunctionType"
        ],
        [
            "STORE_NAME",
            "from types import FrameType, TracebackType, CodeType, FunctionType"
        ],
        [
            "STORE_NAME",
            "from types import FrameType, TracebackType, CodeType, FunctionType"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import PY3, Type, is_lambda, lru_cache, read_source_file, is_ipython_cell, \\\n    is_future_import"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import PY3, Type, is_lambda, lru_cache, read_source_file, is_ipython_cell, \\\n    is_future_import"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import PY3, Type, is_lambda, lru_cache, read_source_file, is_ipython_cell, \\\n    is_future_import"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import PY3, Type, is_lambda, lru_cache, read_source_file, is_ipython_cell, \\\n    is_future_import"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import PY3, Type, is_lambda, lru_cache, read_source_file, is_ipython_cell, \\\n    is_future_import"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import PY3, Type, is_lambda, lru_cache, read_source_file, is_ipython_cell, \\\n    is_future_import"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import PY3, Type, is_lambda, lru_cache, read_source_file, is_ipython_cell, \\\n    is_future_import"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class TracedFile(object):\n    \"\"\"\n    An instance of this class corresponds to a single .py file.\n    It contains some useful data in the following attributes:\n\n    - filename: name of the source file\n    - source: textual contents of the file\n    - root: root of the original Abstract Syntax Tree (AST) of the source,\n            where the nodes of this tree have an additional handy attribute:\n            - parent: parent of the node, so this node is a child node of its parent\n    - tracer: instance of TreeTracerBase\n    - code: executable code object compiled from the modified AST\n    \"\"\"\n\n    is_ipython_cell = False\n\n    def __init__(self, tracer, source, filename, flags):\n        # type: (TreeTracerBase, str, str, int) -> None\n        # Here the source code is parsed, modified, and compiled\n        self.root = compile(source, filename, 'exec', ast.PyCF_ONLY_AST | flags, dont_inherit=True)  # type: ast.Module\n\n        self.nodes = []  # type: List[ast.AST]\n\n        self.set_basic_node_attributes()\n\n        new_root = tracer.parse_extra(self.root, source, filename)\n        if new_root is not None:\n            self.root = new_root\n\n        self.set_basic_node_attributes()\n        self.set_enter_call_nodes()\n\n        new_root = deepcopy(self.root)\n        new_root = _NodeVisitor().visit(new_root)\n\n        self.code = compile(new_root, filename, \"exec\", dont_inherit=True, flags=flags)  # type: CodeType\n        self.tracer = tracer\n        self.source = source\n        self.filename = filename\n\n    def set_basic_node_attributes(self):\n        self.nodes = []  # type: List[ast.AST]\n        for node in ast.walk(self.root):  # type: ast.AST\n            for child in ast.iter_child_nodes(node):\n                child.parent = node\n            node._tree_index = len(self.nodes)\n            self.nodes.append(node)\n\n        # Mark __future__ imports and anything before (i.e. module docstrings)\n        # to be ignored by the AST transformer\n        for i, stmt in enumerate(self.root.body):\n            if is_future_import(stmt):\n                for s in self.root.body[:i + 1]:\n                    for node in ast.walk(s):\n                        node._visit_ignore = True\n\n    def set_enter_call_nodes(self):\n        for node in self.nodes:\n            if isinstance(node, (ast.Module, ast.FunctionDef)):\n                for stmt in node.body:\n                    if not is_future_import(stmt):\n                        stmt._enter_call_node = True\n                        break"
        ],
        [
            "STORE_NAME",
            "class TracedFile(object):\n    \"\"\"\n    An instance of this class corresponds to a single .py file.\n    It contains some useful data in the following attributes:\n\n    - filename: name of the source file\n    - source: textual contents of the file\n    - root: root of the original Abstract Syntax Tree (AST) of the source,\n            where the nodes of this tree have an additional handy attribute:\n            - parent: parent of the node, so this node is a child node of its parent\n    - tracer: instance of TreeTracerBase\n    - code: executable code object compiled from the modified AST\n    \"\"\"\n\n    is_ipython_cell = False\n\n    def __init__(self, tracer, source, filename, flags):\n        # type: (TreeTracerBase, str, str, int) -> None\n        # Here the source code is parsed, modified, and compiled\n        self.root = compile(source, filename, 'exec', ast.PyCF_ONLY_AST | flags, dont_inherit=True)  # type: ast.Module\n\n        self.nodes = []  # type: List[ast.AST]\n\n        self.set_basic_node_attributes()\n\n        new_root = tracer.parse_extra(self.root, source, filename)\n        if new_root is not None:\n            self.root = new_root\n\n        self.set_basic_node_attributes()\n        self.set_enter_call_nodes()\n\n        new_root = deepcopy(self.root)\n        new_root = _NodeVisitor().visit(new_root)\n\n        self.code = compile(new_root, filename, \"exec\", dont_inherit=True, flags=flags)  # type: CodeType\n        self.tracer = tracer\n        self.source = source\n        self.filename = filename\n\n    def set_basic_node_attributes(self):\n        self.nodes = []  # type: List[ast.AST]\n        for node in ast.walk(self.root):  # type: ast.AST\n            for child in ast.iter_child_nodes(node):\n                child.parent = node\n            node._tree_index = len(self.nodes)\n            self.nodes.append(node)\n\n        # Mark __future__ imports and anything before (i.e. module docstrings)\n        # to be ignored by the AST transformer\n        for i, stmt in enumerate(self.root.body):\n            if is_future_import(stmt):\n                for s in self.root.body[:i + 1]:\n                    for node in ast.walk(s):\n                        node._visit_ignore = True\n\n    def set_enter_call_nodes(self):\n        for node in self.nodes:\n            if isinstance(node, (ast.Module, ast.FunctionDef)):\n                for stmt in node.body:\n                    if not is_future_import(stmt):\n                        stmt._enter_call_node = True\n                        break"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class FrameInfo(object):\n    \"\"\"\n    Contains extra data about an execution frame.\n    Can be obtained from the stack attribute of a TreeTracerBase instance\n    \"\"\"\n    def __init__(self):\n        # Stack of statements currently being executed\n        self.statement_stack = []  # type: List[ast.stmt]\n\n        # Stack of expression nodes within the above statement that\n        # the interpreter is planning on evaluating, or has just evaluated\n        # in the case of the last element of the list. For example, given\n        # the expression f(g(x)), the stack would be [f, g, x] before and just\n        # after evaluating x, since function arguments are evaluated before the\n        # actual function call.\n        self.expression_stack = []  # type: List[ast.expr]\n\n        # Mapping from the expression node to its most recent value\n        # in the corresponding frame\n        self.expression_values = {}  # type: Dict[ast.expr, Any]\n\n        # Node where the frame has explicitly returned\n        # There may be parent nodes such as enclosing loops that still need to finish executing\n        self.return_node = None  # type: Optional[ast.Return]\n\n        # Most recent exception raised in the frame\n        self.exc_value = None"
        ],
        [
            "STORE_NAME",
            "class FrameInfo(object):\n    \"\"\"\n    Contains extra data about an execution frame.\n    Can be obtained from the stack attribute of a TreeTracerBase instance\n    \"\"\"\n    def __init__(self):\n        # Stack of statements currently being executed\n        self.statement_stack = []  # type: List[ast.stmt]\n\n        # Stack of expression nodes within the above statement that\n        # the interpreter is planning on evaluating, or has just evaluated\n        # in the case of the last element of the list. For example, given\n        # the expression f(g(x)), the stack would be [f, g, x] before and just\n        # after evaluating x, since function arguments are evaluated before the\n        # actual function call.\n        self.expression_stack = []  # type: List[ast.expr]\n\n        # Mapping from the expression node to its most recent value\n        # in the corresponding frame\n        self.expression_values = {}  # type: Dict[ast.expr, Any]\n\n        # Node where the frame has explicitly returned\n        # There may be parent nodes such as enclosing loops that still need to finish executing\n        self.return_node = None  # type: Optional[ast.Return]\n\n        # Most recent exception raised in the frame\n        self.exc_value = None"
        ],
        [
            "LOAD_NAME",
            "NamedTuple"
        ],
        [
            "LOAD_NAME",
            "Optional"
        ],
        [
            "LOAD_NAME",
            "Union"
        ],
        [
            "LOAD_NAME",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.expr"
        ],
        [
            "LOAD_NAME",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.stmt"
        ],
        [
            "BINARY_SUBSCR",
            "Union[ast.expr, ast.stmt]"
        ],
        [
            "BINARY_SUBSCR",
            "Optional[Union[ast.expr, ast.stmt]]"
        ],
        [
            "LOAD_NAME",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.AST"
        ],
        [
            "LOAD_NAME",
            "FrameType"
        ],
        [
            "LOAD_NAME",
            "FrameType"
        ],
        [
            "CALL",
            "NamedTuple('EnterCallInfo', [\n\n    # Node  from where the call was made\n    ('call_node', Optional[Union[ast.expr, ast.stmt]]),\n\n    # Node where the call begins\n    ('enter_node', ast.AST),\n\n    # Frame from which the call was made\n    ('caller_frame', FrameType),\n\n    # Frame of the call\n    ('current_frame', FrameType)])"
        ],
        [
            "STORE_NAME",
            "EnterCallInfo"
        ],
        [
            "LOAD_NAME",
            "NamedTuple"
        ],
        [
            "LOAD_NAME",
            "Optional"
        ],
        [
            "LOAD_NAME",
            "Union"
        ],
        [
            "LOAD_NAME",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.expr"
        ],
        [
            "LOAD_NAME",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.stmt"
        ],
        [
            "BINARY_SUBSCR",
            "Union[ast.expr, ast.stmt]"
        ],
        [
            "BINARY_SUBSCR",
            "Optional[Union[ast.expr, ast.stmt]]"
        ],
        [
            "LOAD_NAME",
            "Optional"
        ],
        [
            "LOAD_NAME",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Return"
        ],
        [
            "BINARY_SUBSCR",
            "Optional[ast.Return]"
        ],
        [
            "LOAD_NAME",
            "FrameType"
        ],
        [
            "LOAD_NAME",
            "FrameType"
        ],
        [
            "LOAD_NAME",
            "Any"
        ],
        [
            "LOAD_NAME",
            "Optional"
        ],
        [
            "LOAD_NAME",
            "Exception"
        ],
        [
            "BINARY_SUBSCR",
            "Optional[Exception]"
        ],
        [
            "LOAD_NAME",
            "Optional"
        ],
        [
            "LOAD_NAME",
            "TracebackType"
        ],
        [
            "BINARY_SUBSCR",
            "Optional[TracebackType]"
        ],
        [
            "CALL",
            "NamedTuple('ExitCallInfo', [\n\n    # Node  from where the call was made\n    ('call_node', Optional[Union[ast.expr, ast.stmt]]),\n\n    # Node where the call explicitly returned\n    ('return_node', Optional[ast.Return]),\n\n    # Frame from which the call was made\n    ('caller_frame', FrameType),\n\n    # Frame of the call\n    ('current_frame', FrameType),\n\n    # Node where the call explicitly returned\n    ('return_value', Any),\n\n    # Exception raised in the call causing it to end,\n    # will propagate to the caller\n    ('exc_value', Optional[Exception]),\n\n    # Traceback corresponding to exc_value\n    ('exc_tb', Optional[TracebackType])])"
        ],
        [
            "STORE_NAME",
            "ExitCallInfo"
        ],
        [
            "LOAD_NAME",
            "namedtuple"
        ],
        [
            "CALL",
            "namedtuple('ChangeValue', 'value')"
        ],
        [
            "STORE_NAME",
            "ChangeValue"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class TreeTracerBase(object):\n    \"\"\"\n    Create a subclass of this class with one or more of the 'hooks'\n    (methods which are empty in this class) overridden to take a custom action\n    in the given situation. Then decorate functions with an instance of this class\n    to trace them.\n    \"\"\"\n\n    def __init__(self):\n        # Mapping from frames of execution being traced to FrameInfo objects\n        # for extra metadata.\n        self.stack = {}  # type: Dict[FrameType, FrameInfo]\n        self.main_to_secondary_frames = defaultdict(list)\n        self.secondary_to_main_frames = {}\n\n    @lru_cache()\n    def compile(self, source, filename, flags=0):\n        # type: (str, str, int) -> TracedFile\n        return TracedFile(self, source, filename, flags)\n\n    def _trace_methods_dict(self, traced_file):\n        # type: (TracedFile) -> Dict[str, Callable]\n        return {f.__name__: partial(f, traced_file)\n                for f in [\n                    self._treetrace_hidden_with_stmt,\n                    self._treetrace_hidden_before_expr,\n                    self._treetrace_hidden_after_expr,\n                ]}\n\n    def trace_function(self, func):\n        # type: (FunctionType) -> FunctionType\n        \"\"\"\n        Returns a version of the passed function with the AST modified to\n        trigger the tracing hooks.\n        \"\"\"\n        if not isinstance(func, FunctionType):\n            raise ValueError('You can only trace user-defined functions. '\n                             'The birdseye decorator must be applied first, '\n                             'at the bottom of the list.')\n\n        try:\n            if inspect.iscoroutinefunction(func) or inspect.isasyncgenfunction(func):\n                raise ValueError('You cannot trace async functions')\n        except AttributeError:\n            pass\n\n        if is_lambda(func):\n            raise ValueError('You cannot trace lambdas')\n\n        filename = inspect.getsourcefile(func)  # type: str\n\n        if is_ipython_cell(filename):\n            # noinspection PyPackageRequirements\n            from IPython import get_ipython\n            import linecache\n\n            flags = get_ipython().compile.flags\n            source = ''.join(linecache.cache[filename][2])\n        else:\n            source = read_source_file(filename)\n            flags = 0\n\n        # We compile the entire file instead of just the function source\n        # because it can contain context which affects the function code,\n        # e.g. enclosing functions and classes or __future__ imports\n        traced_file = self.compile(source, filename, flags)\n\n        if func.__dict__:\n            raise ValueError('The birdseye decorator must be applied first, '\n                             'at the bottom of the list.')\n\n        # Then we have to recursively search through the newly compiled\n        # code to find the code we actually want corresponding to this function\n        code_options = []  # type: List[CodeType]\n\n        def find_code(root_code):\n            # type: (CodeType) -> None\n            for const in root_code.co_consts:  # type: CodeType\n                if not inspect.iscode(const):\n                    continue\n                matches = (const.co_firstlineno == func.__code__.co_firstlineno and\n                           const.co_name == func.__code__.co_name)\n                if matches:\n                    code_options.append(const)\n                find_code(const)\n\n        find_code(traced_file.code)\n\n        if len(code_options) > 1:\n            # Currently lambdas aren't allowed anyway, but should be in the future\n            assert is_lambda(func)\n            raise ValueError(\"Failed to trace lambda. Convert the function to a def.\")\n        new_func_code = code_options[0]  # type: CodeType\n\n        # Give the new function access to the hooks\n        # We have to use the original __globals__ and not a copy\n        # because it's the actual module namespace that may get updated by other code\n        func.__globals__.update(self._trace_methods_dict(traced_file))\n\n        # http://stackoverflow.com/a/13503277/2482744\n        # noinspection PyArgumentList\n        new_func = FunctionType(new_func_code, func.__globals__, func.__name__, func.__defaults__, func.__closure__)\n        update_wrapper(new_func, func)  # type: FunctionType\n        if PY3:\n            new_func.__kwdefaults__ = getattr(func, '__kwdefaults__', None)\n        new_func.traced_file = traced_file\n        return new_func\n\n    def __call__(self, func=None, optional=False):\n        # type: (FunctionType, bool) -> Callable\n        \"\"\"\n        Decorator which returns a (possibly optionally) traced function.\n        This decorator can be called with or without arguments.\n        Typically it is called without arguments, in which case it returns\n        a traced function.\n        If optional=True, it returns a function similar to the original\n        but with an additional optional parameter trace_call, default False.\n        If trace_call is false, the underlying untraced function is used.\n        If true, the traced version is used.\n        \"\"\"\n        if inspect.isclass(func):\n            raise TypeError('Decorating classes is no longer supported')\n\n        if func:\n            # The decorator has been called without arguments/parentheses,\n            # e.g.\n            # @eye\n            # def ...\n            return self.trace_function(func)\n\n        # The decorator has been called with arguments/parentheses,\n        # e.g.\n        # @eye(...)\n        # def ...\n        # We must return a decorator\n\n        if not optional:\n            return self.trace_function\n\n        def decorator(actual_func):\n\n            traced = self.trace_function(actual_func)\n\n            @wraps(actual_func)\n            def wrapper(*args, **kwargs):\n                trace_call = kwargs.pop('trace_call', False)\n                if trace_call:\n                    f = traced\n                else:\n                    f = actual_func\n                return f(*args, **kwargs)\n\n            return wrapper\n\n        return decorator\n\n    def _main_frame(self, node):\n        # type: (ast.AST) -> Optional[FrameType]\n        frame = sys._getframe(2)\n        result = self.secondary_to_main_frames.get(frame)\n        if result:\n            return result\n\n        original_frame = frame\n\n        while frame.f_code.co_name in ('<listcomp>', '<dictcomp>', '<setcomp>'):\n            frame = frame.f_back\n\n        for node in ancestors(node):\n            if isinstance(node, (ast.FunctionDef, ast.Lambda)):\n                break\n\n            if isinstance(node, ast.ClassDef):\n                frame = frame.f_back\n\n        if frame.f_code.co_name in ('<lambda>', '<genexpr>'):\n            return None\n\n        self.secondary_to_main_frames[original_frame] = frame\n        self.main_to_secondary_frames[frame].append(original_frame)\n        return frame\n\n    def _treetrace_hidden_with_stmt(self, traced_file, _tree_index):\n        # type: (TracedFile, int) -> _StmtContext\n        \"\"\"\n        Called directly from the modified code.\n        Every statement in the original code becomes:\n\n        with _treetrace_hidden_with_stmt(...):\n            <statement>\n        \"\"\"\n        node = traced_file.nodes[_tree_index]\n        node = cast(ast.stmt, node)\n        frame = self._main_frame(node)\n        return _StmtContext(self, node, frame)\n\n    def _treetrace_hidden_before_expr(self, traced_file, _tree_index):\n        # type: (TracedFile, int) -> ast.expr\n        \"\"\"\n        Called directly from the modified code before an expression is\n        evaluated.\n        \"\"\"\n        node = traced_file.nodes[_tree_index]\n        node = cast(ast.expr, node)\n        frame = self._main_frame(node)\n        if frame is None:\n            return node\n\n        frame_info = self.stack[frame]\n        frame_info.expression_stack.append(node)\n\n        self.before_expr(node, frame)\n        return node\n\n    def _treetrace_hidden_after_expr(self, _, node, value):\n        # type: (TracedFile, ast.expr, Any) -> Any\n        \"\"\"\n        Called directly from the modified code after an expression is\n        evaluated.\n        \"\"\"\n        frame = self._main_frame(node)\n        if frame is None:\n            return value\n\n        result = self._after_expr(node, frame, value, None, None)\n        if result is not None:\n            assert isinstance(result, ChangeValue), \"after_expr must return None or an instance of ChangeValue\"\n            value = result.value\n        return value\n\n    def _after_expr(self, node, frame, value, exc_value, exc_tb):\n        frame_info = self.stack[frame]\n        frame_info.expression_stack.pop()\n        frame_info.expression_values[node] = value\n        return self.after_expr(node, frame, value, exc_value, exc_tb)\n\n    def _enter_call(self, enter_node, current_frame):\n        # type: (ast.AST, FrameType) -> None\n        caller_frame, call_node = self._get_caller_stuff(current_frame)\n        self.stack[current_frame] = FrameInfo()\n        self.enter_call(EnterCallInfo(call_node, enter_node, caller_frame, current_frame))\n\n    def _get_caller_stuff(self, frame):\n        # type: (FrameType) -> Tuple[FrameType, Optional[Union[ast.expr, ast.stmt]]]\n        caller_frame = frame.f_back\n        call_node = None\n        main_frame = self.secondary_to_main_frames.get(caller_frame)\n        if main_frame:\n            caller_frame = main_frame\n            frame_info = self.stack[caller_frame]\n            expression_stack = frame_info.expression_stack\n            if expression_stack:\n                call_node = expression_stack[-1]\n            else:\n                call_node = frame_info.statement_stack[-1]  # type: ignore\n        return caller_frame, call_node\n\n    # The methods below are hooks meant to be overridden in subclasses to take custom actions\n\n    def before_expr(self, node, frame):\n        # type: (ast.expr, FrameType) -> None\n        \"\"\"\n        Called right before the expression corresponding to `node` is evaluated\n        within `frame`.\n        \"\"\"\n\n    def after_expr(self, node, frame, value, exc_value, exc_tb):\n        # type: (ast.expr, FrameType, Any, Optional[BaseException], Optional[TracebackType]) -> Optional[ChangeValue]\n        \"\"\"\n        Called right after the expression corresponding to `node` is evaluated\n        within `frame`. `value` is the value of the expression, if it succeeded.\n        If the evaluation raised an exception, exc_value will be the exception object\n        and exc_tb the traceback.\n\n        Return `ChangeValue(x)` to change the value of the expression as\n        seen by the rest of the program from `value` to `x`.\n        \"\"\"\n\n    def before_stmt(self, node, frame):\n        # type: (ast.stmt, FrameType) -> None\n        \"\"\"\n        Called right before the statement corresponding to `node` is executed\n        within `frame`.\n        \"\"\"\n\n    def after_stmt(self, node, frame, exc_value, exc_traceback, exc_node):\n        # type: (ast.stmt, FrameType, Optional[BaseException], Optional[TracebackType], Optional[ast.AST]) -> Optional[bool]\n        \"\"\"\n        Called right after the statement corresponding to `node` is executed\n        within `frame`.\n        If the statement raised an exception, exc_value will be the exception object,\n        exc_tb the traceback, and exc_node the node where the exception was raised\n        (either this statement or an expression within).\n\n        Returning True will suppress any exception raised (as with __exit__ in general).\n        \"\"\"\n\n    def enter_call(self, enter_info):\n        # type: (EnterCallInfo) -> None\n        \"\"\"\n        Called before a function call begins executing. For typical `def` functions,\n        this is called before the `before_stmt` for to the first statement in the function.\n        \"\"\"\n\n    def exit_call(self, exit_info):\n        # type: (ExitCallInfo) -> None\n        \"\"\"\n        Called after a function call finishes executing. For typical `def` functions,\n        this is called after the `after_stmt` for to the last statement to execute.\n        \"\"\"\n\n    def parse_extra(self, root, source, filename):\n        # type: (ast.Module, str, str) -> Optional[ast.Module]\n        \"\"\"\n        Called before the AST (root) is modified to let subclasses make additional changes first.\n        \"\"\""
        ],
        [
            "STORE_NAME",
            "class TreeTracerBase(object):\n    \"\"\"\n    Create a subclass of this class with one or more of the 'hooks'\n    (methods which are empty in this class) overridden to take a custom action\n    in the given situation. Then decorate functions with an instance of this class\n    to trace them.\n    \"\"\"\n\n    def __init__(self):\n        # Mapping from frames of execution being traced to FrameInfo objects\n        # for extra metadata.\n        self.stack = {}  # type: Dict[FrameType, FrameInfo]\n        self.main_to_secondary_frames = defaultdict(list)\n        self.secondary_to_main_frames = {}\n\n    @lru_cache()\n    def compile(self, source, filename, flags=0):\n        # type: (str, str, int) -> TracedFile\n        return TracedFile(self, source, filename, flags)\n\n    def _trace_methods_dict(self, traced_file):\n        # type: (TracedFile) -> Dict[str, Callable]\n        return {f.__name__: partial(f, traced_file)\n                for f in [\n                    self._treetrace_hidden_with_stmt,\n                    self._treetrace_hidden_before_expr,\n                    self._treetrace_hidden_after_expr,\n                ]}\n\n    def trace_function(self, func):\n        # type: (FunctionType) -> FunctionType\n        \"\"\"\n        Returns a version of the passed function with the AST modified to\n        trigger the tracing hooks.\n        \"\"\"\n        if not isinstance(func, FunctionType):\n            raise ValueError('You can only trace user-defined functions. '\n                             'The birdseye decorator must be applied first, '\n                             'at the bottom of the list.')\n\n        try:\n            if inspect.iscoroutinefunction(func) or inspect.isasyncgenfunction(func):\n                raise ValueError('You cannot trace async functions')\n        except AttributeError:\n            pass\n\n        if is_lambda(func):\n            raise ValueError('You cannot trace lambdas')\n\n        filename = inspect.getsourcefile(func)  # type: str\n\n        if is_ipython_cell(filename):\n            # noinspection PyPackageRequirements\n            from IPython import get_ipython\n            import linecache\n\n            flags = get_ipython().compile.flags\n            source = ''.join(linecache.cache[filename][2])\n        else:\n            source = read_source_file(filename)\n            flags = 0\n\n        # We compile the entire file instead of just the function source\n        # because it can contain context which affects the function code,\n        # e.g. enclosing functions and classes or __future__ imports\n        traced_file = self.compile(source, filename, flags)\n\n        if func.__dict__:\n            raise ValueError('The birdseye decorator must be applied first, '\n                             'at the bottom of the list.')\n\n        # Then we have to recursively search through the newly compiled\n        # code to find the code we actually want corresponding to this function\n        code_options = []  # type: List[CodeType]\n\n        def find_code(root_code):\n            # type: (CodeType) -> None\n            for const in root_code.co_consts:  # type: CodeType\n                if not inspect.iscode(const):\n                    continue\n                matches = (const.co_firstlineno == func.__code__.co_firstlineno and\n                           const.co_name == func.__code__.co_name)\n                if matches:\n                    code_options.append(const)\n                find_code(const)\n\n        find_code(traced_file.code)\n\n        if len(code_options) > 1:\n            # Currently lambdas aren't allowed anyway, but should be in the future\n            assert is_lambda(func)\n            raise ValueError(\"Failed to trace lambda. Convert the function to a def.\")\n        new_func_code = code_options[0]  # type: CodeType\n\n        # Give the new function access to the hooks\n        # We have to use the original __globals__ and not a copy\n        # because it's the actual module namespace that may get updated by other code\n        func.__globals__.update(self._trace_methods_dict(traced_file))\n\n        # http://stackoverflow.com/a/13503277/2482744\n        # noinspection PyArgumentList\n        new_func = FunctionType(new_func_code, func.__globals__, func.__name__, func.__defaults__, func.__closure__)\n        update_wrapper(new_func, func)  # type: FunctionType\n        if PY3:\n            new_func.__kwdefaults__ = getattr(func, '__kwdefaults__', None)\n        new_func.traced_file = traced_file\n        return new_func\n\n    def __call__(self, func=None, optional=False):\n        # type: (FunctionType, bool) -> Callable\n        \"\"\"\n        Decorator which returns a (possibly optionally) traced function.\n        This decorator can be called with or without arguments.\n        Typically it is called without arguments, in which case it returns\n        a traced function.\n        If optional=True, it returns a function similar to the original\n        but with an additional optional parameter trace_call, default False.\n        If trace_call is false, the underlying untraced function is used.\n        If true, the traced version is used.\n        \"\"\"\n        if inspect.isclass(func):\n            raise TypeError('Decorating classes is no longer supported')\n\n        if func:\n            # The decorator has been called without arguments/parentheses,\n            # e.g.\n            # @eye\n            # def ...\n            return self.trace_function(func)\n\n        # The decorator has been called with arguments/parentheses,\n        # e.g.\n        # @eye(...)\n        # def ...\n        # We must return a decorator\n\n        if not optional:\n            return self.trace_function\n\n        def decorator(actual_func):\n\n            traced = self.trace_function(actual_func)\n\n            @wraps(actual_func)\n            def wrapper(*args, **kwargs):\n                trace_call = kwargs.pop('trace_call', False)\n                if trace_call:\n                    f = traced\n                else:\n                    f = actual_func\n                return f(*args, **kwargs)\n\n            return wrapper\n\n        return decorator\n\n    def _main_frame(self, node):\n        # type: (ast.AST) -> Optional[FrameType]\n        frame = sys._getframe(2)\n        result = self.secondary_to_main_frames.get(frame)\n        if result:\n            return result\n\n        original_frame = frame\n\n        while frame.f_code.co_name in ('<listcomp>', '<dictcomp>', '<setcomp>'):\n            frame = frame.f_back\n\n        for node in ancestors(node):\n            if isinstance(node, (ast.FunctionDef, ast.Lambda)):\n                break\n\n            if isinstance(node, ast.ClassDef):\n                frame = frame.f_back\n\n        if frame.f_code.co_name in ('<lambda>', '<genexpr>'):\n            return None\n\n        self.secondary_to_main_frames[original_frame] = frame\n        self.main_to_secondary_frames[frame].append(original_frame)\n        return frame\n\n    def _treetrace_hidden_with_stmt(self, traced_file, _tree_index):\n        # type: (TracedFile, int) -> _StmtContext\n        \"\"\"\n        Called directly from the modified code.\n        Every statement in the original code becomes:\n\n        with _treetrace_hidden_with_stmt(...):\n            <statement>\n        \"\"\"\n        node = traced_file.nodes[_tree_index]\n        node = cast(ast.stmt, node)\n        frame = self._main_frame(node)\n        return _StmtContext(self, node, frame)\n\n    def _treetrace_hidden_before_expr(self, traced_file, _tree_index):\n        # type: (TracedFile, int) -> ast.expr\n        \"\"\"\n        Called directly from the modified code before an expression is\n        evaluated.\n        \"\"\"\n        node = traced_file.nodes[_tree_index]\n        node = cast(ast.expr, node)\n        frame = self._main_frame(node)\n        if frame is None:\n            return node\n\n        frame_info = self.stack[frame]\n        frame_info.expression_stack.append(node)\n\n        self.before_expr(node, frame)\n        return node\n\n    def _treetrace_hidden_after_expr(self, _, node, value):\n        # type: (TracedFile, ast.expr, Any) -> Any\n        \"\"\"\n        Called directly from the modified code after an expression is\n        evaluated.\n        \"\"\"\n        frame = self._main_frame(node)\n        if frame is None:\n            return value\n\n        result = self._after_expr(node, frame, value, None, None)\n        if result is not None:\n            assert isinstance(result, ChangeValue), \"after_expr must return None or an instance of ChangeValue\"\n            value = result.value\n        return value\n\n    def _after_expr(self, node, frame, value, exc_value, exc_tb):\n        frame_info = self.stack[frame]\n        frame_info.expression_stack.pop()\n        frame_info.expression_values[node] = value\n        return self.after_expr(node, frame, value, exc_value, exc_tb)\n\n    def _enter_call(self, enter_node, current_frame):\n        # type: (ast.AST, FrameType) -> None\n        caller_frame, call_node = self._get_caller_stuff(current_frame)\n        self.stack[current_frame] = FrameInfo()\n        self.enter_call(EnterCallInfo(call_node, enter_node, caller_frame, current_frame))\n\n    def _get_caller_stuff(self, frame):\n        # type: (FrameType) -> Tuple[FrameType, Optional[Union[ast.expr, ast.stmt]]]\n        caller_frame = frame.f_back\n        call_node = None\n        main_frame = self.secondary_to_main_frames.get(caller_frame)\n        if main_frame:\n            caller_frame = main_frame\n            frame_info = self.stack[caller_frame]\n            expression_stack = frame_info.expression_stack\n            if expression_stack:\n                call_node = expression_stack[-1]\n            else:\n                call_node = frame_info.statement_stack[-1]  # type: ignore\n        return caller_frame, call_node\n\n    # The methods below are hooks meant to be overridden in subclasses to take custom actions\n\n    def before_expr(self, node, frame):\n        # type: (ast.expr, FrameType) -> None\n        \"\"\"\n        Called right before the expression corresponding to `node` is evaluated\n        within `frame`.\n        \"\"\"\n\n    def after_expr(self, node, frame, value, exc_value, exc_tb):\n        # type: (ast.expr, FrameType, Any, Optional[BaseException], Optional[TracebackType]) -> Optional[ChangeValue]\n        \"\"\"\n        Called right after the expression corresponding to `node` is evaluated\n        within `frame`. `value` is the value of the expression, if it succeeded.\n        If the evaluation raised an exception, exc_value will be the exception object\n        and exc_tb the traceback.\n\n        Return `ChangeValue(x)` to change the value of the expression as\n        seen by the rest of the program from `value` to `x`.\n        \"\"\"\n\n    def before_stmt(self, node, frame):\n        # type: (ast.stmt, FrameType) -> None\n        \"\"\"\n        Called right before the statement corresponding to `node` is executed\n        within `frame`.\n        \"\"\"\n\n    def after_stmt(self, node, frame, exc_value, exc_traceback, exc_node):\n        # type: (ast.stmt, FrameType, Optional[BaseException], Optional[TracebackType], Optional[ast.AST]) -> Optional[bool]\n        \"\"\"\n        Called right after the statement corresponding to `node` is executed\n        within `frame`.\n        If the statement raised an exception, exc_value will be the exception object,\n        exc_tb the traceback, and exc_node the node where the exception was raised\n        (either this statement or an expression within).\n\n        Returning True will suppress any exception raised (as with __exit__ in general).\n        \"\"\"\n\n    def enter_call(self, enter_info):\n        # type: (EnterCallInfo) -> None\n        \"\"\"\n        Called before a function call begins executing. For typical `def` functions,\n        this is called before the `before_stmt` for to the first statement in the function.\n        \"\"\"\n\n    def exit_call(self, exit_info):\n        # type: (ExitCallInfo) -> None\n        \"\"\"\n        Called after a function call finishes executing. For typical `def` functions,\n        this is called after the `after_stmt` for to the last statement to execute.\n        \"\"\"\n\n    def parse_extra(self, root, source, filename):\n        # type: (ast.Module, str, str) -> Optional[ast.Module]\n        \"\"\"\n        Called before the AST (root) is modified to let subclasses make additional changes first.\n        \"\"\""
        ],
        [
            "LOAD_NAME",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.NodeTransformer"
        ],
        [
            "CALL",
            "class _NodeVisitor(ast.NodeTransformer):\n    \"\"\"\n    This does the AST modifications that call the hooks.\n    \"\"\"\n\n    def generic_visit(self, node):\n        # type: (ast.AST) -> ast.AST\n        if not getattr(node, '_visit_ignore', False):\n            if (isinstance(node, ast.expr) and\n                    not (hasattr(node, \"ctx\") and not isinstance(node.ctx, ast.Load)) and\n                    not isinstance(node, getattr(ast, 'Starred', ()))):\n                return self.visit_expr(node)\n            if isinstance(node, ast.stmt):\n                return self.visit_stmt(node)\n        return super(_NodeVisitor, self).generic_visit(node)\n\n    def visit_expr(self, node):\n        # type: (ast.expr) -> ast.Call\n        \"\"\"\n        each expression e gets wrapped like this:\n            _treetrace_hidden_after_expr(_treetrace_hidden_before_expr(_tree_index), e)\n\n        where the _treetrace_* functions are the corresponding methods with the\n        TreeTracerBase and traced_file arguments already filled in (see _trace_methods_dict)\n        \"\"\"\n\n        before_marker = self._create_simple_marker_call(node, TreeTracerBase._treetrace_hidden_before_expr)\n        ast.copy_location(before_marker, node)\n\n        after_marker = ast.Call(\n            func=ast.Name(id=TreeTracerBase._treetrace_hidden_after_expr.__name__,\n                          ctx=ast.Load()),\n            args=[\n                before_marker,\n                super(_NodeVisitor, self).generic_visit(node),\n            ],\n            keywords=[],\n        )\n        ast.copy_location(after_marker, node)\n        ast.fix_missing_locations(after_marker)\n\n        return after_marker\n\n    def visit_stmt(self, node):\n        # type: (ast.stmt) -> ast.With\n        \"\"\"\n        Every statement in the original code becomes:\n\n        with _treetrace_hidden_with_stmt(_tree_index):\n            <statement>\n\n        where the _treetrace_hidden_with_stmt function is the the corresponding method with the\n        TreeTracerBase and traced_file arguments already filled in (see _trace_methods_dict)\n        \"\"\"\n        context_expr = self._create_simple_marker_call(\n            super(_NodeVisitor, self).generic_visit(node),\n            TreeTracerBase._treetrace_hidden_with_stmt)\n\n        if PY3:\n            wrapped = ast.With(\n                items=[ast.withitem(context_expr=context_expr)],\n                body=[node],\n            )\n        else:\n            wrapped = ast.With(\n                context_expr=context_expr,\n                body=[node],\n            )\n        ast.copy_location(wrapped, node)\n        ast.fix_missing_locations(wrapped)\n        return wrapped\n\n    @staticmethod\n    def _create_simple_marker_call(node, func):\n        # type: (ast.AST, Callable) -> ast.Call\n        \"\"\"\n        Returns a Call node representing `func(node._tree_index)`\n        where node._tree_index is a numerical literal which allows the node object\n        to be retrieved later through the nodes attribute of a TracedFile.\n        \"\"\"\n        return ast.Call(\n            func=ast.Name(id=func.__name__,\n                          ctx=ast.Load()),\n            args=[ast.Num(node._tree_index)],\n            keywords=[],\n        )"
        ],
        [
            "STORE_NAME",
            "class _NodeVisitor(ast.NodeTransformer):\n    \"\"\"\n    This does the AST modifications that call the hooks.\n    \"\"\"\n\n    def generic_visit(self, node):\n        # type: (ast.AST) -> ast.AST\n        if not getattr(node, '_visit_ignore', False):\n            if (isinstance(node, ast.expr) and\n                    not (hasattr(node, \"ctx\") and not isinstance(node.ctx, ast.Load)) and\n                    not isinstance(node, getattr(ast, 'Starred', ()))):\n                return self.visit_expr(node)\n            if isinstance(node, ast.stmt):\n                return self.visit_stmt(node)\n        return super(_NodeVisitor, self).generic_visit(node)\n\n    def visit_expr(self, node):\n        # type: (ast.expr) -> ast.Call\n        \"\"\"\n        each expression e gets wrapped like this:\n            _treetrace_hidden_after_expr(_treetrace_hidden_before_expr(_tree_index), e)\n\n        where the _treetrace_* functions are the corresponding methods with the\n        TreeTracerBase and traced_file arguments already filled in (see _trace_methods_dict)\n        \"\"\"\n\n        before_marker = self._create_simple_marker_call(node, TreeTracerBase._treetrace_hidden_before_expr)\n        ast.copy_location(before_marker, node)\n\n        after_marker = ast.Call(\n            func=ast.Name(id=TreeTracerBase._treetrace_hidden_after_expr.__name__,\n                          ctx=ast.Load()),\n            args=[\n                before_marker,\n                super(_NodeVisitor, self).generic_visit(node),\n            ],\n            keywords=[],\n        )\n        ast.copy_location(after_marker, node)\n        ast.fix_missing_locations(after_marker)\n\n        return after_marker\n\n    def visit_stmt(self, node):\n        # type: (ast.stmt) -> ast.With\n        \"\"\"\n        Every statement in the original code becomes:\n\n        with _treetrace_hidden_with_stmt(_tree_index):\n            <statement>\n\n        where the _treetrace_hidden_with_stmt function is the the corresponding method with the\n        TreeTracerBase and traced_file arguments already filled in (see _trace_methods_dict)\n        \"\"\"\n        context_expr = self._create_simple_marker_call(\n            super(_NodeVisitor, self).generic_visit(node),\n            TreeTracerBase._treetrace_hidden_with_stmt)\n\n        if PY3:\n            wrapped = ast.With(\n                items=[ast.withitem(context_expr=context_expr)],\n                body=[node],\n            )\n        else:\n            wrapped = ast.With(\n                context_expr=context_expr,\n                body=[node],\n            )\n        ast.copy_location(wrapped, node)\n        ast.fix_missing_locations(wrapped)\n        return wrapped\n\n    @staticmethod\n    def _create_simple_marker_call(node, func):\n        # type: (ast.AST, Callable) -> ast.Call\n        \"\"\"\n        Returns a Call node representing `func(node._tree_index)`\n        where node._tree_index is a numerical literal which allows the node object\n        to be retrieved later through the nodes attribute of a TracedFile.\n        \"\"\"\n        return ast.Call(\n            func=ast.Name(id=func.__name__,\n                          ctx=ast.Load()),\n            args=[ast.Num(node._tree_index)],\n            keywords=[],\n        )"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class _StmtContext(object):\n    __slots__ = ('tracer', 'node', 'frame')\n\n    def __init__(self, tracer, node, frame):\n        # type: (TreeTracerBase, ast.stmt, FrameType) -> None\n        self.tracer = tracer\n        self.node = node\n        self.frame = frame\n\n    def __enter__(self):\n        tracer = self.tracer\n        node = self.node\n        frame = self.frame\n        if getattr(node, '_enter_call_node', False):\n            tracer._enter_call(node, frame)\n        frame_info = tracer.stack[frame]\n        frame_info.expression_stack = []\n        frame_info.statement_stack.append(node)\n        tracer.before_stmt(node, frame)\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        # type: (Type[Exception], Exception, TracebackType) -> bool\n        node = self.node\n        tracer = self.tracer\n        frame = self.frame\n        frame_info = tracer.stack[frame]\n\n        frame_info.statement_stack.pop()\n\n        exc_node = None  # type: Optional[Union[ast.expr, ast.stmt]]\n        if exc_val and exc_val is not frame_info.exc_value:\n            exc_node = node\n            frame_info.exc_value = exc_val\n\n            # Call the after_expr hook if the exception was raised by an expression\n            expression_stack = frame_info.expression_stack\n            if expression_stack:\n                exc_node = expression_stack[-1]\n                tracer._after_expr(exc_node, frame, None, exc_val, exc_tb)\n\n        result = tracer.after_stmt(node, frame, exc_val, exc_tb, exc_node)\n\n        if isinstance(node, ast.Return):\n            frame_info.return_node = node\n\n        parent = node.parent  # type: ast.AST\n        return_node = frame_info.return_node\n        exiting = (isinstance(parent, (ast.FunctionDef, ast.Module)) and\n                   (node is parent.body[-1] or\n                    exc_val or\n                    return_node))\n        if exiting:\n            caller_frame, call_node = tracer._get_caller_stuff(frame)\n            return_value = None\n            if return_node and return_node.value and not exc_val:\n                return_value = frame_info.expression_values[return_node.value]\n            tracer.exit_call(ExitCallInfo(call_node,\n                                          return_node,\n                                          caller_frame,\n                                          frame,\n                                          return_value,\n                                          exc_val,\n                                          exc_tb\n                                          ))\n\n            del tracer.stack[frame]\n            for secondary_frame in self.tracer.main_to_secondary_frames.pop(frame):\n                del self.tracer.secondary_to_main_frames[secondary_frame]\n\n        return result"
        ],
        [
            "STORE_NAME",
            "class _StmtContext(object):\n    __slots__ = ('tracer', 'node', 'frame')\n\n    def __init__(self, tracer, node, frame):\n        # type: (TreeTracerBase, ast.stmt, FrameType) -> None\n        self.tracer = tracer\n        self.node = node\n        self.frame = frame\n\n    def __enter__(self):\n        tracer = self.tracer\n        node = self.node\n        frame = self.frame\n        if getattr(node, '_enter_call_node', False):\n            tracer._enter_call(node, frame)\n        frame_info = tracer.stack[frame]\n        frame_info.expression_stack = []\n        frame_info.statement_stack.append(node)\n        tracer.before_stmt(node, frame)\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        # type: (Type[Exception], Exception, TracebackType) -> bool\n        node = self.node\n        tracer = self.tracer\n        frame = self.frame\n        frame_info = tracer.stack[frame]\n\n        frame_info.statement_stack.pop()\n\n        exc_node = None  # type: Optional[Union[ast.expr, ast.stmt]]\n        if exc_val and exc_val is not frame_info.exc_value:\n            exc_node = node\n            frame_info.exc_value = exc_val\n\n            # Call the after_expr hook if the exception was raised by an expression\n            expression_stack = frame_info.expression_stack\n            if expression_stack:\n                exc_node = expression_stack[-1]\n                tracer._after_expr(exc_node, frame, None, exc_val, exc_tb)\n\n        result = tracer.after_stmt(node, frame, exc_val, exc_tb, exc_node)\n\n        if isinstance(node, ast.Return):\n            frame_info.return_node = node\n\n        parent = node.parent  # type: ast.AST\n        return_node = frame_info.return_node\n        exiting = (isinstance(parent, (ast.FunctionDef, ast.Module)) and\n                   (node is parent.body[-1] or\n                    exc_val or\n                    return_node))\n        if exiting:\n            caller_frame, call_node = tracer._get_caller_stuff(frame)\n            return_value = None\n            if return_node and return_node.value and not exc_val:\n                return_value = frame_info.expression_values[return_node.value]\n            tracer.exit_call(ExitCallInfo(call_node,\n                                          return_node,\n                                          caller_frame,\n                                          frame,\n                                          return_value,\n                                          exc_val,\n                                          exc_tb\n                                          ))\n\n            del tracer.stack[frame]\n            for secondary_frame in self.tracer.main_to_secondary_frames.pop(frame):\n                del self.tracer.secondary_to_main_frames[secondary_frame]\n\n        return result"
        ],
        [
            "STORE_NAME",
            "def ancestors(node):\n    # type: (ast.AST) -> Iterator[ast.AST]\n    while True:\n        try:\n            node = node.parent\n        except AttributeError:\n            break\n        yield node"
        ],
        [
            "LOAD_NAME",
            "Union"
        ],
        [
            "LOAD_NAME",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.For"
        ],
        [
            "LOAD_NAME",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.While"
        ],
        [
            "LOAD_NAME",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.comprehension"
        ],
        [
            "BINARY_SUBSCR",
            "Union[ast.For, ast.While, ast.comprehension]"
        ],
        [
            "STORE_NAME",
            "Loop"
        ],
        [
            "STORE_NAME",
            "def loops(node):\n    # type: (ast.AST) -> Tuple[Loop, ...]\n    \"\"\"\n    Return all the 'enclosing loops' of a node, up to the innermost class or\n    function definition. This also includes the 'for in' clauses in list/dict/set/generator\n    comprehensions. So for example, in this code:\n\n      for x in ...:\n          def foo():\n              while True:\n                  print([z for y in ...])\n\n    The loops enclosing the node 'z' are 'while True' and 'for y in ...', in that order.\n    \"\"\"\n    result = []\n    while True:\n        try:\n            parent = node.parent\n        except AttributeError:\n            break\n        if isinstance(parent, ast.FunctionDef):\n            break\n\n        is_containing_loop = (((isinstance(parent, ast.For) and parent.iter is not node or\n                                isinstance(parent, ast.While))\n                               and node not in parent.orelse) or\n                              (isinstance(parent, ast.comprehension) and node in parent.ifs))\n        if is_containing_loop:\n            result.append(parent)\n\n        elif isinstance(parent, (ast.ListComp,\n                                 ast.GeneratorExp,\n                                 ast.DictComp,\n                                 ast.SetComp)):\n            generators = parent.generators\n            if node in generators:\n                generators = list(takewhile(lambda n: n != node, generators))\n            result.extend(reversed(generators))\n\n        node = parent\n\n    result.reverse()\n    return tuple(result)"
        ],
        [
            "STORE_NAME",
            "\"\"\"\n    An instance of this class corresponds to a single .py file.\n    It contains some useful data in the following attributes:\n\n    - filename: name of the source file\n    - source: textual contents of the file\n    - root: root of the original Abstract Syntax Tree (AST) of the source,\n            where the nodes of this tree have an additional handy attribute:\n            - parent: parent of the node, so this node is a child node of its parent\n    - tracer: instance of TreeTracerBase\n    - code: executable code object compiled from the modified AST\n    \"\"\""
        ],
        [
            "STORE_NAME",
            "is_ipython_cell"
        ],
        [
            "STORE_NAME",
            "    def __init__(self, tracer, source, filename, flags):\n        # type: (TreeTracerBase, str, str, int) -> None\n        # Here the source code is parsed, modified, and compiled\n        self.root = compile(source, filename, 'exec', ast.PyCF_ONLY_AST | flags, dont_inherit=True)  # type: ast.Module\n\n        self.nodes = []  # type: List[ast.AST]\n\n        self.set_basic_node_attributes()\n\n        new_root = tracer.parse_extra(self.root, source, filename)\n        if new_root is not None:\n            self.root = new_root\n\n        self.set_basic_node_attributes()\n        self.set_enter_call_nodes()\n\n        new_root = deepcopy(self.root)\n        new_root = _NodeVisitor().visit(new_root)\n\n        self.code = compile(new_root, filename, \"exec\", dont_inherit=True, flags=flags)  # type: CodeType\n        self.tracer = tracer\n        self.source = source\n        self.filename = filename"
        ],
        [
            "STORE_NAME",
            "    def set_basic_node_attributes(self):\n        self.nodes = []  # type: List[ast.AST]\n        for node in ast.walk(self.root):  # type: ast.AST\n            for child in ast.iter_child_nodes(node):\n                child.parent = node\n            node._tree_index = len(self.nodes)\n            self.nodes.append(node)\n\n        # Mark __future__ imports and anything before (i.e. module docstrings)\n        # to be ignored by the AST transformer\n        for i, stmt in enumerate(self.root.body):\n            if is_future_import(stmt):\n                for s in self.root.body[:i + 1]:\n                    for node in ast.walk(s):\n                        node._visit_ignore = True"
        ],
        [
            "STORE_NAME",
            "    def set_enter_call_nodes(self):\n        for node in self.nodes:\n            if isinstance(node, (ast.Module, ast.FunctionDef)):\n                for stmt in node.body:\n                    if not is_future_import(stmt):\n                        stmt._enter_call_node = True\n                        break"
        ],
        [
            "LOAD_GLOBAL",
            "compile"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.PyCF_ONLY_AST"
        ],
        [
            "LOAD_FAST",
            "flags"
        ],
        [
            "BINARY_OP",
            "ast.PyCF_ONLY_AST | flags"
        ],
        [
            "CALL",
            "compile(source, filename, 'exec', ast.PyCF_ONLY_AST | flags, dont_inherit=True)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.root"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.nodes"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.set_basic_node_attributes"
        ],
        [
            "CALL",
            "self.set_basic_node_attributes()"
        ],
        [
            "LOAD_FAST",
            "tracer"
        ],
        [
            "LOAD_METHOD",
            "tracer.parse_extra"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.root"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "CALL",
            "tracer.parse_extra(self.root, source, filename)"
        ],
        [
            "STORE_FAST",
            "new_root"
        ],
        [
            "LOAD_FAST",
            "new_root"
        ],
        [
            "LOAD_FAST",
            "new_root"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.root"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.set_basic_node_attributes"
        ],
        [
            "CALL",
            "self.set_basic_node_attributes()"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.set_enter_call_nodes"
        ],
        [
            "CALL",
            "self.set_enter_call_nodes()"
        ],
        [
            "LOAD_GLOBAL",
            "deepcopy"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.root"
        ],
        [
            "CALL",
            "deepcopy(self.root)"
        ],
        [
            "STORE_FAST",
            "new_root"
        ],
        [
            "LOAD_GLOBAL",
            "_NodeVisitor"
        ],
        [
            "CALL",
            "_NodeVisitor()"
        ],
        [
            "LOAD_METHOD",
            "_NodeVisitor().visit"
        ],
        [
            "LOAD_FAST",
            "new_root"
        ],
        [
            "CALL",
            "_NodeVisitor().visit(new_root)"
        ],
        [
            "STORE_FAST",
            "new_root"
        ],
        [
            "LOAD_GLOBAL",
            "compile"
        ],
        [
            "LOAD_FAST",
            "new_root"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "flags"
        ],
        [
            "CALL",
            "compile(new_root, filename, \"exec\", dont_inherit=True, flags=flags)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.code"
        ],
        [
            "LOAD_FAST",
            "tracer"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.tracer"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.source"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.filename"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.nodes"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.walk"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.root"
        ],
        [
            "CALL",
            "ast.walk(self.root)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.iter_child_nodes"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "ast.iter_child_nodes(node)"
        ],
        [
            "STORE_FAST",
            "child"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "child"
        ],
        [
            "STORE_ATTR",
            "child.parent"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.nodes"
        ],
        [
            "CALL",
            "len(self.nodes)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "STORE_ATTR",
            "node._tree_index"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.nodes"
        ],
        [
            "LOAD_METHOD",
            "self.nodes.append"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "self.nodes.append(node)"
        ],
        [
            "LOAD_GLOBAL",
            "enumerate"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.root"
        ],
        [
            "LOAD_ATTR",
            "self.root.body"
        ],
        [
            "CALL",
            "enumerate(self.root.body)"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "STORE_FAST",
            "stmt"
        ],
        [
            "LOAD_GLOBAL",
            "is_future_import"
        ],
        [
            "LOAD_FAST",
            "stmt"
        ],
        [
            "CALL",
            "is_future_import(stmt)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.root"
        ],
        [
            "LOAD_ATTR",
            "self.root.body"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_OP",
            "i + 1"
        ],
        [
            "BINARY_SUBSCR",
            "self.root.body[:i + 1]"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.walk"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "CALL",
            "ast.walk(s)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "STORE_ATTR",
            "node._visit_ignore"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.nodes"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Module"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.FunctionDef"
        ],
        [
            "CALL",
            "isinstance(node, (ast.Module, ast.FunctionDef))"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.body"
        ],
        [
            "STORE_FAST",
            "stmt"
        ],
        [
            "LOAD_GLOBAL",
            "is_future_import"
        ],
        [
            "LOAD_FAST",
            "stmt"
        ],
        [
            "CALL",
            "is_future_import(stmt)"
        ],
        [
            "LOAD_FAST",
            "stmt"
        ],
        [
            "STORE_ATTR",
            "stmt._enter_call_node"
        ],
        [
            "STORE_NAME",
            "\"\"\"\n    Contains extra data about an execution frame.\n    Can be obtained from the stack attribute of a TreeTracerBase instance\n    \"\"\""
        ],
        [
            "STORE_NAME",
            "    def __init__(self):\n        # Stack of statements currently being executed\n        self.statement_stack = []  # type: List[ast.stmt]\n\n        # Stack of expression nodes within the above statement that\n        # the interpreter is planning on evaluating, or has just evaluated\n        # in the case of the last element of the list. For example, given\n        # the expression f(g(x)), the stack would be [f, g, x] before and just\n        # after evaluating x, since function arguments are evaluated before the\n        # actual function call.\n        self.expression_stack = []  # type: List[ast.expr]\n\n        # Mapping from the expression node to its most recent value\n        # in the corresponding frame\n        self.expression_values = {}  # type: Dict[ast.expr, Any]\n\n        # Node where the frame has explicitly returned\n        # There may be parent nodes such as enclosing loops that still need to finish executing\n        self.return_node = None  # type: Optional[ast.Return]\n\n        # Most recent exception raised in the frame\n        self.exc_value = None"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.statement_stack"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.expression_stack"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.expression_values"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.return_node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.exc_value"
        ],
        [
            "STORE_NAME",
            "\"\"\"\n    Create a subclass of this class with one or more of the 'hooks'\n    (methods which are empty in this class) overridden to take a custom action\n    in the given situation. Then decorate functions with an instance of this class\n    to trace them.\n    \"\"\""
        ],
        [
            "STORE_NAME",
            "    def __init__(self):\n        # Mapping from frames of execution being traced to FrameInfo objects\n        # for extra metadata.\n        self.stack = {}  # type: Dict[FrameType, FrameInfo]\n        self.main_to_secondary_frames = defaultdict(list)\n        self.secondary_to_main_frames = {}"
        ],
        [
            "LOAD_NAME",
            "lru_cache"
        ],
        [
            "CALL",
            "lru_cache()"
        ],
        [
            "CALL",
            "lru_cache()"
        ],
        [
            "STORE_NAME",
            "    @lru_cache()\n    def compile(self, source, filename, flags=0):\n        # type: (str, str, int) -> TracedFile\n        return TracedFile(self, source, filename, flags)"
        ],
        [
            "STORE_NAME",
            "    def _trace_methods_dict(self, traced_file):\n        # type: (TracedFile) -> Dict[str, Callable]\n        return {f.__name__: partial(f, traced_file)\n                for f in [\n                    self._treetrace_hidden_with_stmt,\n                    self._treetrace_hidden_before_expr,\n                    self._treetrace_hidden_after_expr,\n                ]}"
        ],
        [
            "STORE_NAME",
            "    def trace_function(self, func):\n        # type: (FunctionType) -> FunctionType\n        \"\"\"\n        Returns a version of the passed function with the AST modified to\n        trigger the tracing hooks.\n        \"\"\"\n        if not isinstance(func, FunctionType):\n            raise ValueError('You can only trace user-defined functions. '\n                             'The birdseye decorator must be applied first, '\n                             'at the bottom of the list.')\n\n        try:\n            if inspect.iscoroutinefunction(func) or inspect.isasyncgenfunction(func):\n                raise ValueError('You cannot trace async functions')\n        except AttributeError:\n            pass\n\n        if is_lambda(func):\n            raise ValueError('You cannot trace lambdas')\n\n        filename = inspect.getsourcefile(func)  # type: str\n\n        if is_ipython_cell(filename):\n            # noinspection PyPackageRequirements\n            from IPython import get_ipython\n            import linecache\n\n            flags = get_ipython().compile.flags\n            source = ''.join(linecache.cache[filename][2])\n        else:\n            source = read_source_file(filename)\n            flags = 0\n\n        # We compile the entire file instead of just the function source\n        # because it can contain context which affects the function code,\n        # e.g. enclosing functions and classes or __future__ imports\n        traced_file = self.compile(source, filename, flags)\n\n        if func.__dict__:\n            raise ValueError('The birdseye decorator must be applied first, '\n                             'at the bottom of the list.')\n\n        # Then we have to recursively search through the newly compiled\n        # code to find the code we actually want corresponding to this function\n        code_options = []  # type: List[CodeType]\n\n        def find_code(root_code):\n            # type: (CodeType) -> None\n            for const in root_code.co_consts:  # type: CodeType\n                if not inspect.iscode(const):\n                    continue\n                matches = (const.co_firstlineno == func.__code__.co_firstlineno and\n                           const.co_name == func.__code__.co_name)\n                if matches:\n                    code_options.append(const)\n                find_code(const)\n\n        find_code(traced_file.code)\n\n        if len(code_options) > 1:\n            # Currently lambdas aren't allowed anyway, but should be in the future\n            assert is_lambda(func)\n            raise ValueError(\"Failed to trace lambda. Convert the function to a def.\")\n        new_func_code = code_options[0]  # type: CodeType\n\n        # Give the new function access to the hooks\n        # We have to use the original __globals__ and not a copy\n        # because it's the actual module namespace that may get updated by other code\n        func.__globals__.update(self._trace_methods_dict(traced_file))\n\n        # http://stackoverflow.com/a/13503277/2482744\n        # noinspection PyArgumentList\n        new_func = FunctionType(new_func_code, func.__globals__, func.__name__, func.__defaults__, func.__closure__)\n        update_wrapper(new_func, func)  # type: FunctionType\n        if PY3:\n            new_func.__kwdefaults__ = getattr(func, '__kwdefaults__', None)\n        new_func.traced_file = traced_file\n        return new_func"
        ],
        [
            "STORE_NAME",
            "    def __call__(self, func=None, optional=False):\n        # type: (FunctionType, bool) -> Callable\n        \"\"\"\n        Decorator which returns a (possibly optionally) traced function.\n        This decorator can be called with or without arguments.\n        Typically it is called without arguments, in which case it returns\n        a traced function.\n        If optional=True, it returns a function similar to the original\n        but with an additional optional parameter trace_call, default False.\n        If trace_call is false, the underlying untraced function is used.\n        If true, the traced version is used.\n        \"\"\"\n        if inspect.isclass(func):\n            raise TypeError('Decorating classes is no longer supported')\n\n        if func:\n            # The decorator has been called without arguments/parentheses,\n            # e.g.\n            # @eye\n            # def ...\n            return self.trace_function(func)\n\n        # The decorator has been called with arguments/parentheses,\n        # e.g.\n        # @eye(...)\n        # def ...\n        # We must return a decorator\n\n        if not optional:\n            return self.trace_function\n\n        def decorator(actual_func):\n\n            traced = self.trace_function(actual_func)\n\n            @wraps(actual_func)\n            def wrapper(*args, **kwargs):\n                trace_call = kwargs.pop('trace_call', False)\n                if trace_call:\n                    f = traced\n                else:\n                    f = actual_func\n                return f(*args, **kwargs)\n\n            return wrapper\n\n        return decorator"
        ],
        [
            "STORE_NAME",
            "    def _main_frame(self, node):\n        # type: (ast.AST) -> Optional[FrameType]\n        frame = sys._getframe(2)\n        result = self.secondary_to_main_frames.get(frame)\n        if result:\n            return result\n\n        original_frame = frame\n\n        while frame.f_code.co_name in ('<listcomp>', '<dictcomp>', '<setcomp>'):\n            frame = frame.f_back\n\n        for node in ancestors(node):\n            if isinstance(node, (ast.FunctionDef, ast.Lambda)):\n                break\n\n            if isinstance(node, ast.ClassDef):\n                frame = frame.f_back\n\n        if frame.f_code.co_name in ('<lambda>', '<genexpr>'):\n            return None\n\n        self.secondary_to_main_frames[original_frame] = frame\n        self.main_to_secondary_frames[frame].append(original_frame)\n        return frame"
        ],
        [
            "STORE_NAME",
            "    def _treetrace_hidden_with_stmt(self, traced_file, _tree_index):\n        # type: (TracedFile, int) -> _StmtContext\n        \"\"\"\n        Called directly from the modified code.\n        Every statement in the original code becomes:\n\n        with _treetrace_hidden_with_stmt(...):\n            <statement>\n        \"\"\"\n        node = traced_file.nodes[_tree_index]\n        node = cast(ast.stmt, node)\n        frame = self._main_frame(node)\n        return _StmtContext(self, node, frame)"
        ],
        [
            "STORE_NAME",
            "    def _treetrace_hidden_before_expr(self, traced_file, _tree_index):\n        # type: (TracedFile, int) -> ast.expr\n        \"\"\"\n        Called directly from the modified code before an expression is\n        evaluated.\n        \"\"\"\n        node = traced_file.nodes[_tree_index]\n        node = cast(ast.expr, node)\n        frame = self._main_frame(node)\n        if frame is None:\n            return node\n\n        frame_info = self.stack[frame]\n        frame_info.expression_stack.append(node)\n\n        self.before_expr(node, frame)\n        return node"
        ],
        [
            "STORE_NAME",
            "    def _treetrace_hidden_after_expr(self, _, node, value):\n        # type: (TracedFile, ast.expr, Any) -> Any\n        \"\"\"\n        Called directly from the modified code after an expression is\n        evaluated.\n        \"\"\"\n        frame = self._main_frame(node)\n        if frame is None:\n            return value\n\n        result = self._after_expr(node, frame, value, None, None)\n        if result is not None:\n            assert isinstance(result, ChangeValue), \"after_expr must return None or an instance of ChangeValue\"\n            value = result.value\n        return value"
        ],
        [
            "STORE_NAME",
            "    def _after_expr(self, node, frame, value, exc_value, exc_tb):\n        frame_info = self.stack[frame]\n        frame_info.expression_stack.pop()\n        frame_info.expression_values[node] = value\n        return self.after_expr(node, frame, value, exc_value, exc_tb)"
        ],
        [
            "STORE_NAME",
            "    def _enter_call(self, enter_node, current_frame):\n        # type: (ast.AST, FrameType) -> None\n        caller_frame, call_node = self._get_caller_stuff(current_frame)\n        self.stack[current_frame] = FrameInfo()\n        self.enter_call(EnterCallInfo(call_node, enter_node, caller_frame, current_frame))"
        ],
        [
            "STORE_NAME",
            "    def _get_caller_stuff(self, frame):\n        # type: (FrameType) -> Tuple[FrameType, Optional[Union[ast.expr, ast.stmt]]]\n        caller_frame = frame.f_back\n        call_node = None\n        main_frame = self.secondary_to_main_frames.get(caller_frame)\n        if main_frame:\n            caller_frame = main_frame\n            frame_info = self.stack[caller_frame]\n            expression_stack = frame_info.expression_stack\n            if expression_stack:\n                call_node = expression_stack[-1]\n            else:\n                call_node = frame_info.statement_stack[-1]  # type: ignore\n        return caller_frame, call_node"
        ],
        [
            "STORE_NAME",
            "    def before_expr(self, node, frame):\n        # type: (ast.expr, FrameType) -> None\n        \"\"\"\n        Called right before the expression corresponding to `node` is evaluated\n        within `frame`.\n        \"\"\""
        ],
        [
            "STORE_NAME",
            "    def after_expr(self, node, frame, value, exc_value, exc_tb):\n        # type: (ast.expr, FrameType, Any, Optional[BaseException], Optional[TracebackType]) -> Optional[ChangeValue]\n        \"\"\"\n        Called right after the expression corresponding to `node` is evaluated\n        within `frame`. `value` is the value of the expression, if it succeeded.\n        If the evaluation raised an exception, exc_value will be the exception object\n        and exc_tb the traceback.\n\n        Return `ChangeValue(x)` to change the value of the expression as\n        seen by the rest of the program from `value` to `x`.\n        \"\"\""
        ],
        [
            "STORE_NAME",
            "    def before_stmt(self, node, frame):\n        # type: (ast.stmt, FrameType) -> None\n        \"\"\"\n        Called right before the statement corresponding to `node` is executed\n        within `frame`.\n        \"\"\""
        ],
        [
            "STORE_NAME",
            "    def after_stmt(self, node, frame, exc_value, exc_traceback, exc_node):\n        # type: (ast.stmt, FrameType, Optional[BaseException], Optional[TracebackType], Optional[ast.AST]) -> Optional[bool]\n        \"\"\"\n        Called right after the statement corresponding to `node` is executed\n        within `frame`.\n        If the statement raised an exception, exc_value will be the exception object,\n        exc_tb the traceback, and exc_node the node where the exception was raised\n        (either this statement or an expression within).\n\n        Returning True will suppress any exception raised (as with __exit__ in general).\n        \"\"\""
        ],
        [
            "STORE_NAME",
            "    def enter_call(self, enter_info):\n        # type: (EnterCallInfo) -> None\n        \"\"\"\n        Called before a function call begins executing. For typical `def` functions,\n        this is called before the `before_stmt` for to the first statement in the function.\n        \"\"\""
        ],
        [
            "STORE_NAME",
            "    def exit_call(self, exit_info):\n        # type: (ExitCallInfo) -> None\n        \"\"\"\n        Called after a function call finishes executing. For typical `def` functions,\n        this is called after the `after_stmt` for to the last statement to execute.\n        \"\"\""
        ],
        [
            "STORE_NAME",
            "    def parse_extra(self, root, source, filename):\n        # type: (ast.Module, str, str) -> Optional[ast.Module]\n        \"\"\"\n        Called before the AST (root) is modified to let subclasses make additional changes first.\n        \"\"\""
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.stack"
        ],
        [
            "LOAD_GLOBAL",
            "defaultdict"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "CALL",
            "defaultdict(list)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.main_to_secondary_frames"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.secondary_to_main_frames"
        ],
        [
            "LOAD_GLOBAL",
            "TracedFile"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "flags"
        ],
        [
            "CALL",
            "TracedFile(self, source, filename, flags)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._treetrace_hidden_with_stmt"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._treetrace_hidden_before_expr"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._treetrace_hidden_after_expr"
        ],
        [
            "CALL",
            "{f.__name__: partial(f, traced_file)\n                for f in [\n                    self._treetrace_hidden_with_stmt,\n                    self._treetrace_hidden_before_expr,\n                    self._treetrace_hidden_after_expr,\n                ]}"
        ],
        [
            "LOAD_FAST",
            "{f.__name__: partial(f, traced_file)\n                for f in [\n                    self._treetrace_hidden_with_stmt,\n                    self._treetrace_hidden_before_expr,\n                    self._treetrace_hidden_after_expr,\n                ]}"
        ],
        [
            "STORE_FAST",
            "f"
        ],
        [
            "LOAD_FAST",
            "f"
        ],
        [
            "LOAD_ATTR",
            "f.__name__"
        ],
        [
            "LOAD_GLOBAL",
            "partial"
        ],
        [
            "LOAD_FAST",
            "f"
        ],
        [
            "LOAD_DEREF",
            "traced_file"
        ],
        [
            "CALL",
            "partial(f, traced_file)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "LOAD_GLOBAL",
            "FunctionType"
        ],
        [
            "CALL",
            "isinstance(func, FunctionType)"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError('You can only trace user-defined functions. '\n                             'The birdseye decorator must be applied first, '\n                             'at the bottom of the list.')"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.iscoroutinefunction"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "CALL",
            "inspect.iscoroutinefunction(func)"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.isasyncgenfunction"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "CALL",
            "inspect.isasyncgenfunction(func)"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError('You cannot trace async functions')"
        ],
        [
            "LOAD_GLOBAL",
            "AttributeError"
        ],
        [
            "LOAD_GLOBAL",
            "is_lambda"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "CALL",
            "is_lambda(func)"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError('You cannot trace lambdas')"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.getsourcefile"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "CALL",
            "inspect.getsourcefile(func)"
        ],
        [
            "STORE_FAST",
            "filename"
        ],
        [
            "LOAD_GLOBAL",
            "is_ipython_cell"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "CALL",
            "is_ipython_cell(filename)"
        ],
        [
            "STORE_FAST",
            "from IPython import get_ipython"
        ],
        [
            "STORE_FAST",
            "import linecache"
        ],
        [
            "LOAD_FAST",
            "get_ipython"
        ],
        [
            "CALL",
            "get_ipython()"
        ],
        [
            "LOAD_ATTR",
            "get_ipython().compile"
        ],
        [
            "LOAD_ATTR",
            "get_ipython().compile.flags"
        ],
        [
            "STORE_FAST",
            "flags"
        ],
        [
            "LOAD_METHOD",
            "''.join"
        ],
        [
            "LOAD_FAST",
            "linecache"
        ],
        [
            "LOAD_ATTR",
            "linecache.cache"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "BINARY_SUBSCR",
            "linecache.cache[filename]"
        ],
        [
            "BINARY_SUBSCR",
            "linecache.cache[filename][2]"
        ],
        [
            "CALL",
            "''.join(linecache.cache[filename][2])"
        ],
        [
            "STORE_FAST",
            "source"
        ],
        [
            "LOAD_GLOBAL",
            "read_source_file"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "CALL",
            "read_source_file(filename)"
        ],
        [
            "STORE_FAST",
            "source"
        ],
        [
            "STORE_FAST",
            "flags"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.compile"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "flags"
        ],
        [
            "CALL",
            "self.compile(source, filename, flags)"
        ],
        [
            "STORE_FAST",
            "traced_file"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.__dict__"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError('The birdseye decorator must be applied first, '\n                             'at the bottom of the list.')"
        ],
        [
            "STORE_DEREF",
            "code_options"
        ],
        [
            "STORE_DEREF",
            "        def find_code(root_code):\n            # type: (CodeType) -> None\n            for const in root_code.co_consts:  # type: CodeType\n                if not inspect.iscode(const):\n                    continue\n                matches = (const.co_firstlineno == func.__code__.co_firstlineno and\n                           const.co_name == func.__code__.co_name)\n                if matches:\n                    code_options.append(const)\n                find_code(const)"
        ],
        [
            "LOAD_DEREF",
            "find_code"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.code"
        ],
        [
            "CALL",
            "find_code(traced_file.code)"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_DEREF",
            "code_options"
        ],
        [
            "CALL",
            "len(code_options)"
        ],
        [
            "COMPARE_OP",
            "len(code_options) > 1"
        ],
        [
            "LOAD_GLOBAL",
            "is_lambda"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "CALL",
            "is_lambda(func)"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError(\"Failed to trace lambda. Convert the function to a def.\")"
        ],
        [
            "LOAD_DEREF",
            "code_options"
        ],
        [
            "BINARY_SUBSCR",
            "code_options[0]"
        ],
        [
            "STORE_FAST",
            "new_func_code"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.__globals__"
        ],
        [
            "LOAD_METHOD",
            "func.__globals__.update"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._trace_methods_dict"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "CALL",
            "self._trace_methods_dict(traced_file)"
        ],
        [
            "CALL",
            "func.__globals__.update(self._trace_methods_dict(traced_file))"
        ],
        [
            "LOAD_GLOBAL",
            "FunctionType"
        ],
        [
            "LOAD_FAST",
            "new_func_code"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.__globals__"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.__name__"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.__defaults__"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.__closure__"
        ],
        [
            "CALL",
            "FunctionType(new_func_code, func.__globals__, func.__name__, func.__defaults__, func.__closure__)"
        ],
        [
            "STORE_FAST",
            "new_func"
        ],
        [
            "LOAD_GLOBAL",
            "update_wrapper"
        ],
        [
            "LOAD_FAST",
            "new_func"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "CALL",
            "update_wrapper(new_func, func)"
        ],
        [
            "LOAD_GLOBAL",
            "PY3"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "CALL",
            "getattr(func, '__kwdefaults__', None)"
        ],
        [
            "LOAD_FAST",
            "new_func"
        ],
        [
            "STORE_ATTR",
            "new_func.__kwdefaults__"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_FAST",
            "new_func"
        ],
        [
            "STORE_ATTR",
            "new_func.traced_file"
        ],
        [
            "LOAD_FAST",
            "new_func"
        ],
        [
            "LOAD_FAST",
            "root_code"
        ],
        [
            "LOAD_ATTR",
            "root_code.co_consts"
        ],
        [
            "STORE_FAST",
            "const"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.iscode"
        ],
        [
            "LOAD_FAST",
            "const"
        ],
        [
            "CALL",
            "inspect.iscode(const)"
        ],
        [
            "LOAD_FAST",
            "const"
        ],
        [
            "LOAD_ATTR",
            "const.co_firstlineno"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.__code__"
        ],
        [
            "LOAD_ATTR",
            "func.__code__.co_firstlineno"
        ],
        [
            "COMPARE_OP",
            "const.co_firstlineno == func.__code__.co_firstlineno"
        ],
        [
            "LOAD_FAST",
            "const"
        ],
        [
            "LOAD_ATTR",
            "const.co_name"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.__code__"
        ],
        [
            "LOAD_ATTR",
            "func.__code__.co_name"
        ],
        [
            "COMPARE_OP",
            "const.co_name == func.__code__.co_name"
        ],
        [
            "STORE_FAST",
            "matches"
        ],
        [
            "LOAD_FAST",
            "matches"
        ],
        [
            "LOAD_DEREF",
            "code_options"
        ],
        [
            "LOAD_METHOD",
            "code_options.append"
        ],
        [
            "LOAD_FAST",
            "const"
        ],
        [
            "CALL",
            "code_options.append(const)"
        ],
        [
            "LOAD_DEREF",
            "find_code"
        ],
        [
            "LOAD_FAST",
            "const"
        ],
        [
            "CALL",
            "find_code(const)"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.isclass"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "CALL",
            "inspect.isclass(func)"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "CALL",
            "TypeError('Decorating classes is no longer supported')"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.trace_function"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "CALL",
            "self.trace_function(func)"
        ],
        [
            "LOAD_FAST",
            "optional"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.trace_function"
        ],
        [
            "STORE_FAST",
            "        def decorator(actual_func):\n\n            traced = self.trace_function(actual_func)\n\n            @wraps(actual_func)\n            def wrapper(*args, **kwargs):\n                trace_call = kwargs.pop('trace_call', False)\n                if trace_call:\n                    f = traced\n                else:\n                    f = actual_func\n                return f(*args, **kwargs)\n\n            return wrapper"
        ],
        [
            "LOAD_FAST",
            "decorator"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.trace_function"
        ],
        [
            "LOAD_DEREF",
            "actual_func"
        ],
        [
            "CALL",
            "self.trace_function(actual_func)"
        ],
        [
            "STORE_DEREF",
            "traced"
        ],
        [
            "LOAD_GLOBAL",
            "wraps"
        ],
        [
            "LOAD_DEREF",
            "actual_func"
        ],
        [
            "CALL",
            "wraps(actual_func)"
        ],
        [
            "CALL",
            "wraps(actual_func)"
        ],
        [
            "STORE_FAST",
            "            @wraps(actual_func)\n            def wrapper(*args, **kwargs):\n                trace_call = kwargs.pop('trace_call', False)\n                if trace_call:\n                    f = traced\n                else:\n                    f = actual_func\n                return f(*args, **kwargs)"
        ],
        [
            "LOAD_FAST",
            "wrapper"
        ],
        [
            "LOAD_FAST",
            "kwargs"
        ],
        [
            "LOAD_METHOD",
            "kwargs.pop"
        ],
        [
            "CALL",
            "kwargs.pop('trace_call', False)"
        ],
        [
            "STORE_FAST",
            "trace_call"
        ],
        [
            "LOAD_FAST",
            "trace_call"
        ],
        [
            "LOAD_DEREF",
            "traced"
        ],
        [
            "STORE_FAST",
            "f"
        ],
        [
            "LOAD_DEREF",
            "actual_func"
        ],
        [
            "STORE_FAST",
            "f"
        ],
        [
            "LOAD_FAST",
            "f"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_FAST",
            "kwargs"
        ],
        [
            "CALL_FUNCTION_EX",
            "f(*args, **kwargs)"
        ],
        [
            "LOAD_GLOBAL",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys._getframe"
        ],
        [
            "CALL",
            "sys._getframe(2)"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.secondary_to_main_frames"
        ],
        [
            "LOAD_METHOD",
            "self.secondary_to_main_frames.get"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "self.secondary_to_main_frames.get(frame)"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "STORE_FAST",
            "original_frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_name"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code.co_name in ('<listcomp>', '<dictcomp>', '<setcomp>')"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_back"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_name"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code.co_name in ('<listcomp>', '<dictcomp>', '<setcomp>')"
        ],
        [
            "LOAD_GLOBAL",
            "ancestors"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "ancestors(node)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.FunctionDef"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Lambda"
        ],
        [
            "CALL",
            "isinstance(node, (ast.FunctionDef, ast.Lambda))"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.ClassDef"
        ],
        [
            "CALL",
            "isinstance(node, ast.ClassDef)"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_back"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_name"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code.co_name in ('<lambda>', '<genexpr>')"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.secondary_to_main_frames"
        ],
        [
            "LOAD_FAST",
            "original_frame"
        ],
        [
            "STORE_SUBSCR",
            "self.secondary_to_main_frames[original_frame]"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.main_to_secondary_frames"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "BINARY_SUBSCR",
            "self.main_to_secondary_frames[frame]"
        ],
        [
            "LOAD_METHOD",
            "self.main_to_secondary_frames[frame].append"
        ],
        [
            "LOAD_FAST",
            "original_frame"
        ],
        [
            "CALL",
            "self.main_to_secondary_frames[frame].append(original_frame)"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.nodes"
        ],
        [
            "LOAD_FAST",
            "_tree_index"
        ],
        [
            "BINARY_SUBSCR",
            "traced_file.nodes[_tree_index]"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "cast"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.stmt"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "cast(ast.stmt, node)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._main_frame"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "self._main_frame(node)"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_GLOBAL",
            "_StmtContext"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "_StmtContext(self, node, frame)"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.nodes"
        ],
        [
            "LOAD_FAST",
            "_tree_index"
        ],
        [
            "BINARY_SUBSCR",
            "traced_file.nodes[_tree_index]"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "cast"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.expr"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "cast(ast.expr, node)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._main_frame"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "self._main_frame(node)"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "STORE_FAST",
            "frame_info"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.expression_stack"
        ],
        [
            "LOAD_METHOD",
            "frame_info.expression_stack.append"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "frame_info.expression_stack.append(node)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.before_expr"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "self.before_expr(node, frame)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._main_frame"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "self._main_frame(node)"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._after_expr"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "CALL",
            "self._after_expr(node, frame, value, None, None)"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_GLOBAL",
            "ChangeValue"
        ],
        [
            "CALL",
            "isinstance(result, ChangeValue)"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_ATTR",
            "result.value"
        ],
        [
            "STORE_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "STORE_FAST",
            "frame_info"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.expression_stack"
        ],
        [
            "LOAD_METHOD",
            "frame_info.expression_stack.pop"
        ],
        [
            "CALL",
            "frame_info.expression_stack.pop()"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.expression_values"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "STORE_SUBSCR",
            "frame_info.expression_values[node]"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.after_expr"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "exc_value"
        ],
        [
            "LOAD_FAST",
            "exc_tb"
        ],
        [
            "CALL",
            "self.after_expr(node, frame, value, exc_value, exc_tb)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._get_caller_stuff"
        ],
        [
            "LOAD_FAST",
            "current_frame"
        ],
        [
            "CALL",
            "self._get_caller_stuff(current_frame)"
        ],
        [
            "STORE_FAST",
            "caller_frame"
        ],
        [
            "STORE_FAST",
            "call_node"
        ],
        [
            "LOAD_GLOBAL",
            "FrameInfo"
        ],
        [
            "CALL",
            "FrameInfo()"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_FAST",
            "current_frame"
        ],
        [
            "STORE_SUBSCR",
            "self.stack[current_frame]"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.enter_call"
        ],
        [
            "LOAD_GLOBAL",
            "EnterCallInfo"
        ],
        [
            "LOAD_FAST",
            "call_node"
        ],
        [
            "LOAD_FAST",
            "enter_node"
        ],
        [
            "LOAD_FAST",
            "caller_frame"
        ],
        [
            "LOAD_FAST",
            "current_frame"
        ],
        [
            "CALL",
            "EnterCallInfo(call_node, enter_node, caller_frame, current_frame)"
        ],
        [
            "CALL",
            "self.enter_call(EnterCallInfo(call_node, enter_node, caller_frame, current_frame))"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_back"
        ],
        [
            "STORE_FAST",
            "caller_frame"
        ],
        [
            "STORE_FAST",
            "call_node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.secondary_to_main_frames"
        ],
        [
            "LOAD_METHOD",
            "self.secondary_to_main_frames.get"
        ],
        [
            "LOAD_FAST",
            "caller_frame"
        ],
        [
            "CALL",
            "self.secondary_to_main_frames.get(caller_frame)"
        ],
        [
            "STORE_FAST",
            "main_frame"
        ],
        [
            "LOAD_FAST",
            "main_frame"
        ],
        [
            "LOAD_FAST",
            "main_frame"
        ],
        [
            "STORE_FAST",
            "caller_frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_FAST",
            "caller_frame"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[caller_frame]"
        ],
        [
            "STORE_FAST",
            "frame_info"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.expression_stack"
        ],
        [
            "STORE_FAST",
            "expression_stack"
        ],
        [
            "LOAD_FAST",
            "expression_stack"
        ],
        [
            "LOAD_FAST",
            "expression_stack"
        ],
        [
            "BINARY_SUBSCR",
            "expression_stack[-1]"
        ],
        [
            "STORE_FAST",
            "call_node"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.statement_stack"
        ],
        [
            "BINARY_SUBSCR",
            "frame_info.statement_stack[-1]"
        ],
        [
            "STORE_FAST",
            "call_node"
        ],
        [
            "LOAD_FAST",
            "caller_frame"
        ],
        [
            "LOAD_FAST",
            "call_node"
        ],
        [
            "STORE_NAME",
            "\"\"\"\n    This does the AST modifications that call the hooks.\n    \"\"\""
        ],
        [
            "STORE_NAME",
            "    def generic_visit(self, node):\n        # type: (ast.AST) -> ast.AST\n        if not getattr(node, '_visit_ignore', False):\n            if (isinstance(node, ast.expr) and\n                    not (hasattr(node, \"ctx\") and not isinstance(node.ctx, ast.Load)) and\n                    not isinstance(node, getattr(ast, 'Starred', ()))):\n                return self.visit_expr(node)\n            if isinstance(node, ast.stmt):\n                return self.visit_stmt(node)\n        return super(_NodeVisitor, self).generic_visit(node)"
        ],
        [
            "STORE_NAME",
            "    def visit_expr(self, node):\n        # type: (ast.expr) -> ast.Call\n        \"\"\"\n        each expression e gets wrapped like this:\n            _treetrace_hidden_after_expr(_treetrace_hidden_before_expr(_tree_index), e)\n\n        where the _treetrace_* functions are the corresponding methods with the\n        TreeTracerBase and traced_file arguments already filled in (see _trace_methods_dict)\n        \"\"\"\n\n        before_marker = self._create_simple_marker_call(node, TreeTracerBase._treetrace_hidden_before_expr)\n        ast.copy_location(before_marker, node)\n\n        after_marker = ast.Call(\n            func=ast.Name(id=TreeTracerBase._treetrace_hidden_after_expr.__name__,\n                          ctx=ast.Load()),\n            args=[\n                before_marker,\n                super(_NodeVisitor, self).generic_visit(node),\n            ],\n            keywords=[],\n        )\n        ast.copy_location(after_marker, node)\n        ast.fix_missing_locations(after_marker)\n\n        return after_marker"
        ],
        [
            "STORE_NAME",
            "    def visit_stmt(self, node):\n        # type: (ast.stmt) -> ast.With\n        \"\"\"\n        Every statement in the original code becomes:\n\n        with _treetrace_hidden_with_stmt(_tree_index):\n            <statement>\n\n        where the _treetrace_hidden_with_stmt function is the the corresponding method with the\n        TreeTracerBase and traced_file arguments already filled in (see _trace_methods_dict)\n        \"\"\"\n        context_expr = self._create_simple_marker_call(\n            super(_NodeVisitor, self).generic_visit(node),\n            TreeTracerBase._treetrace_hidden_with_stmt)\n\n        if PY3:\n            wrapped = ast.With(\n                items=[ast.withitem(context_expr=context_expr)],\n                body=[node],\n            )\n        else:\n            wrapped = ast.With(\n                context_expr=context_expr,\n                body=[node],\n            )\n        ast.copy_location(wrapped, node)\n        ast.fix_missing_locations(wrapped)\n        return wrapped"
        ],
        [
            "LOAD_NAME",
            "staticmethod"
        ],
        [
            "CALL",
            "staticmethod"
        ],
        [
            "STORE_NAME",
            "    @staticmethod\n    def _create_simple_marker_call(node, func):\n        # type: (ast.AST, Callable) -> ast.Call\n        \"\"\"\n        Returns a Call node representing `func(node._tree_index)`\n        where node._tree_index is a numerical literal which allows the node object\n        to be retrieved later through the nodes attribute of a TracedFile.\n        \"\"\"\n        return ast.Call(\n            func=ast.Name(id=func.__name__,\n                          ctx=ast.Load()),\n            args=[ast.Num(node._tree_index)],\n            keywords=[],\n        )"
        ],
        [
            "STORE_NAME",
            "    @staticmethod\n    def _create_simple_marker_call(node, func):\n        # type: (ast.AST, Callable) -> ast.Call\n        \"\"\"\n        Returns a Call node representing `func(node._tree_index)`\n        where node._tree_index is a numerical literal which allows the node object\n        to be retrieved later through the nodes attribute of a TracedFile.\n        \"\"\"\n        return ast.Call(\n            func=ast.Name(id=func.__name__,\n                          ctx=ast.Load()),\n            args=[ast.Num(node._tree_index)],\n            keywords=[],\n        )"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "getattr(node, '_visit_ignore', False)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.expr"
        ],
        [
            "CALL",
            "isinstance(node, ast.expr)"
        ],
        [
            "LOAD_GLOBAL",
            "hasattr"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "hasattr(node, \"ctx\")"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.ctx"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Load"
        ],
        [
            "CALL",
            "isinstance(node.ctx, ast.Load)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "CALL",
            "getattr(ast, 'Starred', ())"
        ],
        [
            "CALL",
            "isinstance(node, getattr(ast, 'Starred', ()))"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.visit_expr"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "self.visit_expr(node)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.stmt"
        ],
        [
            "CALL",
            "isinstance(node, ast.stmt)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.visit_stmt"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "self.visit_stmt(node)"
        ],
        [
            "LOAD_GLOBAL",
            "super"
        ],
        [
            "LOAD_GLOBAL",
            "_NodeVisitor"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "super(_NodeVisitor, self)"
        ],
        [
            "LOAD_METHOD",
            "super(_NodeVisitor, self).generic_visit"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "super(_NodeVisitor, self).generic_visit(node)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._create_simple_marker_call"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "TreeTracerBase"
        ],
        [
            "LOAD_ATTR",
            "TreeTracerBase._treetrace_hidden_before_expr"
        ],
        [
            "CALL",
            "self._create_simple_marker_call(node, TreeTracerBase._treetrace_hidden_before_expr)"
        ],
        [
            "STORE_FAST",
            "before_marker"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.copy_location"
        ],
        [
            "LOAD_FAST",
            "before_marker"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "ast.copy_location(before_marker, node)"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Call"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Name"
        ],
        [
            "LOAD_GLOBAL",
            "TreeTracerBase"
        ],
        [
            "LOAD_ATTR",
            "TreeTracerBase._treetrace_hidden_after_expr"
        ],
        [
            "LOAD_ATTR",
            "TreeTracerBase._treetrace_hidden_after_expr.__name__"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Load"
        ],
        [
            "CALL",
            "ast.Load()"
        ],
        [
            "CALL",
            "ast.Name(id=TreeTracerBase._treetrace_hidden_after_expr.__name__,\n                          ctx=ast.Load())"
        ],
        [
            "LOAD_FAST",
            "before_marker"
        ],
        [
            "LOAD_GLOBAL",
            "super"
        ],
        [
            "LOAD_GLOBAL",
            "_NodeVisitor"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "super(_NodeVisitor, self)"
        ],
        [
            "LOAD_METHOD",
            "super(_NodeVisitor, self).generic_visit"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "super(_NodeVisitor, self).generic_visit(node)"
        ],
        [
            "CALL",
            "ast.Call(\n            func=ast.Name(id=TreeTracerBase._treetrace_hidden_after_expr.__name__,\n                          ctx=ast.Load()),\n            args=[\n                before_marker,\n                super(_NodeVisitor, self).generic_visit(node),\n            ],\n            keywords=[],\n        )"
        ],
        [
            "STORE_FAST",
            "after_marker"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.copy_location"
        ],
        [
            "LOAD_FAST",
            "after_marker"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "ast.copy_location(after_marker, node)"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.fix_missing_locations"
        ],
        [
            "LOAD_FAST",
            "after_marker"
        ],
        [
            "CALL",
            "ast.fix_missing_locations(after_marker)"
        ],
        [
            "LOAD_FAST",
            "after_marker"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._create_simple_marker_call"
        ],
        [
            "LOAD_GLOBAL",
            "super"
        ],
        [
            "LOAD_GLOBAL",
            "_NodeVisitor"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "super(_NodeVisitor, self)"
        ],
        [
            "LOAD_METHOD",
            "super(_NodeVisitor, self).generic_visit"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "super(_NodeVisitor, self).generic_visit(node)"
        ],
        [
            "LOAD_GLOBAL",
            "TreeTracerBase"
        ],
        [
            "LOAD_ATTR",
            "TreeTracerBase._treetrace_hidden_with_stmt"
        ],
        [
            "CALL",
            "self._create_simple_marker_call(\n            super(_NodeVisitor, self).generic_visit(node),\n            TreeTracerBase._treetrace_hidden_with_stmt)"
        ],
        [
            "STORE_FAST",
            "context_expr"
        ],
        [
            "LOAD_GLOBAL",
            "PY3"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.With"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.withitem"
        ],
        [
            "LOAD_FAST",
            "context_expr"
        ],
        [
            "CALL",
            "ast.withitem(context_expr=context_expr)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "ast.With(\n                items=[ast.withitem(context_expr=context_expr)],\n                body=[node],\n            )"
        ],
        [
            "STORE_FAST",
            "wrapped"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.With"
        ],
        [
            "LOAD_FAST",
            "context_expr"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "ast.With(\n                context_expr=context_expr,\n                body=[node],\n            )"
        ],
        [
            "STORE_FAST",
            "wrapped"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.copy_location"
        ],
        [
            "LOAD_FAST",
            "wrapped"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "ast.copy_location(wrapped, node)"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.fix_missing_locations"
        ],
        [
            "LOAD_FAST",
            "wrapped"
        ],
        [
            "CALL",
            "ast.fix_missing_locations(wrapped)"
        ],
        [
            "LOAD_FAST",
            "wrapped"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Call"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Name"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.__name__"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Load"
        ],
        [
            "CALL",
            "ast.Load()"
        ],
        [
            "CALL",
            "ast.Name(id=func.__name__,\n                          ctx=ast.Load())"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Num"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._tree_index"
        ],
        [
            "CALL",
            "ast.Num(node._tree_index)"
        ],
        [
            "CALL",
            "ast.Call(\n            func=ast.Name(id=func.__name__,\n                          ctx=ast.Load()),\n            args=[ast.Num(node._tree_index)],\n            keywords=[],\n        )"
        ],
        [
            "STORE_NAME",
            "__slots__"
        ],
        [
            "STORE_NAME",
            "    def __init__(self, tracer, node, frame):\n        # type: (TreeTracerBase, ast.stmt, FrameType) -> None\n        self.tracer = tracer\n        self.node = node\n        self.frame = frame"
        ],
        [
            "STORE_NAME",
            "    def __enter__(self):\n        tracer = self.tracer\n        node = self.node\n        frame = self.frame\n        if getattr(node, '_enter_call_node', False):\n            tracer._enter_call(node, frame)\n        frame_info = tracer.stack[frame]\n        frame_info.expression_stack = []\n        frame_info.statement_stack.append(node)\n        tracer.before_stmt(node, frame)"
        ],
        [
            "STORE_NAME",
            "    def __exit__(self, exc_type, exc_val, exc_tb):\n        # type: (Type[Exception], Exception, TracebackType) -> bool\n        node = self.node\n        tracer = self.tracer\n        frame = self.frame\n        frame_info = tracer.stack[frame]\n\n        frame_info.statement_stack.pop()\n\n        exc_node = None  # type: Optional[Union[ast.expr, ast.stmt]]\n        if exc_val and exc_val is not frame_info.exc_value:\n            exc_node = node\n            frame_info.exc_value = exc_val\n\n            # Call the after_expr hook if the exception was raised by an expression\n            expression_stack = frame_info.expression_stack\n            if expression_stack:\n                exc_node = expression_stack[-1]\n                tracer._after_expr(exc_node, frame, None, exc_val, exc_tb)\n\n        result = tracer.after_stmt(node, frame, exc_val, exc_tb, exc_node)\n\n        if isinstance(node, ast.Return):\n            frame_info.return_node = node\n\n        parent = node.parent  # type: ast.AST\n        return_node = frame_info.return_node\n        exiting = (isinstance(parent, (ast.FunctionDef, ast.Module)) and\n                   (node is parent.body[-1] or\n                    exc_val or\n                    return_node))\n        if exiting:\n            caller_frame, call_node = tracer._get_caller_stuff(frame)\n            return_value = None\n            if return_node and return_node.value and not exc_val:\n                return_value = frame_info.expression_values[return_node.value]\n            tracer.exit_call(ExitCallInfo(call_node,\n                                          return_node,\n                                          caller_frame,\n                                          frame,\n                                          return_value,\n                                          exc_val,\n                                          exc_tb\n                                          ))\n\n            del tracer.stack[frame]\n            for secondary_frame in self.tracer.main_to_secondary_frames.pop(frame):\n                del self.tracer.secondary_to_main_frames[secondary_frame]\n\n        return result"
        ],
        [
            "LOAD_FAST",
            "tracer"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.tracer"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.node"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.tracer"
        ],
        [
            "STORE_FAST",
            "tracer"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.node"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.frame"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "getattr(node, '_enter_call_node', False)"
        ],
        [
            "LOAD_FAST",
            "tracer"
        ],
        [
            "LOAD_METHOD",
            "tracer._enter_call"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "tracer._enter_call(node, frame)"
        ],
        [
            "LOAD_FAST",
            "tracer"
        ],
        [
            "LOAD_ATTR",
            "tracer.stack"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "BINARY_SUBSCR",
            "tracer.stack[frame]"
        ],
        [
            "STORE_FAST",
            "frame_info"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "STORE_ATTR",
            "frame_info.expression_stack"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.statement_stack"
        ],
        [
            "LOAD_METHOD",
            "frame_info.statement_stack.append"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "frame_info.statement_stack.append(node)"
        ],
        [
            "LOAD_FAST",
            "tracer"
        ],
        [
            "LOAD_METHOD",
            "tracer.before_stmt"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "tracer.before_stmt(node, frame)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.node"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.tracer"
        ],
        [
            "STORE_FAST",
            "tracer"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.frame"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "tracer"
        ],
        [
            "LOAD_ATTR",
            "tracer.stack"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "BINARY_SUBSCR",
            "tracer.stack[frame]"
        ],
        [
            "STORE_FAST",
            "frame_info"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.statement_stack"
        ],
        [
            "LOAD_METHOD",
            "frame_info.statement_stack.pop"
        ],
        [
            "CALL",
            "frame_info.statement_stack.pop()"
        ],
        [
            "STORE_FAST",
            "exc_node"
        ],
        [
            "LOAD_FAST",
            "exc_val"
        ],
        [
            "LOAD_FAST",
            "exc_val"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.exc_value"
        ],
        [
            "IS_OP",
            "exc_val is not frame_info.exc_value"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "STORE_FAST",
            "exc_node"
        ],
        [
            "LOAD_FAST",
            "exc_val"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "STORE_ATTR",
            "frame_info.exc_value"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.expression_stack"
        ],
        [
            "STORE_FAST",
            "expression_stack"
        ],
        [
            "LOAD_FAST",
            "expression_stack"
        ],
        [
            "LOAD_FAST",
            "expression_stack"
        ],
        [
            "BINARY_SUBSCR",
            "expression_stack[-1]"
        ],
        [
            "STORE_FAST",
            "exc_node"
        ],
        [
            "LOAD_FAST",
            "tracer"
        ],
        [
            "LOAD_METHOD",
            "tracer._after_expr"
        ],
        [
            "LOAD_FAST",
            "exc_node"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "exc_val"
        ],
        [
            "LOAD_FAST",
            "exc_tb"
        ],
        [
            "CALL",
            "tracer._after_expr(exc_node, frame, None, exc_val, exc_tb)"
        ],
        [
            "LOAD_FAST",
            "tracer"
        ],
        [
            "LOAD_METHOD",
            "tracer.after_stmt"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "exc_val"
        ],
        [
            "LOAD_FAST",
            "exc_tb"
        ],
        [
            "LOAD_FAST",
            "exc_node"
        ],
        [
            "CALL",
            "tracer.after_stmt(node, frame, exc_val, exc_tb, exc_node)"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Return"
        ],
        [
            "CALL",
            "isinstance(node, ast.Return)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "STORE_ATTR",
            "frame_info.return_node"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "STORE_FAST",
            "parent"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.return_node"
        ],
        [
            "STORE_FAST",
            "return_node"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "parent"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.FunctionDef"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Module"
        ],
        [
            "CALL",
            "isinstance(parent, (ast.FunctionDef, ast.Module))"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "parent"
        ],
        [
            "LOAD_ATTR",
            "parent.body"
        ],
        [
            "BINARY_SUBSCR",
            "parent.body[-1]"
        ],
        [
            "IS_OP",
            "node is parent.body[-1]"
        ],
        [
            "LOAD_FAST",
            "exc_val"
        ],
        [
            "LOAD_FAST",
            "return_node"
        ],
        [
            "STORE_FAST",
            "exiting"
        ],
        [
            "LOAD_FAST",
            "exiting"
        ],
        [
            "LOAD_FAST",
            "tracer"
        ],
        [
            "LOAD_METHOD",
            "tracer._get_caller_stuff"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "tracer._get_caller_stuff(frame)"
        ],
        [
            "STORE_FAST",
            "caller_frame"
        ],
        [
            "STORE_FAST",
            "call_node"
        ],
        [
            "STORE_FAST",
            "return_value"
        ],
        [
            "LOAD_FAST",
            "return_node"
        ],
        [
            "LOAD_FAST",
            "return_node"
        ],
        [
            "LOAD_ATTR",
            "return_node.value"
        ],
        [
            "LOAD_FAST",
            "exc_val"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.expression_values"
        ],
        [
            "LOAD_FAST",
            "return_node"
        ],
        [
            "LOAD_ATTR",
            "return_node.value"
        ],
        [
            "BINARY_SUBSCR",
            "frame_info.expression_values[return_node.value]"
        ],
        [
            "STORE_FAST",
            "return_value"
        ],
        [
            "LOAD_FAST",
            "tracer"
        ],
        [
            "LOAD_METHOD",
            "tracer.exit_call"
        ],
        [
            "LOAD_GLOBAL",
            "ExitCallInfo"
        ],
        [
            "LOAD_FAST",
            "call_node"
        ],
        [
            "LOAD_FAST",
            "return_node"
        ],
        [
            "LOAD_FAST",
            "caller_frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "return_value"
        ],
        [
            "LOAD_FAST",
            "exc_val"
        ],
        [
            "LOAD_FAST",
            "exc_tb"
        ],
        [
            "CALL",
            "ExitCallInfo(call_node,\n                                          return_node,\n                                          caller_frame,\n                                          frame,\n                                          return_value,\n                                          exc_val,\n                                          exc_tb\n                                          )"
        ],
        [
            "CALL",
            "tracer.exit_call(ExitCallInfo(call_node,\n                                          return_node,\n                                          caller_frame,\n                                          frame,\n                                          return_value,\n                                          exc_val,\n                                          exc_tb\n                                          ))"
        ],
        [
            "LOAD_FAST",
            "tracer"
        ],
        [
            "LOAD_ATTR",
            "tracer.stack"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "DELETE_SUBSCR",
            "tracer.stack[frame]"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.tracer"
        ],
        [
            "LOAD_ATTR",
            "self.tracer.main_to_secondary_frames"
        ],
        [
            "LOAD_METHOD",
            "self.tracer.main_to_secondary_frames.pop"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "self.tracer.main_to_secondary_frames.pop(frame)"
        ],
        [
            "STORE_FAST",
            "secondary_frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.tracer"
        ],
        [
            "LOAD_ATTR",
            "self.tracer.secondary_to_main_frames"
        ],
        [
            "LOAD_FAST",
            "secondary_frame"
        ],
        [
            "DELETE_SUBSCR",
            "self.tracer.secondary_to_main_frames[secondary_frame]"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "AttributeError"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_DEREF",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "STORE_FAST",
            "parent"
        ],
        [
            "LOAD_GLOBAL",
            "AttributeError"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "parent"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.FunctionDef"
        ],
        [
            "CALL",
            "isinstance(parent, ast.FunctionDef)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "parent"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.For"
        ],
        [
            "CALL",
            "isinstance(parent, ast.For)"
        ],
        [
            "LOAD_FAST",
            "parent"
        ],
        [
            "LOAD_ATTR",
            "parent.iter"
        ],
        [
            "LOAD_DEREF",
            "node"
        ],
        [
            "IS_OP",
            "parent.iter is not node"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "parent"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.While"
        ],
        [
            "CALL",
            "isinstance(parent, ast.While)"
        ],
        [
            "LOAD_DEREF",
            "node"
        ],
        [
            "LOAD_FAST",
            "parent"
        ],
        [
            "LOAD_ATTR",
            "parent.orelse"
        ],
        [
            "CONTAINS_OP",
            "node not in parent.orelse"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "parent"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.comprehension"
        ],
        [
            "CALL",
            "isinstance(parent, ast.comprehension)"
        ],
        [
            "LOAD_DEREF",
            "node"
        ],
        [
            "LOAD_FAST",
            "parent"
        ],
        [
            "LOAD_ATTR",
            "parent.ifs"
        ],
        [
            "CONTAINS_OP",
            "node in parent.ifs"
        ],
        [
            "STORE_FAST",
            "is_containing_loop"
        ],
        [
            "LOAD_FAST",
            "is_containing_loop"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_METHOD",
            "result.append"
        ],
        [
            "LOAD_FAST",
            "parent"
        ],
        [
            "CALL",
            "result.append(parent)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "parent"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.ListComp"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.GeneratorExp"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.DictComp"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.SetComp"
        ],
        [
            "CALL",
            "isinstance(parent, (ast.ListComp,\n                                 ast.GeneratorExp,\n                                 ast.DictComp,\n                                 ast.SetComp))"
        ],
        [
            "LOAD_FAST",
            "parent"
        ],
        [
            "LOAD_ATTR",
            "parent.generators"
        ],
        [
            "STORE_FAST",
            "generators"
        ],
        [
            "LOAD_DEREF",
            "node"
        ],
        [
            "LOAD_FAST",
            "generators"
        ],
        [
            "CONTAINS_OP",
            "node in generators"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_GLOBAL",
            "takewhile"
        ],
        [
            "LOAD_FAST",
            "generators"
        ],
        [
            "CALL",
            "takewhile(lambda n: n != node, generators)"
        ],
        [
            "CALL",
            "list(takewhile(lambda n: n != node, generators))"
        ],
        [
            "STORE_FAST",
            "generators"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_METHOD",
            "result.extend"
        ],
        [
            "LOAD_GLOBAL",
            "reversed"
        ],
        [
            "LOAD_FAST",
            "generators"
        ],
        [
            "CALL",
            "reversed(generators)"
        ],
        [
            "CALL",
            "result.extend(reversed(generators))"
        ],
        [
            "LOAD_FAST",
            "parent"
        ],
        [
            "STORE_DEREF",
            "node"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_METHOD",
            "result.reverse"
        ],
        [
            "CALL",
            "result.reverse()"
        ],
        [
            "LOAD_GLOBAL",
            "tuple"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "CALL",
            "tuple(result)"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "LOAD_DEREF",
            "node"
        ],
        [
            "COMPARE_OP",
            "n != node"
        ]
    ],
    "tracer2.py": [
        [
            "STORE_NAME",
            "import functools"
        ],
        [
            "STORE_NAME",
            "import inspect"
        ],
        [
            "STORE_NAME",
            "import os"
        ],
        [
            "STORE_NAME",
            "import re"
        ],
        [
            "STORE_NAME",
            "import sys"
        ],
        [
            "STORE_NAME",
            "import threading"
        ],
        [
            "STORE_NAME",
            "from collections import OrderedDict"
        ],
        [
            "STORE_NAME",
            "import six"
        ],
        [
            "STORE_NAME",
            "from cheap_repr import cheap_repr, find_repr_function"
        ],
        [
            "STORE_NAME",
            "from cheap_repr import cheap_repr, find_repr_function"
        ],
        [
            "STORE_NAME",
            "from snoop.utils import my_cheap_repr, NO_ASTTOKENS, ArgDefaultDict, iscoroutinefunction, \\\n    truncate_list, ensure_tuple, is_comprehension_frame, no_args_decorator"
        ],
        [
            "STORE_NAME",
            "from snoop.utils import my_cheap_repr, NO_ASTTOKENS, ArgDefaultDict, iscoroutinefunction, \\\n    truncate_list, ensure_tuple, is_comprehension_frame, no_args_decorator"
        ],
        [
            "STORE_NAME",
            "from snoop.utils import my_cheap_repr, NO_ASTTOKENS, ArgDefaultDict, iscoroutinefunction, \\\n    truncate_list, ensure_tuple, is_comprehension_frame, no_args_decorator"
        ],
        [
            "STORE_NAME",
            "from snoop.utils import my_cheap_repr, NO_ASTTOKENS, ArgDefaultDict, iscoroutinefunction, \\\n    truncate_list, ensure_tuple, is_comprehension_frame, no_args_decorator"
        ],
        [
            "STORE_NAME",
            "from snoop.utils import my_cheap_repr, NO_ASTTOKENS, ArgDefaultDict, iscoroutinefunction, \\\n    truncate_list, ensure_tuple, is_comprehension_frame, no_args_decorator"
        ],
        [
            "STORE_NAME",
            "from snoop.utils import my_cheap_repr, NO_ASTTOKENS, ArgDefaultDict, iscoroutinefunction, \\\n    truncate_list, ensure_tuple, is_comprehension_frame, no_args_decorator"
        ],
        [
            "STORE_NAME",
            "from snoop.utils import my_cheap_repr, NO_ASTTOKENS, ArgDefaultDict, iscoroutinefunction, \\\n    truncate_list, ensure_tuple, is_comprehension_frame, no_args_decorator"
        ],
        [
            "STORE_NAME",
            "from snoop.utils import my_cheap_repr, NO_ASTTOKENS, ArgDefaultDict, iscoroutinefunction, \\\n    truncate_list, ensure_tuple, is_comprehension_frame, no_args_decorator"
        ],
        [
            "STORE_NAME",
            "from .formatting import Event, Source"
        ],
        [
            "STORE_NAME",
            "from .formatting import Event, Source"
        ],
        [
            "STORE_NAME",
            "from .variables import CommonVariable, Exploding, BaseVariable"
        ],
        [
            "STORE_NAME",
            "from .variables import CommonVariable, Exploding, BaseVariable"
        ],
        [
            "STORE_NAME",
            "from .variables import CommonVariable, Exploding, BaseVariable"
        ],
        [
            "LOAD_NAME",
            "find_repr_function"
        ],
        [
            "LOAD_NAME",
            "six"
        ],
        [
            "LOAD_ATTR",
            "six.text_type"
        ],
        [
            "CALL",
            "find_repr_function(six.text_type)"
        ],
        [
            "STORE_ATTR",
            "find_repr_function(six.text_type).maxparts"
        ],
        [
            "LOAD_NAME",
            "find_repr_function"
        ],
        [
            "LOAD_NAME",
            "six"
        ],
        [
            "LOAD_ATTR",
            "six.binary_type"
        ],
        [
            "CALL",
            "find_repr_function(six.binary_type)"
        ],
        [
            "STORE_ATTR",
            "find_repr_function(six.binary_type).maxparts"
        ],
        [
            "LOAD_NAME",
            "find_repr_function"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "find_repr_function(object)"
        ],
        [
            "STORE_ATTR",
            "find_repr_function(object).maxparts"
        ],
        [
            "LOAD_NAME",
            "find_repr_function"
        ],
        [
            "LOAD_NAME",
            "int"
        ],
        [
            "CALL",
            "find_repr_function(int)"
        ],
        [
            "STORE_ATTR",
            "find_repr_function(int).maxparts"
        ],
        [
            "LOAD_NAME",
            "cheap_repr"
        ],
        [
            "STORE_ATTR",
            "cheap_repr.suppression_threshold"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class FrameInfo(object):\n    def __init__(self, frame):\n        self.frame = frame\n        self.local_reprs = {}\n        self.last_line_no = frame.f_lineno\n        self.comprehension_variables = OrderedDict()\n        self.source = Source.for_frame(frame)\n        self.is_generator = frame.f_code.co_flags & inspect.CO_GENERATOR\n        self.had_exception = False\n        if is_comprehension_frame(frame):\n            self.comprehension_type = (\n                    re.match(r'<(\\w+)comp>', frame.f_code.co_name).group(1).title()\n                    + u' comprehension'\n            )\n        else:\n            self.comprehension_type = ''\n\n    def update_variables(self, watch, watch_extras, event):\n        self.last_line_no = self.frame.f_lineno\n        old_local_reprs = self.local_reprs\n        self.local_reprs = OrderedDict(\n            (source, my_cheap_repr(value))\n            for source, value in\n            self.get_local_reprs(watch, watch_extras)\n        )\n\n        if self.comprehension_type:\n            for name, value_repr in self.local_reprs.items():\n                values = self.comprehension_variables.setdefault(name, [])\n                if not values or values[-1] != value_repr:\n                    values.append(value_repr)\n                    values[:] = truncate_list(values, 11)\n            if event in ('return', 'exception'):\n                return [\n                    (name, ', '.join(values))\n                    for name, values in self.comprehension_variables.items()\n                ]\n            else:\n                return []\n\n        variables = []\n        for name, value_repr in self.local_reprs.items():\n            if name not in old_local_reprs or old_local_reprs[name] != value_repr:\n                variables.append((name, value_repr))\n        return variables\n\n    def get_local_reprs(self, watch, watch_extras):\n        frame = self.frame\n        code = frame.f_code\n        vars_order = code.co_varnames + code.co_cellvars + code.co_freevars + tuple(frame.f_locals.keys())\n\n        result_items = sorted(\n            frame.f_locals.items(),\n            key=lambda key_value: vars_order.index(key_value[0])\n        )\n\n        for variable in watch:\n            result_items += sorted(variable.items(frame))\n\n        for source, value in result_items:\n            yield source, value\n            for extra in watch_extras:\n                try:\n                    pair = extra(source, value)\n                except Exception:\n                    pass\n                else:\n                    if pair is not None:\n                        assert len(pair) == 2, \"Watch extra must return pair or None\"\n                        yield pair"
        ],
        [
            "STORE_NAME",
            "class FrameInfo(object):\n    def __init__(self, frame):\n        self.frame = frame\n        self.local_reprs = {}\n        self.last_line_no = frame.f_lineno\n        self.comprehension_variables = OrderedDict()\n        self.source = Source.for_frame(frame)\n        self.is_generator = frame.f_code.co_flags & inspect.CO_GENERATOR\n        self.had_exception = False\n        if is_comprehension_frame(frame):\n            self.comprehension_type = (\n                    re.match(r'<(\\w+)comp>', frame.f_code.co_name).group(1).title()\n                    + u' comprehension'\n            )\n        else:\n            self.comprehension_type = ''\n\n    def update_variables(self, watch, watch_extras, event):\n        self.last_line_no = self.frame.f_lineno\n        old_local_reprs = self.local_reprs\n        self.local_reprs = OrderedDict(\n            (source, my_cheap_repr(value))\n            for source, value in\n            self.get_local_reprs(watch, watch_extras)\n        )\n\n        if self.comprehension_type:\n            for name, value_repr in self.local_reprs.items():\n                values = self.comprehension_variables.setdefault(name, [])\n                if not values or values[-1] != value_repr:\n                    values.append(value_repr)\n                    values[:] = truncate_list(values, 11)\n            if event in ('return', 'exception'):\n                return [\n                    (name, ', '.join(values))\n                    for name, values in self.comprehension_variables.items()\n                ]\n            else:\n                return []\n\n        variables = []\n        for name, value_repr in self.local_reprs.items():\n            if name not in old_local_reprs or old_local_reprs[name] != value_repr:\n                variables.append((name, value_repr))\n        return variables\n\n    def get_local_reprs(self, watch, watch_extras):\n        frame = self.frame\n        code = frame.f_code\n        vars_order = code.co_varnames + code.co_cellvars + code.co_freevars + tuple(frame.f_locals.keys())\n\n        result_items = sorted(\n            frame.f_locals.items(),\n            key=lambda key_value: vars_order.index(key_value[0])\n        )\n\n        for variable in watch:\n            result_items += sorted(variable.items(frame))\n\n        for source, value in result_items:\n            yield source, value\n            for extra in watch_extras:\n                try:\n                    pair = extra(source, value)\n                except Exception:\n                    pass\n                else:\n                    if pair is not None:\n                        assert len(pair) == 2, \"Watch extra must return pair or None\"\n                        yield pair"
        ],
        [
            "LOAD_NAME",
            "threading"
        ],
        [
            "LOAD_ATTR",
            "threading.local"
        ],
        [
            "CALL",
            "threading.local()"
        ],
        [
            "STORE_NAME",
            "thread_global"
        ],
        [
            "LOAD_NAME",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.dirname"
        ],
        [
            "LOAD_ATTR",
            "(lambda: 0).__code__"
        ],
        [
            "LOAD_ATTR",
            "(lambda: 0).__code__.co_filename"
        ],
        [
            "CALL",
            "os.path.dirname((lambda: 0).__code__.co_filename)"
        ],
        [
            "STORE_NAME",
            "internal_directories"
        ],
        [
            "STORE_NAME",
            "import birdseye"
        ],
        [
            "LOAD_NAME",
            "internal_directories"
        ],
        [
            "LOAD_NAME",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.dirname"
        ],
        [
            "LOAD_NAME",
            "birdseye"
        ],
        [
            "LOAD_ATTR",
            "birdseye.__file__"
        ],
        [
            "CALL",
            "os.path.dirname(birdseye.__file__)"
        ],
        [
            "BINARY_OP",
            "internal_directories += (os.path.dirname(birdseye.__file__),)"
        ],
        [
            "STORE_NAME",
            "internal_directories"
        ],
        [
            "LOAD_NAME",
            "ImportError"
        ],
        [
            "LOAD_NAME",
            "type"
        ],
        [
            "CALL",
            "class TracerMeta(type):\n    def __new__(mcs, *args, **kwargs):\n        result = super(TracerMeta, mcs).__new__(mcs, *args, **kwargs)\n        result.default = result()\n        return result\n\n    def __call__(cls, *args, **kwargs):\n        if no_args_decorator(args, kwargs):\n            return cls.default(args[0])\n        else:\n            return super(TracerMeta, cls).__call__(*args, **kwargs)\n\n    def __enter__(self):\n        return self.default.__enter__(context=1)\n\n    def __exit__(self, *args):\n        return self.default.__exit__(*args, context=1)"
        ],
        [
            "STORE_NAME",
            "class TracerMeta(type):\n    def __new__(mcs, *args, **kwargs):\n        result = super(TracerMeta, mcs).__new__(mcs, *args, **kwargs)\n        result.default = result()\n        return result\n\n    def __call__(cls, *args, **kwargs):\n        if no_args_decorator(args, kwargs):\n            return cls.default(args[0])\n        else:\n            return super(TracerMeta, cls).__call__(*args, **kwargs)\n\n    def __enter__(self):\n        return self.default.__enter__(context=1)\n\n    def __exit__(self, *args):\n        return self.default.__exit__(*args, context=1)"
        ],
        [
            "LOAD_NAME",
            "six"
        ],
        [
            "LOAD_ATTR",
            "six.add_metaclass"
        ],
        [
            "LOAD_NAME",
            "TracerMeta"
        ],
        [
            "CALL",
            "six.add_metaclass(TracerMeta)"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "@six.add_metaclass(TracerMeta)\nclass Tracer(object):\n    def __init__(\n            self,\n            watch=(),\n            watch_explode=(),\n            depth=1,\n    ):\n        self.watch = [\n            v if isinstance(v, BaseVariable) else CommonVariable(v)\n            for v in ensure_tuple(watch)\n        ] + [\n            v if isinstance(v, BaseVariable) else Exploding(v)\n            for v in ensure_tuple(watch_explode)\n        ]\n        self.frame_infos = ArgDefaultDict(FrameInfo)\n        self.depth = depth\n        assert self.depth >= 1\n        self.target_codes = set()\n        self.target_frames = set()\n\n    def __call__(self, function):\n        if iscoroutinefunction(function):\n            raise NotImplementedError(\"coroutines are not supported, sorry!\")\n\n        self.target_codes.add(function.__code__)\n\n        @functools.wraps(function)\n        def simple_wrapper(*args, **kwargs):\n            with self:\n                return function(*args, **kwargs)\n\n        @functools.wraps(function)\n        def generator_wrapper(*args, **kwargs):\n            gen = function(*args, **kwargs)\n            method, incoming = gen.send, None\n            while True:\n                with self:\n                    try:\n                        outgoing = method(incoming)\n                    except StopIteration:\n                        return\n                try:\n                    method, incoming = gen.send, (yield outgoing)\n                except Exception as e:\n                    method, incoming = gen.throw, e\n\n        if inspect.isgeneratorfunction(function):\n            return generator_wrapper\n        else:\n            return simple_wrapper\n\n    def __enter__(self, context=0):\n        if not self.config.enabled:\n            return\n\n        calling_frame = sys._getframe(context + 1)\n        if not self._is_internal_frame(calling_frame):\n            calling_frame.f_trace = self.trace\n            self.target_frames.add(calling_frame)\n            self.config.last_frame = calling_frame\n            self.trace(calling_frame, 'enter', None)\n\n        stack = thread_global.__dict__.setdefault('original_trace_functions', [])\n        stack.append(sys.gettrace())\n        sys.settrace(self.trace)\n\n    def __exit__(self, exc_type, exc_value, exc_traceback, context=0):\n        if not self.config.enabled:\n            return\n\n        stack = thread_global.original_trace_functions\n        sys.settrace(stack.pop())\n        calling_frame = sys._getframe(context + 1)\n        self.trace(calling_frame, 'exit', None)\n        self.target_frames.discard(calling_frame)\n        self.frame_infos.pop(calling_frame, None)\n\n    def _is_internal_frame(self, frame):\n        return frame.f_code.co_filename.startswith(internal_directories)\n    \n    def _is_traced_frame(self, frame):\n        return frame.f_code in self.target_codes or frame in self.target_frames\n\n    def trace(self, frame, event, arg):\n        if not self._is_traced_frame(frame):\n            if (\n                    self.depth == 1\n                    or self._is_internal_frame(frame)\n            ) and not is_comprehension_frame(frame):\n                return None\n            else:\n                candidate = frame\n                i = 0\n                while True:\n                    if is_comprehension_frame(candidate):\n                        candidate = candidate.f_back\n                        continue\n                    i += 1\n                    if self._is_traced_frame(candidate):\n                        break\n                    candidate = candidate.f_back\n                    if i >= self.depth or candidate is None or self._is_internal_frame(candidate):\n                        return None\n\n        thread_local = self.config.thread_local\n        thread_local.__dict__.setdefault('depth', -1)\n        frame_info = self.frame_infos[frame]\n        if event in ('call', 'enter'):\n            thread_local.depth += 1\n        elif self.config.last_frame and self.config.last_frame is not frame:\n            line_no = frame_info.last_line_no\n            trace_event = Event(frame_info, event, arg, thread_local.depth, line_no=line_no)\n            line = self.config.formatter.format_line_only(trace_event)\n            self.config.write(line)\n\n        if event == 'exception':\n            frame_info.had_exception = True\n\n        self.config.last_frame = frame\n\n        trace_event = Event(frame_info, event, arg, thread_local.depth)\n        if not (frame.f_code.co_name == '<genexpr>' and event not in ('return', 'exception')):\n            trace_event.variables = frame_info.update_variables(\n                self.watch,\n                self.config.watch_extras,\n                event,\n            )\n\n        if event in ('return', 'exit'):\n            del self.frame_infos[frame]\n            thread_local.depth -= 1\n\n        formatted = self.config.formatter.format(trace_event)\n        self.config.write(formatted)\n\n        return self.trace"
        ],
        [
            "CALL",
            "six.add_metaclass(TracerMeta)"
        ],
        [
            "STORE_NAME",
            "@six.add_metaclass(TracerMeta)\nclass Tracer(object):\n    def __init__(\n            self,\n            watch=(),\n            watch_explode=(),\n            depth=1,\n    ):\n        self.watch = [\n            v if isinstance(v, BaseVariable) else CommonVariable(v)\n            for v in ensure_tuple(watch)\n        ] + [\n            v if isinstance(v, BaseVariable) else Exploding(v)\n            for v in ensure_tuple(watch_explode)\n        ]\n        self.frame_infos = ArgDefaultDict(FrameInfo)\n        self.depth = depth\n        assert self.depth >= 1\n        self.target_codes = set()\n        self.target_frames = set()\n\n    def __call__(self, function):\n        if iscoroutinefunction(function):\n            raise NotImplementedError(\"coroutines are not supported, sorry!\")\n\n        self.target_codes.add(function.__code__)\n\n        @functools.wraps(function)\n        def simple_wrapper(*args, **kwargs):\n            with self:\n                return function(*args, **kwargs)\n\n        @functools.wraps(function)\n        def generator_wrapper(*args, **kwargs):\n            gen = function(*args, **kwargs)\n            method, incoming = gen.send, None\n            while True:\n                with self:\n                    try:\n                        outgoing = method(incoming)\n                    except StopIteration:\n                        return\n                try:\n                    method, incoming = gen.send, (yield outgoing)\n                except Exception as e:\n                    method, incoming = gen.throw, e\n\n        if inspect.isgeneratorfunction(function):\n            return generator_wrapper\n        else:\n            return simple_wrapper\n\n    def __enter__(self, context=0):\n        if not self.config.enabled:\n            return\n\n        calling_frame = sys._getframe(context + 1)\n        if not self._is_internal_frame(calling_frame):\n            calling_frame.f_trace = self.trace\n            self.target_frames.add(calling_frame)\n            self.config.last_frame = calling_frame\n            self.trace(calling_frame, 'enter', None)\n\n        stack = thread_global.__dict__.setdefault('original_trace_functions', [])\n        stack.append(sys.gettrace())\n        sys.settrace(self.trace)\n\n    def __exit__(self, exc_type, exc_value, exc_traceback, context=0):\n        if not self.config.enabled:\n            return\n\n        stack = thread_global.original_trace_functions\n        sys.settrace(stack.pop())\n        calling_frame = sys._getframe(context + 1)\n        self.trace(calling_frame, 'exit', None)\n        self.target_frames.discard(calling_frame)\n        self.frame_infos.pop(calling_frame, None)\n\n    def _is_internal_frame(self, frame):\n        return frame.f_code.co_filename.startswith(internal_directories)\n    \n    def _is_traced_frame(self, frame):\n        return frame.f_code in self.target_codes or frame in self.target_frames\n\n    def trace(self, frame, event, arg):\n        if not self._is_traced_frame(frame):\n            if (\n                    self.depth == 1\n                    or self._is_internal_frame(frame)\n            ) and not is_comprehension_frame(frame):\n                return None\n            else:\n                candidate = frame\n                i = 0\n                while True:\n                    if is_comprehension_frame(candidate):\n                        candidate = candidate.f_back\n                        continue\n                    i += 1\n                    if self._is_traced_frame(candidate):\n                        break\n                    candidate = candidate.f_back\n                    if i >= self.depth or candidate is None or self._is_internal_frame(candidate):\n                        return None\n\n        thread_local = self.config.thread_local\n        thread_local.__dict__.setdefault('depth', -1)\n        frame_info = self.frame_infos[frame]\n        if event in ('call', 'enter'):\n            thread_local.depth += 1\n        elif self.config.last_frame and self.config.last_frame is not frame:\n            line_no = frame_info.last_line_no\n            trace_event = Event(frame_info, event, arg, thread_local.depth, line_no=line_no)\n            line = self.config.formatter.format_line_only(trace_event)\n            self.config.write(line)\n\n        if event == 'exception':\n            frame_info.had_exception = True\n\n        self.config.last_frame = frame\n\n        trace_event = Event(frame_info, event, arg, thread_local.depth)\n        if not (frame.f_code.co_name == '<genexpr>' and event not in ('return', 'exception')):\n            trace_event.variables = frame_info.update_variables(\n                self.watch,\n                self.config.watch_extras,\n                event,\n            )\n\n        if event in ('return', 'exit'):\n            del self.frame_infos[frame]\n            thread_local.depth -= 1\n\n        formatted = self.config.formatter.format(trace_event)\n        self.config.write(formatted)\n\n        return self.trace"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class Spy(object):\n    def __init__(self, config):\n        self.config = config\n\n    def __call__(self, *args, **kwargs):\n        if NO_ASTTOKENS:\n            raise Exception(\"birdseye doesn't support this version of Python\")\n\n        try:\n            import birdseye\n        except ImportError:\n            raise Exception(\"You must install birdseye separately to use spy: pip install birdseye\")\n\n        # Decorator without parentheses\n        if no_args_decorator(args, kwargs):\n            return self._trace(args[0])\n\n        # Decorator with parentheses and perhaps arguments\n        def decorator(func):\n            return self._trace(func, *args, **kwargs)\n\n        return decorator\n\n    def _trace(self, func, *args, **kwargs):\n        # noinspection PyUnresolvedReferences\n        from birdseye import eye\n\n        traced = eye(func)\n        traced = self.config.snoop(*args, **kwargs)(traced)\n\n        @functools.wraps(func)\n        def wrapper(*func_args, **func_kwargs):\n            if self.config.enabled:\n                final_func = traced\n            else:\n                final_func = func\n\n            return final_func(*func_args, **func_kwargs)\n\n        return wrapper"
        ],
        [
            "STORE_NAME",
            "class Spy(object):\n    def __init__(self, config):\n        self.config = config\n\n    def __call__(self, *args, **kwargs):\n        if NO_ASTTOKENS:\n            raise Exception(\"birdseye doesn't support this version of Python\")\n\n        try:\n            import birdseye\n        except ImportError:\n            raise Exception(\"You must install birdseye separately to use spy: pip install birdseye\")\n\n        # Decorator without parentheses\n        if no_args_decorator(args, kwargs):\n            return self._trace(args[0])\n\n        # Decorator with parentheses and perhaps arguments\n        def decorator(func):\n            return self._trace(func, *args, **kwargs)\n\n        return decorator\n\n    def _trace(self, func, *args, **kwargs):\n        # noinspection PyUnresolvedReferences\n        from birdseye import eye\n\n        traced = eye(func)\n        traced = self.config.snoop(*args, **kwargs)(traced)\n\n        @functools.wraps(func)\n        def wrapper(*func_args, **func_kwargs):\n            if self.config.enabled:\n                final_func = traced\n            else:\n                final_func = func\n\n            return final_func(*func_args, **func_kwargs)\n\n        return wrapper"
        ],
        [
            "STORE_NAME",
            "    def __init__(self, frame):\n        self.frame = frame\n        self.local_reprs = {}\n        self.last_line_no = frame.f_lineno\n        self.comprehension_variables = OrderedDict()\n        self.source = Source.for_frame(frame)\n        self.is_generator = frame.f_code.co_flags & inspect.CO_GENERATOR\n        self.had_exception = False\n        if is_comprehension_frame(frame):\n            self.comprehension_type = (\n                    re.match(r'<(\\w+)comp>', frame.f_code.co_name).group(1).title()\n                    + u' comprehension'\n            )\n        else:\n            self.comprehension_type = ''"
        ],
        [
            "STORE_NAME",
            "    def update_variables(self, watch, watch_extras, event):\n        self.last_line_no = self.frame.f_lineno\n        old_local_reprs = self.local_reprs\n        self.local_reprs = OrderedDict(\n            (source, my_cheap_repr(value))\n            for source, value in\n            self.get_local_reprs(watch, watch_extras)\n        )\n\n        if self.comprehension_type:\n            for name, value_repr in self.local_reprs.items():\n                values = self.comprehension_variables.setdefault(name, [])\n                if not values or values[-1] != value_repr:\n                    values.append(value_repr)\n                    values[:] = truncate_list(values, 11)\n            if event in ('return', 'exception'):\n                return [\n                    (name, ', '.join(values))\n                    for name, values in self.comprehension_variables.items()\n                ]\n            else:\n                return []\n\n        variables = []\n        for name, value_repr in self.local_reprs.items():\n            if name not in old_local_reprs or old_local_reprs[name] != value_repr:\n                variables.append((name, value_repr))\n        return variables"
        ],
        [
            "STORE_NAME",
            "    def get_local_reprs(self, watch, watch_extras):\n        frame = self.frame\n        code = frame.f_code\n        vars_order = code.co_varnames + code.co_cellvars + code.co_freevars + tuple(frame.f_locals.keys())\n\n        result_items = sorted(\n            frame.f_locals.items(),\n            key=lambda key_value: vars_order.index(key_value[0])\n        )\n\n        for variable in watch:\n            result_items += sorted(variable.items(frame))\n\n        for source, value in result_items:\n            yield source, value\n            for extra in watch_extras:\n                try:\n                    pair = extra(source, value)\n                except Exception:\n                    pass\n                else:\n                    if pair is not None:\n                        assert len(pair) == 2, \"Watch extra must return pair or None\"\n                        yield pair"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.local_reprs"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_lineno"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.last_line_no"
        ],
        [
            "LOAD_GLOBAL",
            "OrderedDict"
        ],
        [
            "CALL",
            "OrderedDict()"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.comprehension_variables"
        ],
        [
            "LOAD_GLOBAL",
            "Source"
        ],
        [
            "LOAD_ATTR",
            "Source.for_frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "Source.for_frame(frame)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.source"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_flags"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.CO_GENERATOR"
        ],
        [
            "BINARY_OP",
            "frame.f_code.co_flags & inspect.CO_GENERATOR"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.is_generator"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.had_exception"
        ],
        [
            "LOAD_GLOBAL",
            "is_comprehension_frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "is_comprehension_frame(frame)"
        ],
        [
            "LOAD_GLOBAL",
            "re"
        ],
        [
            "LOAD_ATTR",
            "re.match"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_name"
        ],
        [
            "CALL",
            "re.match(r'<(\\w+)comp>', frame.f_code.co_name)"
        ],
        [
            "LOAD_METHOD",
            "re.match(r'<(\\w+)comp>', frame.f_code.co_name).group"
        ],
        [
            "CALL",
            "re.match(r'<(\\w+)comp>', frame.f_code.co_name).group(1)"
        ],
        [
            "LOAD_METHOD",
            "re.match(r'<(\\w+)comp>', frame.f_code.co_name).group(1).title"
        ],
        [
            "CALL",
            "re.match(r'<(\\w+)comp>', frame.f_code.co_name).group(1).title()"
        ],
        [
            "BINARY_OP",
            "re.match(r'<(\\w+)comp>', frame.f_code.co_name).group(1).title()\n                    + u' comprehension'"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.comprehension_type"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.comprehension_type"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.frame"
        ],
        [
            "LOAD_ATTR",
            "self.frame.f_lineno"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.last_line_no"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.local_reprs"
        ],
        [
            "STORE_FAST",
            "old_local_reprs"
        ],
        [
            "LOAD_GLOBAL",
            "OrderedDict"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.get_local_reprs"
        ],
        [
            "LOAD_FAST",
            "watch"
        ],
        [
            "LOAD_FAST",
            "watch_extras"
        ],
        [
            "CALL",
            "self.get_local_reprs(watch, watch_extras)"
        ],
        [
            "CALL",
            "(\n            (source, my_cheap_repr(value))\n            for source, value in\n            self.get_local_reprs(watch, watch_extras)\n        )"
        ],
        [
            "CALL",
            "OrderedDict(\n            (source, my_cheap_repr(value))\n            for source, value in\n            self.get_local_reprs(watch, watch_extras)\n        )"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.local_reprs"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.comprehension_type"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.local_reprs"
        ],
        [
            "LOAD_METHOD",
            "self.local_reprs.items"
        ],
        [
            "CALL",
            "self.local_reprs.items()"
        ],
        [
            "STORE_FAST",
            "name"
        ],
        [
            "STORE_FAST",
            "value_repr"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.comprehension_variables"
        ],
        [
            "LOAD_METHOD",
            "self.comprehension_variables.setdefault"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "CALL",
            "self.comprehension_variables.setdefault(name, [])"
        ],
        [
            "STORE_FAST",
            "values"
        ],
        [
            "LOAD_FAST",
            "values"
        ],
        [
            "LOAD_FAST",
            "values"
        ],
        [
            "BINARY_SUBSCR",
            "values[-1]"
        ],
        [
            "LOAD_FAST",
            "value_repr"
        ],
        [
            "COMPARE_OP",
            "values[-1] != value_repr"
        ],
        [
            "LOAD_FAST",
            "values"
        ],
        [
            "LOAD_METHOD",
            "values.append"
        ],
        [
            "LOAD_FAST",
            "value_repr"
        ],
        [
            "CALL",
            "values.append(value_repr)"
        ],
        [
            "LOAD_GLOBAL",
            "truncate_list"
        ],
        [
            "LOAD_FAST",
            "values"
        ],
        [
            "CALL",
            "truncate_list(values, 11)"
        ],
        [
            "LOAD_FAST",
            "values"
        ],
        [
            "STORE_SUBSCR",
            "values[:]"
        ],
        [
            "LOAD_FAST",
            "event"
        ],
        [
            "CONTAINS_OP",
            "event in ('return', 'exception')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.comprehension_variables"
        ],
        [
            "LOAD_METHOD",
            "self.comprehension_variables.items"
        ],
        [
            "CALL",
            "self.comprehension_variables.items()"
        ],
        [
            "CALL",
            "[\n                    (name, ', '.join(values))\n                    for name, values in self.comprehension_variables.items()\n                ]"
        ],
        [
            "STORE_FAST",
            "variables"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.local_reprs"
        ],
        [
            "LOAD_METHOD",
            "self.local_reprs.items"
        ],
        [
            "CALL",
            "self.local_reprs.items()"
        ],
        [
            "STORE_FAST",
            "name"
        ],
        [
            "STORE_FAST",
            "value_repr"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "old_local_reprs"
        ],
        [
            "CONTAINS_OP",
            "name not in old_local_reprs"
        ],
        [
            "LOAD_FAST",
            "old_local_reprs"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "BINARY_SUBSCR",
            "old_local_reprs[name]"
        ],
        [
            "LOAD_FAST",
            "value_repr"
        ],
        [
            "COMPARE_OP",
            "old_local_reprs[name] != value_repr"
        ],
        [
            "LOAD_FAST",
            "variables"
        ],
        [
            "LOAD_METHOD",
            "variables.append"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "value_repr"
        ],
        [
            "CALL",
            "variables.append((name, value_repr))"
        ],
        [
            "LOAD_FAST",
            "variables"
        ],
        [
            "LOAD_FAST",
            "(\n            (source, my_cheap_repr(value))\n            for source, value in\n            self.get_local_reprs(watch, watch_extras)\n        )"
        ],
        [
            "STORE_FAST",
            "source"
        ],
        [
            "STORE_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_GLOBAL",
            "my_cheap_repr"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "CALL",
            "my_cheap_repr(value)"
        ],
        [
            "LOAD_FAST",
            "[\n                    (name, ', '.join(values))\n                    for name, values in self.comprehension_variables.items()\n                ]"
        ],
        [
            "STORE_FAST",
            "name"
        ],
        [
            "STORE_FAST",
            "values"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_METHOD",
            "', '.join"
        ],
        [
            "LOAD_FAST",
            "values"
        ],
        [
            "CALL",
            "', '.join(values)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.frame"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "STORE_FAST",
            "code"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_varnames"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_cellvars"
        ],
        [
            "BINARY_OP",
            "code.co_varnames + code.co_cellvars"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_freevars"
        ],
        [
            "BINARY_OP",
            "code.co_varnames + code.co_cellvars + code.co_freevars"
        ],
        [
            "LOAD_GLOBAL",
            "tuple"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_locals"
        ],
        [
            "LOAD_METHOD",
            "frame.f_locals.keys"
        ],
        [
            "CALL",
            "frame.f_locals.keys()"
        ],
        [
            "CALL",
            "tuple(frame.f_locals.keys())"
        ],
        [
            "BINARY_OP",
            "code.co_varnames + code.co_cellvars + code.co_freevars + tuple(frame.f_locals.keys())"
        ],
        [
            "STORE_DEREF",
            "vars_order"
        ],
        [
            "LOAD_GLOBAL",
            "sorted"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_locals"
        ],
        [
            "LOAD_METHOD",
            "frame.f_locals.items"
        ],
        [
            "CALL",
            "frame.f_locals.items()"
        ],
        [
            "CALL",
            "sorted(\n            frame.f_locals.items(),\n            key=lambda key_value: vars_order.index(key_value[0])\n        )"
        ],
        [
            "STORE_FAST",
            "result_items"
        ],
        [
            "LOAD_FAST",
            "watch"
        ],
        [
            "STORE_FAST",
            "variable"
        ],
        [
            "LOAD_FAST",
            "result_items"
        ],
        [
            "LOAD_GLOBAL",
            "sorted"
        ],
        [
            "LOAD_FAST",
            "variable"
        ],
        [
            "LOAD_METHOD",
            "variable.items"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "variable.items(frame)"
        ],
        [
            "CALL",
            "sorted(variable.items(frame))"
        ],
        [
            "BINARY_OP",
            "result_items += sorted(variable.items(frame))"
        ],
        [
            "STORE_FAST",
            "result_items"
        ],
        [
            "LOAD_FAST",
            "result_items"
        ],
        [
            "STORE_FAST",
            "source"
        ],
        [
            "STORE_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "watch_extras"
        ],
        [
            "STORE_FAST",
            "extra"
        ],
        [
            "LOAD_FAST",
            "extra"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "CALL",
            "extra(source, value)"
        ],
        [
            "STORE_FAST",
            "pair"
        ],
        [
            "LOAD_FAST",
            "pair"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "pair"
        ],
        [
            "CALL",
            "len(pair)"
        ],
        [
            "COMPARE_OP",
            "len(pair) == 2"
        ],
        [
            "LOAD_FAST",
            "pair"
        ],
        [
            "LOAD_GLOBAL",
            "Exception"
        ],
        [
            "LOAD_DEREF",
            "vars_order"
        ],
        [
            "LOAD_METHOD",
            "vars_order.index"
        ],
        [
            "LOAD_FAST",
            "key_value"
        ],
        [
            "BINARY_SUBSCR",
            "key_value[0]"
        ],
        [
            "CALL",
            "vars_order.index(key_value[0])"
        ],
        [
            "STORE_NAME",
            "    def __new__(mcs, *args, **kwargs):\n        result = super(TracerMeta, mcs).__new__(mcs, *args, **kwargs)\n        result.default = result()\n        return result"
        ],
        [
            "STORE_NAME",
            "    def __call__(cls, *args, **kwargs):\n        if no_args_decorator(args, kwargs):\n            return cls.default(args[0])\n        else:\n            return super(TracerMeta, cls).__call__(*args, **kwargs)"
        ],
        [
            "STORE_NAME",
            "    def __enter__(self):\n        return self.default.__enter__(context=1)"
        ],
        [
            "STORE_NAME",
            "    def __exit__(self, *args):\n        return self.default.__exit__(*args, context=1)"
        ],
        [
            "STORE_NAME",
            "    def __exit__(self, *args):\n        return self.default.__exit__(*args, context=1)"
        ],
        [
            "LOAD_GLOBAL",
            "super"
        ],
        [
            "LOAD_GLOBAL",
            "TracerMeta"
        ],
        [
            "LOAD_FAST",
            "mcs"
        ],
        [
            "CALL",
            "super(TracerMeta, mcs)"
        ],
        [
            "LOAD_ATTR",
            "super(TracerMeta, mcs).__new__"
        ],
        [
            "LOAD_FAST",
            "mcs"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_FAST",
            "kwargs"
        ],
        [
            "CALL_FUNCTION_EX",
            "super(TracerMeta, mcs).__new__(mcs, *args, **kwargs)"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "CALL",
            "result()"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "STORE_ATTR",
            "result.default"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_GLOBAL",
            "no_args_decorator"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_FAST",
            "kwargs"
        ],
        [
            "CALL",
            "no_args_decorator(args, kwargs)"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_METHOD",
            "cls.default"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "BINARY_SUBSCR",
            "args[0]"
        ],
        [
            "CALL",
            "cls.default(args[0])"
        ],
        [
            "LOAD_GLOBAL",
            "super"
        ],
        [
            "LOAD_GLOBAL",
            "TracerMeta"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "CALL",
            "super(TracerMeta, cls)"
        ],
        [
            "LOAD_ATTR",
            "super(TracerMeta, cls).__call__"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_FAST",
            "kwargs"
        ],
        [
            "CALL_FUNCTION_EX",
            "super(TracerMeta, cls).__call__(*args, **kwargs)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.default"
        ],
        [
            "LOAD_METHOD",
            "self.default.__enter__"
        ],
        [
            "CALL",
            "self.default.__enter__(context=1)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.default"
        ],
        [
            "LOAD_ATTR",
            "self.default.__exit__"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "CALL_FUNCTION_EX",
            "self.default.__exit__(*args, context=1)"
        ],
        [
            "STORE_NAME",
            "    def __init__(\n            self,\n            watch=(),\n            watch_explode=(),\n            depth=1,\n    ):\n        self.watch = [\n            v if isinstance(v, BaseVariable) else CommonVariable(v)\n            for v in ensure_tuple(watch)\n        ] + [\n            v if isinstance(v, BaseVariable) else Exploding(v)\n            for v in ensure_tuple(watch_explode)\n        ]\n        self.frame_infos = ArgDefaultDict(FrameInfo)\n        self.depth = depth\n        assert self.depth >= 1\n        self.target_codes = set()\n        self.target_frames = set()"
        ],
        [
            "STORE_NAME",
            "    def __call__(self, function):\n        if iscoroutinefunction(function):\n            raise NotImplementedError(\"coroutines are not supported, sorry!\")\n\n        self.target_codes.add(function.__code__)\n\n        @functools.wraps(function)\n        def simple_wrapper(*args, **kwargs):\n            with self:\n                return function(*args, **kwargs)\n\n        @functools.wraps(function)\n        def generator_wrapper(*args, **kwargs):\n            gen = function(*args, **kwargs)\n            method, incoming = gen.send, None\n            while True:\n                with self:\n                    try:\n                        outgoing = method(incoming)\n                    except StopIteration:\n                        return\n                try:\n                    method, incoming = gen.send, (yield outgoing)\n                except Exception as e:\n                    method, incoming = gen.throw, e\n\n        if inspect.isgeneratorfunction(function):\n            return generator_wrapper\n        else:\n            return simple_wrapper"
        ],
        [
            "STORE_NAME",
            "    def __enter__(self, context=0):\n        if not self.config.enabled:\n            return\n\n        calling_frame = sys._getframe(context + 1)\n        if not self._is_internal_frame(calling_frame):\n            calling_frame.f_trace = self.trace\n            self.target_frames.add(calling_frame)\n            self.config.last_frame = calling_frame\n            self.trace(calling_frame, 'enter', None)\n\n        stack = thread_global.__dict__.setdefault('original_trace_functions', [])\n        stack.append(sys.gettrace())\n        sys.settrace(self.trace)"
        ],
        [
            "STORE_NAME",
            "    def __exit__(self, exc_type, exc_value, exc_traceback, context=0):\n        if not self.config.enabled:\n            return\n\n        stack = thread_global.original_trace_functions\n        sys.settrace(stack.pop())\n        calling_frame = sys._getframe(context + 1)\n        self.trace(calling_frame, 'exit', None)\n        self.target_frames.discard(calling_frame)\n        self.frame_infos.pop(calling_frame, None)"
        ],
        [
            "STORE_NAME",
            "    def _is_internal_frame(self, frame):\n        return frame.f_code.co_filename.startswith(internal_directories)"
        ],
        [
            "STORE_NAME",
            "    def _is_traced_frame(self, frame):\n        return frame.f_code in self.target_codes or frame in self.target_frames"
        ],
        [
            "STORE_NAME",
            "    def trace(self, frame, event, arg):\n        if not self._is_traced_frame(frame):\n            if (\n                    self.depth == 1\n                    or self._is_internal_frame(frame)\n            ) and not is_comprehension_frame(frame):\n                return None\n            else:\n                candidate = frame\n                i = 0\n                while True:\n                    if is_comprehension_frame(candidate):\n                        candidate = candidate.f_back\n                        continue\n                    i += 1\n                    if self._is_traced_frame(candidate):\n                        break\n                    candidate = candidate.f_back\n                    if i >= self.depth or candidate is None or self._is_internal_frame(candidate):\n                        return None\n\n        thread_local = self.config.thread_local\n        thread_local.__dict__.setdefault('depth', -1)\n        frame_info = self.frame_infos[frame]\n        if event in ('call', 'enter'):\n            thread_local.depth += 1\n        elif self.config.last_frame and self.config.last_frame is not frame:\n            line_no = frame_info.last_line_no\n            trace_event = Event(frame_info, event, arg, thread_local.depth, line_no=line_no)\n            line = self.config.formatter.format_line_only(trace_event)\n            self.config.write(line)\n\n        if event == 'exception':\n            frame_info.had_exception = True\n\n        self.config.last_frame = frame\n\n        trace_event = Event(frame_info, event, arg, thread_local.depth)\n        if not (frame.f_code.co_name == '<genexpr>' and event not in ('return', 'exception')):\n            trace_event.variables = frame_info.update_variables(\n                self.watch,\n                self.config.watch_extras,\n                event,\n            )\n\n        if event in ('return', 'exit'):\n            del self.frame_infos[frame]\n            thread_local.depth -= 1\n\n        formatted = self.config.formatter.format(trace_event)\n        self.config.write(formatted)\n\n        return self.trace"
        ],
        [
            "LOAD_GLOBAL",
            "ensure_tuple"
        ],
        [
            "LOAD_FAST",
            "watch"
        ],
        [
            "CALL",
            "ensure_tuple(watch)"
        ],
        [
            "CALL",
            "[\n            v if isinstance(v, BaseVariable) else CommonVariable(v)\n            for v in ensure_tuple(watch)\n        ]"
        ],
        [
            "LOAD_GLOBAL",
            "ensure_tuple"
        ],
        [
            "LOAD_FAST",
            "watch_explode"
        ],
        [
            "CALL",
            "ensure_tuple(watch_explode)"
        ],
        [
            "CALL",
            "[\n            v if isinstance(v, BaseVariable) else Exploding(v)\n            for v in ensure_tuple(watch_explode)\n        ]"
        ],
        [
            "BINARY_OP",
            "[\n            v if isinstance(v, BaseVariable) else CommonVariable(v)\n            for v in ensure_tuple(watch)\n        ] + [\n            v if isinstance(v, BaseVariable) else Exploding(v)\n            for v in ensure_tuple(watch_explode)\n        ]"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.watch"
        ],
        [
            "LOAD_GLOBAL",
            "ArgDefaultDict"
        ],
        [
            "LOAD_GLOBAL",
            "FrameInfo"
        ],
        [
            "CALL",
            "ArgDefaultDict(FrameInfo)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.frame_infos"
        ],
        [
            "LOAD_FAST",
            "depth"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.depth"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.depth"
        ],
        [
            "COMPARE_OP",
            "self.depth >= 1"
        ],
        [
            "LOAD_GLOBAL",
            "set"
        ],
        [
            "CALL",
            "set()"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.target_codes"
        ],
        [
            "LOAD_GLOBAL",
            "set"
        ],
        [
            "CALL",
            "set()"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.target_frames"
        ],
        [
            "LOAD_FAST",
            "[\n            v if isinstance(v, BaseVariable) else CommonVariable(v)\n            for v in ensure_tuple(watch)\n        ]"
        ],
        [
            "STORE_FAST",
            "v"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "LOAD_GLOBAL",
            "BaseVariable"
        ],
        [
            "CALL",
            "isinstance(v, BaseVariable)"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "LOAD_GLOBAL",
            "CommonVariable"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "CALL",
            "CommonVariable(v)"
        ],
        [
            "LOAD_FAST",
            "[\n            v if isinstance(v, BaseVariable) else Exploding(v)\n            for v in ensure_tuple(watch_explode)\n        ]"
        ],
        [
            "STORE_FAST",
            "v"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "LOAD_GLOBAL",
            "BaseVariable"
        ],
        [
            "CALL",
            "isinstance(v, BaseVariable)"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "LOAD_GLOBAL",
            "Exploding"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "CALL",
            "Exploding(v)"
        ],
        [
            "LOAD_GLOBAL",
            "iscoroutinefunction"
        ],
        [
            "LOAD_DEREF",
            "function"
        ],
        [
            "CALL",
            "iscoroutinefunction(function)"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplementedError"
        ],
        [
            "CALL",
            "NotImplementedError(\"coroutines are not supported, sorry!\")"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.target_codes"
        ],
        [
            "LOAD_METHOD",
            "self.target_codes.add"
        ],
        [
            "LOAD_DEREF",
            "function"
        ],
        [
            "LOAD_ATTR",
            "function.__code__"
        ],
        [
            "CALL",
            "self.target_codes.add(function.__code__)"
        ],
        [
            "LOAD_GLOBAL",
            "functools"
        ],
        [
            "LOAD_ATTR",
            "functools.wraps"
        ],
        [
            "LOAD_DEREF",
            "function"
        ],
        [
            "CALL",
            "functools.wraps(function)"
        ],
        [
            "CALL",
            "functools.wraps(function)"
        ],
        [
            "STORE_FAST",
            "        @functools.wraps(function)\n        def simple_wrapper(*args, **kwargs):\n            with self:\n                return function(*args, **kwargs)"
        ],
        [
            "LOAD_GLOBAL",
            "functools"
        ],
        [
            "LOAD_ATTR",
            "functools.wraps"
        ],
        [
            "LOAD_DEREF",
            "function"
        ],
        [
            "CALL",
            "functools.wraps(function)"
        ],
        [
            "CALL",
            "functools.wraps(function)"
        ],
        [
            "STORE_FAST",
            "        @functools.wraps(function)\n        def generator_wrapper(*args, **kwargs):\n            gen = function(*args, **kwargs)\n            method, incoming = gen.send, None\n            while True:\n                with self:\n                    try:\n                        outgoing = method(incoming)\n                    except StopIteration:\n                        return\n                try:\n                    method, incoming = gen.send, (yield outgoing)\n                except Exception as e:\n                    method, incoming = gen.throw, e"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.isgeneratorfunction"
        ],
        [
            "LOAD_DEREF",
            "function"
        ],
        [
            "CALL",
            "inspect.isgeneratorfunction(function)"
        ],
        [
            "LOAD_FAST",
            "generator_wrapper"
        ],
        [
            "LOAD_FAST",
            "simple_wrapper"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_DEREF",
            "function"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_FAST",
            "kwargs"
        ],
        [
            "CALL_FUNCTION_EX",
            "function(*args, **kwargs)"
        ],
        [
            "CALL",
            "            with self:\n                return function(*args, **kwargs)"
        ],
        [
            "LOAD_DEREF",
            "function"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_FAST",
            "kwargs"
        ],
        [
            "CALL_FUNCTION_EX",
            "function(*args, **kwargs)"
        ],
        [
            "STORE_FAST",
            "gen"
        ],
        [
            "LOAD_FAST",
            "gen"
        ],
        [
            "LOAD_ATTR",
            "gen.send"
        ],
        [
            "STORE_FAST",
            "incoming"
        ],
        [
            "STORE_FAST",
            "method"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_FAST",
            "method"
        ],
        [
            "LOAD_FAST",
            "incoming"
        ],
        [
            "CALL",
            "method(incoming)"
        ],
        [
            "STORE_FAST",
            "outgoing"
        ],
        [
            "LOAD_GLOBAL",
            "StopIteration"
        ],
        [
            "CALL",
            "                with self:\n                    try:\n                        outgoing = method(incoming)\n                    except StopIteration:\n                        return"
        ],
        [
            "CALL",
            "                with self:\n                    try:\n                        outgoing = method(incoming)\n                    except StopIteration:\n                        return"
        ],
        [
            "LOAD_FAST",
            "gen"
        ],
        [
            "LOAD_ATTR",
            "gen.send"
        ],
        [
            "LOAD_FAST",
            "outgoing"
        ],
        [
            "STORE_FAST",
            "incoming"
        ],
        [
            "STORE_FAST",
            "method"
        ],
        [
            "LOAD_GLOBAL",
            "Exception"
        ],
        [
            "STORE_FAST",
            "                except Exception as e:\n                    method, incoming = gen.throw, e"
        ],
        [
            "LOAD_FAST",
            "gen"
        ],
        [
            "LOAD_ATTR",
            "gen.throw"
        ],
        [
            "LOAD_FAST",
            "e"
        ],
        [
            "STORE_FAST",
            "incoming"
        ],
        [
            "STORE_FAST",
            "method"
        ],
        [
            "STORE_FAST",
            "method"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.enabled"
        ],
        [
            "LOAD_GLOBAL",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys._getframe"
        ],
        [
            "LOAD_FAST",
            "context"
        ],
        [
            "BINARY_OP",
            "context + 1"
        ],
        [
            "CALL",
            "sys._getframe(context + 1)"
        ],
        [
            "STORE_FAST",
            "calling_frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._is_internal_frame"
        ],
        [
            "LOAD_FAST",
            "calling_frame"
        ],
        [
            "CALL",
            "self._is_internal_frame(calling_frame)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.trace"
        ],
        [
            "LOAD_FAST",
            "calling_frame"
        ],
        [
            "STORE_ATTR",
            "calling_frame.f_trace"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.target_frames"
        ],
        [
            "LOAD_METHOD",
            "self.target_frames.add"
        ],
        [
            "LOAD_FAST",
            "calling_frame"
        ],
        [
            "CALL",
            "self.target_frames.add(calling_frame)"
        ],
        [
            "LOAD_FAST",
            "calling_frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "STORE_ATTR",
            "self.config.last_frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.trace"
        ],
        [
            "LOAD_FAST",
            "calling_frame"
        ],
        [
            "CALL",
            "self.trace(calling_frame, 'enter', None)"
        ],
        [
            "LOAD_GLOBAL",
            "thread_global"
        ],
        [
            "LOAD_ATTR",
            "thread_global.__dict__"
        ],
        [
            "LOAD_METHOD",
            "thread_global.__dict__.setdefault"
        ],
        [
            "CALL",
            "thread_global.__dict__.setdefault('original_trace_functions', [])"
        ],
        [
            "STORE_FAST",
            "stack"
        ],
        [
            "LOAD_FAST",
            "stack"
        ],
        [
            "LOAD_METHOD",
            "stack.append"
        ],
        [
            "LOAD_GLOBAL",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.gettrace"
        ],
        [
            "CALL",
            "sys.gettrace()"
        ],
        [
            "CALL",
            "stack.append(sys.gettrace())"
        ],
        [
            "LOAD_GLOBAL",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.settrace"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.trace"
        ],
        [
            "CALL",
            "sys.settrace(self.trace)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.enabled"
        ],
        [
            "LOAD_GLOBAL",
            "thread_global"
        ],
        [
            "LOAD_ATTR",
            "thread_global.original_trace_functions"
        ],
        [
            "STORE_FAST",
            "stack"
        ],
        [
            "LOAD_GLOBAL",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.settrace"
        ],
        [
            "LOAD_FAST",
            "stack"
        ],
        [
            "LOAD_METHOD",
            "stack.pop"
        ],
        [
            "CALL",
            "stack.pop()"
        ],
        [
            "CALL",
            "sys.settrace(stack.pop())"
        ],
        [
            "LOAD_GLOBAL",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys._getframe"
        ],
        [
            "LOAD_FAST",
            "context"
        ],
        [
            "BINARY_OP",
            "context + 1"
        ],
        [
            "CALL",
            "sys._getframe(context + 1)"
        ],
        [
            "STORE_FAST",
            "calling_frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.trace"
        ],
        [
            "LOAD_FAST",
            "calling_frame"
        ],
        [
            "CALL",
            "self.trace(calling_frame, 'exit', None)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.target_frames"
        ],
        [
            "LOAD_METHOD",
            "self.target_frames.discard"
        ],
        [
            "LOAD_FAST",
            "calling_frame"
        ],
        [
            "CALL",
            "self.target_frames.discard(calling_frame)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.frame_infos"
        ],
        [
            "LOAD_METHOD",
            "self.frame_infos.pop"
        ],
        [
            "LOAD_FAST",
            "calling_frame"
        ],
        [
            "CALL",
            "self.frame_infos.pop(calling_frame, None)"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_filename"
        ],
        [
            "LOAD_METHOD",
            "frame.f_code.co_filename.startswith"
        ],
        [
            "LOAD_GLOBAL",
            "internal_directories"
        ],
        [
            "CALL",
            "frame.f_code.co_filename.startswith(internal_directories)"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.target_codes"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code in self.target_codes"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.target_frames"
        ],
        [
            "CONTAINS_OP",
            "frame in self.target_frames"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._is_traced_frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "self._is_traced_frame(frame)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.depth"
        ],
        [
            "COMPARE_OP",
            "self.depth == 1"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._is_internal_frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "self._is_internal_frame(frame)"
        ],
        [
            "LOAD_GLOBAL",
            "is_comprehension_frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "is_comprehension_frame(frame)"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "STORE_FAST",
            "candidate"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "LOAD_GLOBAL",
            "is_comprehension_frame"
        ],
        [
            "LOAD_FAST",
            "candidate"
        ],
        [
            "CALL",
            "is_comprehension_frame(candidate)"
        ],
        [
            "LOAD_FAST",
            "candidate"
        ],
        [
            "LOAD_ATTR",
            "candidate.f_back"
        ],
        [
            "STORE_FAST",
            "candidate"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_OP",
            "i += 1"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._is_traced_frame"
        ],
        [
            "LOAD_FAST",
            "candidate"
        ],
        [
            "CALL",
            "self._is_traced_frame(candidate)"
        ],
        [
            "LOAD_FAST",
            "candidate"
        ],
        [
            "LOAD_ATTR",
            "candidate.f_back"
        ],
        [
            "STORE_FAST",
            "candidate"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.depth"
        ],
        [
            "COMPARE_OP",
            "i >= self.depth"
        ],
        [
            "LOAD_FAST",
            "candidate"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._is_internal_frame"
        ],
        [
            "LOAD_FAST",
            "candidate"
        ],
        [
            "CALL",
            "self._is_internal_frame(candidate)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.thread_local"
        ],
        [
            "STORE_FAST",
            "thread_local"
        ],
        [
            "LOAD_FAST",
            "thread_local"
        ],
        [
            "LOAD_ATTR",
            "thread_local.__dict__"
        ],
        [
            "LOAD_METHOD",
            "thread_local.__dict__.setdefault"
        ],
        [
            "CALL",
            "thread_local.__dict__.setdefault('depth', -1)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.frame_infos"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "BINARY_SUBSCR",
            "self.frame_infos[frame]"
        ],
        [
            "STORE_FAST",
            "frame_info"
        ],
        [
            "LOAD_FAST",
            "event"
        ],
        [
            "CONTAINS_OP",
            "event in ('call', 'enter')"
        ],
        [
            "LOAD_FAST",
            "thread_local"
        ],
        [
            "LOAD_ATTR",
            "thread_local.depth"
        ],
        [
            "BINARY_OP",
            "thread_local.depth += 1"
        ],
        [
            "STORE_ATTR",
            "thread_local.depth"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.last_frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.last_frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "IS_OP",
            "self.config.last_frame is not frame"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.last_line_no"
        ],
        [
            "STORE_FAST",
            "line_no"
        ],
        [
            "LOAD_GLOBAL",
            "Event"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_FAST",
            "event"
        ],
        [
            "LOAD_FAST",
            "arg"
        ],
        [
            "LOAD_FAST",
            "thread_local"
        ],
        [
            "LOAD_ATTR",
            "thread_local.depth"
        ],
        [
            "LOAD_FAST",
            "line_no"
        ],
        [
            "CALL",
            "Event(frame_info, event, arg, thread_local.depth, line_no=line_no)"
        ],
        [
            "STORE_FAST",
            "trace_event"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.formatter"
        ],
        [
            "LOAD_METHOD",
            "self.config.formatter.format_line_only"
        ],
        [
            "LOAD_FAST",
            "trace_event"
        ],
        [
            "CALL",
            "self.config.formatter.format_line_only(trace_event)"
        ],
        [
            "STORE_FAST",
            "line"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_METHOD",
            "self.config.write"
        ],
        [
            "LOAD_FAST",
            "line"
        ],
        [
            "CALL",
            "self.config.write(line)"
        ],
        [
            "LOAD_FAST",
            "event"
        ],
        [
            "COMPARE_OP",
            "event == 'exception'"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "STORE_ATTR",
            "frame_info.had_exception"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "STORE_ATTR",
            "self.config.last_frame"
        ],
        [
            "LOAD_GLOBAL",
            "Event"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_FAST",
            "event"
        ],
        [
            "LOAD_FAST",
            "arg"
        ],
        [
            "LOAD_FAST",
            "thread_local"
        ],
        [
            "LOAD_ATTR",
            "thread_local.depth"
        ],
        [
            "CALL",
            "Event(frame_info, event, arg, thread_local.depth)"
        ],
        [
            "STORE_FAST",
            "trace_event"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_name"
        ],
        [
            "COMPARE_OP",
            "frame.f_code.co_name == '<genexpr>'"
        ],
        [
            "LOAD_FAST",
            "event"
        ],
        [
            "CONTAINS_OP",
            "event not in ('return', 'exception')"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_METHOD",
            "frame_info.update_variables"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.watch"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.watch_extras"
        ],
        [
            "LOAD_FAST",
            "event"
        ],
        [
            "CALL",
            "frame_info.update_variables(\n                self.watch,\n                self.config.watch_extras,\n                event,\n            )"
        ],
        [
            "LOAD_FAST",
            "trace_event"
        ],
        [
            "STORE_ATTR",
            "trace_event.variables"
        ],
        [
            "LOAD_FAST",
            "event"
        ],
        [
            "CONTAINS_OP",
            "event in ('return', 'exit')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.frame_infos"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "DELETE_SUBSCR",
            "self.frame_infos[frame]"
        ],
        [
            "LOAD_FAST",
            "thread_local"
        ],
        [
            "LOAD_ATTR",
            "thread_local.depth"
        ],
        [
            "BINARY_OP",
            "thread_local.depth -= 1"
        ],
        [
            "STORE_ATTR",
            "thread_local.depth"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.formatter"
        ],
        [
            "LOAD_METHOD",
            "self.config.formatter.format"
        ],
        [
            "LOAD_FAST",
            "trace_event"
        ],
        [
            "CALL",
            "self.config.formatter.format(trace_event)"
        ],
        [
            "STORE_FAST",
            "formatted"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_METHOD",
            "self.config.write"
        ],
        [
            "LOAD_FAST",
            "formatted"
        ],
        [
            "CALL",
            "self.config.write(formatted)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.trace"
        ],
        [
            "STORE_NAME",
            "    def __init__(self, config):\n        self.config = config"
        ],
        [
            "STORE_NAME",
            "    def __call__(self, *args, **kwargs):\n        if NO_ASTTOKENS:\n            raise Exception(\"birdseye doesn't support this version of Python\")\n\n        try:\n            import birdseye\n        except ImportError:\n            raise Exception(\"You must install birdseye separately to use spy: pip install birdseye\")\n\n        # Decorator without parentheses\n        if no_args_decorator(args, kwargs):\n            return self._trace(args[0])\n\n        # Decorator with parentheses and perhaps arguments\n        def decorator(func):\n            return self._trace(func, *args, **kwargs)\n\n        return decorator"
        ],
        [
            "STORE_NAME",
            "    def _trace(self, func, *args, **kwargs):\n        # noinspection PyUnresolvedReferences\n        from birdseye import eye\n\n        traced = eye(func)\n        traced = self.config.snoop(*args, **kwargs)(traced)\n\n        @functools.wraps(func)\n        def wrapper(*func_args, **func_kwargs):\n            if self.config.enabled:\n                final_func = traced\n            else:\n                final_func = func\n\n            return final_func(*func_args, **func_kwargs)\n\n        return wrapper"
        ],
        [
            "LOAD_FAST",
            "config"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.config"
        ],
        [
            "LOAD_GLOBAL",
            "NO_ASTTOKENS"
        ],
        [
            "LOAD_GLOBAL",
            "Exception"
        ],
        [
            "CALL",
            "Exception(\"birdseye doesn't support this version of Python\")"
        ],
        [
            "STORE_FAST",
            "import birdseye"
        ],
        [
            "LOAD_GLOBAL",
            "ImportError"
        ],
        [
            "LOAD_GLOBAL",
            "Exception"
        ],
        [
            "CALL",
            "Exception(\"You must install birdseye separately to use spy: pip install birdseye\")"
        ],
        [
            "LOAD_GLOBAL",
            "no_args_decorator"
        ],
        [
            "LOAD_DEREF",
            "args"
        ],
        [
            "LOAD_DEREF",
            "kwargs"
        ],
        [
            "CALL",
            "no_args_decorator(args, kwargs)"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._trace"
        ],
        [
            "LOAD_DEREF",
            "args"
        ],
        [
            "BINARY_SUBSCR",
            "args[0]"
        ],
        [
            "CALL",
            "self._trace(args[0])"
        ],
        [
            "STORE_FAST",
            "        def decorator(func):\n            return self._trace(func, *args, **kwargs)"
        ],
        [
            "LOAD_FAST",
            "decorator"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._trace"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "LOAD_DEREF",
            "args"
        ],
        [
            "LOAD_DEREF",
            "kwargs"
        ],
        [
            "CALL_FUNCTION_EX",
            "self._trace(func, *args, **kwargs)"
        ],
        [
            "STORE_FAST",
            "from birdseye import eye"
        ],
        [
            "LOAD_FAST",
            "eye"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "CALL",
            "eye(func)"
        ],
        [
            "STORE_DEREF",
            "traced"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.snoop"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_FAST",
            "kwargs"
        ],
        [
            "CALL_FUNCTION_EX",
            "self.config.snoop(*args, **kwargs)"
        ],
        [
            "LOAD_DEREF",
            "traced"
        ],
        [
            "CALL",
            "self.config.snoop(*args, **kwargs)(traced)"
        ],
        [
            "STORE_DEREF",
            "traced"
        ],
        [
            "LOAD_GLOBAL",
            "functools"
        ],
        [
            "LOAD_ATTR",
            "functools.wraps"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "CALL",
            "functools.wraps(func)"
        ],
        [
            "CALL",
            "functools.wraps(func)"
        ],
        [
            "STORE_FAST",
            "        @functools.wraps(func)\n        def wrapper(*func_args, **func_kwargs):\n            if self.config.enabled:\n                final_func = traced\n            else:\n                final_func = func\n\n            return final_func(*func_args, **func_kwargs)"
        ],
        [
            "LOAD_FAST",
            "wrapper"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.enabled"
        ],
        [
            "LOAD_DEREF",
            "traced"
        ],
        [
            "STORE_FAST",
            "final_func"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "STORE_FAST",
            "final_func"
        ],
        [
            "LOAD_FAST",
            "final_func"
        ],
        [
            "LOAD_FAST",
            "func_args"
        ],
        [
            "LOAD_FAST",
            "func_kwargs"
        ],
        [
            "CALL_FUNCTION_EX",
            "final_func(*func_args, **func_kwargs)"
        ]
    ],
    "utils.py": [
        [
            "STORE_NAME",
            "from __future__ import print_function, division, absolute_import"
        ],
        [
            "STORE_NAME",
            "from __future__ import print_function, division, absolute_import"
        ],
        [
            "STORE_NAME",
            "from __future__ import print_function, division, absolute_import"
        ],
        [
            "STORE_NAME",
            "import ast"
        ],
        [
            "STORE_NAME",
            "import json"
        ],
        [
            "STORE_NAME",
            "from future import standard_library"
        ],
        [
            "LOAD_NAME",
            "standard_library"
        ],
        [
            "LOAD_ATTR",
            "standard_library.install_aliases"
        ],
        [
            "CALL",
            "standard_library.install_aliases()"
        ],
        [
            "STORE_NAME",
            "import token"
        ],
        [
            "STORE_NAME",
            "from future.utils import raise_from"
        ],
        [
            "STORE_NAME",
            "import ntpath"
        ],
        [
            "STORE_NAME",
            "import os"
        ],
        [
            "STORE_NAME",
            "import types"
        ],
        [
            "STORE_NAME",
            "from sys import version_info"
        ],
        [
            "STORE_NAME",
            "from typing import TypeVar, Union, List, Any, Iterator, Tuple, Iterable"
        ],
        [
            "STORE_NAME",
            "from typing import TypeVar, Union, List, Any, Iterator, Tuple, Iterable"
        ],
        [
            "STORE_NAME",
            "from typing import TypeVar, Union, List, Any, Iterator, Tuple, Iterable"
        ],
        [
            "STORE_NAME",
            "from typing import TypeVar, Union, List, Any, Iterator, Tuple, Iterable"
        ],
        [
            "STORE_NAME",
            "from typing import TypeVar, Union, List, Any, Iterator, Tuple, Iterable"
        ],
        [
            "STORE_NAME",
            "from typing import TypeVar, Union, List, Any, Iterator, Tuple, Iterable"
        ],
        [
            "STORE_NAME",
            "from typing import TypeVar, Union, List, Any, Iterator, Tuple, Iterable"
        ],
        [
            "STORE_NAME",
            "from typing import Type"
        ],
        [
            "LOAD_NAME",
            "ImportError"
        ],
        [
            "LOAD_NAME",
            "type"
        ],
        [
            "STORE_NAME",
            "Type"
        ],
        [
            "STORE_NAME",
            "from typing import Deque"
        ],
        [
            "LOAD_NAME",
            "ImportError"
        ],
        [
            "STORE_NAME",
            "from collections import deque as Deque"
        ],
        [
            "STORE_NAME",
            "from functools import lru_cache"
        ],
        [
            "LOAD_NAME",
            "ImportError"
        ],
        [
            "STORE_NAME",
            "from backports.functools_lru_cache import lru_cache"
        ],
        [
            "STORE_NAME",
            "from littleutils import strip_required_prefix"
        ],
        [
            "LOAD_NAME",
            "version_info"
        ],
        [
            "LOAD_ATTR",
            "version_info.major"
        ],
        [
            "COMPARE_OP",
            "version_info.major == 2"
        ],
        [
            "STORE_NAME",
            "PY2"
        ],
        [
            "LOAD_NAME",
            "PY2"
        ],
        [
            "UNARY_NOT",
            "not PY2"
        ],
        [
            "STORE_NAME",
            "PY3"
        ],
        [
            "LOAD_NAME",
            "TypeVar"
        ],
        [
            "CALL",
            "TypeVar('T')"
        ],
        [
            "STORE_NAME",
            "T"
        ],
        [
            "LOAD_NAME",
            "TypeVar"
        ],
        [
            "CALL",
            "TypeVar('RT')"
        ],
        [
            "STORE_NAME",
            "RT"
        ],
        [
            "STORE_NAME",
            "IPYTHON_FILE_PATH"
        ],
        [
            "STORE_NAME",
            "FILE_SENTINEL_NAME"
        ],
        [
            "LOAD_NAME",
            "PY2"
        ],
        [
            "LOAD_NAME",
            "unicode"
        ],
        [
            "STORE_NAME",
            "Text"
        ],
        [
            "LOAD_NAME",
            "str"
        ],
        [
            "STORE_NAME",
            "Text"
        ],
        [
            "STORE_NAME",
            "def path_leaf(path):\n    # type: (str) -> str\n    # http://stackoverflow.com/a/8384788/2482744\n    head, tail = ntpath.split(path)\n    return tail or ntpath.basename(head)"
        ],
        [
            "STORE_NAME",
            "def common_ancestor(paths):\n    # type: (List[str]) -> str\n    \"\"\"\n    Returns a path to a directory that contains all the given absolute paths\n    \"\"\"\n    prefix = os.path.commonprefix(paths)\n\n    # Ensure that the prefix doesn't end in part of the name of a file/directory\n    prefix = ntpath.split(prefix)[0]\n\n    # Ensure that it ends with a slash\n    first_char_after = paths[0][len(prefix)]\n    if first_char_after in r'\\/':\n        prefix += first_char_after\n\n    return prefix"
        ],
        [
            "STORE_NAME",
            "def short_path(path, all_paths):\n    # type: (str, List[str]) -> str\n    if path == IPYTHON_FILE_PATH:\n        return path\n\n    all_paths = [f for f in all_paths\n                 if f != IPYTHON_FILE_PATH]\n    prefix = common_ancestor(all_paths)\n    if prefix in r'\\/':\n        prefix = ''\n    return strip_required_prefix(path, prefix) or path_leaf(path)"
        ],
        [
            "STORE_NAME",
            "def fix_abs_path(path):\n    if path == IPYTHON_FILE_PATH:\n        return path\n    if os.path.sep == '/' and not path.startswith('/'):\n        path = '/' + path\n    return path"
        ],
        [
            "LOAD_NAME",
            "PY2"
        ],
        [
            "STORE_NAME",
            "    def correct_type(obj):\n        \"\"\"\n        Returns the correct type of obj, regardless of __class__ assignment\n        or old-style classes:\n\n        >>> class A:\n        ...     pass\n        ...\n        ...\n        ... class B(object):\n        ...     pass\n        ...\n        ...\n        ... class C(object):\n        ...     __class__ = A\n        ...\n        >>> correct_type(A()) is A\n        True\n        >>> correct_type(B()) is B\n        True\n        >>> correct_type(C()) is C\n        True\n        \"\"\"\n        t = type(obj)\n        # noinspection PyUnresolvedReferences\n        if t is types.InstanceType:\n            return obj.__class__\n        return t"
        ],
        [
            "LOAD_NAME",
            "type"
        ],
        [
            "STORE_NAME",
            "correct_type"
        ],
        [
            "STORE_NAME",
            "def of_type(type_or_tuple, iterable):\n    # type: (Union[type, Tuple[Union[type, tuple], ...]], Iterable[Any]) -> Iterator[Any]\n    return (x for x in iterable if isinstance(x, type_or_tuple))"
        ],
        [
            "STORE_NAME",
            "def safe_next(it):\n    # type: (Iterator[T]) -> T\n    \"\"\"\n    next() can raise a StopIteration which can cause strange bugs inside generators.\n    \"\"\"\n    try:\n        return next(it)\n    except StopIteration as e:\n        raise_from(RuntimeError, e)\n        raise"
        ],
        [
            "STORE_NAME",
            "def one_or_none(expression):\n    \"\"\"Performs a one_or_none on a sqlalchemy expression.\"\"\"\n    if hasattr(expression, 'one_or_none'):\n        return expression.one_or_none()\n    result = expression.all()\n    if len(result) == 0:\n        return None\n    elif len(result) == 1:\n        return result[0]\n    else:\n        raise Exception(\"There is more than one item returned for the supplied filter\")"
        ],
        [
            "STORE_NAME",
            "def flatten_list(lst):\n    result = []\n    for x in lst:\n        if isinstance(x, list):\n            result.extend(flatten_list(x))\n        else:\n            result.append(x)\n    return result"
        ],
        [
            "STORE_NAME",
            "def is_lambda(f):\n    try:\n        code = f.__code__\n    except AttributeError:\n        return False\n    return code.co_name == (lambda: 0).__code__.co_name"
        ],
        [
            "LOAD_NAME",
            "json"
        ],
        [
            "LOAD_ATTR",
            "json.JSONEncoder"
        ],
        [
            "CALL",
            "class ProtocolEncoder(json.JSONEncoder):\n    def default(self, o):\n        try:\n            method = o.as_json\n        except AttributeError:\n            return super(ProtocolEncoder, self).default(o)\n        else:\n            return method()"
        ],
        [
            "STORE_NAME",
            "class ProtocolEncoder(json.JSONEncoder):\n    def default(self, o):\n        try:\n            method = o.as_json\n        except AttributeError:\n            return super(ProtocolEncoder, self).default(o)\n        else:\n            return method()"
        ],
        [
            "STORE_NAME",
            "from tokenize import open as open_with_encoding_check"
        ],
        [
            "LOAD_NAME",
            "ImportError"
        ],
        [
            "STORE_NAME",
            "from lib2to3.pgen2.tokenize import detect_encoding"
        ],
        [
            "STORE_NAME",
            "import io"
        ],
        [
            "STORE_NAME",
            "    def open_with_encoding_check(filename):  # type: ignore\n        \"\"\"Open a file in read only mode using the encoding detected by\n        detect_encoding().\n        \"\"\"\n        fp = io.open(filename, 'rb')\n        try:\n            encoding, lines = detect_encoding(fp.readline)\n            fp.seek(0)\n            text = io.TextIOWrapper(fp, encoding, line_buffering=True)\n            text.mode = 'r'\n            return text\n        except:\n            fp.close()\n            raise"
        ],
        [
            "STORE_NAME",
            "def read_source_file(filename):\n    from lib2to3.pgen2.tokenize import cookie_re\n\n    if filename.endswith('.pyc'):\n        filename = filename[:-1]\n\n    with open_with_encoding_check(filename) as f:\n        return ''.join([\n            '\\n' if i < 2 and cookie_re.match(line)\n            else line\n            for i, line in enumerate(f)\n        ])"
        ],
        [
            "STORE_NAME",
            "def source_without_decorators(tokens, function_node):\n    def_token = safe_next(t for t in tokens.get_tokens(function_node)\n                          if t.string == 'def' and t.type == token.NAME)\n\n    startpos = def_token.startpos\n    source = tokens.text[startpos:function_node.last_token.endpos].rstrip()\n    assert source.startswith('def')\n\n    return startpos, source"
        ],
        [
            "STORE_NAME",
            "def prn(*args):\n    for arg in args:\n        print(arg)\n    if len(args) == 1:\n        return args[0]\n    return args"
        ],
        [
            "STORE_NAME",
            "def is_ipython_cell(filename):\n    return filename.startswith('<ipython-input-')"
        ],
        [
            "STORE_NAME",
            "def is_future_import(node):\n    return isinstance(node, ast.ImportFrom) and node.module == \"__future__\""
        ],
        [
            "STORE_NAME",
            "def get_unfrozen_datetime():\n    try:\n        # if freezegun could be active, we need to use real_datetime to ensure we use the actual time instead of the\n        # time set by freezegun.\n        # we have to import this at the last possible moment because birdeye is very likely to be imported before\n        # freezegun is activated.\n        from freezegun.api import real_datetime\n    except ImportError:\n        from datetime import datetime as real_datetime\n\n    return real_datetime.now()"
        ],
        [
            "LOAD_GLOBAL",
            "ntpath"
        ],
        [
            "LOAD_ATTR",
            "ntpath.split"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "CALL",
            "ntpath.split(path)"
        ],
        [
            "STORE_FAST",
            "head"
        ],
        [
            "STORE_FAST",
            "tail"
        ],
        [
            "LOAD_FAST",
            "tail"
        ],
        [
            "LOAD_GLOBAL",
            "ntpath"
        ],
        [
            "LOAD_ATTR",
            "ntpath.basename"
        ],
        [
            "LOAD_FAST",
            "head"
        ],
        [
            "CALL",
            "ntpath.basename(head)"
        ],
        [
            "LOAD_GLOBAL",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.commonprefix"
        ],
        [
            "LOAD_FAST",
            "paths"
        ],
        [
            "CALL",
            "os.path.commonprefix(paths)"
        ],
        [
            "STORE_FAST",
            "prefix"
        ],
        [
            "LOAD_GLOBAL",
            "ntpath"
        ],
        [
            "LOAD_ATTR",
            "ntpath.split"
        ],
        [
            "LOAD_FAST",
            "prefix"
        ],
        [
            "CALL",
            "ntpath.split(prefix)"
        ],
        [
            "BINARY_SUBSCR",
            "ntpath.split(prefix)[0]"
        ],
        [
            "STORE_FAST",
            "prefix"
        ],
        [
            "LOAD_FAST",
            "paths"
        ],
        [
            "BINARY_SUBSCR",
            "paths[0]"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "prefix"
        ],
        [
            "CALL",
            "len(prefix)"
        ],
        [
            "BINARY_SUBSCR",
            "paths[0][len(prefix)]"
        ],
        [
            "STORE_FAST",
            "first_char_after"
        ],
        [
            "LOAD_FAST",
            "first_char_after"
        ],
        [
            "CONTAINS_OP",
            "first_char_after in r'\\/'"
        ],
        [
            "LOAD_FAST",
            "prefix"
        ],
        [
            "LOAD_FAST",
            "first_char_after"
        ],
        [
            "BINARY_OP",
            "prefix += first_char_after"
        ],
        [
            "STORE_FAST",
            "prefix"
        ],
        [
            "LOAD_FAST",
            "prefix"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_GLOBAL",
            "IPYTHON_FILE_PATH"
        ],
        [
            "COMPARE_OP",
            "path == IPYTHON_FILE_PATH"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_FAST",
            "all_paths"
        ],
        [
            "CALL",
            "[f for f in all_paths\n                 if f != IPYTHON_FILE_PATH]"
        ],
        [
            "STORE_FAST",
            "all_paths"
        ],
        [
            "LOAD_GLOBAL",
            "common_ancestor"
        ],
        [
            "LOAD_FAST",
            "all_paths"
        ],
        [
            "CALL",
            "common_ancestor(all_paths)"
        ],
        [
            "STORE_FAST",
            "prefix"
        ],
        [
            "LOAD_FAST",
            "prefix"
        ],
        [
            "CONTAINS_OP",
            "prefix in r'\\/'"
        ],
        [
            "STORE_FAST",
            "prefix"
        ],
        [
            "LOAD_GLOBAL",
            "strip_required_prefix"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_FAST",
            "prefix"
        ],
        [
            "CALL",
            "strip_required_prefix(path, prefix)"
        ],
        [
            "LOAD_GLOBAL",
            "path_leaf"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "CALL",
            "path_leaf(path)"
        ],
        [
            "LOAD_FAST",
            "[f for f in all_paths\n                 if f != IPYTHON_FILE_PATH]"
        ],
        [
            "STORE_FAST",
            "f"
        ],
        [
            "LOAD_FAST",
            "f"
        ],
        [
            "LOAD_GLOBAL",
            "IPYTHON_FILE_PATH"
        ],
        [
            "COMPARE_OP",
            "f != IPYTHON_FILE_PATH"
        ],
        [
            "LOAD_FAST",
            "f"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_GLOBAL",
            "IPYTHON_FILE_PATH"
        ],
        [
            "COMPARE_OP",
            "path == IPYTHON_FILE_PATH"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_GLOBAL",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_ATTR",
            "os.path.sep"
        ],
        [
            "COMPARE_OP",
            "os.path.sep == '/'"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_METHOD",
            "path.startswith"
        ],
        [
            "CALL",
            "path.startswith('/')"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "BINARY_OP",
            "'/' + path"
        ],
        [
            "STORE_FAST",
            "path"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_GLOBAL",
            "type"
        ],
        [
            "LOAD_FAST",
            "obj"
        ],
        [
            "CALL",
            "type(obj)"
        ],
        [
            "STORE_FAST",
            "t"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "LOAD_GLOBAL",
            "types"
        ],
        [
            "LOAD_ATTR",
            "types.InstanceType"
        ],
        [
            "IS_OP",
            "t is types.InstanceType"
        ],
        [
            "LOAD_FAST",
            "obj"
        ],
        [
            "LOAD_ATTR",
            "obj.__class__"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "LOAD_FAST",
            "iterable"
        ],
        [
            "CALL",
            "(x for x in iterable if isinstance(x, type_or_tuple))"
        ],
        [
            "LOAD_FAST",
            "(x for x in iterable if isinstance(x, type_or_tuple))"
        ],
        [
            "STORE_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_DEREF",
            "type_or_tuple"
        ],
        [
            "CALL",
            "isinstance(x, type_or_tuple)"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "next"
        ],
        [
            "LOAD_FAST",
            "it"
        ],
        [
            "CALL",
            "next(it)"
        ],
        [
            "LOAD_GLOBAL",
            "StopIteration"
        ],
        [
            "STORE_FAST",
            "    except StopIteration as e:\n        raise_from(RuntimeError, e)\n        raise"
        ],
        [
            "LOAD_GLOBAL",
            "raise_from"
        ],
        [
            "LOAD_GLOBAL",
            "RuntimeError"
        ],
        [
            "LOAD_FAST",
            "e"
        ],
        [
            "CALL",
            "raise_from(RuntimeError, e)"
        ],
        [
            "LOAD_GLOBAL",
            "hasattr"
        ],
        [
            "LOAD_FAST",
            "expression"
        ],
        [
            "CALL",
            "hasattr(expression, 'one_or_none')"
        ],
        [
            "LOAD_FAST",
            "expression"
        ],
        [
            "LOAD_METHOD",
            "expression.one_or_none"
        ],
        [
            "CALL",
            "expression.one_or_none()"
        ],
        [
            "LOAD_FAST",
            "expression"
        ],
        [
            "LOAD_METHOD",
            "expression.all"
        ],
        [
            "CALL",
            "expression.all()"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "CALL",
            "len(result)"
        ],
        [
            "COMPARE_OP",
            "len(result) == 0"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "CALL",
            "len(result)"
        ],
        [
            "COMPARE_OP",
            "len(result) == 1"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "BINARY_SUBSCR",
            "result[0]"
        ],
        [
            "LOAD_GLOBAL",
            "Exception"
        ],
        [
            "CALL",
            "Exception(\"There is more than one item returned for the supplied filter\")"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "lst"
        ],
        [
            "STORE_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "CALL",
            "isinstance(x, list)"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_METHOD",
            "result.extend"
        ],
        [
            "LOAD_GLOBAL",
            "flatten_list"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "flatten_list(x)"
        ],
        [
            "CALL",
            "result.extend(flatten_list(x))"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_METHOD",
            "result.append"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "result.append(x)"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "f"
        ],
        [
            "LOAD_ATTR",
            "f.__code__"
        ],
        [
            "STORE_FAST",
            "code"
        ],
        [
            "LOAD_GLOBAL",
            "AttributeError"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_name"
        ],
        [
            "LOAD_ATTR",
            "(lambda: 0).__code__"
        ],
        [
            "LOAD_ATTR",
            "(lambda: 0).__code__.co_name"
        ],
        [
            "COMPARE_OP",
            "code.co_name == (lambda: 0).__code__.co_name"
        ],
        [
            "STORE_NAME",
            "    def default(self, o):\n        try:\n            method = o.as_json\n        except AttributeError:\n            return super(ProtocolEncoder, self).default(o)\n        else:\n            return method()"
        ],
        [
            "STORE_NAME",
            "    def default(self, o):\n        try:\n            method = o.as_json\n        except AttributeError:\n            return super(ProtocolEncoder, self).default(o)\n        else:\n            return method()"
        ],
        [
            "LOAD_FAST",
            "o"
        ],
        [
            "LOAD_ATTR",
            "o.as_json"
        ],
        [
            "STORE_FAST",
            "method"
        ],
        [
            "LOAD_FAST",
            "method"
        ],
        [
            "CALL",
            "method()"
        ],
        [
            "LOAD_GLOBAL",
            "AttributeError"
        ],
        [
            "LOAD_GLOBAL",
            "super"
        ],
        [
            "LOAD_GLOBAL",
            "ProtocolEncoder"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "super(ProtocolEncoder, self)"
        ],
        [
            "LOAD_METHOD",
            "super(ProtocolEncoder, self).default"
        ],
        [
            "LOAD_FAST",
            "o"
        ],
        [
            "CALL",
            "super(ProtocolEncoder, self).default(o)"
        ],
        [
            "LOAD_GLOBAL",
            "io"
        ],
        [
            "LOAD_ATTR",
            "io.open"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "CALL",
            "io.open(filename, 'rb')"
        ],
        [
            "STORE_FAST",
            "fp"
        ],
        [
            "LOAD_GLOBAL",
            "detect_encoding"
        ],
        [
            "LOAD_FAST",
            "fp"
        ],
        [
            "LOAD_ATTR",
            "fp.readline"
        ],
        [
            "CALL",
            "detect_encoding(fp.readline)"
        ],
        [
            "STORE_FAST",
            "encoding"
        ],
        [
            "STORE_FAST",
            "lines"
        ],
        [
            "LOAD_FAST",
            "fp"
        ],
        [
            "LOAD_METHOD",
            "fp.seek"
        ],
        [
            "CALL",
            "fp.seek(0)"
        ],
        [
            "LOAD_GLOBAL",
            "io"
        ],
        [
            "LOAD_ATTR",
            "io.TextIOWrapper"
        ],
        [
            "LOAD_FAST",
            "fp"
        ],
        [
            "LOAD_FAST",
            "encoding"
        ],
        [
            "CALL",
            "io.TextIOWrapper(fp, encoding, line_buffering=True)"
        ],
        [
            "STORE_FAST",
            "text"
        ],
        [
            "LOAD_FAST",
            "text"
        ],
        [
            "STORE_ATTR",
            "text.mode"
        ],
        [
            "LOAD_FAST",
            "text"
        ],
        [
            "LOAD_FAST",
            "fp"
        ],
        [
            "LOAD_METHOD",
            "fp.close"
        ],
        [
            "CALL",
            "fp.close()"
        ],
        [
            "STORE_DEREF",
            "from lib2to3.pgen2.tokenize import cookie_re"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_METHOD",
            "filename.endswith"
        ],
        [
            "CALL",
            "filename.endswith('.pyc')"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "BINARY_SUBSCR",
            "filename[:-1]"
        ],
        [
            "STORE_FAST",
            "filename"
        ],
        [
            "LOAD_GLOBAL",
            "open_with_encoding_check"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "CALL",
            "open_with_encoding_check(filename)"
        ],
        [
            "STORE_FAST",
            "f"
        ],
        [
            "LOAD_METHOD",
            "''.join"
        ],
        [
            "LOAD_GLOBAL",
            "enumerate"
        ],
        [
            "LOAD_FAST",
            "f"
        ],
        [
            "CALL",
            "enumerate(f)"
        ],
        [
            "CALL",
            "[\n            '\\n' if i < 2 and cookie_re.match(line)\n            else line\n            for i, line in enumerate(f)\n        ]"
        ],
        [
            "CALL",
            "''.join([\n            '\\n' if i < 2 and cookie_re.match(line)\n            else line\n            for i, line in enumerate(f)\n        ])"
        ],
        [
            "CALL",
            "    with open_with_encoding_check(filename) as f:\n        return ''.join([\n            '\\n' if i < 2 and cookie_re.match(line)\n            else line\n            for i, line in enumerate(f)\n        ])"
        ],
        [
            "LOAD_FAST",
            "[\n            '\\n' if i < 2 and cookie_re.match(line)\n            else line\n            for i, line in enumerate(f)\n        ]"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "STORE_FAST",
            "line"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "COMPARE_OP",
            "i < 2"
        ],
        [
            "LOAD_DEREF",
            "cookie_re"
        ],
        [
            "LOAD_METHOD",
            "cookie_re.match"
        ],
        [
            "LOAD_FAST",
            "line"
        ],
        [
            "CALL",
            "cookie_re.match(line)"
        ],
        [
            "LOAD_FAST",
            "line"
        ],
        [
            "LOAD_GLOBAL",
            "safe_next"
        ],
        [
            "LOAD_FAST",
            "tokens"
        ],
        [
            "LOAD_METHOD",
            "tokens.get_tokens"
        ],
        [
            "LOAD_FAST",
            "function_node"
        ],
        [
            "CALL",
            "tokens.get_tokens(function_node)"
        ],
        [
            "CALL",
            "(t for t in tokens.get_tokens(function_node)\n                          if t.string == 'def' and t.type == token.NAME)"
        ],
        [
            "CALL",
            "safe_next(t for t in tokens.get_tokens(function_node)\n                          if t.string == 'def' and t.type == token.NAME)"
        ],
        [
            "STORE_FAST",
            "def_token"
        ],
        [
            "LOAD_FAST",
            "def_token"
        ],
        [
            "LOAD_ATTR",
            "def_token.startpos"
        ],
        [
            "STORE_FAST",
            "startpos"
        ],
        [
            "LOAD_FAST",
            "tokens"
        ],
        [
            "LOAD_ATTR",
            "tokens.text"
        ],
        [
            "LOAD_FAST",
            "startpos"
        ],
        [
            "LOAD_FAST",
            "function_node"
        ],
        [
            "LOAD_ATTR",
            "function_node.last_token"
        ],
        [
            "LOAD_ATTR",
            "function_node.last_token.endpos"
        ],
        [
            "BINARY_SUBSCR",
            "tokens.text[startpos:function_node.last_token.endpos]"
        ],
        [
            "LOAD_METHOD",
            "tokens.text[startpos:function_node.last_token.endpos].rstrip"
        ],
        [
            "CALL",
            "tokens.text[startpos:function_node.last_token.endpos].rstrip()"
        ],
        [
            "STORE_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_METHOD",
            "source.startswith"
        ],
        [
            "CALL",
            "source.startswith('def')"
        ],
        [
            "LOAD_FAST",
            "startpos"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "(t for t in tokens.get_tokens(function_node)\n                          if t.string == 'def' and t.type == token.NAME)"
        ],
        [
            "STORE_FAST",
            "t"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "LOAD_ATTR",
            "t.string"
        ],
        [
            "COMPARE_OP",
            "t.string == 'def'"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "LOAD_ATTR",
            "t.type"
        ],
        [
            "LOAD_GLOBAL",
            "token"
        ],
        [
            "LOAD_ATTR",
            "token.NAME"
        ],
        [
            "COMPARE_OP",
            "t.type == token.NAME"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "STORE_FAST",
            "arg"
        ],
        [
            "LOAD_GLOBAL",
            "print"
        ],
        [
            "LOAD_FAST",
            "arg"
        ],
        [
            "CALL",
            "print(arg)"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "CALL",
            "len(args)"
        ],
        [
            "COMPARE_OP",
            "len(args) == 1"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "BINARY_SUBSCR",
            "args[0]"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_METHOD",
            "filename.startswith"
        ],
        [
            "CALL",
            "filename.startswith('<ipython-input-')"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.ImportFrom"
        ],
        [
            "CALL",
            "isinstance(node, ast.ImportFrom)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.module"
        ],
        [
            "COMPARE_OP",
            "node.module == \"__future__\""
        ],
        [
            "STORE_FAST",
            "from freezegun.api import real_datetime"
        ],
        [
            "LOAD_GLOBAL",
            "ImportError"
        ],
        [
            "STORE_FAST",
            "from datetime import datetime as real_datetime"
        ],
        [
            "LOAD_FAST",
            "real_datetime"
        ],
        [
            "LOAD_METHOD",
            "real_datetime.now"
        ],
        [
            "CALL",
            "real_datetime.now()"
        ]
    ],
    "utils2.py": [
        [
            "STORE_NAME",
            "import ast"
        ],
        [
            "STORE_NAME",
            "import inspect"
        ],
        [
            "STORE_NAME",
            "import os"
        ],
        [
            "STORE_NAME",
            "import sys"
        ],
        [
            "STORE_NAME",
            "from itertools import chain"
        ],
        [
            "STORE_NAME",
            "import six"
        ],
        [
            "STORE_NAME",
            "from cheap_repr import cheap_repr, try_register_repr"
        ],
        [
            "STORE_NAME",
            "from cheap_repr import cheap_repr, try_register_repr"
        ],
        [
            "LOAD_NAME",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.version"
        ],
        [
            "LOAD_METHOD",
            "sys.version.lower"
        ],
        [
            "CALL",
            "sys.version.lower()"
        ],
        [
            "CONTAINS_OP",
            "'pypy' in sys.version.lower()"
        ],
        [
            "LOAD_NAME",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.version_info"
        ],
        [
            "BINARY_SUBSCR",
            "sys.version_info[:2]"
        ],
        [
            "CONTAINS_OP",
            "sys.version_info[:2] in [(3, 4), (3, 8)]"
        ],
        [
            "STORE_NAME",
            "NO_ASTTOKENS"
        ],
        [
            "LOAD_NAME",
            "IOError"
        ],
        [
            "LOAD_NAME",
            "OSError"
        ],
        [
            "LOAD_NAME",
            "ValueError"
        ],
        [
            "STORE_NAME",
            "file_reading_errors"
        ],
        [
            "STORE_NAME",
            "def shitcode(s):\n    return ''.join(\n        (c if (0 < ord(c) < 256) else '?') for c in s\n    )"
        ],
        [
            "STORE_NAME",
            "def truncate(seq, max_length, middle):\n    if len(seq) > max_length:\n        left = (max_length - len(middle)) // 2\n        right = max_length - len(middle) - left\n        seq = seq[:left] + middle + seq[-right:]\n    return seq"
        ],
        [
            "STORE_NAME",
            "def truncate_string(string, max_length):\n    return truncate(string, max_length, '...')"
        ],
        [
            "STORE_NAME",
            "def truncate_list(lst, max_length):\n    return truncate(lst, max_length, ['...'])"
        ],
        [
            "STORE_NAME",
            "def ensure_tuple(x, split=False):\n    if split and isinstance(x, six.string_types):\n        x = x.replace(',', ' ').split()\n    if not isinstance(x, (list, set, tuple)):\n        x = (x,)\n    return tuple(x)"
        ],
        [
            "STORE_NAME",
            "def short_filename(code):\n    result = os.path.basename(code.co_filename)\n    if result.endswith('.pyc'):\n        result = result[:-1]\n    return result"
        ],
        [
            "STORE_NAME",
            "def is_comprehension_frame(frame):\n    return frame.f_code.co_name in ('<listcomp>', '<dictcomp>', '<setcomp>')"
        ],
        [
            "STORE_NAME",
            "def needs_parentheses(source):\n    def code(s):\n        return compile(s.format(source), '<variable>', 'eval').co_code\n\n    try:\n        without_parens = code('{}.x')\n    except SyntaxError:\n        # Likely a multiline expression that needs parentheses to be valid\n        code('({})')\n        return True\n    else:\n        return without_parens != code('({}).x')"
        ],
        [
            "STORE_NAME",
            "def with_needed_parentheses(source):\n    if needs_parentheses(source):\n        return '({})'.format(source)\n    else:\n        return source"
        ],
        [
            "STORE_NAME",
            "REPR_TARGET_LENGTH"
        ],
        [
            "STORE_NAME",
            "def my_cheap_repr(x):\n    return cheap_repr(x, target_length=REPR_TARGET_LENGTH)"
        ],
        [
            "LOAD_NAME",
            "dict"
        ],
        [
            "CALL",
            "class ArgDefaultDict(dict):\n    def __init__(self, factory):\n        super(ArgDefaultDict, self).__init__()\n        self.factory = factory\n\n    def __missing__(self, key):\n        result = self[key] = self.factory(key)\n        return result"
        ],
        [
            "STORE_NAME",
            "class ArgDefaultDict(dict):\n    def __init__(self, factory):\n        super(ArgDefaultDict, self).__init__()\n        self.factory = factory\n\n    def __missing__(self, key):\n        result = self[key] = self.factory(key)\n        return result"
        ],
        [
            "STORE_NAME",
            "def optional_numeric_label(i, lst):\n    if len(lst) == 1:\n        return ''\n    else:\n        return ' ' + str(i + 1)"
        ],
        [
            "STORE_NAME",
            "def is_pathlike(x):\n    if hasattr(os, 'PathLike'):\n        return isinstance(x, os.PathLike)\n\n    return (\n            hasattr(x, '__fspath__') or\n            # Make a concession for older `pathlib` versions:\n            (hasattr(x, 'open') and\n             'path' in x.__class__.__name__.lower())\n    )"
        ],
        [
            "LOAD_NAME",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.iscoroutinefunction"
        ],
        [
            "STORE_NAME",
            "iscoroutinefunction"
        ],
        [
            "LOAD_NAME",
            "AttributeError"
        ],
        [
            "STORE_NAME",
            "    def iscoroutinefunction(_):\n        return False"
        ],
        [
            "LOAD_NAME",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Try"
        ],
        [
            "STORE_NAME",
            "try_statement"
        ],
        [
            "LOAD_NAME",
            "AttributeError"
        ],
        [
            "LOAD_NAME",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.TryExcept"
        ],
        [
            "STORE_NAME",
            "try_statement"
        ],
        [
            "LOAD_NAME",
            "__import__"
        ],
        [
            "CALL",
            "__import__(\"__builtin__\")"
        ],
        [
            "STORE_NAME",
            "builtins"
        ],
        [
            "LOAD_NAME",
            "ImportError"
        ],
        [
            "LOAD_NAME",
            "__import__"
        ],
        [
            "CALL",
            "__import__(\"builtins\")"
        ],
        [
            "STORE_NAME",
            "builtins"
        ],
        [
            "LOAD_NAME",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.FormattedValue"
        ],
        [
            "STORE_NAME",
            "FormattedValue"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "    class FormattedValue(object):\n        pass"
        ],
        [
            "STORE_NAME",
            "    class FormattedValue(object):\n        pass"
        ],
        [
            "STORE_NAME",
            "def no_args_decorator(args, kwargs):\n    return len(args) == 1 and inspect.isfunction(args[0]) and not kwargs"
        ],
        [
            "STORE_NAME",
            "from functools import lru_cache"
        ],
        [
            "LOAD_NAME",
            "ImportError"
        ],
        [
            "STORE_NAME",
            "from backports.functools_lru_cache import lru_cache"
        ],
        [
            "LOAD_NAME",
            "str"
        ],
        [
            "CALL",
            "class DirectRepr(str):\n    def __repr__(self):\n        return self"
        ],
        [
            "STORE_NAME",
            "class DirectRepr(str):\n    def __repr__(self):\n        return self"
        ],
        [
            "STORE_NAME",
            "from django.db.models import QuerySet"
        ],
        [
            "LOAD_NAME",
            "ImportError"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "    class QuerySet(object):\n        pass"
        ],
        [
            "STORE_NAME",
            "    class QuerySet(object):\n        pass"
        ],
        [
            "STORE_NAME",
            "def _sample_indices(length, max_length):\n    if length <= max_length + 2:\n        return range(length)\n    else:\n        return chain(range(max_length // 2),\n                     range(length - max_length // 2,\n                           length))"
        ],
        [
            "LOAD_NAME",
            "try_register_repr"
        ],
        [
            "CALL",
            "try_register_repr('pandas', 'Series')"
        ],
        [
            "CALL",
            "try_register_repr('pandas', 'Series')"
        ],
        [
            "STORE_NAME",
            "@try_register_repr('pandas', 'Series')\ndef _repr_series_one_line(x, helper):\n    n = len(x)\n    if n == 0:\n        return repr(x)\n    newlevel = helper.level - 1\n    pieces = []\n    maxparts = _repr_series_one_line.maxparts\n    for i in _sample_indices(n, maxparts):\n        k = x.index[i:i + 1].format(sparsify=False)[0]\n        v = x.iloc[i]\n        pieces.append('%s = %s' % (k, cheap_repr(v, newlevel)))\n    if n > maxparts + 2:\n        pieces.insert(maxparts // 2, '...')\n    return '; '.join(pieces)"
        ],
        [
            "LOAD_METHOD",
            "''.join"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "CALL",
            "(\n        (c if (0 < ord(c) < 256) else '?') for c in s\n    )"
        ],
        [
            "CALL",
            "''.join(\n        (c if (0 < ord(c) < 256) else '?') for c in s\n    )"
        ],
        [
            "LOAD_FAST",
            "(\n        (c if (0 < ord(c) < 256) else '?') for c in s\n    )"
        ],
        [
            "STORE_FAST",
            "c"
        ],
        [
            "LOAD_GLOBAL",
            "ord"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "CALL",
            "ord(c)"
        ],
        [
            "COMPARE_OP",
            "0 < ord(c) < 256"
        ],
        [
            "COMPARE_OP",
            "0 < ord(c) < 256"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "seq"
        ],
        [
            "CALL",
            "len(seq)"
        ],
        [
            "LOAD_FAST",
            "max_length"
        ],
        [
            "COMPARE_OP",
            "len(seq) > max_length"
        ],
        [
            "LOAD_FAST",
            "max_length"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "middle"
        ],
        [
            "CALL",
            "len(middle)"
        ],
        [
            "BINARY_OP",
            "max_length - len(middle)"
        ],
        [
            "BINARY_OP",
            "(max_length - len(middle)) // 2"
        ],
        [
            "STORE_FAST",
            "left"
        ],
        [
            "LOAD_FAST",
            "max_length"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "middle"
        ],
        [
            "CALL",
            "len(middle)"
        ],
        [
            "BINARY_OP",
            "max_length - len(middle)"
        ],
        [
            "LOAD_FAST",
            "left"
        ],
        [
            "BINARY_OP",
            "max_length - len(middle) - left"
        ],
        [
            "STORE_FAST",
            "right"
        ],
        [
            "LOAD_FAST",
            "seq"
        ],
        [
            "LOAD_FAST",
            "left"
        ],
        [
            "BINARY_SUBSCR",
            "seq[:left]"
        ],
        [
            "LOAD_FAST",
            "middle"
        ],
        [
            "BINARY_OP",
            "seq[:left] + middle"
        ],
        [
            "LOAD_FAST",
            "seq"
        ],
        [
            "LOAD_FAST",
            "right"
        ],
        [
            "UNARY_NEGATIVE",
            "-right"
        ],
        [
            "BINARY_SUBSCR",
            "seq[-right:]"
        ],
        [
            "BINARY_OP",
            "seq[:left] + middle + seq[-right:]"
        ],
        [
            "STORE_FAST",
            "seq"
        ],
        [
            "LOAD_FAST",
            "seq"
        ],
        [
            "LOAD_GLOBAL",
            "truncate"
        ],
        [
            "LOAD_FAST",
            "string"
        ],
        [
            "LOAD_FAST",
            "max_length"
        ],
        [
            "CALL",
            "truncate(string, max_length, '...')"
        ],
        [
            "LOAD_GLOBAL",
            "truncate"
        ],
        [
            "LOAD_FAST",
            "lst"
        ],
        [
            "LOAD_FAST",
            "max_length"
        ],
        [
            "CALL",
            "truncate(lst, max_length, ['...'])"
        ],
        [
            "LOAD_FAST",
            "split"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "six"
        ],
        [
            "LOAD_ATTR",
            "six.string_types"
        ],
        [
            "CALL",
            "isinstance(x, six.string_types)"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_METHOD",
            "x.replace"
        ],
        [
            "CALL",
            "x.replace(',', ' ')"
        ],
        [
            "LOAD_METHOD",
            "x.replace(',', ' ').split"
        ],
        [
            "CALL",
            "x.replace(',', ' ').split()"
        ],
        [
            "STORE_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_GLOBAL",
            "set"
        ],
        [
            "LOAD_GLOBAL",
            "tuple"
        ],
        [
            "CALL",
            "isinstance(x, (list, set, tuple))"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "STORE_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "tuple"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "tuple(x)"
        ],
        [
            "LOAD_GLOBAL",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.basename"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_filename"
        ],
        [
            "CALL",
            "os.path.basename(code.co_filename)"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_METHOD",
            "result.endswith"
        ],
        [
            "CALL",
            "result.endswith('.pyc')"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "BINARY_SUBSCR",
            "result[:-1]"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_name"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code.co_name in ('<listcomp>', '<dictcomp>', '<setcomp>')"
        ],
        [
            "STORE_FAST",
            "    def code(s):\n        return compile(s.format(source), '<variable>', 'eval').co_code"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "CALL",
            "code('{}.x')"
        ],
        [
            "STORE_FAST",
            "without_parens"
        ],
        [
            "LOAD_FAST",
            "without_parens"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "CALL",
            "code('({}).x')"
        ],
        [
            "COMPARE_OP",
            "without_parens != code('({}).x')"
        ],
        [
            "LOAD_GLOBAL",
            "SyntaxError"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "CALL",
            "code('({})')"
        ],
        [
            "LOAD_GLOBAL",
            "compile"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_METHOD",
            "s.format"
        ],
        [
            "LOAD_DEREF",
            "source"
        ],
        [
            "CALL",
            "s.format(source)"
        ],
        [
            "CALL",
            "compile(s.format(source), '<variable>', 'eval')"
        ],
        [
            "LOAD_ATTR",
            "compile(s.format(source), '<variable>', 'eval').co_code"
        ],
        [
            "LOAD_GLOBAL",
            "needs_parentheses"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CALL",
            "needs_parentheses(source)"
        ],
        [
            "LOAD_METHOD",
            "'({})'.format"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CALL",
            "'({})'.format(source)"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_GLOBAL",
            "cheap_repr"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "REPR_TARGET_LENGTH"
        ],
        [
            "CALL",
            "cheap_repr(x, target_length=REPR_TARGET_LENGTH)"
        ],
        [
            "STORE_NAME",
            "    def __init__(self, factory):\n        super(ArgDefaultDict, self).__init__()\n        self.factory = factory"
        ],
        [
            "STORE_NAME",
            "    def __missing__(self, key):\n        result = self[key] = self.factory(key)\n        return result"
        ],
        [
            "STORE_NAME",
            "    def __missing__(self, key):\n        result = self[key] = self.factory(key)\n        return result"
        ],
        [
            "LOAD_GLOBAL",
            "super"
        ],
        [
            "LOAD_GLOBAL",
            "ArgDefaultDict"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "super(ArgDefaultDict, self)"
        ],
        [
            "LOAD_METHOD",
            "super(ArgDefaultDict, self).__init__"
        ],
        [
            "CALL",
            "super(ArgDefaultDict, self).__init__()"
        ],
        [
            "LOAD_FAST",
            "factory"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.factory"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.factory"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "CALL",
            "self.factory(key)"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "STORE_SUBSCR",
            "self[key]"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "lst"
        ],
        [
            "CALL",
            "len(lst)"
        ],
        [
            "COMPARE_OP",
            "len(lst) == 1"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_OP",
            "i + 1"
        ],
        [
            "CALL",
            "str(i + 1)"
        ],
        [
            "BINARY_OP",
            "' ' + str(i + 1)"
        ],
        [
            "LOAD_GLOBAL",
            "hasattr"
        ],
        [
            "LOAD_GLOBAL",
            "os"
        ],
        [
            "CALL",
            "hasattr(os, 'PathLike')"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.PathLike"
        ],
        [
            "CALL",
            "isinstance(x, os.PathLike)"
        ],
        [
            "LOAD_GLOBAL",
            "hasattr"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "hasattr(x, '__fspath__')"
        ],
        [
            "LOAD_GLOBAL",
            "hasattr"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "hasattr(x, 'open')"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_ATTR",
            "x.__class__"
        ],
        [
            "LOAD_ATTR",
            "x.__class__.__name__"
        ],
        [
            "LOAD_METHOD",
            "x.__class__.__name__.lower"
        ],
        [
            "CALL",
            "x.__class__.__name__.lower()"
        ],
        [
            "CONTAINS_OP",
            "'path' in x.__class__.__name__.lower()"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "CALL",
            "len(args)"
        ],
        [
            "COMPARE_OP",
            "len(args) == 1"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.isfunction"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "BINARY_SUBSCR",
            "args[0]"
        ],
        [
            "CALL",
            "inspect.isfunction(args[0])"
        ],
        [
            "LOAD_FAST",
            "kwargs"
        ],
        [
            "UNARY_NOT",
            "not kwargs"
        ],
        [
            "STORE_NAME",
            "    def __repr__(self):\n        return self"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "LOAD_FAST",
            "max_length"
        ],
        [
            "BINARY_OP",
            "max_length + 2"
        ],
        [
            "COMPARE_OP",
            "length <= max_length + 2"
        ],
        [
            "LOAD_GLOBAL",
            "range"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "CALL",
            "range(length)"
        ],
        [
            "LOAD_GLOBAL",
            "chain"
        ],
        [
            "LOAD_GLOBAL",
            "range"
        ],
        [
            "LOAD_FAST",
            "max_length"
        ],
        [
            "BINARY_OP",
            "max_length // 2"
        ],
        [
            "CALL",
            "range(max_length // 2)"
        ],
        [
            "LOAD_GLOBAL",
            "range"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "LOAD_FAST",
            "max_length"
        ],
        [
            "BINARY_OP",
            "max_length // 2"
        ],
        [
            "BINARY_OP",
            "length - max_length // 2"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "CALL",
            "range(length - max_length // 2,\n                           length)"
        ],
        [
            "CALL",
            "chain(range(max_length // 2),\n                     range(length - max_length // 2,\n                           length))"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "len(x)"
        ],
        [
            "STORE_FAST",
            "n"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "COMPARE_OP",
            "n == 0"
        ],
        [
            "LOAD_GLOBAL",
            "repr"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "repr(x)"
        ],
        [
            "LOAD_FAST",
            "helper"
        ],
        [
            "LOAD_ATTR",
            "helper.level"
        ],
        [
            "BINARY_OP",
            "helper.level - 1"
        ],
        [
            "STORE_FAST",
            "newlevel"
        ],
        [
            "STORE_FAST",
            "pieces"
        ],
        [
            "LOAD_GLOBAL",
            "_repr_series_one_line"
        ],
        [
            "LOAD_ATTR",
            "_repr_series_one_line.maxparts"
        ],
        [
            "STORE_FAST",
            "maxparts"
        ],
        [
            "LOAD_GLOBAL",
            "_sample_indices"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "LOAD_FAST",
            "maxparts"
        ],
        [
            "CALL",
            "_sample_indices(n, maxparts)"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_ATTR",
            "x.index"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_OP",
            "i + 1"
        ],
        [
            "BINARY_SUBSCR",
            "x.index[i:i + 1]"
        ],
        [
            "LOAD_METHOD",
            "x.index[i:i + 1].format"
        ],
        [
            "CALL",
            "x.index[i:i + 1].format(sparsify=False)"
        ],
        [
            "BINARY_SUBSCR",
            "x.index[i:i + 1].format(sparsify=False)[0]"
        ],
        [
            "STORE_FAST",
            "k"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_ATTR",
            "x.iloc"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_SUBSCR",
            "x.iloc[i]"
        ],
        [
            "STORE_FAST",
            "v"
        ],
        [
            "LOAD_FAST",
            "pieces"
        ],
        [
            "LOAD_METHOD",
            "pieces.append"
        ],
        [
            "LOAD_FAST",
            "k"
        ],
        [
            "LOAD_GLOBAL",
            "cheap_repr"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "LOAD_FAST",
            "newlevel"
        ],
        [
            "CALL",
            "cheap_repr(v, newlevel)"
        ],
        [
            "BUILD_STRING",
            "'%s = %s' % (k, cheap_repr(v, newlevel))"
        ],
        [
            "CALL",
            "pieces.append('%s = %s' % (k, cheap_repr(v, newlevel)))"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "LOAD_FAST",
            "maxparts"
        ],
        [
            "BINARY_OP",
            "maxparts + 2"
        ],
        [
            "COMPARE_OP",
            "n > maxparts + 2"
        ],
        [
            "LOAD_FAST",
            "pieces"
        ],
        [
            "LOAD_METHOD",
            "pieces.insert"
        ],
        [
            "LOAD_FAST",
            "maxparts"
        ],
        [
            "BINARY_OP",
            "maxparts // 2"
        ],
        [
            "CALL",
            "pieces.insert(maxparts // 2, '...')"
        ],
        [
            "LOAD_METHOD",
            "'; '.join"
        ],
        [
            "LOAD_FAST",
            "pieces"
        ],
        [
            "CALL",
            "'; '.join(pieces)"
        ]
    ]
}