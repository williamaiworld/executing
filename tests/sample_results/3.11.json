{
    "bird.py": [
        [
            "STORE_NAME",
            "from __future__ import absolute_import, division, print_function"
        ],
        [
            "STORE_NAME",
            "from __future__ import absolute_import, division, print_function"
        ],
        [
            "STORE_NAME",
            "from __future__ import absolute_import, division, print_function"
        ],
        [
            "STORE_NAME",
            "from future import standard_library"
        ],
        [
            "LOAD_NAME",
            "standard_library"
        ],
        [
            "LOAD_ATTR",
            "standard_library.install_aliases"
        ],
        [
            "CALL",
            "standard_library.install_aliases()"
        ],
        [
            "STORE_NAME",
            "from future.utils import iteritems"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
        ],
        [
            "STORE_NAME",
            "from types import FrameType, TracebackType, CodeType, FunctionType, ModuleType"
        ],
        [
            "STORE_NAME",
            "from types import FrameType, TracebackType, CodeType, FunctionType, ModuleType"
        ],
        [
            "STORE_NAME",
            "from types import FrameType, TracebackType, CodeType, FunctionType, ModuleType"
        ],
        [
            "STORE_NAME",
            "from types import FrameType, TracebackType, CodeType, FunctionType, ModuleType"
        ],
        [
            "STORE_NAME",
            "from types import FrameType, TracebackType, CodeType, FunctionType, ModuleType"
        ],
        [
            "STORE_NAME",
            "import typing"
        ],
        [
            "STORE_NAME",
            "import ast"
        ],
        [
            "STORE_NAME",
            "import html"
        ],
        [
            "STORE_NAME",
            "import inspect"
        ],
        [
            "STORE_NAME",
            "import json"
        ],
        [
            "STORE_NAME",
            "import os"
        ],
        [
            "STORE_NAME",
            "import traceback"
        ],
        [
            "STORE_NAME",
            "from collections import defaultdict, Sequence, Set, Mapping, deque, namedtuple, Counter"
        ],
        [
            "STORE_NAME",
            "from collections import defaultdict, Sequence, Set, Mapping, deque, namedtuple, Counter"
        ],
        [
            "STORE_NAME",
            "from collections import defaultdict, Sequence, Set, Mapping, deque, namedtuple, Counter"
        ],
        [
            "STORE_NAME",
            "from collections import defaultdict, Sequence, Set, Mapping, deque, namedtuple, Counter"
        ],
        [
            "STORE_NAME",
            "from collections import defaultdict, Sequence, Set, Mapping, deque, namedtuple, Counter"
        ],
        [
            "STORE_NAME",
            "from collections import defaultdict, Sequence, Set, Mapping, deque, namedtuple, Counter"
        ],
        [
            "STORE_NAME",
            "from collections import defaultdict, Sequence, Set, Mapping, deque, namedtuple, Counter"
        ],
        [
            "STORE_NAME",
            "from functools import partial"
        ],
        [
            "STORE_NAME",
            "from itertools import chain, islice"
        ],
        [
            "STORE_NAME",
            "from itertools import chain, islice"
        ],
        [
            "STORE_NAME",
            "from threading import Lock"
        ],
        [
            "STORE_NAME",
            "from uuid import uuid4"
        ],
        [
            "STORE_NAME",
            "import hashlib"
        ],
        [
            "STORE_NAME",
            "import sys"
        ],
        [
            "STORE_NAME",
            "from asttokens import ASTTokens"
        ],
        [
            "STORE_NAME",
            "from littleutils import group_by_key_func, only"
        ],
        [
            "STORE_NAME",
            "from littleutils import group_by_key_func, only"
        ],
        [
            "STORE_NAME",
            "from outdated import warn_if_outdated"
        ],
        [
            "STORE_NAME",
            "from cached_property import cached_property"
        ],
        [
            "STORE_NAME",
            "from cheap_repr import cheap_repr, try_register_repr"
        ],
        [
            "STORE_NAME",
            "from cheap_repr import cheap_repr, try_register_repr"
        ],
        [
            "STORE_NAME",
            "from cheap_repr.utils import safe_qualname, exception_string"
        ],
        [
            "STORE_NAME",
            "from cheap_repr.utils import safe_qualname, exception_string"
        ],
        [
            "STORE_NAME",
            "from birdseye.db import Database, retry_db"
        ],
        [
            "STORE_NAME",
            "from birdseye.db import Database, retry_db"
        ],
        [
            "STORE_NAME",
            "from birdseye.tracer import TreeTracerBase, TracedFile, EnterCallInfo, ExitCallInfo, FrameInfo, ChangeValue, Loop"
        ],
        [
            "STORE_NAME",
            "from birdseye.tracer import TreeTracerBase, TracedFile, EnterCallInfo, ExitCallInfo, FrameInfo, ChangeValue, Loop"
        ],
        [
            "STORE_NAME",
            "from birdseye.tracer import TreeTracerBase, TracedFile, EnterCallInfo, ExitCallInfo, FrameInfo, ChangeValue, Loop"
        ],
        [
            "STORE_NAME",
            "from birdseye.tracer import TreeTracerBase, TracedFile, EnterCallInfo, ExitCallInfo, FrameInfo, ChangeValue, Loop"
        ],
        [
            "STORE_NAME",
            "from birdseye.tracer import TreeTracerBase, TracedFile, EnterCallInfo, ExitCallInfo, FrameInfo, ChangeValue, Loop"
        ],
        [
            "STORE_NAME",
            "from birdseye.tracer import TreeTracerBase, TracedFile, EnterCallInfo, ExitCallInfo, FrameInfo, ChangeValue, Loop"
        ],
        [
            "STORE_NAME",
            "from birdseye.tracer import TreeTracerBase, TracedFile, EnterCallInfo, ExitCallInfo, FrameInfo, ChangeValue, Loop"
        ],
        [
            "STORE_NAME",
            "from birdseye import tracer"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
        ],
        [
            "STORE_NAME",
            "from birdseye import __version__"
        ],
        [
            "STORE_NAME",
            "from numpy import ndarray"
        ],
        [
            "LOAD_NAME",
            "ImportError"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "    class ndarray(object):\n        pass"
        ],
        [
            "STORE_NAME",
            "    class ndarray(object):\n        pass"
        ],
        [
            "STORE_NAME",
            "from pandas import DataFrame, Series"
        ],
        [
            "STORE_NAME",
            "from pandas import DataFrame, Series"
        ],
        [
            "LOAD_NAME",
            "ImportError"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "    class DataFrame(object):\n        pass"
        ],
        [
            "STORE_NAME",
            "    class DataFrame(object):\n        pass"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "    class Series(object):\n        pass"
        ],
        [
            "STORE_NAME",
            "    class Series(object):\n        pass"
        ],
        [
            "STORE_NAME",
            "from django.db.models import QuerySet"
        ],
        [
            "LOAD_NAME",
            "ImportError"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "    class QuerySet(object):\n        pass"
        ],
        [
            "STORE_NAME",
            "    class QuerySet(object):\n        pass"
        ],
        [
            "LOAD_NAME",
            "warn_if_outdated"
        ],
        [
            "LOAD_NAME",
            "__version__"
        ],
        [
            "CALL",
            "warn_if_outdated('birdseye', __version__)"
        ],
        [
            "LOAD_NAME",
            "namedtuple"
        ],
        [
            "CALL",
            "namedtuple('CodeInfo', 'db_func traced_file arg_names')"
        ],
        [
            "STORE_NAME",
            "CodeInfo"
        ],
        [
            "LOAD_NAME",
            "TreeTracerBase"
        ],
        [
            "CALL",
            "class BirdsEye(TreeTracerBase):\n    \"\"\"\n    Decorate functions with an instance of this class to debug them,\n    or just use the existing instance `eye`.\n    \"\"\"\n\n    def __init__(self, db_uri=None, num_samples=None):\n        \"\"\"\n        Set db_uri to specify where the database lives, as an alternative to\n        the environment variable BIRDSEYE_DB.\n        \"\"\"\n        super(BirdsEye, self).__init__()\n        self._db_uri = db_uri\n        self._code_infos = {}  # type: Dict[CodeType, CodeInfo]\n        self._last_call_id = None\n        self._ipython_cell_value = None\n        self.num_samples = num_samples or dict(\n            big=dict(\n                attributes=50,\n                dict=50,\n                list=30,\n                set=30,\n                pandas_rows=20,\n                pandas_cols=100,\n            ),\n            small=dict(\n                attributes=50,\n                dict=10,\n                list=6,\n                set=6,\n                pandas_rows=6,\n                pandas_cols=10,\n            ),\n        )\n\n    @cached_property\n    def db(self):\n        return Database(self._db_uri)\n\n    def parse_extra(self, root, source, filename):\n        # type: (ast.Module, str, str) -> None\n        for node in ast.walk(root):  # type: ast.AST\n            node._loops = tracer.loops(node)\n            if isinstance(node, ast.expr):\n                node._is_interesting_expression = is_interesting_expression(node)\n\n    @lru_cache()\n    def compile(self, source, filename, flags=0):\n        traced_file = super(BirdsEye, self).compile(source, filename, flags)\n        traced_file.tokens = ASTTokens(source, tree=traced_file.root)\n        return traced_file\n\n    def before_stmt(self, node, frame):\n        # type: (ast.stmt, FrameType) -> None\n        if frame.f_code not in self._code_infos:\n            return\n        if isinstance(node.parent, ast.For) and node is node.parent.body[0]:\n            self._add_iteration(node._loops, frame)\n\n    def before_expr(self, node, frame):\n        if isinstance(node.parent, ast.While) and node is node.parent.test:\n            self._add_iteration(node._loops, frame)\n\n    def _add_iteration(self, loops, frame):\n        # type: (typing.Sequence[Loop], FrameType) -> None\n        \"\"\"\n        Given one or more nested loops, add an iteration for the innermost\n        loop (the last in the sequence).\n        \"\"\"\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for i, loop_node in enumerate(loops):\n            loop = iteration.loops[loop_node._tree_index]\n            if i == len(loops) - 1:\n                loop.append(Iteration())\n            else:\n                iteration = loop.last()\n\n    def after_expr(self, node, frame, value, exc_value, exc_tb):\n        # type: (ast.expr, FrameType, Any, Optional[BaseException], Optional[TracebackType]) -> Optional[ChangeValue]\n\n        if _tracing_recursively(frame):\n            return None\n\n        if frame.f_code not in self._code_infos:\n            return None\n\n        if node._is_interesting_expression:\n            # If this is an expression statement and the last statement\n            # in the body, the value is returned from the cell magic\n            # to be displayed as usual\n            if (self._code_infos[frame.f_code].traced_file.is_ipython_cell\n                    and isinstance(node.parent, ast.Expr)\n                    and node.parent is node.parent.parent.body[-1]):\n                self._ipython_cell_value = value\n\n            if is_obvious_builtin(node, self.stack[frame].expression_values[node]):\n                return None\n\n            frame_info = self.stack[frame]\n            if exc_value:\n                node_value = self._exception_value(node, frame, exc_value)\n            else:\n                node_value = NodeValue.expression(\n                    self.num_samples,\n                    value,\n                    level=max(1, 3 - len(node._loops) * (not self._is_first_loop_iteration(node, frame))),\n                )\n                self._set_node_value(node, frame, node_value)\n            self._check_inner_call(frame_info, node, node_value)\n\n        # i.e. is `node` the `y` in `[f(x) for x in y]`, making `node.parent` the `for x in y`\n        is_special_comprehension_iter = (\n                isinstance(node.parent, ast.comprehension) and\n                node is node.parent.iter and\n\n                # Generators execute in their own time and aren't directly attached to the parent frame\n                not isinstance(node.parent.parent, ast.GeneratorExp))\n\n        if not is_special_comprehension_iter:\n            return None\n\n        # Mark `for x in y` as a bit that executed, so it doesn't show as grey\n        self._set_node_value(node.parent, frame, NodeValue.covered())\n\n        if exc_value:\n            return None\n\n        # Track each iteration over `y` so that the 'loop' can be stepped through\n        loops = node._loops + (node.parent,)  # type: Tuple[Loop, ...]\n\n        def comprehension_iter_proxy():\n            for item in value:\n                self._add_iteration(loops, frame)\n                yield item\n\n        # This effectively changes to code to `for x in comprehension_iter_proxy()`\n        return ChangeValue(comprehension_iter_proxy())\n\n    def _check_inner_call(self, frame_info, node, node_value):\n        # type: (FrameInfo, Union[ast.stmt, ast.expr], NodeValue) -> None\n        inner_calls = frame_info.inner_calls.pop(node, None)\n        if inner_calls:\n            node_value.set_meta('inner_calls', inner_calls)\n\n    def _is_first_loop_iteration(self, node, frame):\n        # type: (ast.AST, FrameType) -> bool\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for loop_node in node._loops:  # type: ast.AST\n            loop = iteration.loops[loop_node._tree_index]\n            iteration = loop.last()\n            if iteration.index > 0:\n                return False\n        return True\n\n    def _set_node_value(self, node, frame, value):\n        # type: (ast.AST, FrameType, NodeValue) -> None\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for loop_node in node._loops:  # type: ast.AST\n            loop = iteration.loops[loop_node._tree_index]\n            loop.recorded_node(node)\n            iteration = loop.last()\n        iteration.vals[node._tree_index] = value\n\n    def _exception_value(self, node, frame, exc_value):\n        # type: (Union[ast.expr, ast.stmt], FrameType, BaseException) -> NodeValue\n        value = NodeValue.exception(exc_value)\n        self._set_node_value(node, frame, value)\n        return value\n\n    def after_stmt(self, node, frame, exc_value, exc_traceback, exc_node):\n        # type: (ast.stmt, FrameType, Optional[BaseException], Optional[TracebackType], Optional[ast.AST]) -> Optional[bool]\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return None\n        if exc_value and node is exc_node:\n            value = self._exception_value(node, frame, exc_value)\n        else:\n            value = NodeValue.covered()\n            self._set_node_value(node, frame, value)\n        self._check_inner_call(self.stack[frame], node, value)\n        return None\n\n    def enter_call(self, enter_info):\n        # type: (EnterCallInfo) -> None\n        frame = enter_info.current_frame  # type: FrameType\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return\n        frame_info = self.stack[frame]\n        frame_info.start_time = get_unfrozen_datetime()\n        frame_info.iteration = Iteration()\n\n        code_info = self._code_infos[frame.f_code]\n        if isinstance(enter_info.enter_node.parent, ast.Module):\n            arguments = []\n        else:\n            f_locals = frame.f_locals.copy()  # type: Dict[str, Any]\n            arguments = [(name, f_locals.pop(name))\n                         for name in code_info.arg_names\n                         if name] + [\n\n                            # Local variables other than actual arguments. These are variables from\n                            # the enclosing scope. It's handy to treat them like arguments in the UI\n                            it for it in f_locals.items()\n                            if it[0][0] != '.'  # Appears when using nested tuple arguments\n                        ]\n        frame_info.arguments = json.dumps([[k, cheap_repr(v)] for k, v in arguments])\n        frame_info.call_id = self._call_id()\n        frame_info.inner_calls = defaultdict(list)\n        prev = self.stack.get(enter_info.caller_frame)\n        if prev:\n            inner_calls = getattr(prev, 'inner_calls', None)\n            if inner_calls is not None:\n                inner_calls[enter_info.call_node].append(frame_info.call_id)\n\n    def _call_id(self):\n        # type: () -> Text\n        return uuid4().hex\n\n    def exit_call(self, exit_info):\n        # type: (ExitCallInfo) -> None\n        \"\"\"\n        This is where all the data collected during the call is gathered up\n        and sent to the database.\n        \"\"\"\n        frame = exit_info.current_frame  # type: FrameType\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return\n        frame_info = self.stack[frame]\n\n        top_iteration = frame_info.iteration  # type: Iteration\n        node_values = _deep_dict()\n        self._extract_node_values(top_iteration, (), node_values)\n\n        db_func = self._code_infos[frame.f_code].db_func\n        exc = exit_info.exc_value  # type: Optional[Exception]\n        if exc:\n            traceback_str = ''.join(traceback.format_exception(type(exc), exc, exit_info.exc_tb))\n            exception = exception_string(exc)\n        else:\n            traceback_str = exception = None\n\n        @retry_db\n        def add_call():\n            Call = self.db.Call\n            call = Call(id=frame_info.call_id,\n                        function_id=db_func,\n                        arguments=frame_info.arguments,\n                        return_value=cheap_repr(exit_info.return_value),\n                        exception=exception,\n                        traceback=traceback_str,\n                        data=json.dumps(\n                            dict(\n                                node_values=node_values,\n                                loop_iterations=top_iteration.extract_iterations()['loops'],\n                                type_names=type_registry.names(),\n                                num_special_types=type_registry.num_special_types,\n                            ),\n                            cls=ProtocolEncoder,\n                            separators=(',', ':')\n                        ),\n                        start_time=frame_info.start_time)\n            with self.db.session_scope() as session:\n                session.add(call)\n\n        add_call()\n\n        self._last_call_id = frame_info.call_id\n\n    def _extract_node_values(self, iteration, path, node_values):\n        # type: (Iteration, Tuple[int, ...], dict) -> None\n        \"\"\"\n        Populates node_values with values inside iteration.\n        \"\"\"\n        # Each element of `path` is an index of a loop iteration\n        # e.g. given the nested loops:\n        #\n        # for i in [0, 1, 2]:\n        #     for j in [0, 1, 2, 3]:\n        #\n        # path may be (i, j) for each of the iterations\n        for tree_index, node_value in iteration.vals.items():\n\n            # So this `full_path` is a tuple of ints, but the first\n            # int has a different meaning from the others\n            full_path = (tree_index,) + path\n\n            # Given a path (a, b, c) we're making node_values 'contain'\n            # this structure:\n            # {a: {b: {c: node_value}}}\n            d = node_values\n            for path_k in full_path[:-1]:\n                d = d[path_k]\n            d[full_path[-1]] = node_value\n\n        for loop in iteration.loops.values():\n            for i, iteration in enumerate(loop):\n                self._extract_node_values(iteration, path + (i,), node_values)\n\n    def trace_function(self, func):\n        # type: (FunctionType) -> FunctionType\n        new_func = super(BirdsEye, self).trace_function(func)\n        code_info = self._code_infos.get(new_func.__code__)\n        if code_info:\n            return new_func\n\n        lines, start_lineno = inspect.getsourcelines(func)  # type: List[Text], int\n        end_lineno = start_lineno + len(lines)\n        name = safe_qualname(func)\n        source_file = inspect.getsourcefile(func)\n        if source_file.startswith('<ipython-input'):\n            filename = IPYTHON_FILE_PATH\n        else:\n            filename = os.path.abspath(source_file)\n        traced_file = new_func.traced_file\n\n        arg_info = inspect.getargs(new_func.__code__)\n        arg_names = list(chain(flatten_list(arg_info[0]), arg_info[1:]))  # type: List[str]\n        self._trace(name, filename, traced_file, new_func.__code__, typ='function',\n                    start_lineno=start_lineno, end_lineno=end_lineno,\n                    arg_names=arg_names)\n\n        return new_func\n\n    def exec_ipython_cell(self, source, callback):\n        from IPython import get_ipython\n        shell = get_ipython()\n        filename = name = shell.compile.cache(source)\n        flags = shell.compile.flags\n\n        traced_file = self.compile(source, filename, flags)\n        traced_file.is_ipython_cell = True\n\n        for node in traced_file.root.body:\n            if is_future_import(node):\n                raise ValueError('from __future__ import ... statements '\n                                 'are not allowed in cells traced with %%eye')\n\n        shell.user_global_ns.update(self._trace_methods_dict(traced_file))\n\n        self._trace(name, filename, traced_file, traced_file.code, 'module', source)\n\n        try:\n            shell.ex(traced_file.code)\n            return self._ipython_cell_value\n        finally:\n            callback(self._last_call_id)\n            self._ipython_cell_value = None\n\n    def trace_this_module(self, context=0, deep=False):\n        frame = inspect.currentframe()\n\n        filename = None\n        while context >= 0:\n            frame = frame.f_back\n            filename = inspect.getsourcefile(frame)\n            if filename is not None:\n                context -= 1\n        filename = os.path.abspath(filename)\n\n        if frame.f_globals.get('__name__') != '__main__':\n            if PY3 and self._treetrace_hidden_with_stmt.__name__ not in frame.f_globals:\n                raise RuntimeError(\n                    'To trace an imported module, you must import birdseye before '\n                    'importing that module.')\n            return\n\n        lines = read_source_file(filename).splitlines()\n        lines[:frame.f_lineno] = [''] * frame.f_lineno\n        source = '\\n'.join(lines)\n        self.exec_string(source, filename, frame.f_globals, frame.f_locals, deep)\n        sys.exit(0)\n\n    def exec_string(self, source, filename, globs=None, locs=None, deep=False):\n        globs = globs or {}\n        locs = locs or {}\n\n        traced_file = self.compile(source, filename)\n\n        globs.update(self._trace_methods_dict(traced_file))\n\n        self._trace(FILE_SENTINEL_NAME, filename, traced_file, traced_file.code, 'module', source)\n\n        if deep:\n            nodes_by_lineno = {\n                node.lineno: node\n                for node in traced_file.nodes\n                if isinstance(node, ast.FunctionDef)\n            }\n\n            def find_code(root_code):\n                # type: (CodeType) -> None\n                for code in root_code.co_consts:  # type: CodeType\n                    if not inspect.iscode(code) or code.co_name.startswith('<'):\n                        continue\n\n                    find_code(code)\n\n                    lineno = code.co_firstlineno\n                    node = nodes_by_lineno.get(lineno)\n                    if not node:\n                        continue\n\n                    self._trace(\n                        code.co_name, filename, traced_file, code,\n                        typ='function',\n                        source=source,\n                        start_lineno=lineno,\n                        end_lineno=node.last_token.end[0] + 1,\n                    )\n\n            find_code(traced_file.code)\n\n        exec(traced_file.code, globs, locs)\n\n    def _trace(\n            self,\n            name,\n            filename,\n            traced_file,\n            code,\n            typ,\n            source='',\n            start_lineno=1,\n            end_lineno=None,\n            arg_names=(),\n    ):\n        if not end_lineno:\n            end_lineno = start_lineno + len(source.splitlines())\n        nodes = list(self._nodes_of_interest(traced_file, start_lineno, end_lineno))\n        html_body = self._nodes_html(nodes, start_lineno, end_lineno, traced_file)\n\n        data_dict = dict(\n            # This maps each node to the loops enclosing that node\n            node_loops={\n                node._tree_index: [n._tree_index for n in node._loops]\n                for node, _ in nodes\n                if node._loops\n            },\n        )\n        if typ == 'function':\n            tokens = traced_file.tokens\n            func_node = only(node\n                             for node, _ in nodes\n                             if isinstance(node, ast.FunctionDef)\n                             and node.first_token.start[0] == start_lineno)\n            func_startpos, source = source_without_decorators(tokens, func_node)\n            # These are for the PyCharm plugin\n            data_dict.update(\n                node_ranges=list(self._node_ranges(nodes, tokens, func_startpos)),\n                loop_ranges=list(self._loop_ranges(nodes, tokens, func_startpos)),\n            )\n\n        data = json.dumps(data_dict, sort_keys=True)\n        db_func = self._db_func(data, filename, html_body, name, start_lineno, source, typ)\n        self._code_infos[code] = CodeInfo(db_func, traced_file, arg_names)\n\n    def _loop_ranges(self, nodes, tokens, func_start):\n        # For a for loop, e.g.\n        #\n        #     for x in y:\n        #\n        # this yields the range of the target 'x'.\n        #\n        # For a while loop, e.g.\n        #\n        #     while x < 10:\n        #\n        # this yields the range of the condition 'x < 10'.\n        for node, (classes, _, __) in nodes:\n            if 'loop' not in classes:\n                continue\n\n            try:\n                target = node.target  # for loop\n            except AttributeError:\n                target = node.test  # while loop\n\n            start, end = tokens.get_text_range(target)\n            start -= func_start\n            end -= func_start\n\n            yield dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end\n            )\n\n    def _node_ranges(self, nodes, tokens, func_start):\n        for node, (classes, _, __) in nodes:\n            start, end = tokens.get_text_range(node)\n            start -= func_start\n            end -= func_start\n\n            if start < 0:\n                assert (end < 0  # nodes before the def, i.e. decorators\n                        or isinstance(node, ast.FunctionDef))\n                continue\n\n            yield dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end,\n                depth=node._depth,\n                classes=classes,\n            )\n\n    @retry_db\n    def _db_func(self, data, filename, html_body, name, start_lineno, source, typ):\n        \"\"\"\n        Retrieve the Function object from the database if one exists, or create one.\n        \"\"\"\n\n        def h(s):\n            return hashlib.sha256(s.encode('utf8')).hexdigest()\n\n        function_hash = h(filename + name + html_body + data + str(start_lineno))\n\n        Function = self.db.Function\n\n        with self.db.session_scope() as session:\n            db_func = one_or_none(session.query(Function).filter_by(hash=function_hash))  # type: Optional[Function]\n            if not db_func:\n                db_func = Function(file=filename,\n                                   name=name,\n                                   type=typ,\n                                   html_body=html_body,\n                                   lineno=start_lineno,\n                                   data=data,\n                                   body_hash=h(source),\n                                   hash=function_hash)\n                session.add(db_func)\n                session.commit()  # ensure .id exists\n            assert isinstance(db_func.id, int)\n            return db_func.id\n\n    def _nodes_of_interest(self, traced_file, start_lineno, end_lineno):\n        # type: (TracedFile, int, int) -> Iterator[Tuple[ast.AST, Tuple]]\n        \"\"\"\n        Nodes that may have a value, show up as a box in the UI, and lie within the\n        given line range.\n        \"\"\"\n        for node in traced_file.nodes:\n            classes = []\n\n            if (isinstance(node, (ast.While, ast.For, ast.comprehension)) and\n                    not isinstance(node.parent, ast.GeneratorExp)):\n                classes.append('loop')\n            if isinstance(node, ast.stmt):\n                classes.append('stmt')\n\n            if isinstance(node, ast.expr):\n                if not node._is_interesting_expression:\n                    continue\n            elif not classes:\n                continue\n\n            assert isinstance(node, ast.AST)\n\n            # In particular FormattedValue is missing this\n            if not hasattr(node, 'first_token'):\n                continue\n\n            if not start_lineno <= node.first_token.start[0] <= end_lineno:\n                continue\n\n            start, end = traced_file.tokens.get_text_range(node)  # type: int, int\n            if start == end == 0:\n                continue\n\n            yield node, (classes, start, end)\n\n    def _nodes_html(self, nodes, start_lineno, end_lineno, traced_file):\n        # type: (list, int, int, TracedFile) -> str\n        \"\"\"\n        The algorithm for generating the HTML works as follows. We generate a list\n        of HTMLPositions, which are essentially places to insert HTML into the source plus some\n        metadata. The order of the fields of HTMLPosition ensure that when the list is sorted,\n        the resulting HTML is valid and correct. Specifically, the fields are:\n        \n          1. index: the index in the source string where the HTML would be inserted\n          2. is_start: Indicates if this piece of HTML is the start of a tag, rather than the end.\n             Ends should appear first, so that the resulting HTML looks like:\n                <span> ... </span><span> ... </span>\n             rather than:\n                <span> ... <span></span> ... </span>\n             (I think this might actually be unnecessary, since I can't think of any cases of two\n              expressions right next to each other with nothing in between)\n          3. depth: the depth of the corresponding node in the AST. We want the start of a tag from\n             a node to appear before the start of a tag nested within, e.g. `foo()` should become:\n                <span [for foo()]><span [for foo]>foo</span>()</span>\n             rather than:   \n                <span [for foo]><span [for foo()]>foo</span>()</span>\n          4. html: the actual HTML to insert. Not important for ordering.\n          \n        Mostly the list contains pairs of HTMLPositions corresponding to AST nodes, one for the\n        start and one for the end.\n        \n        After the list is sorted, the HTML generated is essentially:\n        \n        source[0:positions[0].index] + positions[0].html + source[positions[0].index:positions[1].index] + positions[1].html + ...\n        \"\"\"\n\n        traced_file.root._depth = 0\n        for node in ast.walk(traced_file.root):  # type: ast.AST\n            for child in ast.iter_child_nodes(node):\n                child._depth = node._depth + 1\n\n        positions = []  # type: List[HTMLPosition]\n\n        for node, (classes, start, end) in nodes:\n            # noinspection PyArgumentList\n            positions.extend(map(\n                HTMLPosition,\n                [start, end],\n                [True, False],  # is_start\n                [node._depth, node._depth],\n                ['<span data-index=\"%s\" class=\"%s\">' % (node._tree_index, ' '.join(classes)),\n                 '</span>']))\n\n        end_lineno = self._separate_comprehensions(\n            [n[0] for n in nodes],\n            end_lineno, positions, traced_file)\n\n        # This just makes the loop below simpler\n        positions.append(HTMLPosition(len(traced_file.source), False, 0, ''))\n\n        positions.sort()\n\n        html_parts = []\n        start = 0\n        for position in positions:\n            html_parts.append(html.escape(traced_file.source[start:position.index]))\n            html_parts.append(position.html)\n            start = position.index\n        html_body = ''.join(html_parts)\n        html_body = '\\n'.join(html_body.split('\\n')[start_lineno - 1:end_lineno - 1])\n\n        return html_body.strip('\\n')\n\n    def _separate_comprehensions(self, nodes, end_lineno, positions, traced_file):\n        # type: (list, int, List[HTMLPosition], TracedFile) -> int\n        \"\"\"\n        Comprehensions (e.g. list comprehensions) are troublesome because they can\n        be navigated like loops, and the buttons for these need to be on separate lines.\n        This function inserts newlines to turn:\n\n        [x + y for x in range(3) for y in range(5)] and\n        [[x + y for x in range(3)] for y in range(5)]\n\n        into\n\n        [x + y for x in range(3)\n         for y in range(5)] and\n        [[x + y for x in range(3)]\n         for y in range(5)]\n        \"\"\"\n\n        comprehensions = group_by_key_func(of_type((ast.comprehension, ast.While, ast.For), nodes),\n                                           lambda c: c.first_token.start[0]\n                                           )  # type: Dict[Any, Iterable[ast.comprehension]]\n\n        def get_start(n):\n            # type: (ast.AST) -> int\n            return traced_file.tokens.get_text_range(n)[0]\n\n        for comp_list in comprehensions.values():\n            prev_start = None  # type: Optional[int]\n            for comp in sorted(comp_list, key=lambda c: c.first_token.startpos):\n                if isinstance(comp, ast.comprehension) and comp is comp.parent.generators[0]:\n                    start = get_start(comp.parent)\n                    if prev_start is not None and start < prev_start:\n                        start = get_start(comp)\n                else:\n                    start = get_start(comp)\n                if prev_start is not None:\n                    positions.append(HTMLPosition(start, True, 0, '\\n '))\n                    end_lineno += 1\n                prev_start = start\n\n        return end_lineno"
        ],
        [
            "STORE_NAME",
            "class BirdsEye(TreeTracerBase):\n    \"\"\"\n    Decorate functions with an instance of this class to debug them,\n    or just use the existing instance `eye`.\n    \"\"\"\n\n    def __init__(self, db_uri=None, num_samples=None):\n        \"\"\"\n        Set db_uri to specify where the database lives, as an alternative to\n        the environment variable BIRDSEYE_DB.\n        \"\"\"\n        super(BirdsEye, self).__init__()\n        self._db_uri = db_uri\n        self._code_infos = {}  # type: Dict[CodeType, CodeInfo]\n        self._last_call_id = None\n        self._ipython_cell_value = None\n        self.num_samples = num_samples or dict(\n            big=dict(\n                attributes=50,\n                dict=50,\n                list=30,\n                set=30,\n                pandas_rows=20,\n                pandas_cols=100,\n            ),\n            small=dict(\n                attributes=50,\n                dict=10,\n                list=6,\n                set=6,\n                pandas_rows=6,\n                pandas_cols=10,\n            ),\n        )\n\n    @cached_property\n    def db(self):\n        return Database(self._db_uri)\n\n    def parse_extra(self, root, source, filename):\n        # type: (ast.Module, str, str) -> None\n        for node in ast.walk(root):  # type: ast.AST\n            node._loops = tracer.loops(node)\n            if isinstance(node, ast.expr):\n                node._is_interesting_expression = is_interesting_expression(node)\n\n    @lru_cache()\n    def compile(self, source, filename, flags=0):\n        traced_file = super(BirdsEye, self).compile(source, filename, flags)\n        traced_file.tokens = ASTTokens(source, tree=traced_file.root)\n        return traced_file\n\n    def before_stmt(self, node, frame):\n        # type: (ast.stmt, FrameType) -> None\n        if frame.f_code not in self._code_infos:\n            return\n        if isinstance(node.parent, ast.For) and node is node.parent.body[0]:\n            self._add_iteration(node._loops, frame)\n\n    def before_expr(self, node, frame):\n        if isinstance(node.parent, ast.While) and node is node.parent.test:\n            self._add_iteration(node._loops, frame)\n\n    def _add_iteration(self, loops, frame):\n        # type: (typing.Sequence[Loop], FrameType) -> None\n        \"\"\"\n        Given one or more nested loops, add an iteration for the innermost\n        loop (the last in the sequence).\n        \"\"\"\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for i, loop_node in enumerate(loops):\n            loop = iteration.loops[loop_node._tree_index]\n            if i == len(loops) - 1:\n                loop.append(Iteration())\n            else:\n                iteration = loop.last()\n\n    def after_expr(self, node, frame, value, exc_value, exc_tb):\n        # type: (ast.expr, FrameType, Any, Optional[BaseException], Optional[TracebackType]) -> Optional[ChangeValue]\n\n        if _tracing_recursively(frame):\n            return None\n\n        if frame.f_code not in self._code_infos:\n            return None\n\n        if node._is_interesting_expression:\n            # If this is an expression statement and the last statement\n            # in the body, the value is returned from the cell magic\n            # to be displayed as usual\n            if (self._code_infos[frame.f_code].traced_file.is_ipython_cell\n                    and isinstance(node.parent, ast.Expr)\n                    and node.parent is node.parent.parent.body[-1]):\n                self._ipython_cell_value = value\n\n            if is_obvious_builtin(node, self.stack[frame].expression_values[node]):\n                return None\n\n            frame_info = self.stack[frame]\n            if exc_value:\n                node_value = self._exception_value(node, frame, exc_value)\n            else:\n                node_value = NodeValue.expression(\n                    self.num_samples,\n                    value,\n                    level=max(1, 3 - len(node._loops) * (not self._is_first_loop_iteration(node, frame))),\n                )\n                self._set_node_value(node, frame, node_value)\n            self._check_inner_call(frame_info, node, node_value)\n\n        # i.e. is `node` the `y` in `[f(x) for x in y]`, making `node.parent` the `for x in y`\n        is_special_comprehension_iter = (\n                isinstance(node.parent, ast.comprehension) and\n                node is node.parent.iter and\n\n                # Generators execute in their own time and aren't directly attached to the parent frame\n                not isinstance(node.parent.parent, ast.GeneratorExp))\n\n        if not is_special_comprehension_iter:\n            return None\n\n        # Mark `for x in y` as a bit that executed, so it doesn't show as grey\n        self._set_node_value(node.parent, frame, NodeValue.covered())\n\n        if exc_value:\n            return None\n\n        # Track each iteration over `y` so that the 'loop' can be stepped through\n        loops = node._loops + (node.parent,)  # type: Tuple[Loop, ...]\n\n        def comprehension_iter_proxy():\n            for item in value:\n                self._add_iteration(loops, frame)\n                yield item\n\n        # This effectively changes to code to `for x in comprehension_iter_proxy()`\n        return ChangeValue(comprehension_iter_proxy())\n\n    def _check_inner_call(self, frame_info, node, node_value):\n        # type: (FrameInfo, Union[ast.stmt, ast.expr], NodeValue) -> None\n        inner_calls = frame_info.inner_calls.pop(node, None)\n        if inner_calls:\n            node_value.set_meta('inner_calls', inner_calls)\n\n    def _is_first_loop_iteration(self, node, frame):\n        # type: (ast.AST, FrameType) -> bool\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for loop_node in node._loops:  # type: ast.AST\n            loop = iteration.loops[loop_node._tree_index]\n            iteration = loop.last()\n            if iteration.index > 0:\n                return False\n        return True\n\n    def _set_node_value(self, node, frame, value):\n        # type: (ast.AST, FrameType, NodeValue) -> None\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for loop_node in node._loops:  # type: ast.AST\n            loop = iteration.loops[loop_node._tree_index]\n            loop.recorded_node(node)\n            iteration = loop.last()\n        iteration.vals[node._tree_index] = value\n\n    def _exception_value(self, node, frame, exc_value):\n        # type: (Union[ast.expr, ast.stmt], FrameType, BaseException) -> NodeValue\n        value = NodeValue.exception(exc_value)\n        self._set_node_value(node, frame, value)\n        return value\n\n    def after_stmt(self, node, frame, exc_value, exc_traceback, exc_node):\n        # type: (ast.stmt, FrameType, Optional[BaseException], Optional[TracebackType], Optional[ast.AST]) -> Optional[bool]\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return None\n        if exc_value and node is exc_node:\n            value = self._exception_value(node, frame, exc_value)\n        else:\n            value = NodeValue.covered()\n            self._set_node_value(node, frame, value)\n        self._check_inner_call(self.stack[frame], node, value)\n        return None\n\n    def enter_call(self, enter_info):\n        # type: (EnterCallInfo) -> None\n        frame = enter_info.current_frame  # type: FrameType\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return\n        frame_info = self.stack[frame]\n        frame_info.start_time = get_unfrozen_datetime()\n        frame_info.iteration = Iteration()\n\n        code_info = self._code_infos[frame.f_code]\n        if isinstance(enter_info.enter_node.parent, ast.Module):\n            arguments = []\n        else:\n            f_locals = frame.f_locals.copy()  # type: Dict[str, Any]\n            arguments = [(name, f_locals.pop(name))\n                         for name in code_info.arg_names\n                         if name] + [\n\n                            # Local variables other than actual arguments. These are variables from\n                            # the enclosing scope. It's handy to treat them like arguments in the UI\n                            it for it in f_locals.items()\n                            if it[0][0] != '.'  # Appears when using nested tuple arguments\n                        ]\n        frame_info.arguments = json.dumps([[k, cheap_repr(v)] for k, v in arguments])\n        frame_info.call_id = self._call_id()\n        frame_info.inner_calls = defaultdict(list)\n        prev = self.stack.get(enter_info.caller_frame)\n        if prev:\n            inner_calls = getattr(prev, 'inner_calls', None)\n            if inner_calls is not None:\n                inner_calls[enter_info.call_node].append(frame_info.call_id)\n\n    def _call_id(self):\n        # type: () -> Text\n        return uuid4().hex\n\n    def exit_call(self, exit_info):\n        # type: (ExitCallInfo) -> None\n        \"\"\"\n        This is where all the data collected during the call is gathered up\n        and sent to the database.\n        \"\"\"\n        frame = exit_info.current_frame  # type: FrameType\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return\n        frame_info = self.stack[frame]\n\n        top_iteration = frame_info.iteration  # type: Iteration\n        node_values = _deep_dict()\n        self._extract_node_values(top_iteration, (), node_values)\n\n        db_func = self._code_infos[frame.f_code].db_func\n        exc = exit_info.exc_value  # type: Optional[Exception]\n        if exc:\n            traceback_str = ''.join(traceback.format_exception(type(exc), exc, exit_info.exc_tb))\n            exception = exception_string(exc)\n        else:\n            traceback_str = exception = None\n\n        @retry_db\n        def add_call():\n            Call = self.db.Call\n            call = Call(id=frame_info.call_id,\n                        function_id=db_func,\n                        arguments=frame_info.arguments,\n                        return_value=cheap_repr(exit_info.return_value),\n                        exception=exception,\n                        traceback=traceback_str,\n                        data=json.dumps(\n                            dict(\n                                node_values=node_values,\n                                loop_iterations=top_iteration.extract_iterations()['loops'],\n                                type_names=type_registry.names(),\n                                num_special_types=type_registry.num_special_types,\n                            ),\n                            cls=ProtocolEncoder,\n                            separators=(',', ':')\n                        ),\n                        start_time=frame_info.start_time)\n            with self.db.session_scope() as session:\n                session.add(call)\n\n        add_call()\n\n        self._last_call_id = frame_info.call_id\n\n    def _extract_node_values(self, iteration, path, node_values):\n        # type: (Iteration, Tuple[int, ...], dict) -> None\n        \"\"\"\n        Populates node_values with values inside iteration.\n        \"\"\"\n        # Each element of `path` is an index of a loop iteration\n        # e.g. given the nested loops:\n        #\n        # for i in [0, 1, 2]:\n        #     for j in [0, 1, 2, 3]:\n        #\n        # path may be (i, j) for each of the iterations\n        for tree_index, node_value in iteration.vals.items():\n\n            # So this `full_path` is a tuple of ints, but the first\n            # int has a different meaning from the others\n            full_path = (tree_index,) + path\n\n            # Given a path (a, b, c) we're making node_values 'contain'\n            # this structure:\n            # {a: {b: {c: node_value}}}\n            d = node_values\n            for path_k in full_path[:-1]:\n                d = d[path_k]\n            d[full_path[-1]] = node_value\n\n        for loop in iteration.loops.values():\n            for i, iteration in enumerate(loop):\n                self._extract_node_values(iteration, path + (i,), node_values)\n\n    def trace_function(self, func):\n        # type: (FunctionType) -> FunctionType\n        new_func = super(BirdsEye, self).trace_function(func)\n        code_info = self._code_infos.get(new_func.__code__)\n        if code_info:\n            return new_func\n\n        lines, start_lineno = inspect.getsourcelines(func)  # type: List[Text], int\n        end_lineno = start_lineno + len(lines)\n        name = safe_qualname(func)\n        source_file = inspect.getsourcefile(func)\n        if source_file.startswith('<ipython-input'):\n            filename = IPYTHON_FILE_PATH\n        else:\n            filename = os.path.abspath(source_file)\n        traced_file = new_func.traced_file\n\n        arg_info = inspect.getargs(new_func.__code__)\n        arg_names = list(chain(flatten_list(arg_info[0]), arg_info[1:]))  # type: List[str]\n        self._trace(name, filename, traced_file, new_func.__code__, typ='function',\n                    start_lineno=start_lineno, end_lineno=end_lineno,\n                    arg_names=arg_names)\n\n        return new_func\n\n    def exec_ipython_cell(self, source, callback):\n        from IPython import get_ipython\n        shell = get_ipython()\n        filename = name = shell.compile.cache(source)\n        flags = shell.compile.flags\n\n        traced_file = self.compile(source, filename, flags)\n        traced_file.is_ipython_cell = True\n\n        for node in traced_file.root.body:\n            if is_future_import(node):\n                raise ValueError('from __future__ import ... statements '\n                                 'are not allowed in cells traced with %%eye')\n\n        shell.user_global_ns.update(self._trace_methods_dict(traced_file))\n\n        self._trace(name, filename, traced_file, traced_file.code, 'module', source)\n\n        try:\n            shell.ex(traced_file.code)\n            return self._ipython_cell_value\n        finally:\n            callback(self._last_call_id)\n            self._ipython_cell_value = None\n\n    def trace_this_module(self, context=0, deep=False):\n        frame = inspect.currentframe()\n\n        filename = None\n        while context >= 0:\n            frame = frame.f_back\n            filename = inspect.getsourcefile(frame)\n            if filename is not None:\n                context -= 1\n        filename = os.path.abspath(filename)\n\n        if frame.f_globals.get('__name__') != '__main__':\n            if PY3 and self._treetrace_hidden_with_stmt.__name__ not in frame.f_globals:\n                raise RuntimeError(\n                    'To trace an imported module, you must import birdseye before '\n                    'importing that module.')\n            return\n\n        lines = read_source_file(filename).splitlines()\n        lines[:frame.f_lineno] = [''] * frame.f_lineno\n        source = '\\n'.join(lines)\n        self.exec_string(source, filename, frame.f_globals, frame.f_locals, deep)\n        sys.exit(0)\n\n    def exec_string(self, source, filename, globs=None, locs=None, deep=False):\n        globs = globs or {}\n        locs = locs or {}\n\n        traced_file = self.compile(source, filename)\n\n        globs.update(self._trace_methods_dict(traced_file))\n\n        self._trace(FILE_SENTINEL_NAME, filename, traced_file, traced_file.code, 'module', source)\n\n        if deep:\n            nodes_by_lineno = {\n                node.lineno: node\n                for node in traced_file.nodes\n                if isinstance(node, ast.FunctionDef)\n            }\n\n            def find_code(root_code):\n                # type: (CodeType) -> None\n                for code in root_code.co_consts:  # type: CodeType\n                    if not inspect.iscode(code) or code.co_name.startswith('<'):\n                        continue\n\n                    find_code(code)\n\n                    lineno = code.co_firstlineno\n                    node = nodes_by_lineno.get(lineno)\n                    if not node:\n                        continue\n\n                    self._trace(\n                        code.co_name, filename, traced_file, code,\n                        typ='function',\n                        source=source,\n                        start_lineno=lineno,\n                        end_lineno=node.last_token.end[0] + 1,\n                    )\n\n            find_code(traced_file.code)\n\n        exec(traced_file.code, globs, locs)\n\n    def _trace(\n            self,\n            name,\n            filename,\n            traced_file,\n            code,\n            typ,\n            source='',\n            start_lineno=1,\n            end_lineno=None,\n            arg_names=(),\n    ):\n        if not end_lineno:\n            end_lineno = start_lineno + len(source.splitlines())\n        nodes = list(self._nodes_of_interest(traced_file, start_lineno, end_lineno))\n        html_body = self._nodes_html(nodes, start_lineno, end_lineno, traced_file)\n\n        data_dict = dict(\n            # This maps each node to the loops enclosing that node\n            node_loops={\n                node._tree_index: [n._tree_index for n in node._loops]\n                for node, _ in nodes\n                if node._loops\n            },\n        )\n        if typ == 'function':\n            tokens = traced_file.tokens\n            func_node = only(node\n                             for node, _ in nodes\n                             if isinstance(node, ast.FunctionDef)\n                             and node.first_token.start[0] == start_lineno)\n            func_startpos, source = source_without_decorators(tokens, func_node)\n            # These are for the PyCharm plugin\n            data_dict.update(\n                node_ranges=list(self._node_ranges(nodes, tokens, func_startpos)),\n                loop_ranges=list(self._loop_ranges(nodes, tokens, func_startpos)),\n            )\n\n        data = json.dumps(data_dict, sort_keys=True)\n        db_func = self._db_func(data, filename, html_body, name, start_lineno, source, typ)\n        self._code_infos[code] = CodeInfo(db_func, traced_file, arg_names)\n\n    def _loop_ranges(self, nodes, tokens, func_start):\n        # For a for loop, e.g.\n        #\n        #     for x in y:\n        #\n        # this yields the range of the target 'x'.\n        #\n        # For a while loop, e.g.\n        #\n        #     while x < 10:\n        #\n        # this yields the range of the condition 'x < 10'.\n        for node, (classes, _, __) in nodes:\n            if 'loop' not in classes:\n                continue\n\n            try:\n                target = node.target  # for loop\n            except AttributeError:\n                target = node.test  # while loop\n\n            start, end = tokens.get_text_range(target)\n            start -= func_start\n            end -= func_start\n\n            yield dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end\n            )\n\n    def _node_ranges(self, nodes, tokens, func_start):\n        for node, (classes, _, __) in nodes:\n            start, end = tokens.get_text_range(node)\n            start -= func_start\n            end -= func_start\n\n            if start < 0:\n                assert (end < 0  # nodes before the def, i.e. decorators\n                        or isinstance(node, ast.FunctionDef))\n                continue\n\n            yield dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end,\n                depth=node._depth,\n                classes=classes,\n            )\n\n    @retry_db\n    def _db_func(self, data, filename, html_body, name, start_lineno, source, typ):\n        \"\"\"\n        Retrieve the Function object from the database if one exists, or create one.\n        \"\"\"\n\n        def h(s):\n            return hashlib.sha256(s.encode('utf8')).hexdigest()\n\n        function_hash = h(filename + name + html_body + data + str(start_lineno))\n\n        Function = self.db.Function\n\n        with self.db.session_scope() as session:\n            db_func = one_or_none(session.query(Function).filter_by(hash=function_hash))  # type: Optional[Function]\n            if not db_func:\n                db_func = Function(file=filename,\n                                   name=name,\n                                   type=typ,\n                                   html_body=html_body,\n                                   lineno=start_lineno,\n                                   data=data,\n                                   body_hash=h(source),\n                                   hash=function_hash)\n                session.add(db_func)\n                session.commit()  # ensure .id exists\n            assert isinstance(db_func.id, int)\n            return db_func.id\n\n    def _nodes_of_interest(self, traced_file, start_lineno, end_lineno):\n        # type: (TracedFile, int, int) -> Iterator[Tuple[ast.AST, Tuple]]\n        \"\"\"\n        Nodes that may have a value, show up as a box in the UI, and lie within the\n        given line range.\n        \"\"\"\n        for node in traced_file.nodes:\n            classes = []\n\n            if (isinstance(node, (ast.While, ast.For, ast.comprehension)) and\n                    not isinstance(node.parent, ast.GeneratorExp)):\n                classes.append('loop')\n            if isinstance(node, ast.stmt):\n                classes.append('stmt')\n\n            if isinstance(node, ast.expr):\n                if not node._is_interesting_expression:\n                    continue\n            elif not classes:\n                continue\n\n            assert isinstance(node, ast.AST)\n\n            # In particular FormattedValue is missing this\n            if not hasattr(node, 'first_token'):\n                continue\n\n            if not start_lineno <= node.first_token.start[0] <= end_lineno:\n                continue\n\n            start, end = traced_file.tokens.get_text_range(node)  # type: int, int\n            if start == end == 0:\n                continue\n\n            yield node, (classes, start, end)\n\n    def _nodes_html(self, nodes, start_lineno, end_lineno, traced_file):\n        # type: (list, int, int, TracedFile) -> str\n        \"\"\"\n        The algorithm for generating the HTML works as follows. We generate a list\n        of HTMLPositions, which are essentially places to insert HTML into the source plus some\n        metadata. The order of the fields of HTMLPosition ensure that when the list is sorted,\n        the resulting HTML is valid and correct. Specifically, the fields are:\n        \n          1. index: the index in the source string where the HTML would be inserted\n          2. is_start: Indicates if this piece of HTML is the start of a tag, rather than the end.\n             Ends should appear first, so that the resulting HTML looks like:\n                <span> ... </span><span> ... </span>\n             rather than:\n                <span> ... <span></span> ... </span>\n             (I think this might actually be unnecessary, since I can't think of any cases of two\n              expressions right next to each other with nothing in between)\n          3. depth: the depth of the corresponding node in the AST. We want the start of a tag from\n             a node to appear before the start of a tag nested within, e.g. `foo()` should become:\n                <span [for foo()]><span [for foo]>foo</span>()</span>\n             rather than:   \n                <span [for foo]><span [for foo()]>foo</span>()</span>\n          4. html: the actual HTML to insert. Not important for ordering.\n          \n        Mostly the list contains pairs of HTMLPositions corresponding to AST nodes, one for the\n        start and one for the end.\n        \n        After the list is sorted, the HTML generated is essentially:\n        \n        source[0:positions[0].index] + positions[0].html + source[positions[0].index:positions[1].index] + positions[1].html + ...\n        \"\"\"\n\n        traced_file.root._depth = 0\n        for node in ast.walk(traced_file.root):  # type: ast.AST\n            for child in ast.iter_child_nodes(node):\n                child._depth = node._depth + 1\n\n        positions = []  # type: List[HTMLPosition]\n\n        for node, (classes, start, end) in nodes:\n            # noinspection PyArgumentList\n            positions.extend(map(\n                HTMLPosition,\n                [start, end],\n                [True, False],  # is_start\n                [node._depth, node._depth],\n                ['<span data-index=\"%s\" class=\"%s\">' % (node._tree_index, ' '.join(classes)),\n                 '</span>']))\n\n        end_lineno = self._separate_comprehensions(\n            [n[0] for n in nodes],\n            end_lineno, positions, traced_file)\n\n        # This just makes the loop below simpler\n        positions.append(HTMLPosition(len(traced_file.source), False, 0, ''))\n\n        positions.sort()\n\n        html_parts = []\n        start = 0\n        for position in positions:\n            html_parts.append(html.escape(traced_file.source[start:position.index]))\n            html_parts.append(position.html)\n            start = position.index\n        html_body = ''.join(html_parts)\n        html_body = '\\n'.join(html_body.split('\\n')[start_lineno - 1:end_lineno - 1])\n\n        return html_body.strip('\\n')\n\n    def _separate_comprehensions(self, nodes, end_lineno, positions, traced_file):\n        # type: (list, int, List[HTMLPosition], TracedFile) -> int\n        \"\"\"\n        Comprehensions (e.g. list comprehensions) are troublesome because they can\n        be navigated like loops, and the buttons for these need to be on separate lines.\n        This function inserts newlines to turn:\n\n        [x + y for x in range(3) for y in range(5)] and\n        [[x + y for x in range(3)] for y in range(5)]\n\n        into\n\n        [x + y for x in range(3)\n         for y in range(5)] and\n        [[x + y for x in range(3)]\n         for y in range(5)]\n        \"\"\"\n\n        comprehensions = group_by_key_func(of_type((ast.comprehension, ast.While, ast.For), nodes),\n                                           lambda c: c.first_token.start[0]\n                                           )  # type: Dict[Any, Iterable[ast.comprehension]]\n\n        def get_start(n):\n            # type: (ast.AST) -> int\n            return traced_file.tokens.get_text_range(n)[0]\n\n        for comp_list in comprehensions.values():\n            prev_start = None  # type: Optional[int]\n            for comp in sorted(comp_list, key=lambda c: c.first_token.startpos):\n                if isinstance(comp, ast.comprehension) and comp is comp.parent.generators[0]:\n                    start = get_start(comp.parent)\n                    if prev_start is not None and start < prev_start:\n                        start = get_start(comp)\n                else:\n                    start = get_start(comp)\n                if prev_start is not None:\n                    positions.append(HTMLPosition(start, True, 0, '\\n '))\n                    end_lineno += 1\n                prev_start = start\n\n        return end_lineno"
        ],
        [
            "LOAD_NAME",
            "BirdsEye"
        ],
        [
            "CALL",
            "BirdsEye()"
        ],
        [
            "STORE_NAME",
            "eye"
        ],
        [
            "LOAD_NAME",
            "NamedTuple"
        ],
        [
            "LOAD_NAME",
            "int"
        ],
        [
            "LOAD_NAME",
            "bool"
        ],
        [
            "LOAD_NAME",
            "int"
        ],
        [
            "LOAD_NAME",
            "str"
        ],
        [
            "CALL",
            "NamedTuple('HTMLPosition', [\n    ('index', int),\n    ('is_start', bool),\n    ('depth', int),\n    ('html', str),\n])"
        ],
        [
            "STORE_NAME",
            "HTMLPosition"
        ],
        [
            "STORE_NAME",
            "def _deep_dict():\n    return defaultdict(_deep_dict)"
        ],
        [
            "LOAD_NAME",
            "eye"
        ],
        [
            "LOAD_ATTR",
            "eye.enter_call"
        ],
        [
            "LOAD_ATTR",
            "eye.enter_call.__code__"
        ],
        [
            "LOAD_NAME",
            "eye"
        ],
        [
            "LOAD_ATTR",
            "eye.exit_call"
        ],
        [
            "LOAD_ATTR",
            "eye.exit_call.__code__"
        ],
        [
            "LOAD_NAME",
            "eye"
        ],
        [
            "LOAD_ATTR",
            "eye.after_expr"
        ],
        [
            "LOAD_ATTR",
            "eye.after_expr.__code__"
        ],
        [
            "LOAD_NAME",
            "eye"
        ],
        [
            "LOAD_ATTR",
            "eye.after_stmt"
        ],
        [
            "LOAD_ATTR",
            "eye.after_stmt.__code__"
        ],
        [
            "STORE_NAME",
            "_bad_codes"
        ],
        [
            "STORE_NAME",
            "def _tracing_recursively(frame):\n    while frame:\n        if frame.f_code in _bad_codes:\n            return True\n        frame = frame.f_back"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class Iteration(object):\n    \"\"\"\n    Corresponds to an iteration of a loop during a call, OR\n    the call itself (FrameInfo.iteration).\n    \"\"\"\n\n    def __init__(self):\n        # Mapping of nodes (via node._tree_index) to the value of that\n        # node in this iteration. Only contains nodes within the corresponding\n        # loop or at the top of the function, but not in loops further within\n        # (those will be somewhere within self.loops)\n        # Therefore those nodes have at most one value.\n        self.vals = {}  # type: Dict[int, NodeValue]\n\n        # Mapping of loop nodes (via node._tree_index) to IterationLists\n        # for loops that happened during this iteration\n        self.loops = defaultdict(IterationList)  # type: Dict[int, IterationList]\n\n        # 0-based index of this iteration\n        self.index = None  # type: int\n        self.keep = False\n\n    def extract_iterations(self):\n        # type: () -> Dict[str, Union[int, Dict]]\n        return {\n            'index': self.index,\n            'loops': {\n                tree_index: [iteration.extract_iterations()\n                             for iteration in iteration_list]\n                for tree_index, iteration_list in self.loops.items()\n            }\n        }"
        ],
        [
            "STORE_NAME",
            "class Iteration(object):\n    \"\"\"\n    Corresponds to an iteration of a loop during a call, OR\n    the call itself (FrameInfo.iteration).\n    \"\"\"\n\n    def __init__(self):\n        # Mapping of nodes (via node._tree_index) to the value of that\n        # node in this iteration. Only contains nodes within the corresponding\n        # loop or at the top of the function, but not in loops further within\n        # (those will be somewhere within self.loops)\n        # Therefore those nodes have at most one value.\n        self.vals = {}  # type: Dict[int, NodeValue]\n\n        # Mapping of loop nodes (via node._tree_index) to IterationLists\n        # for loops that happened during this iteration\n        self.loops = defaultdict(IterationList)  # type: Dict[int, IterationList]\n\n        # 0-based index of this iteration\n        self.index = None  # type: int\n        self.keep = False\n\n    def extract_iterations(self):\n        # type: () -> Dict[str, Union[int, Dict]]\n        return {\n            'index': self.index,\n            'loops': {\n                tree_index: [iteration.extract_iterations()\n                             for iteration in iteration_list]\n                for tree_index, iteration_list in self.loops.items()\n            }\n        }"
        ],
        [
            "LOAD_NAME",
            "Iterable"
        ],
        [
            "LOAD_NAME",
            "Iteration"
        ],
        [
            "BINARY_SUBSCR",
            "Iterable[Iteration]"
        ],
        [
            "CALL",
            "class IterationList(Iterable[Iteration]):\n    \"\"\"\n    A list of Iterations, corresponding to a run of a loop.\n    If the loop has many iterations, only contains the first and last few\n    and any in the middle where unique nodes had values, so that\n    any node which appeared during this loop exists in at least some iterations.\n    \"\"\"\n    side_len = 3\n\n    def __init__(self):\n        # Contains the first few iterations\n        # and any after that have unique nodes in them\n        self.start = []  # type: List[Iteration]\n\n        # Contains the last few iterations\n        self.end = deque(maxlen=self.side_len)  # type: Deque[Iteration]\n\n        # Total number of iterations in the loop, not all of which\n        # are kept\n        self.length = 0  # type: int\n\n        # Number of times each node has been recorded in this loop\n        self.recorded = Counter()\n\n    def append(self, iteration):\n        # type: (Iteration) -> None\n        if self.length < self.side_len:\n            self.start.append(iteration)\n        else:\n            # If self.end is too long, the first element self.end[0]\n            # is about to be dropped by the deque. If that iteration\n            # should be kept because of some node that was recorded,\n            # add it to self.start\n            if len(self.end) >= self.side_len and self.end[0].keep:\n                self.start.append(self.end[0])\n\n            self.end.append(iteration)\n        iteration.index = self.length\n        self.length += 1\n\n    def __iter__(self):\n        # type: () -> Iterator[Iteration]\n        return chain(self.start, self.end)\n\n    def last(self):\n        # type: () -> Iteration\n        if self.end:\n            return self.end[-1]\n        else:\n            return self.start[-1]\n\n    def recorded_node(self, node):\n        # type: (ast.AST) -> None\n        if self.recorded[node] >= 2:\n            # We've already seen this node enough\n            return\n\n        # This node is new(ish), make sure we keep this iteration\n        self.last().keep = True\n        self.recorded[node] += 1"
        ],
        [
            "STORE_NAME",
            "class IterationList(Iterable[Iteration]):\n    \"\"\"\n    A list of Iterations, corresponding to a run of a loop.\n    If the loop has many iterations, only contains the first and last few\n    and any in the middle where unique nodes had values, so that\n    any node which appeared during this loop exists in at least some iterations.\n    \"\"\"\n    side_len = 3\n\n    def __init__(self):\n        # Contains the first few iterations\n        # and any after that have unique nodes in them\n        self.start = []  # type: List[Iteration]\n\n        # Contains the last few iterations\n        self.end = deque(maxlen=self.side_len)  # type: Deque[Iteration]\n\n        # Total number of iterations in the loop, not all of which\n        # are kept\n        self.length = 0  # type: int\n\n        # Number of times each node has been recorded in this loop\n        self.recorded = Counter()\n\n    def append(self, iteration):\n        # type: (Iteration) -> None\n        if self.length < self.side_len:\n            self.start.append(iteration)\n        else:\n            # If self.end is too long, the first element self.end[0]\n            # is about to be dropped by the deque. If that iteration\n            # should be kept because of some node that was recorded,\n            # add it to self.start\n            if len(self.end) >= self.side_len and self.end[0].keep:\n                self.start.append(self.end[0])\n\n            self.end.append(iteration)\n        iteration.index = self.length\n        self.length += 1\n\n    def __iter__(self):\n        # type: () -> Iterator[Iteration]\n        return chain(self.start, self.end)\n\n    def last(self):\n        # type: () -> Iteration\n        if self.end:\n            return self.end[-1]\n        else:\n            return self.start[-1]\n\n    def recorded_node(self, node):\n        # type: (ast.AST) -> None\n        if self.recorded[node] >= 2:\n            # We've already seen this node enough\n            return\n\n        # This node is new(ish), make sure we keep this iteration\n        self.last().keep = True\n        self.recorded[node] += 1"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class TypeRegistry(object):\n    basic_types = (type(None), bool, int, float, complex)\n    if PY2:\n        basic_types += (long,)\n    special_types = basic_types + (list, dict, tuple, set, frozenset, str)\n    if PY2:\n        special_types += (unicode if PY2 else bytes,)\n\n    num_special_types = len(special_types)\n\n    def __init__(self):\n        self.lock = Lock()\n        self.data = defaultdict(lambda: len(self.data))  # type: Dict[type, int]\n\n        for t in self.special_types:\n            _ = self.data[t]\n\n    def __getitem__(self, item):\n        t = correct_type(item)\n        with self.lock:\n            return self.data[t]\n\n    def names(self):\n        # type: () -> List[str]\n        rev = dict((v, k) for k, v in self.data.items())\n        return [safe_qualname(rev[i]) for i in range(len(rev))]"
        ],
        [
            "STORE_NAME",
            "class TypeRegistry(object):\n    basic_types = (type(None), bool, int, float, complex)\n    if PY2:\n        basic_types += (long,)\n    special_types = basic_types + (list, dict, tuple, set, frozenset, str)\n    if PY2:\n        special_types += (unicode if PY2 else bytes,)\n\n    num_special_types = len(special_types)\n\n    def __init__(self):\n        self.lock = Lock()\n        self.data = defaultdict(lambda: len(self.data))  # type: Dict[type, int]\n\n        for t in self.special_types:\n            _ = self.data[t]\n\n    def __getitem__(self, item):\n        t = correct_type(item)\n        with self.lock:\n            return self.data[t]\n\n    def names(self):\n        # type: () -> List[str]\n        rev = dict((v, k) for k, v in self.data.items())\n        return [safe_qualname(rev[i]) for i in range(len(rev))]"
        ],
        [
            "LOAD_NAME",
            "TypeRegistry"
        ],
        [
            "CALL",
            "TypeRegistry()"
        ],
        [
            "STORE_NAME",
            "type_registry"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class NodeValue(object):\n    \"\"\"\n    The 'value' of a node during a particular iteration.\n    This can mean different things, see the classmethods.\n    Can also contain some metadata, including links to other calls.\n    \"\"\"\n    __slots__ = ('val_repr', 'type_index', 'meta', 'children')\n\n    def __init__(self, val_repr, type_index):\n        self.val_repr = val_repr  # type: str\n        self.type_index = type_index  # type: int\n        self.meta = None  # type: Optional[Dict[str, Any]]\n        self.children = None  # type: Optional[List[Tuple[str, NodeValue]]]\n\n    def set_meta(self, key, value):\n        # type: (str, Any) -> None\n        self.meta = self.meta or {}\n        self.meta[key] = value\n\n    def add_child(self, samples, level, key, value):\n        # type: (dict, int, str, Any) -> None\n        self.children = self.children or []\n        self.children.append((key, NodeValue.expression(samples, value, level)))\n\n    def as_json(self):\n        result = [self.val_repr, self.type_index, self.meta or {}]  # type: list\n        if self.children:\n            result.extend(self.children)\n        return result\n\n    @classmethod\n    def covered(cls):\n        \"\"\"\n        Represents a bit of code, usually a statement, that executed successfully but\n        doesn't have an actual value.\n        \"\"\"\n        return cls('', -2)\n\n    @classmethod\n    def exception(cls, exc_value):\n        \"\"\"\n        Means that exc_value was raised by a node when executing, and not any inner node.\n        \"\"\"\n        return cls(exception_string(exc_value), -1)\n\n    @classmethod\n    def expression(cls, samples, val, level):\n        # type: (dict, Any, int) -> NodeValue\n        \"\"\"\n        The value of an expression or one of its children, with attributes,\n        dictionary items, etc as children. Has a max depth of `level` levels.\n        \"\"\"\n        result = cls(cheap_repr(val), type_registry[val])\n        if isinstance(val, (TypeRegistry.basic_types, BirdsEye)):\n            return result\n\n        length = None\n        if not isinstance(val, QuerySet):  # len triggers a database query\n            try:\n                length = len(val)\n            except:\n                pass\n            else:\n                result.set_meta('len', length)\n\n        if isinstance(val, ModuleType):\n            level = min(level, 2)\n\n        add_child = partial(result.add_child, samples, level - 1)\n\n        if isinstance(val, (Series, ndarray)):\n            attrs = ['dtype']\n            if isinstance(val, ndarray):\n                attrs.append('shape')\n            for name in attrs:\n                try:\n                    attr = getattr(val, name)\n                except AttributeError:\n                    pass\n                else:\n                    add_child(name, attr)\n\n        if level >= 3 or level >= 2 and isinstance(val, Series):\n            sample_type = 'big'\n        else:\n            sample_type = 'small'\n\n        samples = samples[sample_type]\n\n        # Always expand DataFrames and Series regardless of level to\n        # make the table view of DataFrames work\n\n        if isinstance(val, DataFrame):\n            meta = {}\n            result.set_meta('dataframe', meta)\n\n            max_rows = samples['pandas_rows']\n            max_cols = samples['pandas_cols']\n\n            if length > max_rows + 2:\n                meta['row_break'] = max_rows // 2\n\n            columns = val.columns\n            num_cols = len(columns)\n            if num_cols > max_cols + 2:\n                meta['col_break'] = max_cols // 2\n\n            indices = set(_sample_indices(num_cols, max_cols))\n            for i, (formatted_name, label) in enumerate(zip(val.columns.format(sparsify=False),\n                                                            val.columns)):\n                if i in indices:\n                    add_child(formatted_name, val[label])\n\n            return result\n\n        if isinstance(val, Series):\n            for i in _sample_indices(length, samples['pandas_rows']):\n                try:\n                    k = val.index[i:i + 1].format(sparsify=False)[0]\n                    v = val.iloc[i]\n                except:\n                    pass\n                else:\n                    add_child(k, v)\n            return result\n\n        if (level <= 0 or\n                isinstance(val,\n                           (str, bytes, range)\n                           if PY3 else\n                           (str, unicode, xrange))):\n            return result\n\n        if isinstance(val, (Sequence, ndarray)) and length is not None:\n            for i in _sample_indices(length, samples['list']):\n                try:\n                    v = val[i]\n                except:\n                    pass\n                else:\n                    add_child(str(i), v)\n\n        if isinstance(val, Mapping):\n            for k, v in islice(_safe_iter(val, iteritems), samples['dict']):\n                add_child(cheap_repr(k), v)\n\n        if isinstance(val, Set):\n            vals = _safe_iter(val)\n            num_items = samples['set']\n            if length is None or length > num_items + 2:\n                vals = islice(vals, num_items)\n            for i, v in enumerate(vals):\n                add_child('<%s>' % i, v)\n\n        d = getattr(val, '__dict__', None)\n        if d:\n            for k in sorted(islice(_safe_iter(d),\n                                   samples['attributes']),\n                            key=str):\n                v = d[k]\n                if isinstance(v, TracedFile):\n                    continue\n                add_child(str(k), v)\n        else:\n            for s in sorted(getattr(type(val), '__slots__', None) or ()):\n                try:\n                    attr = getattr(val, s)\n                except AttributeError:\n                    pass\n                else:\n                    add_child(str(s), attr)\n        return result"
        ],
        [
            "STORE_NAME",
            "class NodeValue(object):\n    \"\"\"\n    The 'value' of a node during a particular iteration.\n    This can mean different things, see the classmethods.\n    Can also contain some metadata, including links to other calls.\n    \"\"\"\n    __slots__ = ('val_repr', 'type_index', 'meta', 'children')\n\n    def __init__(self, val_repr, type_index):\n        self.val_repr = val_repr  # type: str\n        self.type_index = type_index  # type: int\n        self.meta = None  # type: Optional[Dict[str, Any]]\n        self.children = None  # type: Optional[List[Tuple[str, NodeValue]]]\n\n    def set_meta(self, key, value):\n        # type: (str, Any) -> None\n        self.meta = self.meta or {}\n        self.meta[key] = value\n\n    def add_child(self, samples, level, key, value):\n        # type: (dict, int, str, Any) -> None\n        self.children = self.children or []\n        self.children.append((key, NodeValue.expression(samples, value, level)))\n\n    def as_json(self):\n        result = [self.val_repr, self.type_index, self.meta or {}]  # type: list\n        if self.children:\n            result.extend(self.children)\n        return result\n\n    @classmethod\n    def covered(cls):\n        \"\"\"\n        Represents a bit of code, usually a statement, that executed successfully but\n        doesn't have an actual value.\n        \"\"\"\n        return cls('', -2)\n\n    @classmethod\n    def exception(cls, exc_value):\n        \"\"\"\n        Means that exc_value was raised by a node when executing, and not any inner node.\n        \"\"\"\n        return cls(exception_string(exc_value), -1)\n\n    @classmethod\n    def expression(cls, samples, val, level):\n        # type: (dict, Any, int) -> NodeValue\n        \"\"\"\n        The value of an expression or one of its children, with attributes,\n        dictionary items, etc as children. Has a max depth of `level` levels.\n        \"\"\"\n        result = cls(cheap_repr(val), type_registry[val])\n        if isinstance(val, (TypeRegistry.basic_types, BirdsEye)):\n            return result\n\n        length = None\n        if not isinstance(val, QuerySet):  # len triggers a database query\n            try:\n                length = len(val)\n            except:\n                pass\n            else:\n                result.set_meta('len', length)\n\n        if isinstance(val, ModuleType):\n            level = min(level, 2)\n\n        add_child = partial(result.add_child, samples, level - 1)\n\n        if isinstance(val, (Series, ndarray)):\n            attrs = ['dtype']\n            if isinstance(val, ndarray):\n                attrs.append('shape')\n            for name in attrs:\n                try:\n                    attr = getattr(val, name)\n                except AttributeError:\n                    pass\n                else:\n                    add_child(name, attr)\n\n        if level >= 3 or level >= 2 and isinstance(val, Series):\n            sample_type = 'big'\n        else:\n            sample_type = 'small'\n\n        samples = samples[sample_type]\n\n        # Always expand DataFrames and Series regardless of level to\n        # make the table view of DataFrames work\n\n        if isinstance(val, DataFrame):\n            meta = {}\n            result.set_meta('dataframe', meta)\n\n            max_rows = samples['pandas_rows']\n            max_cols = samples['pandas_cols']\n\n            if length > max_rows + 2:\n                meta['row_break'] = max_rows // 2\n\n            columns = val.columns\n            num_cols = len(columns)\n            if num_cols > max_cols + 2:\n                meta['col_break'] = max_cols // 2\n\n            indices = set(_sample_indices(num_cols, max_cols))\n            for i, (formatted_name, label) in enumerate(zip(val.columns.format(sparsify=False),\n                                                            val.columns)):\n                if i in indices:\n                    add_child(formatted_name, val[label])\n\n            return result\n\n        if isinstance(val, Series):\n            for i in _sample_indices(length, samples['pandas_rows']):\n                try:\n                    k = val.index[i:i + 1].format(sparsify=False)[0]\n                    v = val.iloc[i]\n                except:\n                    pass\n                else:\n                    add_child(k, v)\n            return result\n\n        if (level <= 0 or\n                isinstance(val,\n                           (str, bytes, range)\n                           if PY3 else\n                           (str, unicode, xrange))):\n            return result\n\n        if isinstance(val, (Sequence, ndarray)) and length is not None:\n            for i in _sample_indices(length, samples['list']):\n                try:\n                    v = val[i]\n                except:\n                    pass\n                else:\n                    add_child(str(i), v)\n\n        if isinstance(val, Mapping):\n            for k, v in islice(_safe_iter(val, iteritems), samples['dict']):\n                add_child(cheap_repr(k), v)\n\n        if isinstance(val, Set):\n            vals = _safe_iter(val)\n            num_items = samples['set']\n            if length is None or length > num_items + 2:\n                vals = islice(vals, num_items)\n            for i, v in enumerate(vals):\n                add_child('<%s>' % i, v)\n\n        d = getattr(val, '__dict__', None)\n        if d:\n            for k in sorted(islice(_safe_iter(d),\n                                   samples['attributes']),\n                            key=str):\n                v = d[k]\n                if isinstance(v, TracedFile):\n                    continue\n                add_child(str(k), v)\n        else:\n            for s in sorted(getattr(type(val), '__slots__', None) or ()):\n                try:\n                    attr = getattr(val, s)\n                except AttributeError:\n                    pass\n                else:\n                    add_child(str(s), attr)\n        return result"
        ],
        [
            "STORE_NAME",
            "def _safe_iter(val, f=lambda x: x):\n    try:\n        for x in f(val):\n            yield x\n    except:\n        pass"
        ],
        [
            "STORE_NAME",
            "def _sample_indices(length, max_length):\n    if length <= max_length + 2:\n        return range(length)\n    else:\n        return chain(range(max_length // 2),\n                     range(length - max_length // 2,\n                           length))"
        ],
        [
            "LOAD_NAME",
            "try_register_repr"
        ],
        [
            "CALL",
            "try_register_repr('pandas', 'Series')"
        ],
        [
            "CALL",
            "try_register_repr('pandas', 'Series')"
        ],
        [
            "STORE_NAME",
            "@try_register_repr('pandas', 'Series')\ndef _repr_series_one_line(x, helper):\n    n = len(x)\n    if n == 0:\n        return repr(x)\n    newlevel = helper.level - 1\n    pieces = []\n    maxparts = _repr_series_one_line.maxparts\n    for i in _sample_indices(n, maxparts):\n        k = x.index[i:i + 1].format(sparsify=False)[0]\n        v = x.iloc[i]\n        pieces.append('%s = %s' % (k, cheap_repr(v, newlevel)))\n    if n > maxparts + 2:\n        pieces.insert(maxparts // 2, '...')\n    return '; '.join(pieces)"
        ],
        [
            "STORE_NAME",
            "def is_interesting_expression(node):\n    # type: (ast.AST) -> bool\n    \"\"\"\n    If this expression has a value that may not be exactly what it looks like,\n    return True. Put differently, return False if this is just a literal.\n    \"\"\"\n    return (isinstance(node, ast.expr) and\n            not (isinstance(node, (ast.Num, ast.Str, getattr(ast, 'NameConstant', ()))) or\n                 isinstance(getattr(node, 'ctx', None),\n                            (ast.Store, ast.Del)) or\n                 (isinstance(node, ast.UnaryOp) and\n                  isinstance(node.op, (ast.UAdd, ast.USub)) and\n                  isinstance(node.operand, ast.Num)) or\n                 (isinstance(node, (ast.List, ast.Tuple, ast.Dict)) and\n                  not any(is_interesting_expression(n) for n in ast.iter_child_nodes(node)))))"
        ],
        [
            "STORE_NAME",
            "def is_obvious_builtin(node, value):\n    # type: (ast.expr, Any) -> bool\n    \"\"\"\n    Return True if this node looks like a builtin and it really is\n    (i.e. hasn't been shadowed).\n    \"\"\"\n    # noinspection PyUnresolvedReferences\n    builtins = cast(dict, __builtins__)\n    return ((isinstance(node, ast.Name) and\n             node.id in builtins and\n             builtins[node.id] is value) or\n            isinstance(node, getattr(ast, 'NameConstant', ())))"
        ],
        [
            "STORE_NAME",
            "\"\"\"\n    Decorate functions with an instance of this class to debug them,\n    or just use the existing instance `eye`.\n    \"\"\""
        ],
        [
            "STORE_NAME",
            "    def __init__(self, db_uri=None, num_samples=None):\n        \"\"\"\n        Set db_uri to specify where the database lives, as an alternative to\n        the environment variable BIRDSEYE_DB.\n        \"\"\"\n        super(BirdsEye, self).__init__()\n        self._db_uri = db_uri\n        self._code_infos = {}  # type: Dict[CodeType, CodeInfo]\n        self._last_call_id = None\n        self._ipython_cell_value = None\n        self.num_samples = num_samples or dict(\n            big=dict(\n                attributes=50,\n                dict=50,\n                list=30,\n                set=30,\n                pandas_rows=20,\n                pandas_cols=100,\n            ),\n            small=dict(\n                attributes=50,\n                dict=10,\n                list=6,\n                set=6,\n                pandas_rows=6,\n                pandas_cols=10,\n            ),\n        )"
        ],
        [
            "LOAD_NAME",
            "cached_property"
        ],
        [
            "CALL",
            "cached_property"
        ],
        [
            "STORE_NAME",
            "    @cached_property\n    def db(self):\n        return Database(self._db_uri)"
        ],
        [
            "STORE_NAME",
            "    def parse_extra(self, root, source, filename):\n        # type: (ast.Module, str, str) -> None\n        for node in ast.walk(root):  # type: ast.AST\n            node._loops = tracer.loops(node)\n            if isinstance(node, ast.expr):\n                node._is_interesting_expression = is_interesting_expression(node)"
        ],
        [
            "LOAD_NAME",
            "lru_cache"
        ],
        [
            "CALL",
            "lru_cache()"
        ],
        [
            "CALL",
            "lru_cache()"
        ],
        [
            "STORE_NAME",
            "    @lru_cache()\n    def compile(self, source, filename, flags=0):\n        traced_file = super(BirdsEye, self).compile(source, filename, flags)\n        traced_file.tokens = ASTTokens(source, tree=traced_file.root)\n        return traced_file"
        ],
        [
            "STORE_NAME",
            "    def before_stmt(self, node, frame):\n        # type: (ast.stmt, FrameType) -> None\n        if frame.f_code not in self._code_infos:\n            return\n        if isinstance(node.parent, ast.For) and node is node.parent.body[0]:\n            self._add_iteration(node._loops, frame)"
        ],
        [
            "STORE_NAME",
            "    def before_expr(self, node, frame):\n        if isinstance(node.parent, ast.While) and node is node.parent.test:\n            self._add_iteration(node._loops, frame)"
        ],
        [
            "STORE_NAME",
            "    def _add_iteration(self, loops, frame):\n        # type: (typing.Sequence[Loop], FrameType) -> None\n        \"\"\"\n        Given one or more nested loops, add an iteration for the innermost\n        loop (the last in the sequence).\n        \"\"\"\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for i, loop_node in enumerate(loops):\n            loop = iteration.loops[loop_node._tree_index]\n            if i == len(loops) - 1:\n                loop.append(Iteration())\n            else:\n                iteration = loop.last()"
        ],
        [
            "STORE_NAME",
            "    def after_expr(self, node, frame, value, exc_value, exc_tb):\n        # type: (ast.expr, FrameType, Any, Optional[BaseException], Optional[TracebackType]) -> Optional[ChangeValue]\n\n        if _tracing_recursively(frame):\n            return None\n\n        if frame.f_code not in self._code_infos:\n            return None\n\n        if node._is_interesting_expression:\n            # If this is an expression statement and the last statement\n            # in the body, the value is returned from the cell magic\n            # to be displayed as usual\n            if (self._code_infos[frame.f_code].traced_file.is_ipython_cell\n                    and isinstance(node.parent, ast.Expr)\n                    and node.parent is node.parent.parent.body[-1]):\n                self._ipython_cell_value = value\n\n            if is_obvious_builtin(node, self.stack[frame].expression_values[node]):\n                return None\n\n            frame_info = self.stack[frame]\n            if exc_value:\n                node_value = self._exception_value(node, frame, exc_value)\n            else:\n                node_value = NodeValue.expression(\n                    self.num_samples,\n                    value,\n                    level=max(1, 3 - len(node._loops) * (not self._is_first_loop_iteration(node, frame))),\n                )\n                self._set_node_value(node, frame, node_value)\n            self._check_inner_call(frame_info, node, node_value)\n\n        # i.e. is `node` the `y` in `[f(x) for x in y]`, making `node.parent` the `for x in y`\n        is_special_comprehension_iter = (\n                isinstance(node.parent, ast.comprehension) and\n                node is node.parent.iter and\n\n                # Generators execute in their own time and aren't directly attached to the parent frame\n                not isinstance(node.parent.parent, ast.GeneratorExp))\n\n        if not is_special_comprehension_iter:\n            return None\n\n        # Mark `for x in y` as a bit that executed, so it doesn't show as grey\n        self._set_node_value(node.parent, frame, NodeValue.covered())\n\n        if exc_value:\n            return None\n\n        # Track each iteration over `y` so that the 'loop' can be stepped through\n        loops = node._loops + (node.parent,)  # type: Tuple[Loop, ...]\n\n        def comprehension_iter_proxy():\n            for item in value:\n                self._add_iteration(loops, frame)\n                yield item\n\n        # This effectively changes to code to `for x in comprehension_iter_proxy()`\n        return ChangeValue(comprehension_iter_proxy())"
        ],
        [
            "STORE_NAME",
            "    def _check_inner_call(self, frame_info, node, node_value):\n        # type: (FrameInfo, Union[ast.stmt, ast.expr], NodeValue) -> None\n        inner_calls = frame_info.inner_calls.pop(node, None)\n        if inner_calls:\n            node_value.set_meta('inner_calls', inner_calls)"
        ],
        [
            "STORE_NAME",
            "    def _is_first_loop_iteration(self, node, frame):\n        # type: (ast.AST, FrameType) -> bool\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for loop_node in node._loops:  # type: ast.AST\n            loop = iteration.loops[loop_node._tree_index]\n            iteration = loop.last()\n            if iteration.index > 0:\n                return False\n        return True"
        ],
        [
            "STORE_NAME",
            "    def _set_node_value(self, node, frame, value):\n        # type: (ast.AST, FrameType, NodeValue) -> None\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for loop_node in node._loops:  # type: ast.AST\n            loop = iteration.loops[loop_node._tree_index]\n            loop.recorded_node(node)\n            iteration = loop.last()\n        iteration.vals[node._tree_index] = value"
        ],
        [
            "STORE_NAME",
            "    def _exception_value(self, node, frame, exc_value):\n        # type: (Union[ast.expr, ast.stmt], FrameType, BaseException) -> NodeValue\n        value = NodeValue.exception(exc_value)\n        self._set_node_value(node, frame, value)\n        return value"
        ],
        [
            "STORE_NAME",
            "    def after_stmt(self, node, frame, exc_value, exc_traceback, exc_node):\n        # type: (ast.stmt, FrameType, Optional[BaseException], Optional[TracebackType], Optional[ast.AST]) -> Optional[bool]\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return None\n        if exc_value and node is exc_node:\n            value = self._exception_value(node, frame, exc_value)\n        else:\n            value = NodeValue.covered()\n            self._set_node_value(node, frame, value)\n        self._check_inner_call(self.stack[frame], node, value)\n        return None"
        ],
        [
            "STORE_NAME",
            "    def enter_call(self, enter_info):\n        # type: (EnterCallInfo) -> None\n        frame = enter_info.current_frame  # type: FrameType\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return\n        frame_info = self.stack[frame]\n        frame_info.start_time = get_unfrozen_datetime()\n        frame_info.iteration = Iteration()\n\n        code_info = self._code_infos[frame.f_code]\n        if isinstance(enter_info.enter_node.parent, ast.Module):\n            arguments = []\n        else:\n            f_locals = frame.f_locals.copy()  # type: Dict[str, Any]\n            arguments = [(name, f_locals.pop(name))\n                         for name in code_info.arg_names\n                         if name] + [\n\n                            # Local variables other than actual arguments. These are variables from\n                            # the enclosing scope. It's handy to treat them like arguments in the UI\n                            it for it in f_locals.items()\n                            if it[0][0] != '.'  # Appears when using nested tuple arguments\n                        ]\n        frame_info.arguments = json.dumps([[k, cheap_repr(v)] for k, v in arguments])\n        frame_info.call_id = self._call_id()\n        frame_info.inner_calls = defaultdict(list)\n        prev = self.stack.get(enter_info.caller_frame)\n        if prev:\n            inner_calls = getattr(prev, 'inner_calls', None)\n            if inner_calls is not None:\n                inner_calls[enter_info.call_node].append(frame_info.call_id)"
        ],
        [
            "STORE_NAME",
            "    def _call_id(self):\n        # type: () -> Text\n        return uuid4().hex"
        ],
        [
            "STORE_NAME",
            "    def exit_call(self, exit_info):\n        # type: (ExitCallInfo) -> None\n        \"\"\"\n        This is where all the data collected during the call is gathered up\n        and sent to the database.\n        \"\"\"\n        frame = exit_info.current_frame  # type: FrameType\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return\n        frame_info = self.stack[frame]\n\n        top_iteration = frame_info.iteration  # type: Iteration\n        node_values = _deep_dict()\n        self._extract_node_values(top_iteration, (), node_values)\n\n        db_func = self._code_infos[frame.f_code].db_func\n        exc = exit_info.exc_value  # type: Optional[Exception]\n        if exc:\n            traceback_str = ''.join(traceback.format_exception(type(exc), exc, exit_info.exc_tb))\n            exception = exception_string(exc)\n        else:\n            traceback_str = exception = None\n\n        @retry_db\n        def add_call():\n            Call = self.db.Call\n            call = Call(id=frame_info.call_id,\n                        function_id=db_func,\n                        arguments=frame_info.arguments,\n                        return_value=cheap_repr(exit_info.return_value),\n                        exception=exception,\n                        traceback=traceback_str,\n                        data=json.dumps(\n                            dict(\n                                node_values=node_values,\n                                loop_iterations=top_iteration.extract_iterations()['loops'],\n                                type_names=type_registry.names(),\n                                num_special_types=type_registry.num_special_types,\n                            ),\n                            cls=ProtocolEncoder,\n                            separators=(',', ':')\n                        ),\n                        start_time=frame_info.start_time)\n            with self.db.session_scope() as session:\n                session.add(call)\n\n        add_call()\n\n        self._last_call_id = frame_info.call_id"
        ],
        [
            "STORE_NAME",
            "    def _extract_node_values(self, iteration, path, node_values):\n        # type: (Iteration, Tuple[int, ...], dict) -> None\n        \"\"\"\n        Populates node_values with values inside iteration.\n        \"\"\"\n        # Each element of `path` is an index of a loop iteration\n        # e.g. given the nested loops:\n        #\n        # for i in [0, 1, 2]:\n        #     for j in [0, 1, 2, 3]:\n        #\n        # path may be (i, j) for each of the iterations\n        for tree_index, node_value in iteration.vals.items():\n\n            # So this `full_path` is a tuple of ints, but the first\n            # int has a different meaning from the others\n            full_path = (tree_index,) + path\n\n            # Given a path (a, b, c) we're making node_values 'contain'\n            # this structure:\n            # {a: {b: {c: node_value}}}\n            d = node_values\n            for path_k in full_path[:-1]:\n                d = d[path_k]\n            d[full_path[-1]] = node_value\n\n        for loop in iteration.loops.values():\n            for i, iteration in enumerate(loop):\n                self._extract_node_values(iteration, path + (i,), node_values)"
        ],
        [
            "STORE_NAME",
            "    def trace_function(self, func):\n        # type: (FunctionType) -> FunctionType\n        new_func = super(BirdsEye, self).trace_function(func)\n        code_info = self._code_infos.get(new_func.__code__)\n        if code_info:\n            return new_func\n\n        lines, start_lineno = inspect.getsourcelines(func)  # type: List[Text], int\n        end_lineno = start_lineno + len(lines)\n        name = safe_qualname(func)\n        source_file = inspect.getsourcefile(func)\n        if source_file.startswith('<ipython-input'):\n            filename = IPYTHON_FILE_PATH\n        else:\n            filename = os.path.abspath(source_file)\n        traced_file = new_func.traced_file\n\n        arg_info = inspect.getargs(new_func.__code__)\n        arg_names = list(chain(flatten_list(arg_info[0]), arg_info[1:]))  # type: List[str]\n        self._trace(name, filename, traced_file, new_func.__code__, typ='function',\n                    start_lineno=start_lineno, end_lineno=end_lineno,\n                    arg_names=arg_names)\n\n        return new_func"
        ],
        [
            "STORE_NAME",
            "    def exec_ipython_cell(self, source, callback):\n        from IPython import get_ipython\n        shell = get_ipython()\n        filename = name = shell.compile.cache(source)\n        flags = shell.compile.flags\n\n        traced_file = self.compile(source, filename, flags)\n        traced_file.is_ipython_cell = True\n\n        for node in traced_file.root.body:\n            if is_future_import(node):\n                raise ValueError('from __future__ import ... statements '\n                                 'are not allowed in cells traced with %%eye')\n\n        shell.user_global_ns.update(self._trace_methods_dict(traced_file))\n\n        self._trace(name, filename, traced_file, traced_file.code, 'module', source)\n\n        try:\n            shell.ex(traced_file.code)\n            return self._ipython_cell_value\n        finally:\n            callback(self._last_call_id)\n            self._ipython_cell_value = None"
        ],
        [
            "STORE_NAME",
            "    def trace_this_module(self, context=0, deep=False):\n        frame = inspect.currentframe()\n\n        filename = None\n        while context >= 0:\n            frame = frame.f_back\n            filename = inspect.getsourcefile(frame)\n            if filename is not None:\n                context -= 1\n        filename = os.path.abspath(filename)\n\n        if frame.f_globals.get('__name__') != '__main__':\n            if PY3 and self._treetrace_hidden_with_stmt.__name__ not in frame.f_globals:\n                raise RuntimeError(\n                    'To trace an imported module, you must import birdseye before '\n                    'importing that module.')\n            return\n\n        lines = read_source_file(filename).splitlines()\n        lines[:frame.f_lineno] = [''] * frame.f_lineno\n        source = '\\n'.join(lines)\n        self.exec_string(source, filename, frame.f_globals, frame.f_locals, deep)\n        sys.exit(0)"
        ],
        [
            "STORE_NAME",
            "    def exec_string(self, source, filename, globs=None, locs=None, deep=False):\n        globs = globs or {}\n        locs = locs or {}\n\n        traced_file = self.compile(source, filename)\n\n        globs.update(self._trace_methods_dict(traced_file))\n\n        self._trace(FILE_SENTINEL_NAME, filename, traced_file, traced_file.code, 'module', source)\n\n        if deep:\n            nodes_by_lineno = {\n                node.lineno: node\n                for node in traced_file.nodes\n                if isinstance(node, ast.FunctionDef)\n            }\n\n            def find_code(root_code):\n                # type: (CodeType) -> None\n                for code in root_code.co_consts:  # type: CodeType\n                    if not inspect.iscode(code) or code.co_name.startswith('<'):\n                        continue\n\n                    find_code(code)\n\n                    lineno = code.co_firstlineno\n                    node = nodes_by_lineno.get(lineno)\n                    if not node:\n                        continue\n\n                    self._trace(\n                        code.co_name, filename, traced_file, code,\n                        typ='function',\n                        source=source,\n                        start_lineno=lineno,\n                        end_lineno=node.last_token.end[0] + 1,\n                    )\n\n            find_code(traced_file.code)\n\n        exec(traced_file.code, globs, locs)"
        ],
        [
            "STORE_NAME",
            "    def _trace(\n            self,\n            name,\n            filename,\n            traced_file,\n            code,\n            typ,\n            source='',\n            start_lineno=1,\n            end_lineno=None,\n            arg_names=(),\n    ):\n        if not end_lineno:\n            end_lineno = start_lineno + len(source.splitlines())\n        nodes = list(self._nodes_of_interest(traced_file, start_lineno, end_lineno))\n        html_body = self._nodes_html(nodes, start_lineno, end_lineno, traced_file)\n\n        data_dict = dict(\n            # This maps each node to the loops enclosing that node\n            node_loops={\n                node._tree_index: [n._tree_index for n in node._loops]\n                for node, _ in nodes\n                if node._loops\n            },\n        )\n        if typ == 'function':\n            tokens = traced_file.tokens\n            func_node = only(node\n                             for node, _ in nodes\n                             if isinstance(node, ast.FunctionDef)\n                             and node.first_token.start[0] == start_lineno)\n            func_startpos, source = source_without_decorators(tokens, func_node)\n            # These are for the PyCharm plugin\n            data_dict.update(\n                node_ranges=list(self._node_ranges(nodes, tokens, func_startpos)),\n                loop_ranges=list(self._loop_ranges(nodes, tokens, func_startpos)),\n            )\n\n        data = json.dumps(data_dict, sort_keys=True)\n        db_func = self._db_func(data, filename, html_body, name, start_lineno, source, typ)\n        self._code_infos[code] = CodeInfo(db_func, traced_file, arg_names)"
        ],
        [
            "STORE_NAME",
            "    def _loop_ranges(self, nodes, tokens, func_start):\n        # For a for loop, e.g.\n        #\n        #     for x in y:\n        #\n        # this yields the range of the target 'x'.\n        #\n        # For a while loop, e.g.\n        #\n        #     while x < 10:\n        #\n        # this yields the range of the condition 'x < 10'.\n        for node, (classes, _, __) in nodes:\n            if 'loop' not in classes:\n                continue\n\n            try:\n                target = node.target  # for loop\n            except AttributeError:\n                target = node.test  # while loop\n\n            start, end = tokens.get_text_range(target)\n            start -= func_start\n            end -= func_start\n\n            yield dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end\n            )"
        ],
        [
            "STORE_NAME",
            "    def _node_ranges(self, nodes, tokens, func_start):\n        for node, (classes, _, __) in nodes:\n            start, end = tokens.get_text_range(node)\n            start -= func_start\n            end -= func_start\n\n            if start < 0:\n                assert (end < 0  # nodes before the def, i.e. decorators\n                        or isinstance(node, ast.FunctionDef))\n                continue\n\n            yield dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end,\n                depth=node._depth,\n                classes=classes,\n            )"
        ],
        [
            "LOAD_NAME",
            "retry_db"
        ],
        [
            "CALL",
            "retry_db"
        ],
        [
            "STORE_NAME",
            "    @retry_db\n    def _db_func(self, data, filename, html_body, name, start_lineno, source, typ):\n        \"\"\"\n        Retrieve the Function object from the database if one exists, or create one.\n        \"\"\"\n\n        def h(s):\n            return hashlib.sha256(s.encode('utf8')).hexdigest()\n\n        function_hash = h(filename + name + html_body + data + str(start_lineno))\n\n        Function = self.db.Function\n\n        with self.db.session_scope() as session:\n            db_func = one_or_none(session.query(Function).filter_by(hash=function_hash))  # type: Optional[Function]\n            if not db_func:\n                db_func = Function(file=filename,\n                                   name=name,\n                                   type=typ,\n                                   html_body=html_body,\n                                   lineno=start_lineno,\n                                   data=data,\n                                   body_hash=h(source),\n                                   hash=function_hash)\n                session.add(db_func)\n                session.commit()  # ensure .id exists\n            assert isinstance(db_func.id, int)\n            return db_func.id"
        ],
        [
            "STORE_NAME",
            "    def _nodes_of_interest(self, traced_file, start_lineno, end_lineno):\n        # type: (TracedFile, int, int) -> Iterator[Tuple[ast.AST, Tuple]]\n        \"\"\"\n        Nodes that may have a value, show up as a box in the UI, and lie within the\n        given line range.\n        \"\"\"\n        for node in traced_file.nodes:\n            classes = []\n\n            if (isinstance(node, (ast.While, ast.For, ast.comprehension)) and\n                    not isinstance(node.parent, ast.GeneratorExp)):\n                classes.append('loop')\n            if isinstance(node, ast.stmt):\n                classes.append('stmt')\n\n            if isinstance(node, ast.expr):\n                if not node._is_interesting_expression:\n                    continue\n            elif not classes:\n                continue\n\n            assert isinstance(node, ast.AST)\n\n            # In particular FormattedValue is missing this\n            if not hasattr(node, 'first_token'):\n                continue\n\n            if not start_lineno <= node.first_token.start[0] <= end_lineno:\n                continue\n\n            start, end = traced_file.tokens.get_text_range(node)  # type: int, int\n            if start == end == 0:\n                continue\n\n            yield node, (classes, start, end)"
        ],
        [
            "STORE_NAME",
            "    def _nodes_html(self, nodes, start_lineno, end_lineno, traced_file):\n        # type: (list, int, int, TracedFile) -> str\n        \"\"\"\n        The algorithm for generating the HTML works as follows. We generate a list\n        of HTMLPositions, which are essentially places to insert HTML into the source plus some\n        metadata. The order of the fields of HTMLPosition ensure that when the list is sorted,\n        the resulting HTML is valid and correct. Specifically, the fields are:\n        \n          1. index: the index in the source string where the HTML would be inserted\n          2. is_start: Indicates if this piece of HTML is the start of a tag, rather than the end.\n             Ends should appear first, so that the resulting HTML looks like:\n                <span> ... </span><span> ... </span>\n             rather than:\n                <span> ... <span></span> ... </span>\n             (I think this might actually be unnecessary, since I can't think of any cases of two\n              expressions right next to each other with nothing in between)\n          3. depth: the depth of the corresponding node in the AST. We want the start of a tag from\n             a node to appear before the start of a tag nested within, e.g. `foo()` should become:\n                <span [for foo()]><span [for foo]>foo</span>()</span>\n             rather than:   \n                <span [for foo]><span [for foo()]>foo</span>()</span>\n          4. html: the actual HTML to insert. Not important for ordering.\n          \n        Mostly the list contains pairs of HTMLPositions corresponding to AST nodes, one for the\n        start and one for the end.\n        \n        After the list is sorted, the HTML generated is essentially:\n        \n        source[0:positions[0].index] + positions[0].html + source[positions[0].index:positions[1].index] + positions[1].html + ...\n        \"\"\"\n\n        traced_file.root._depth = 0\n        for node in ast.walk(traced_file.root):  # type: ast.AST\n            for child in ast.iter_child_nodes(node):\n                child._depth = node._depth + 1\n\n        positions = []  # type: List[HTMLPosition]\n\n        for node, (classes, start, end) in nodes:\n            # noinspection PyArgumentList\n            positions.extend(map(\n                HTMLPosition,\n                [start, end],\n                [True, False],  # is_start\n                [node._depth, node._depth],\n                ['<span data-index=\"%s\" class=\"%s\">' % (node._tree_index, ' '.join(classes)),\n                 '</span>']))\n\n        end_lineno = self._separate_comprehensions(\n            [n[0] for n in nodes],\n            end_lineno, positions, traced_file)\n\n        # This just makes the loop below simpler\n        positions.append(HTMLPosition(len(traced_file.source), False, 0, ''))\n\n        positions.sort()\n\n        html_parts = []\n        start = 0\n        for position in positions:\n            html_parts.append(html.escape(traced_file.source[start:position.index]))\n            html_parts.append(position.html)\n            start = position.index\n        html_body = ''.join(html_parts)\n        html_body = '\\n'.join(html_body.split('\\n')[start_lineno - 1:end_lineno - 1])\n\n        return html_body.strip('\\n')"
        ],
        [
            "STORE_NAME",
            "    def _separate_comprehensions(self, nodes, end_lineno, positions, traced_file):\n        # type: (list, int, List[HTMLPosition], TracedFile) -> int\n        \"\"\"\n        Comprehensions (e.g. list comprehensions) are troublesome because they can\n        be navigated like loops, and the buttons for these need to be on separate lines.\n        This function inserts newlines to turn:\n\n        [x + y for x in range(3) for y in range(5)] and\n        [[x + y for x in range(3)] for y in range(5)]\n\n        into\n\n        [x + y for x in range(3)\n         for y in range(5)] and\n        [[x + y for x in range(3)]\n         for y in range(5)]\n        \"\"\"\n\n        comprehensions = group_by_key_func(of_type((ast.comprehension, ast.While, ast.For), nodes),\n                                           lambda c: c.first_token.start[0]\n                                           )  # type: Dict[Any, Iterable[ast.comprehension]]\n\n        def get_start(n):\n            # type: (ast.AST) -> int\n            return traced_file.tokens.get_text_range(n)[0]\n\n        for comp_list in comprehensions.values():\n            prev_start = None  # type: Optional[int]\n            for comp in sorted(comp_list, key=lambda c: c.first_token.startpos):\n                if isinstance(comp, ast.comprehension) and comp is comp.parent.generators[0]:\n                    start = get_start(comp.parent)\n                    if prev_start is not None and start < prev_start:\n                        start = get_start(comp)\n                else:\n                    start = get_start(comp)\n                if prev_start is not None:\n                    positions.append(HTMLPosition(start, True, 0, '\\n '))\n                    end_lineno += 1\n                prev_start = start\n\n        return end_lineno"
        ],
        [
            "STORE_NAME",
            "    def _separate_comprehensions(self, nodes, end_lineno, positions, traced_file):\n        # type: (list, int, List[HTMLPosition], TracedFile) -> int\n        \"\"\"\n        Comprehensions (e.g. list comprehensions) are troublesome because they can\n        be navigated like loops, and the buttons for these need to be on separate lines.\n        This function inserts newlines to turn:\n\n        [x + y for x in range(3) for y in range(5)] and\n        [[x + y for x in range(3)] for y in range(5)]\n\n        into\n\n        [x + y for x in range(3)\n         for y in range(5)] and\n        [[x + y for x in range(3)]\n         for y in range(5)]\n        \"\"\"\n\n        comprehensions = group_by_key_func(of_type((ast.comprehension, ast.While, ast.For), nodes),\n                                           lambda c: c.first_token.start[0]\n                                           )  # type: Dict[Any, Iterable[ast.comprehension]]\n\n        def get_start(n):\n            # type: (ast.AST) -> int\n            return traced_file.tokens.get_text_range(n)[0]\n\n        for comp_list in comprehensions.values():\n            prev_start = None  # type: Optional[int]\n            for comp in sorted(comp_list, key=lambda c: c.first_token.startpos):\n                if isinstance(comp, ast.comprehension) and comp is comp.parent.generators[0]:\n                    start = get_start(comp.parent)\n                    if prev_start is not None and start < prev_start:\n                        start = get_start(comp)\n                else:\n                    start = get_start(comp)\n                if prev_start is not None:\n                    positions.append(HTMLPosition(start, True, 0, '\\n '))\n                    end_lineno += 1\n                prev_start = start\n\n        return end_lineno"
        ],
        [
            "LOAD_GLOBAL",
            "super"
        ],
        [
            "LOAD_GLOBAL",
            "BirdsEye"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "super(BirdsEye, self)"
        ],
        [
            "LOAD_METHOD",
            "super(BirdsEye, self).__init__"
        ],
        [
            "CALL",
            "super(BirdsEye, self).__init__()"
        ],
        [
            "LOAD_FAST",
            "db_uri"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._db_uri"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._code_infos"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._last_call_id"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._ipython_cell_value"
        ],
        [
            "LOAD_FAST",
            "num_samples"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "CALL",
            "dict(\n                attributes=50,\n                dict=50,\n                list=30,\n                set=30,\n                pandas_rows=20,\n                pandas_cols=100,\n            )"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "CALL",
            "dict(\n                attributes=50,\n                dict=10,\n                list=6,\n                set=6,\n                pandas_rows=6,\n                pandas_cols=10,\n            )"
        ],
        [
            "CALL",
            "dict(\n            big=dict(\n                attributes=50,\n                dict=50,\n                list=30,\n                set=30,\n                pandas_rows=20,\n                pandas_cols=100,\n            ),\n            small=dict(\n                attributes=50,\n                dict=10,\n                list=6,\n                set=6,\n                pandas_rows=6,\n                pandas_cols=10,\n            ),\n        )"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.num_samples"
        ],
        [
            "LOAD_GLOBAL",
            "Database"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._db_uri"
        ],
        [
            "CALL",
            "Database(self._db_uri)"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.walk"
        ],
        [
            "LOAD_FAST",
            "root"
        ],
        [
            "CALL",
            "ast.walk(root)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "tracer"
        ],
        [
            "LOAD_ATTR",
            "tracer.loops"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "tracer.loops(node)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "STORE_ATTR",
            "node._loops"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.expr"
        ],
        [
            "CALL",
            "isinstance(node, ast.expr)"
        ],
        [
            "LOAD_GLOBAL",
            "is_interesting_expression"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "is_interesting_expression(node)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "STORE_ATTR",
            "node._is_interesting_expression"
        ],
        [
            "LOAD_GLOBAL",
            "super"
        ],
        [
            "LOAD_GLOBAL",
            "BirdsEye"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "super(BirdsEye, self)"
        ],
        [
            "LOAD_METHOD",
            "super(BirdsEye, self).compile"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "flags"
        ],
        [
            "CALL",
            "super(BirdsEye, self).compile(source, filename, flags)"
        ],
        [
            "STORE_FAST",
            "traced_file"
        ],
        [
            "LOAD_GLOBAL",
            "ASTTokens"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.root"
        ],
        [
            "CALL",
            "ASTTokens(source, tree=traced_file.root)"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "STORE_ATTR",
            "traced_file.tokens"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code not in self._code_infos"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.For"
        ],
        [
            "CALL",
            "isinstance(node.parent, ast.For)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_ATTR",
            "node.parent.body"
        ],
        [
            "BINARY_SUBSCR",
            "node.parent.body[0]"
        ],
        [
            "IS_OP",
            "node is node.parent.body[0]"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._add_iteration"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._loops"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "self._add_iteration(node._loops, frame)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.While"
        ],
        [
            "CALL",
            "isinstance(node.parent, ast.While)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_ATTR",
            "node.parent.test"
        ],
        [
            "IS_OP",
            "node is node.parent.test"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._add_iteration"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._loops"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "self._add_iteration(node._loops, frame)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "LOAD_ATTR",
            "self.stack[frame].iteration"
        ],
        [
            "STORE_FAST",
            "iteration"
        ],
        [
            "LOAD_GLOBAL",
            "enumerate"
        ],
        [
            "LOAD_FAST",
            "loops"
        ],
        [
            "CALL",
            "enumerate(loops)"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "STORE_FAST",
            "loop_node"
        ],
        [
            "LOAD_FAST",
            "iteration"
        ],
        [
            "LOAD_ATTR",
            "iteration.loops"
        ],
        [
            "LOAD_FAST",
            "loop_node"
        ],
        [
            "LOAD_ATTR",
            "loop_node._tree_index"
        ],
        [
            "BINARY_SUBSCR",
            "iteration.loops[loop_node._tree_index]"
        ],
        [
            "STORE_FAST",
            "loop"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "loops"
        ],
        [
            "CALL",
            "len(loops)"
        ],
        [
            "BINARY_OP",
            "len(loops) - 1"
        ],
        [
            "COMPARE_OP",
            "i == len(loops) - 1"
        ],
        [
            "LOAD_FAST",
            "loop"
        ],
        [
            "LOAD_METHOD",
            "loop.append"
        ],
        [
            "LOAD_GLOBAL",
            "Iteration"
        ],
        [
            "CALL",
            "Iteration()"
        ],
        [
            "CALL",
            "loop.append(Iteration())"
        ],
        [
            "LOAD_FAST",
            "loop"
        ],
        [
            "LOAD_METHOD",
            "loop.last"
        ],
        [
            "CALL",
            "loop.last()"
        ],
        [
            "STORE_FAST",
            "iteration"
        ],
        [
            "LOAD_GLOBAL",
            "_tracing_recursively"
        ],
        [
            "LOAD_DEREF",
            "frame"
        ],
        [
            "CALL",
            "_tracing_recursively(frame)"
        ],
        [
            "LOAD_DEREF",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code not in self._code_infos"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._is_interesting_expression"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "LOAD_DEREF",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "BINARY_SUBSCR",
            "self._code_infos[frame.f_code]"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos[frame.f_code].traced_file"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos[frame.f_code].traced_file.is_ipython_cell"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Expr"
        ],
        [
            "CALL",
            "isinstance(node.parent, ast.Expr)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_ATTR",
            "node.parent.parent"
        ],
        [
            "LOAD_ATTR",
            "node.parent.parent.body"
        ],
        [
            "BINARY_SUBSCR",
            "node.parent.parent.body[-1]"
        ],
        [
            "IS_OP",
            "node.parent is node.parent.parent.body[-1]"
        ],
        [
            "LOAD_DEREF",
            "value"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._ipython_cell_value"
        ],
        [
            "LOAD_GLOBAL",
            "is_obvious_builtin"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_DEREF",
            "frame"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "LOAD_ATTR",
            "self.stack[frame].expression_values"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame].expression_values[node]"
        ],
        [
            "CALL",
            "is_obvious_builtin(node, self.stack[frame].expression_values[node])"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_DEREF",
            "frame"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "STORE_FAST",
            "frame_info"
        ],
        [
            "LOAD_FAST",
            "exc_value"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._exception_value"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_DEREF",
            "frame"
        ],
        [
            "LOAD_FAST",
            "exc_value"
        ],
        [
            "CALL",
            "self._exception_value(node, frame, exc_value)"
        ],
        [
            "STORE_FAST",
            "node_value"
        ],
        [
            "LOAD_GLOBAL",
            "NodeValue"
        ],
        [
            "LOAD_METHOD",
            "NodeValue.expression"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.num_samples"
        ],
        [
            "LOAD_DEREF",
            "value"
        ],
        [
            "LOAD_GLOBAL",
            "max"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._loops"
        ],
        [
            "CALL",
            "len(node._loops)"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._is_first_loop_iteration"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_DEREF",
            "frame"
        ],
        [
            "CALL",
            "self._is_first_loop_iteration(node, frame)"
        ],
        [
            "UNARY_NOT",
            "not self._is_first_loop_iteration(node, frame)"
        ],
        [
            "BINARY_OP",
            "len(node._loops) * (not self._is_first_loop_iteration(node, frame))"
        ],
        [
            "BINARY_OP",
            "3 - len(node._loops) * (not self._is_first_loop_iteration(node, frame))"
        ],
        [
            "CALL",
            "max(1, 3 - len(node._loops) * (not self._is_first_loop_iteration(node, frame)))"
        ],
        [
            "CALL",
            "NodeValue.expression(\n                    self.num_samples,\n                    value,\n                    level=max(1, 3 - len(node._loops) * (not self._is_first_loop_iteration(node, frame))),\n                )"
        ],
        [
            "STORE_FAST",
            "node_value"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._set_node_value"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_DEREF",
            "frame"
        ],
        [
            "LOAD_FAST",
            "node_value"
        ],
        [
            "CALL",
            "self._set_node_value(node, frame, node_value)"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._check_inner_call"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "node_value"
        ],
        [
            "CALL",
            "self._check_inner_call(frame_info, node, node_value)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.comprehension"
        ],
        [
            "CALL",
            "isinstance(node.parent, ast.comprehension)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_ATTR",
            "node.parent.iter"
        ],
        [
            "IS_OP",
            "node is node.parent.iter"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_ATTR",
            "node.parent.parent"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.GeneratorExp"
        ],
        [
            "CALL",
            "isinstance(node.parent.parent, ast.GeneratorExp)"
        ],
        [
            "UNARY_NOT",
            "not isinstance(node.parent.parent, ast.GeneratorExp)"
        ],
        [
            "STORE_FAST",
            "is_special_comprehension_iter"
        ],
        [
            "LOAD_FAST",
            "is_special_comprehension_iter"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._set_node_value"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_DEREF",
            "frame"
        ],
        [
            "LOAD_GLOBAL",
            "NodeValue"
        ],
        [
            "LOAD_METHOD",
            "NodeValue.covered"
        ],
        [
            "CALL",
            "NodeValue.covered()"
        ],
        [
            "CALL",
            "self._set_node_value(node.parent, frame, NodeValue.covered())"
        ],
        [
            "LOAD_FAST",
            "exc_value"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._loops"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "BINARY_OP",
            "node._loops + (node.parent,)"
        ],
        [
            "STORE_DEREF",
            "loops"
        ],
        [
            "STORE_FAST",
            "        def comprehension_iter_proxy():\n            for item in value:\n                self._add_iteration(loops, frame)\n                yield item"
        ],
        [
            "LOAD_GLOBAL",
            "ChangeValue"
        ],
        [
            "LOAD_FAST",
            "comprehension_iter_proxy"
        ],
        [
            "CALL",
            "comprehension_iter_proxy()"
        ],
        [
            "CALL",
            "ChangeValue(comprehension_iter_proxy())"
        ],
        [
            "LOAD_DEREF",
            "value"
        ],
        [
            "STORE_FAST",
            "item"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._add_iteration"
        ],
        [
            "LOAD_DEREF",
            "loops"
        ],
        [
            "LOAD_DEREF",
            "frame"
        ],
        [
            "CALL",
            "self._add_iteration(loops, frame)"
        ],
        [
            "LOAD_FAST",
            "item"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.inner_calls"
        ],
        [
            "LOAD_METHOD",
            "frame_info.inner_calls.pop"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "frame_info.inner_calls.pop(node, None)"
        ],
        [
            "STORE_FAST",
            "inner_calls"
        ],
        [
            "LOAD_FAST",
            "inner_calls"
        ],
        [
            "LOAD_FAST",
            "node_value"
        ],
        [
            "LOAD_METHOD",
            "node_value.set_meta"
        ],
        [
            "LOAD_FAST",
            "inner_calls"
        ],
        [
            "CALL",
            "node_value.set_meta('inner_calls', inner_calls)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "LOAD_ATTR",
            "self.stack[frame].iteration"
        ],
        [
            "STORE_FAST",
            "iteration"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._loops"
        ],
        [
            "STORE_FAST",
            "loop_node"
        ],
        [
            "LOAD_FAST",
            "iteration"
        ],
        [
            "LOAD_ATTR",
            "iteration.loops"
        ],
        [
            "LOAD_FAST",
            "loop_node"
        ],
        [
            "LOAD_ATTR",
            "loop_node._tree_index"
        ],
        [
            "BINARY_SUBSCR",
            "iteration.loops[loop_node._tree_index]"
        ],
        [
            "STORE_FAST",
            "loop"
        ],
        [
            "LOAD_FAST",
            "loop"
        ],
        [
            "LOAD_METHOD",
            "loop.last"
        ],
        [
            "CALL",
            "loop.last()"
        ],
        [
            "STORE_FAST",
            "iteration"
        ],
        [
            "LOAD_FAST",
            "iteration"
        ],
        [
            "LOAD_ATTR",
            "iteration.index"
        ],
        [
            "COMPARE_OP",
            "iteration.index > 0"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "LOAD_ATTR",
            "self.stack[frame].iteration"
        ],
        [
            "STORE_FAST",
            "iteration"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._loops"
        ],
        [
            "STORE_FAST",
            "loop_node"
        ],
        [
            "LOAD_FAST",
            "iteration"
        ],
        [
            "LOAD_ATTR",
            "iteration.loops"
        ],
        [
            "LOAD_FAST",
            "loop_node"
        ],
        [
            "LOAD_ATTR",
            "loop_node._tree_index"
        ],
        [
            "BINARY_SUBSCR",
            "iteration.loops[loop_node._tree_index]"
        ],
        [
            "STORE_FAST",
            "loop"
        ],
        [
            "LOAD_FAST",
            "loop"
        ],
        [
            "LOAD_METHOD",
            "loop.recorded_node"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "loop.recorded_node(node)"
        ],
        [
            "LOAD_FAST",
            "loop"
        ],
        [
            "LOAD_METHOD",
            "loop.last"
        ],
        [
            "CALL",
            "loop.last()"
        ],
        [
            "STORE_FAST",
            "iteration"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "iteration"
        ],
        [
            "LOAD_ATTR",
            "iteration.vals"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._tree_index"
        ],
        [
            "STORE_SUBSCR",
            "iteration.vals[node._tree_index]"
        ],
        [
            "LOAD_GLOBAL",
            "NodeValue"
        ],
        [
            "LOAD_METHOD",
            "NodeValue.exception"
        ],
        [
            "LOAD_FAST",
            "exc_value"
        ],
        [
            "CALL",
            "NodeValue.exception(exc_value)"
        ],
        [
            "STORE_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._set_node_value"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "CALL",
            "self._set_node_value(node, frame, value)"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code not in self._code_infos"
        ],
        [
            "LOAD_GLOBAL",
            "_tracing_recursively"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "_tracing_recursively(frame)"
        ],
        [
            "LOAD_FAST",
            "exc_value"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "exc_node"
        ],
        [
            "IS_OP",
            "node is exc_node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._exception_value"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "exc_value"
        ],
        [
            "CALL",
            "self._exception_value(node, frame, exc_value)"
        ],
        [
            "STORE_FAST",
            "value"
        ],
        [
            "LOAD_GLOBAL",
            "NodeValue"
        ],
        [
            "LOAD_METHOD",
            "NodeValue.covered"
        ],
        [
            "CALL",
            "NodeValue.covered()"
        ],
        [
            "STORE_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._set_node_value"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "CALL",
            "self._set_node_value(node, frame, value)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._check_inner_call"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "CALL",
            "self._check_inner_call(self.stack[frame], node, value)"
        ],
        [
            "LOAD_FAST",
            "enter_info"
        ],
        [
            "LOAD_ATTR",
            "enter_info.current_frame"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code not in self._code_infos"
        ],
        [
            "LOAD_GLOBAL",
            "_tracing_recursively"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "_tracing_recursively(frame)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "STORE_FAST",
            "frame_info"
        ],
        [
            "LOAD_GLOBAL",
            "get_unfrozen_datetime"
        ],
        [
            "CALL",
            "get_unfrozen_datetime()"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "STORE_ATTR",
            "frame_info.start_time"
        ],
        [
            "LOAD_GLOBAL",
            "Iteration"
        ],
        [
            "CALL",
            "Iteration()"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "STORE_ATTR",
            "frame_info.iteration"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "BINARY_SUBSCR",
            "self._code_infos[frame.f_code]"
        ],
        [
            "STORE_FAST",
            "code_info"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "enter_info"
        ],
        [
            "LOAD_ATTR",
            "enter_info.enter_node"
        ],
        [
            "LOAD_ATTR",
            "enter_info.enter_node.parent"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Module"
        ],
        [
            "CALL",
            "isinstance(enter_info.enter_node.parent, ast.Module)"
        ],
        [
            "STORE_FAST",
            "arguments"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_locals"
        ],
        [
            "LOAD_METHOD",
            "frame.f_locals.copy"
        ],
        [
            "CALL",
            "frame.f_locals.copy()"
        ],
        [
            "STORE_DEREF",
            "f_locals"
        ],
        [
            "LOAD_FAST",
            "code_info"
        ],
        [
            "LOAD_ATTR",
            "code_info.arg_names"
        ],
        [
            "CALL",
            "[(name, f_locals.pop(name))\n                         for name in code_info.arg_names\n                         if name]"
        ],
        [
            "LOAD_DEREF",
            "f_locals"
        ],
        [
            "LOAD_METHOD",
            "f_locals.items"
        ],
        [
            "CALL",
            "f_locals.items()"
        ],
        [
            "CALL",
            "[\n\n                            # Local variables other than actual arguments. These are variables from\n                            # the enclosing scope. It's handy to treat them like arguments in the UI\n                            it for it in f_locals.items()\n                            if it[0][0] != '.'  # Appears when using nested tuple arguments\n                        ]"
        ],
        [
            "BINARY_OP",
            "[(name, f_locals.pop(name))\n                         for name in code_info.arg_names\n                         if name] + [\n\n                            # Local variables other than actual arguments. These are variables from\n                            # the enclosing scope. It's handy to treat them like arguments in the UI\n                            it for it in f_locals.items()\n                            if it[0][0] != '.'  # Appears when using nested tuple arguments\n                        ]"
        ],
        [
            "STORE_FAST",
            "arguments"
        ],
        [
            "LOAD_GLOBAL",
            "json"
        ],
        [
            "LOAD_ATTR",
            "json.dumps"
        ],
        [
            "LOAD_FAST",
            "arguments"
        ],
        [
            "CALL",
            "[[k, cheap_repr(v)] for k, v in arguments]"
        ],
        [
            "CALL",
            "json.dumps([[k, cheap_repr(v)] for k, v in arguments])"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "STORE_ATTR",
            "frame_info.arguments"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._call_id"
        ],
        [
            "CALL",
            "self._call_id()"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "STORE_ATTR",
            "frame_info.call_id"
        ],
        [
            "LOAD_GLOBAL",
            "defaultdict"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "CALL",
            "defaultdict(list)"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "STORE_ATTR",
            "frame_info.inner_calls"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_METHOD",
            "self.stack.get"
        ],
        [
            "LOAD_FAST",
            "enter_info"
        ],
        [
            "LOAD_ATTR",
            "enter_info.caller_frame"
        ],
        [
            "CALL",
            "self.stack.get(enter_info.caller_frame)"
        ],
        [
            "STORE_FAST",
            "prev"
        ],
        [
            "LOAD_FAST",
            "prev"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_FAST",
            "prev"
        ],
        [
            "CALL",
            "getattr(prev, 'inner_calls', None)"
        ],
        [
            "STORE_FAST",
            "inner_calls"
        ],
        [
            "LOAD_FAST",
            "inner_calls"
        ],
        [
            "LOAD_FAST",
            "inner_calls"
        ],
        [
            "LOAD_FAST",
            "enter_info"
        ],
        [
            "LOAD_ATTR",
            "enter_info.call_node"
        ],
        [
            "BINARY_SUBSCR",
            "inner_calls[enter_info.call_node]"
        ],
        [
            "LOAD_METHOD",
            "inner_calls[enter_info.call_node].append"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.call_id"
        ],
        [
            "CALL",
            "inner_calls[enter_info.call_node].append(frame_info.call_id)"
        ],
        [
            "LOAD_FAST",
            "[(name, f_locals.pop(name))\n                         for name in code_info.arg_names\n                         if name]"
        ],
        [
            "STORE_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_DEREF",
            "f_locals"
        ],
        [
            "LOAD_METHOD",
            "f_locals.pop"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "CALL",
            "f_locals.pop(name)"
        ],
        [
            "LOAD_FAST",
            "[\n\n                            # Local variables other than actual arguments. These are variables from\n                            # the enclosing scope. It's handy to treat them like arguments in the UI\n                            it for it in f_locals.items()\n                            if it[0][0] != '.'  # Appears when using nested tuple arguments\n                        ]"
        ],
        [
            "STORE_FAST",
            "it"
        ],
        [
            "LOAD_FAST",
            "it"
        ],
        [
            "BINARY_SUBSCR",
            "it[0]"
        ],
        [
            "BINARY_SUBSCR",
            "it[0][0]"
        ],
        [
            "COMPARE_OP",
            "it[0][0] != '.'"
        ],
        [
            "LOAD_FAST",
            "it"
        ],
        [
            "LOAD_FAST",
            "[[k, cheap_repr(v)] for k, v in arguments]"
        ],
        [
            "STORE_FAST",
            "k"
        ],
        [
            "STORE_FAST",
            "v"
        ],
        [
            "LOAD_FAST",
            "k"
        ],
        [
            "LOAD_GLOBAL",
            "cheap_repr"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "CALL",
            "cheap_repr(v)"
        ],
        [
            "LOAD_GLOBAL",
            "uuid4"
        ],
        [
            "CALL",
            "uuid4()"
        ],
        [
            "LOAD_ATTR",
            "uuid4().hex"
        ],
        [
            "LOAD_DEREF",
            "exit_info"
        ],
        [
            "LOAD_ATTR",
            "exit_info.current_frame"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code not in self._code_infos"
        ],
        [
            "LOAD_GLOBAL",
            "_tracing_recursively"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "_tracing_recursively(frame)"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "STORE_DEREF",
            "frame_info"
        ],
        [
            "LOAD_DEREF",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.iteration"
        ],
        [
            "STORE_DEREF",
            "top_iteration"
        ],
        [
            "LOAD_GLOBAL",
            "_deep_dict"
        ],
        [
            "CALL",
            "_deep_dict()"
        ],
        [
            "STORE_DEREF",
            "node_values"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._extract_node_values"
        ],
        [
            "LOAD_DEREF",
            "top_iteration"
        ],
        [
            "LOAD_DEREF",
            "node_values"
        ],
        [
            "CALL",
            "self._extract_node_values(top_iteration, (), node_values)"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "BINARY_SUBSCR",
            "self._code_infos[frame.f_code]"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos[frame.f_code].db_func"
        ],
        [
            "STORE_DEREF",
            "db_func"
        ],
        [
            "LOAD_DEREF",
            "exit_info"
        ],
        [
            "LOAD_ATTR",
            "exit_info.exc_value"
        ],
        [
            "STORE_FAST",
            "exc"
        ],
        [
            "LOAD_FAST",
            "exc"
        ],
        [
            "LOAD_METHOD",
            "''.join"
        ],
        [
            "LOAD_GLOBAL",
            "traceback"
        ],
        [
            "LOAD_ATTR",
            "traceback.format_exception"
        ],
        [
            "LOAD_GLOBAL",
            "type"
        ],
        [
            "LOAD_FAST",
            "exc"
        ],
        [
            "CALL",
            "type(exc)"
        ],
        [
            "LOAD_FAST",
            "exc"
        ],
        [
            "LOAD_DEREF",
            "exit_info"
        ],
        [
            "LOAD_ATTR",
            "exit_info.exc_tb"
        ],
        [
            "CALL",
            "traceback.format_exception(type(exc), exc, exit_info.exc_tb)"
        ],
        [
            "CALL",
            "''.join(traceback.format_exception(type(exc), exc, exit_info.exc_tb))"
        ],
        [
            "STORE_DEREF",
            "traceback_str"
        ],
        [
            "LOAD_GLOBAL",
            "exception_string"
        ],
        [
            "LOAD_FAST",
            "exc"
        ],
        [
            "CALL",
            "exception_string(exc)"
        ],
        [
            "STORE_DEREF",
            "exception"
        ],
        [
            "STORE_DEREF",
            "traceback_str"
        ],
        [
            "STORE_DEREF",
            "exception"
        ],
        [
            "LOAD_GLOBAL",
            "retry_db"
        ],
        [
            "CALL",
            "retry_db"
        ],
        [
            "STORE_FAST",
            "        @retry_db\n        def add_call():\n            Call = self.db.Call\n            call = Call(id=frame_info.call_id,\n                        function_id=db_func,\n                        arguments=frame_info.arguments,\n                        return_value=cheap_repr(exit_info.return_value),\n                        exception=exception,\n                        traceback=traceback_str,\n                        data=json.dumps(\n                            dict(\n                                node_values=node_values,\n                                loop_iterations=top_iteration.extract_iterations()['loops'],\n                                type_names=type_registry.names(),\n                                num_special_types=type_registry.num_special_types,\n                            ),\n                            cls=ProtocolEncoder,\n                            separators=(',', ':')\n                        ),\n                        start_time=frame_info.start_time)\n            with self.db.session_scope() as session:\n                session.add(call)"
        ],
        [
            "LOAD_FAST",
            "add_call"
        ],
        [
            "CALL",
            "add_call()"
        ],
        [
            "LOAD_DEREF",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.call_id"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._last_call_id"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.db"
        ],
        [
            "LOAD_ATTR",
            "self.db.Call"
        ],
        [
            "STORE_FAST",
            "Call"
        ],
        [
            "LOAD_FAST",
            "Call"
        ],
        [
            "LOAD_DEREF",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.call_id"
        ],
        [
            "LOAD_DEREF",
            "db_func"
        ],
        [
            "LOAD_DEREF",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.arguments"
        ],
        [
            "LOAD_GLOBAL",
            "cheap_repr"
        ],
        [
            "LOAD_DEREF",
            "exit_info"
        ],
        [
            "LOAD_ATTR",
            "exit_info.return_value"
        ],
        [
            "CALL",
            "cheap_repr(exit_info.return_value)"
        ],
        [
            "LOAD_DEREF",
            "exception"
        ],
        [
            "LOAD_DEREF",
            "traceback_str"
        ],
        [
            "LOAD_GLOBAL",
            "json"
        ],
        [
            "LOAD_ATTR",
            "json.dumps"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_DEREF",
            "node_values"
        ],
        [
            "LOAD_DEREF",
            "top_iteration"
        ],
        [
            "LOAD_METHOD",
            "top_iteration.extract_iterations"
        ],
        [
            "CALL",
            "top_iteration.extract_iterations()"
        ],
        [
            "BINARY_SUBSCR",
            "top_iteration.extract_iterations()['loops']"
        ],
        [
            "LOAD_GLOBAL",
            "type_registry"
        ],
        [
            "LOAD_METHOD",
            "type_registry.names"
        ],
        [
            "CALL",
            "type_registry.names()"
        ],
        [
            "LOAD_GLOBAL",
            "type_registry"
        ],
        [
            "LOAD_ATTR",
            "type_registry.num_special_types"
        ],
        [
            "CALL",
            "dict(\n                                node_values=node_values,\n                                loop_iterations=top_iteration.extract_iterations()['loops'],\n                                type_names=type_registry.names(),\n                                num_special_types=type_registry.num_special_types,\n                            )"
        ],
        [
            "LOAD_GLOBAL",
            "ProtocolEncoder"
        ],
        [
            "CALL",
            "json.dumps(\n                            dict(\n                                node_values=node_values,\n                                loop_iterations=top_iteration.extract_iterations()['loops'],\n                                type_names=type_registry.names(),\n                                num_special_types=type_registry.num_special_types,\n                            ),\n                            cls=ProtocolEncoder,\n                            separators=(',', ':')\n                        )"
        ],
        [
            "LOAD_DEREF",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.start_time"
        ],
        [
            "CALL",
            "Call(id=frame_info.call_id,\n                        function_id=db_func,\n                        arguments=frame_info.arguments,\n                        return_value=cheap_repr(exit_info.return_value),\n                        exception=exception,\n                        traceback=traceback_str,\n                        data=json.dumps(\n                            dict(\n                                node_values=node_values,\n                                loop_iterations=top_iteration.extract_iterations()['loops'],\n                                type_names=type_registry.names(),\n                                num_special_types=type_registry.num_special_types,\n                            ),\n                            cls=ProtocolEncoder,\n                            separators=(',', ':')\n                        ),\n                        start_time=frame_info.start_time)"
        ],
        [
            "STORE_FAST",
            "call"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.db"
        ],
        [
            "LOAD_METHOD",
            "self.db.session_scope"
        ],
        [
            "CALL",
            "self.db.session_scope()"
        ],
        [
            "STORE_FAST",
            "session"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.add"
        ],
        [
            "LOAD_FAST",
            "call"
        ],
        [
            "CALL",
            "session.add(call)"
        ],
        [
            "CALL",
            "            with self.db.session_scope() as session:\n                session.add(call)"
        ],
        [
            "LOAD_FAST",
            "iteration"
        ],
        [
            "LOAD_ATTR",
            "iteration.vals"
        ],
        [
            "LOAD_METHOD",
            "iteration.vals.items"
        ],
        [
            "CALL",
            "iteration.vals.items()"
        ],
        [
            "STORE_FAST",
            "tree_index"
        ],
        [
            "STORE_FAST",
            "node_value"
        ],
        [
            "LOAD_FAST",
            "tree_index"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "BINARY_OP",
            "(tree_index,) + path"
        ],
        [
            "STORE_FAST",
            "full_path"
        ],
        [
            "LOAD_FAST",
            "node_values"
        ],
        [
            "STORE_FAST",
            "d"
        ],
        [
            "LOAD_FAST",
            "full_path"
        ],
        [
            "BINARY_SUBSCR",
            "full_path[:-1]"
        ],
        [
            "STORE_FAST",
            "path_k"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "LOAD_FAST",
            "path_k"
        ],
        [
            "BINARY_SUBSCR",
            "d[path_k]"
        ],
        [
            "STORE_FAST",
            "d"
        ],
        [
            "LOAD_FAST",
            "node_value"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "LOAD_FAST",
            "full_path"
        ],
        [
            "BINARY_SUBSCR",
            "full_path[-1]"
        ],
        [
            "STORE_SUBSCR",
            "d[full_path[-1]]"
        ],
        [
            "LOAD_FAST",
            "iteration"
        ],
        [
            "LOAD_ATTR",
            "iteration.loops"
        ],
        [
            "LOAD_METHOD",
            "iteration.loops.values"
        ],
        [
            "CALL",
            "iteration.loops.values()"
        ],
        [
            "STORE_FAST",
            "loop"
        ],
        [
            "LOAD_GLOBAL",
            "enumerate"
        ],
        [
            "LOAD_FAST",
            "loop"
        ],
        [
            "CALL",
            "enumerate(loop)"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "STORE_FAST",
            "iteration"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._extract_node_values"
        ],
        [
            "LOAD_FAST",
            "iteration"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_OP",
            "path + (i,)"
        ],
        [
            "LOAD_FAST",
            "node_values"
        ],
        [
            "CALL",
            "self._extract_node_values(iteration, path + (i,), node_values)"
        ],
        [
            "LOAD_GLOBAL",
            "super"
        ],
        [
            "LOAD_GLOBAL",
            "BirdsEye"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "super(BirdsEye, self)"
        ],
        [
            "LOAD_METHOD",
            "super(BirdsEye, self).trace_function"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "CALL",
            "super(BirdsEye, self).trace_function(func)"
        ],
        [
            "STORE_FAST",
            "new_func"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "LOAD_METHOD",
            "self._code_infos.get"
        ],
        [
            "LOAD_FAST",
            "new_func"
        ],
        [
            "LOAD_ATTR",
            "new_func.__code__"
        ],
        [
            "CALL",
            "self._code_infos.get(new_func.__code__)"
        ],
        [
            "STORE_FAST",
            "code_info"
        ],
        [
            "LOAD_FAST",
            "code_info"
        ],
        [
            "LOAD_FAST",
            "new_func"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.getsourcelines"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "CALL",
            "inspect.getsourcelines(func)"
        ],
        [
            "STORE_FAST",
            "lines"
        ],
        [
            "STORE_FAST",
            "start_lineno"
        ],
        [
            "LOAD_FAST",
            "start_lineno"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "lines"
        ],
        [
            "CALL",
            "len(lines)"
        ],
        [
            "BINARY_OP",
            "start_lineno + len(lines)"
        ],
        [
            "STORE_FAST",
            "end_lineno"
        ],
        [
            "LOAD_GLOBAL",
            "safe_qualname"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "CALL",
            "safe_qualname(func)"
        ],
        [
            "STORE_FAST",
            "name"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.getsourcefile"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "CALL",
            "inspect.getsourcefile(func)"
        ],
        [
            "STORE_FAST",
            "source_file"
        ],
        [
            "LOAD_FAST",
            "source_file"
        ],
        [
            "LOAD_METHOD",
            "source_file.startswith"
        ],
        [
            "CALL",
            "source_file.startswith('<ipython-input')"
        ],
        [
            "LOAD_GLOBAL",
            "IPYTHON_FILE_PATH"
        ],
        [
            "STORE_FAST",
            "filename"
        ],
        [
            "LOAD_GLOBAL",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.abspath"
        ],
        [
            "LOAD_FAST",
            "source_file"
        ],
        [
            "CALL",
            "os.path.abspath(source_file)"
        ],
        [
            "STORE_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "new_func"
        ],
        [
            "LOAD_ATTR",
            "new_func.traced_file"
        ],
        [
            "STORE_FAST",
            "traced_file"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.getargs"
        ],
        [
            "LOAD_FAST",
            "new_func"
        ],
        [
            "LOAD_ATTR",
            "new_func.__code__"
        ],
        [
            "CALL",
            "inspect.getargs(new_func.__code__)"
        ],
        [
            "STORE_FAST",
            "arg_info"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_GLOBAL",
            "chain"
        ],
        [
            "LOAD_GLOBAL",
            "flatten_list"
        ],
        [
            "LOAD_FAST",
            "arg_info"
        ],
        [
            "BINARY_SUBSCR",
            "arg_info[0]"
        ],
        [
            "CALL",
            "flatten_list(arg_info[0])"
        ],
        [
            "LOAD_FAST",
            "arg_info"
        ],
        [
            "BINARY_SUBSCR",
            "arg_info[1:]"
        ],
        [
            "CALL",
            "chain(flatten_list(arg_info[0]), arg_info[1:])"
        ],
        [
            "CALL",
            "list(chain(flatten_list(arg_info[0]), arg_info[1:]))"
        ],
        [
            "STORE_FAST",
            "arg_names"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._trace"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_FAST",
            "new_func"
        ],
        [
            "LOAD_ATTR",
            "new_func.__code__"
        ],
        [
            "LOAD_FAST",
            "start_lineno"
        ],
        [
            "LOAD_FAST",
            "end_lineno"
        ],
        [
            "LOAD_FAST",
            "arg_names"
        ],
        [
            "CALL",
            "self._trace(name, filename, traced_file, new_func.__code__, typ='function',\n                    start_lineno=start_lineno, end_lineno=end_lineno,\n                    arg_names=arg_names)"
        ],
        [
            "LOAD_FAST",
            "new_func"
        ],
        [
            "STORE_FAST",
            "from IPython import get_ipython"
        ],
        [
            "LOAD_FAST",
            "get_ipython"
        ],
        [
            "CALL",
            "get_ipython()"
        ],
        [
            "STORE_FAST",
            "shell"
        ],
        [
            "LOAD_FAST",
            "shell"
        ],
        [
            "LOAD_ATTR",
            "shell.compile"
        ],
        [
            "LOAD_METHOD",
            "shell.compile.cache"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CALL",
            "shell.compile.cache(source)"
        ],
        [
            "STORE_FAST",
            "filename"
        ],
        [
            "STORE_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "shell"
        ],
        [
            "LOAD_ATTR",
            "shell.compile"
        ],
        [
            "LOAD_ATTR",
            "shell.compile.flags"
        ],
        [
            "STORE_FAST",
            "flags"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.compile"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "flags"
        ],
        [
            "CALL",
            "self.compile(source, filename, flags)"
        ],
        [
            "STORE_FAST",
            "traced_file"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "STORE_ATTR",
            "traced_file.is_ipython_cell"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.root"
        ],
        [
            "LOAD_ATTR",
            "traced_file.root.body"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "is_future_import"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "is_future_import(node)"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError('from __future__ import ... statements '\n                                 'are not allowed in cells traced with %%eye')"
        ],
        [
            "LOAD_FAST",
            "shell"
        ],
        [
            "LOAD_ATTR",
            "shell.user_global_ns"
        ],
        [
            "LOAD_METHOD",
            "shell.user_global_ns.update"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._trace_methods_dict"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "CALL",
            "self._trace_methods_dict(traced_file)"
        ],
        [
            "CALL",
            "shell.user_global_ns.update(self._trace_methods_dict(traced_file))"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._trace"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.code"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CALL",
            "self._trace(name, filename, traced_file, traced_file.code, 'module', source)"
        ],
        [
            "LOAD_FAST",
            "shell"
        ],
        [
            "LOAD_METHOD",
            "shell.ex"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.code"
        ],
        [
            "CALL",
            "shell.ex(traced_file.code)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._ipython_cell_value"
        ],
        [
            "LOAD_FAST",
            "callback"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._last_call_id"
        ],
        [
            "CALL",
            "callback(self._last_call_id)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._ipython_cell_value"
        ],
        [
            "LOAD_FAST",
            "callback"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._last_call_id"
        ],
        [
            "CALL",
            "callback(self._last_call_id)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._ipython_cell_value"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.currentframe"
        ],
        [
            "CALL",
            "inspect.currentframe()"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "STORE_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "context"
        ],
        [
            "COMPARE_OP",
            "context >= 0"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_back"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.getsourcefile"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "inspect.getsourcefile(frame)"
        ],
        [
            "STORE_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "context"
        ],
        [
            "BINARY_OP",
            "context -= 1"
        ],
        [
            "STORE_FAST",
            "context"
        ],
        [
            "LOAD_FAST",
            "context"
        ],
        [
            "COMPARE_OP",
            "context >= 0"
        ],
        [
            "LOAD_GLOBAL",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.abspath"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "CALL",
            "os.path.abspath(filename)"
        ],
        [
            "STORE_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_globals"
        ],
        [
            "LOAD_METHOD",
            "frame.f_globals.get"
        ],
        [
            "CALL",
            "frame.f_globals.get('__name__')"
        ],
        [
            "COMPARE_OP",
            "frame.f_globals.get('__name__') != '__main__'"
        ],
        [
            "LOAD_GLOBAL",
            "PY3"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._treetrace_hidden_with_stmt"
        ],
        [
            "LOAD_ATTR",
            "self._treetrace_hidden_with_stmt.__name__"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_globals"
        ],
        [
            "CONTAINS_OP",
            "self._treetrace_hidden_with_stmt.__name__ not in frame.f_globals"
        ],
        [
            "LOAD_GLOBAL",
            "RuntimeError"
        ],
        [
            "CALL",
            "RuntimeError(\n                    'To trace an imported module, you must import birdseye before '\n                    'importing that module.')"
        ],
        [
            "LOAD_GLOBAL",
            "read_source_file"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "CALL",
            "read_source_file(filename)"
        ],
        [
            "LOAD_METHOD",
            "read_source_file(filename).splitlines"
        ],
        [
            "CALL",
            "read_source_file(filename).splitlines()"
        ],
        [
            "STORE_FAST",
            "lines"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_lineno"
        ],
        [
            "BINARY_OP",
            "[''] * frame.f_lineno"
        ],
        [
            "LOAD_FAST",
            "lines"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_lineno"
        ],
        [
            "STORE_SUBSCR",
            "lines[:frame.f_lineno]"
        ],
        [
            "LOAD_METHOD",
            "'\\n'.join"
        ],
        [
            "LOAD_FAST",
            "lines"
        ],
        [
            "CALL",
            "'\\n'.join(lines)"
        ],
        [
            "STORE_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.exec_string"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_globals"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_locals"
        ],
        [
            "LOAD_FAST",
            "deep"
        ],
        [
            "CALL",
            "self.exec_string(source, filename, frame.f_globals, frame.f_locals, deep)"
        ],
        [
            "LOAD_GLOBAL",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.exit"
        ],
        [
            "CALL",
            "sys.exit(0)"
        ],
        [
            "LOAD_FAST",
            "globs"
        ],
        [
            "STORE_FAST",
            "globs"
        ],
        [
            "LOAD_FAST",
            "locs"
        ],
        [
            "STORE_FAST",
            "locs"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.compile"
        ],
        [
            "LOAD_DEREF",
            "source"
        ],
        [
            "LOAD_DEREF",
            "filename"
        ],
        [
            "CALL",
            "self.compile(source, filename)"
        ],
        [
            "STORE_DEREF",
            "traced_file"
        ],
        [
            "LOAD_FAST",
            "globs"
        ],
        [
            "LOAD_METHOD",
            "globs.update"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._trace_methods_dict"
        ],
        [
            "LOAD_DEREF",
            "traced_file"
        ],
        [
            "CALL",
            "self._trace_methods_dict(traced_file)"
        ],
        [
            "CALL",
            "globs.update(self._trace_methods_dict(traced_file))"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._trace"
        ],
        [
            "LOAD_GLOBAL",
            "FILE_SENTINEL_NAME"
        ],
        [
            "LOAD_DEREF",
            "filename"
        ],
        [
            "LOAD_DEREF",
            "traced_file"
        ],
        [
            "LOAD_DEREF",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.code"
        ],
        [
            "LOAD_DEREF",
            "source"
        ],
        [
            "CALL",
            "self._trace(FILE_SENTINEL_NAME, filename, traced_file, traced_file.code, 'module', source)"
        ],
        [
            "LOAD_FAST",
            "deep"
        ],
        [
            "LOAD_DEREF",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.nodes"
        ],
        [
            "CALL",
            "{\n                node.lineno: node\n                for node in traced_file.nodes\n                if isinstance(node, ast.FunctionDef)\n            }"
        ],
        [
            "STORE_DEREF",
            "nodes_by_lineno"
        ],
        [
            "STORE_DEREF",
            "            def find_code(root_code):\n                # type: (CodeType) -> None\n                for code in root_code.co_consts:  # type: CodeType\n                    if not inspect.iscode(code) or code.co_name.startswith('<'):\n                        continue\n\n                    find_code(code)\n\n                    lineno = code.co_firstlineno\n                    node = nodes_by_lineno.get(lineno)\n                    if not node:\n                        continue\n\n                    self._trace(\n                        code.co_name, filename, traced_file, code,\n                        typ='function',\n                        source=source,\n                        start_lineno=lineno,\n                        end_lineno=node.last_token.end[0] + 1,\n                    )"
        ],
        [
            "LOAD_DEREF",
            "find_code"
        ],
        [
            "LOAD_DEREF",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.code"
        ],
        [
            "CALL",
            "find_code(traced_file.code)"
        ],
        [
            "LOAD_GLOBAL",
            "exec"
        ],
        [
            "LOAD_DEREF",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.code"
        ],
        [
            "LOAD_FAST",
            "globs"
        ],
        [
            "LOAD_FAST",
            "locs"
        ],
        [
            "CALL",
            "exec(traced_file.code, globs, locs)"
        ],
        [
            "LOAD_FAST",
            "{\n                node.lineno: node\n                for node in traced_file.nodes\n                if isinstance(node, ast.FunctionDef)\n            }"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.FunctionDef"
        ],
        [
            "CALL",
            "isinstance(node, ast.FunctionDef)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.lineno"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "root_code"
        ],
        [
            "LOAD_ATTR",
            "root_code.co_consts"
        ],
        [
            "STORE_FAST",
            "code"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.iscode"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "CALL",
            "inspect.iscode(code)"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_name"
        ],
        [
            "LOAD_METHOD",
            "code.co_name.startswith"
        ],
        [
            "CALL",
            "code.co_name.startswith('<')"
        ],
        [
            "LOAD_DEREF",
            "find_code"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "CALL",
            "find_code(code)"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_firstlineno"
        ],
        [
            "STORE_FAST",
            "lineno"
        ],
        [
            "LOAD_DEREF",
            "nodes_by_lineno"
        ],
        [
            "LOAD_METHOD",
            "nodes_by_lineno.get"
        ],
        [
            "LOAD_FAST",
            "lineno"
        ],
        [
            "CALL",
            "nodes_by_lineno.get(lineno)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._trace"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_name"
        ],
        [
            "LOAD_DEREF",
            "filename"
        ],
        [
            "LOAD_DEREF",
            "traced_file"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_DEREF",
            "source"
        ],
        [
            "LOAD_FAST",
            "lineno"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.last_token"
        ],
        [
            "LOAD_ATTR",
            "node.last_token.end"
        ],
        [
            "BINARY_SUBSCR",
            "node.last_token.end[0]"
        ],
        [
            "BINARY_OP",
            "node.last_token.end[0] + 1"
        ],
        [
            "CALL",
            "self._trace(\n                        code.co_name, filename, traced_file, code,\n                        typ='function',\n                        source=source,\n                        start_lineno=lineno,\n                        end_lineno=node.last_token.end[0] + 1,\n                    )"
        ],
        [
            "LOAD_FAST",
            "end_lineno"
        ],
        [
            "LOAD_DEREF",
            "start_lineno"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_METHOD",
            "source.splitlines"
        ],
        [
            "CALL",
            "source.splitlines()"
        ],
        [
            "CALL",
            "len(source.splitlines())"
        ],
        [
            "BINARY_OP",
            "start_lineno + len(source.splitlines())"
        ],
        [
            "STORE_FAST",
            "end_lineno"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._nodes_of_interest"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_DEREF",
            "start_lineno"
        ],
        [
            "LOAD_FAST",
            "end_lineno"
        ],
        [
            "CALL",
            "self._nodes_of_interest(traced_file, start_lineno, end_lineno)"
        ],
        [
            "CALL",
            "list(self._nodes_of_interest(traced_file, start_lineno, end_lineno))"
        ],
        [
            "STORE_FAST",
            "nodes"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._nodes_html"
        ],
        [
            "LOAD_FAST",
            "nodes"
        ],
        [
            "LOAD_DEREF",
            "start_lineno"
        ],
        [
            "LOAD_FAST",
            "end_lineno"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "CALL",
            "self._nodes_html(nodes, start_lineno, end_lineno, traced_file)"
        ],
        [
            "STORE_FAST",
            "html_body"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_FAST",
            "nodes"
        ],
        [
            "CALL",
            "{\n                node._tree_index: [n._tree_index for n in node._loops]\n                for node, _ in nodes\n                if node._loops\n            }"
        ],
        [
            "CALL",
            "dict(\n            # This maps each node to the loops enclosing that node\n            node_loops={\n                node._tree_index: [n._tree_index for n in node._loops]\n                for node, _ in nodes\n                if node._loops\n            },\n        )"
        ],
        [
            "STORE_FAST",
            "data_dict"
        ],
        [
            "LOAD_FAST",
            "typ"
        ],
        [
            "COMPARE_OP",
            "typ == 'function'"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.tokens"
        ],
        [
            "STORE_FAST",
            "tokens"
        ],
        [
            "LOAD_GLOBAL",
            "only"
        ],
        [
            "LOAD_FAST",
            "nodes"
        ],
        [
            "CALL",
            "(node\n                             for node, _ in nodes\n                             if isinstance(node, ast.FunctionDef)\n                             and node.first_token.start[0] == start_lineno)"
        ],
        [
            "CALL",
            "only(node\n                             for node, _ in nodes\n                             if isinstance(node, ast.FunctionDef)\n                             and node.first_token.start[0] == start_lineno)"
        ],
        [
            "STORE_FAST",
            "func_node"
        ],
        [
            "LOAD_GLOBAL",
            "source_without_decorators"
        ],
        [
            "LOAD_FAST",
            "tokens"
        ],
        [
            "LOAD_FAST",
            "func_node"
        ],
        [
            "CALL",
            "source_without_decorators(tokens, func_node)"
        ],
        [
            "STORE_FAST",
            "func_startpos"
        ],
        [
            "STORE_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "data_dict"
        ],
        [
            "LOAD_METHOD",
            "data_dict.update"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._node_ranges"
        ],
        [
            "LOAD_FAST",
            "nodes"
        ],
        [
            "LOAD_FAST",
            "tokens"
        ],
        [
            "LOAD_FAST",
            "func_startpos"
        ],
        [
            "CALL",
            "self._node_ranges(nodes, tokens, func_startpos)"
        ],
        [
            "CALL",
            "list(self._node_ranges(nodes, tokens, func_startpos))"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._loop_ranges"
        ],
        [
            "LOAD_FAST",
            "nodes"
        ],
        [
            "LOAD_FAST",
            "tokens"
        ],
        [
            "LOAD_FAST",
            "func_startpos"
        ],
        [
            "CALL",
            "self._loop_ranges(nodes, tokens, func_startpos)"
        ],
        [
            "CALL",
            "list(self._loop_ranges(nodes, tokens, func_startpos))"
        ],
        [
            "CALL",
            "data_dict.update(\n                node_ranges=list(self._node_ranges(nodes, tokens, func_startpos)),\n                loop_ranges=list(self._loop_ranges(nodes, tokens, func_startpos)),\n            )"
        ],
        [
            "LOAD_GLOBAL",
            "json"
        ],
        [
            "LOAD_ATTR",
            "json.dumps"
        ],
        [
            "LOAD_FAST",
            "data_dict"
        ],
        [
            "CALL",
            "json.dumps(data_dict, sort_keys=True)"
        ],
        [
            "STORE_FAST",
            "data"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._db_func"
        ],
        [
            "LOAD_FAST",
            "data"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "html_body"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_DEREF",
            "start_lineno"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "typ"
        ],
        [
            "CALL",
            "self._db_func(data, filename, html_body, name, start_lineno, source, typ)"
        ],
        [
            "STORE_FAST",
            "db_func"
        ],
        [
            "LOAD_GLOBAL",
            "CodeInfo"
        ],
        [
            "LOAD_FAST",
            "db_func"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_FAST",
            "arg_names"
        ],
        [
            "CALL",
            "CodeInfo(db_func, traced_file, arg_names)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._code_infos"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "STORE_SUBSCR",
            "self._code_infos[code]"
        ],
        [
            "LOAD_FAST",
            "{\n                node._tree_index: [n._tree_index for n in node._loops]\n                for node, _ in nodes\n                if node._loops\n            }"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "STORE_FAST",
            "_"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._loops"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._tree_index"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._loops"
        ],
        [
            "CALL",
            "[n._tree_index for n in node._loops]"
        ],
        [
            "LOAD_FAST",
            "[n._tree_index for n in node._loops]"
        ],
        [
            "STORE_FAST",
            "n"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "LOAD_ATTR",
            "n._tree_index"
        ],
        [
            "LOAD_FAST",
            "(node\n                             for node, _ in nodes\n                             if isinstance(node, ast.FunctionDef)\n                             and node.first_token.start[0] == start_lineno)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "STORE_FAST",
            "_"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.FunctionDef"
        ],
        [
            "CALL",
            "isinstance(node, ast.FunctionDef)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.first_token"
        ],
        [
            "LOAD_ATTR",
            "node.first_token.start"
        ],
        [
            "BINARY_SUBSCR",
            "node.first_token.start[0]"
        ],
        [
            "LOAD_DEREF",
            "start_lineno"
        ],
        [
            "COMPARE_OP",
            "node.first_token.start[0] == start_lineno"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "nodes"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "STORE_FAST",
            "classes"
        ],
        [
            "STORE_FAST",
            "_"
        ],
        [
            "STORE_FAST",
            "__"
        ],
        [
            "LOAD_FAST",
            "classes"
        ],
        [
            "CONTAINS_OP",
            "'loop' not in classes"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.target"
        ],
        [
            "STORE_FAST",
            "target"
        ],
        [
            "LOAD_GLOBAL",
            "AttributeError"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.test"
        ],
        [
            "STORE_FAST",
            "target"
        ],
        [
            "LOAD_FAST",
            "tokens"
        ],
        [
            "LOAD_METHOD",
            "tokens.get_text_range"
        ],
        [
            "LOAD_FAST",
            "target"
        ],
        [
            "CALL",
            "tokens.get_text_range(target)"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "STORE_FAST",
            "end"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "func_start"
        ],
        [
            "BINARY_OP",
            "start -= func_start"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "end"
        ],
        [
            "LOAD_FAST",
            "func_start"
        ],
        [
            "BINARY_OP",
            "end -= func_start"
        ],
        [
            "STORE_FAST",
            "end"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._tree_index"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "end"
        ],
        [
            "CALL",
            "dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end\n            )"
        ],
        [
            "LOAD_FAST",
            "nodes"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "STORE_FAST",
            "classes"
        ],
        [
            "STORE_FAST",
            "_"
        ],
        [
            "STORE_FAST",
            "__"
        ],
        [
            "LOAD_FAST",
            "tokens"
        ],
        [
            "LOAD_METHOD",
            "tokens.get_text_range"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "tokens.get_text_range(node)"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "STORE_FAST",
            "end"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "func_start"
        ],
        [
            "BINARY_OP",
            "start -= func_start"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "end"
        ],
        [
            "LOAD_FAST",
            "func_start"
        ],
        [
            "BINARY_OP",
            "end -= func_start"
        ],
        [
            "STORE_FAST",
            "end"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "COMPARE_OP",
            "start < 0"
        ],
        [
            "LOAD_FAST",
            "end"
        ],
        [
            "COMPARE_OP",
            "end < 0"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.FunctionDef"
        ],
        [
            "CALL",
            "isinstance(node, ast.FunctionDef)"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._tree_index"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "end"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._depth"
        ],
        [
            "LOAD_FAST",
            "classes"
        ],
        [
            "CALL",
            "dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end,\n                depth=node._depth,\n                classes=classes,\n            )"
        ],
        [
            "STORE_FAST",
            "        def h(s):\n            return hashlib.sha256(s.encode('utf8')).hexdigest()"
        ],
        [
            "LOAD_FAST",
            "h"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "BINARY_OP",
            "filename + name"
        ],
        [
            "LOAD_FAST",
            "html_body"
        ],
        [
            "BINARY_OP",
            "filename + name + html_body"
        ],
        [
            "LOAD_FAST",
            "data"
        ],
        [
            "BINARY_OP",
            "filename + name + html_body + data"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_FAST",
            "start_lineno"
        ],
        [
            "CALL",
            "str(start_lineno)"
        ],
        [
            "BINARY_OP",
            "filename + name + html_body + data + str(start_lineno)"
        ],
        [
            "CALL",
            "h(filename + name + html_body + data + str(start_lineno))"
        ],
        [
            "STORE_FAST",
            "function_hash"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.db"
        ],
        [
            "LOAD_ATTR",
            "self.db.Function"
        ],
        [
            "STORE_FAST",
            "Function"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.db"
        ],
        [
            "LOAD_METHOD",
            "self.db.session_scope"
        ],
        [
            "CALL",
            "self.db.session_scope()"
        ],
        [
            "STORE_FAST",
            "session"
        ],
        [
            "LOAD_GLOBAL",
            "one_or_none"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "LOAD_FAST",
            "Function"
        ],
        [
            "CALL",
            "session.query(Function)"
        ],
        [
            "LOAD_METHOD",
            "session.query(Function).filter_by"
        ],
        [
            "LOAD_FAST",
            "function_hash"
        ],
        [
            "CALL",
            "session.query(Function).filter_by(hash=function_hash)"
        ],
        [
            "CALL",
            "one_or_none(session.query(Function).filter_by(hash=function_hash))"
        ],
        [
            "STORE_FAST",
            "db_func"
        ],
        [
            "LOAD_FAST",
            "db_func"
        ],
        [
            "LOAD_FAST",
            "Function"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "typ"
        ],
        [
            "LOAD_FAST",
            "html_body"
        ],
        [
            "LOAD_FAST",
            "start_lineno"
        ],
        [
            "LOAD_FAST",
            "data"
        ],
        [
            "LOAD_FAST",
            "h"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CALL",
            "h(source)"
        ],
        [
            "LOAD_FAST",
            "function_hash"
        ],
        [
            "CALL",
            "Function(file=filename,\n                                   name=name,\n                                   type=typ,\n                                   html_body=html_body,\n                                   lineno=start_lineno,\n                                   data=data,\n                                   body_hash=h(source),\n                                   hash=function_hash)"
        ],
        [
            "STORE_FAST",
            "db_func"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.add"
        ],
        [
            "LOAD_FAST",
            "db_func"
        ],
        [
            "CALL",
            "session.add(db_func)"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.commit"
        ],
        [
            "CALL",
            "session.commit()"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "db_func"
        ],
        [
            "LOAD_ATTR",
            "db_func.id"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "CALL",
            "isinstance(db_func.id, int)"
        ],
        [
            "LOAD_FAST",
            "db_func"
        ],
        [
            "LOAD_ATTR",
            "db_func.id"
        ],
        [
            "CALL",
            "        with self.db.session_scope() as session:\n            db_func = one_or_none(session.query(Function).filter_by(hash=function_hash))  # type: Optional[Function]\n            if not db_func:\n                db_func = Function(file=filename,\n                                   name=name,\n                                   type=typ,\n                                   html_body=html_body,\n                                   lineno=start_lineno,\n                                   data=data,\n                                   body_hash=h(source),\n                                   hash=function_hash)\n                session.add(db_func)\n                session.commit()  # ensure .id exists\n            assert isinstance(db_func.id, int)\n            return db_func.id"
        ],
        [
            "LOAD_GLOBAL",
            "hashlib"
        ],
        [
            "LOAD_ATTR",
            "hashlib.sha256"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_METHOD",
            "s.encode"
        ],
        [
            "CALL",
            "s.encode('utf8')"
        ],
        [
            "CALL",
            "hashlib.sha256(s.encode('utf8'))"
        ],
        [
            "LOAD_METHOD",
            "hashlib.sha256(s.encode('utf8')).hexdigest"
        ],
        [
            "CALL",
            "hashlib.sha256(s.encode('utf8')).hexdigest()"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.nodes"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "STORE_FAST",
            "classes"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.While"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.For"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.comprehension"
        ],
        [
            "CALL",
            "isinstance(node, (ast.While, ast.For, ast.comprehension))"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.GeneratorExp"
        ],
        [
            "CALL",
            "isinstance(node.parent, ast.GeneratorExp)"
        ],
        [
            "LOAD_FAST",
            "classes"
        ],
        [
            "LOAD_METHOD",
            "classes.append"
        ],
        [
            "CALL",
            "classes.append('loop')"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.stmt"
        ],
        [
            "CALL",
            "isinstance(node, ast.stmt)"
        ],
        [
            "LOAD_FAST",
            "classes"
        ],
        [
            "LOAD_METHOD",
            "classes.append"
        ],
        [
            "CALL",
            "classes.append('stmt')"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.expr"
        ],
        [
            "CALL",
            "isinstance(node, ast.expr)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._is_interesting_expression"
        ],
        [
            "LOAD_FAST",
            "classes"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.AST"
        ],
        [
            "CALL",
            "isinstance(node, ast.AST)"
        ],
        [
            "LOAD_GLOBAL",
            "hasattr"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "hasattr(node, 'first_token')"
        ],
        [
            "LOAD_FAST",
            "start_lineno"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.first_token"
        ],
        [
            "LOAD_ATTR",
            "node.first_token.start"
        ],
        [
            "BINARY_SUBSCR",
            "node.first_token.start[0]"
        ],
        [
            "COMPARE_OP",
            "            if not start_lineno <= node.first_token.start[0] <= end_lineno:\n                continue"
        ],
        [
            "LOAD_FAST",
            "end_lineno"
        ],
        [
            "COMPARE_OP",
            "            if not start_lineno <= node.first_token.start[0] <= end_lineno:\n                continue"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.tokens"
        ],
        [
            "LOAD_METHOD",
            "traced_file.tokens.get_text_range"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "traced_file.tokens.get_text_range(node)"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "STORE_FAST",
            "end"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "end"
        ],
        [
            "COMPARE_OP",
            "            if start == end == 0:\n                continue"
        ],
        [
            "COMPARE_OP",
            "            if start == end == 0:\n                continue"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "classes"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "end"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.root"
        ],
        [
            "STORE_ATTR",
            "traced_file.root._depth"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.walk"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.root"
        ],
        [
            "CALL",
            "ast.walk(traced_file.root)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.iter_child_nodes"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "ast.iter_child_nodes(node)"
        ],
        [
            "STORE_FAST",
            "child"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._depth"
        ],
        [
            "BINARY_OP",
            "node._depth + 1"
        ],
        [
            "LOAD_FAST",
            "child"
        ],
        [
            "STORE_ATTR",
            "child._depth"
        ],
        [
            "STORE_FAST",
            "positions"
        ],
        [
            "LOAD_FAST",
            "nodes"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "STORE_FAST",
            "classes"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "STORE_FAST",
            "end"
        ],
        [
            "LOAD_FAST",
            "positions"
        ],
        [
            "LOAD_METHOD",
            "positions.extend"
        ],
        [
            "LOAD_GLOBAL",
            "map"
        ],
        [
            "LOAD_GLOBAL",
            "HTMLPosition"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "end"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._depth"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._depth"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._tree_index"
        ],
        [
            "LOAD_METHOD",
            "' '.join"
        ],
        [
            "LOAD_FAST",
            "classes"
        ],
        [
            "CALL",
            "' '.join(classes)"
        ],
        [
            "BUILD_STRING",
            "'<span data-index=\"%s\" class=\"%s\">' % (node._tree_index, ' '.join(classes))"
        ],
        [
            "CALL",
            "map(\n                HTMLPosition,\n                [start, end],\n                [True, False],  # is_start\n                [node._depth, node._depth],\n                ['<span data-index=\"%s\" class=\"%s\">' % (node._tree_index, ' '.join(classes)),\n                 '</span>'])"
        ],
        [
            "CALL",
            "positions.extend(map(\n                HTMLPosition,\n                [start, end],\n                [True, False],  # is_start\n                [node._depth, node._depth],\n                ['<span data-index=\"%s\" class=\"%s\">' % (node._tree_index, ' '.join(classes)),\n                 '</span>']))"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._separate_comprehensions"
        ],
        [
            "LOAD_FAST",
            "nodes"
        ],
        [
            "CALL",
            "[n[0] for n in nodes]"
        ],
        [
            "LOAD_FAST",
            "end_lineno"
        ],
        [
            "LOAD_FAST",
            "positions"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "CALL",
            "self._separate_comprehensions(\n            [n[0] for n in nodes],\n            end_lineno, positions, traced_file)"
        ],
        [
            "STORE_FAST",
            "end_lineno"
        ],
        [
            "LOAD_FAST",
            "positions"
        ],
        [
            "LOAD_METHOD",
            "positions.append"
        ],
        [
            "LOAD_GLOBAL",
            "HTMLPosition"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.source"
        ],
        [
            "CALL",
            "len(traced_file.source)"
        ],
        [
            "CALL",
            "HTMLPosition(len(traced_file.source), False, 0, '')"
        ],
        [
            "CALL",
            "positions.append(HTMLPosition(len(traced_file.source), False, 0, ''))"
        ],
        [
            "LOAD_FAST",
            "positions"
        ],
        [
            "LOAD_METHOD",
            "positions.sort"
        ],
        [
            "CALL",
            "positions.sort()"
        ],
        [
            "STORE_FAST",
            "html_parts"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "positions"
        ],
        [
            "STORE_FAST",
            "position"
        ],
        [
            "LOAD_FAST",
            "html_parts"
        ],
        [
            "LOAD_METHOD",
            "html_parts.append"
        ],
        [
            "LOAD_GLOBAL",
            "html"
        ],
        [
            "LOAD_ATTR",
            "html.escape"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.source"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "position"
        ],
        [
            "LOAD_ATTR",
            "position.index"
        ],
        [
            "BINARY_SUBSCR",
            "traced_file.source[start:position.index]"
        ],
        [
            "CALL",
            "html.escape(traced_file.source[start:position.index])"
        ],
        [
            "CALL",
            "html_parts.append(html.escape(traced_file.source[start:position.index]))"
        ],
        [
            "LOAD_FAST",
            "html_parts"
        ],
        [
            "LOAD_METHOD",
            "html_parts.append"
        ],
        [
            "LOAD_FAST",
            "position"
        ],
        [
            "LOAD_ATTR",
            "position.html"
        ],
        [
            "CALL",
            "html_parts.append(position.html)"
        ],
        [
            "LOAD_FAST",
            "position"
        ],
        [
            "LOAD_ATTR",
            "position.index"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "LOAD_METHOD",
            "''.join"
        ],
        [
            "LOAD_FAST",
            "html_parts"
        ],
        [
            "CALL",
            "''.join(html_parts)"
        ],
        [
            "STORE_FAST",
            "html_body"
        ],
        [
            "LOAD_METHOD",
            "'\\n'.join"
        ],
        [
            "LOAD_FAST",
            "html_body"
        ],
        [
            "LOAD_METHOD",
            "html_body.split"
        ],
        [
            "CALL",
            "html_body.split('\\n')"
        ],
        [
            "LOAD_FAST",
            "start_lineno"
        ],
        [
            "BINARY_OP",
            "start_lineno - 1"
        ],
        [
            "LOAD_FAST",
            "end_lineno"
        ],
        [
            "BINARY_OP",
            "end_lineno - 1"
        ],
        [
            "BINARY_SUBSCR",
            "html_body.split('\\n')[start_lineno - 1:end_lineno - 1]"
        ],
        [
            "CALL",
            "'\\n'.join(html_body.split('\\n')[start_lineno - 1:end_lineno - 1])"
        ],
        [
            "STORE_FAST",
            "html_body"
        ],
        [
            "LOAD_FAST",
            "html_body"
        ],
        [
            "LOAD_METHOD",
            "html_body.strip"
        ],
        [
            "CALL",
            "html_body.strip('\\n')"
        ],
        [
            "LOAD_FAST",
            "[n[0] for n in nodes]"
        ],
        [
            "STORE_FAST",
            "n"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "BINARY_SUBSCR",
            "n[0]"
        ],
        [
            "LOAD_GLOBAL",
            "group_by_key_func"
        ],
        [
            "LOAD_GLOBAL",
            "of_type"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.comprehension"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.While"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.For"
        ],
        [
            "LOAD_FAST",
            "nodes"
        ],
        [
            "CALL",
            "of_type((ast.comprehension, ast.While, ast.For), nodes)"
        ],
        [
            "CALL",
            "group_by_key_func(of_type((ast.comprehension, ast.While, ast.For), nodes),\n                                           lambda c: c.first_token.start[0]\n                                           )"
        ],
        [
            "STORE_FAST",
            "comprehensions"
        ],
        [
            "STORE_FAST",
            "        def get_start(n):\n            # type: (ast.AST) -> int\n            return traced_file.tokens.get_text_range(n)[0]"
        ],
        [
            "LOAD_FAST",
            "comprehensions"
        ],
        [
            "LOAD_METHOD",
            "comprehensions.values"
        ],
        [
            "CALL",
            "comprehensions.values()"
        ],
        [
            "STORE_FAST",
            "comp_list"
        ],
        [
            "STORE_FAST",
            "prev_start"
        ],
        [
            "LOAD_GLOBAL",
            "sorted"
        ],
        [
            "LOAD_FAST",
            "comp_list"
        ],
        [
            "CALL",
            "sorted(comp_list, key=lambda c: c.first_token.startpos)"
        ],
        [
            "STORE_FAST",
            "comp"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "comp"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.comprehension"
        ],
        [
            "CALL",
            "isinstance(comp, ast.comprehension)"
        ],
        [
            "LOAD_FAST",
            "comp"
        ],
        [
            "LOAD_FAST",
            "comp"
        ],
        [
            "LOAD_ATTR",
            "comp.parent"
        ],
        [
            "LOAD_ATTR",
            "comp.parent.generators"
        ],
        [
            "BINARY_SUBSCR",
            "comp.parent.generators[0]"
        ],
        [
            "IS_OP",
            "comp is comp.parent.generators[0]"
        ],
        [
            "LOAD_FAST",
            "get_start"
        ],
        [
            "LOAD_FAST",
            "comp"
        ],
        [
            "LOAD_ATTR",
            "comp.parent"
        ],
        [
            "CALL",
            "get_start(comp.parent)"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "prev_start"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "prev_start"
        ],
        [
            "COMPARE_OP",
            "start < prev_start"
        ],
        [
            "LOAD_FAST",
            "get_start"
        ],
        [
            "LOAD_FAST",
            "comp"
        ],
        [
            "CALL",
            "get_start(comp)"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "get_start"
        ],
        [
            "LOAD_FAST",
            "comp"
        ],
        [
            "CALL",
            "get_start(comp)"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "prev_start"
        ],
        [
            "LOAD_FAST",
            "positions"
        ],
        [
            "LOAD_METHOD",
            "positions.append"
        ],
        [
            "LOAD_GLOBAL",
            "HTMLPosition"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "CALL",
            "HTMLPosition(start, True, 0, '\\n ')"
        ],
        [
            "CALL",
            "positions.append(HTMLPosition(start, True, 0, '\\n '))"
        ],
        [
            "LOAD_FAST",
            "end_lineno"
        ],
        [
            "BINARY_OP",
            "end_lineno += 1"
        ],
        [
            "STORE_FAST",
            "end_lineno"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "STORE_FAST",
            "prev_start"
        ],
        [
            "LOAD_FAST",
            "end_lineno"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_ATTR",
            "c.first_token"
        ],
        [
            "LOAD_ATTR",
            "c.first_token.start"
        ],
        [
            "BINARY_SUBSCR",
            "c.first_token.start[0]"
        ],
        [
            "LOAD_DEREF",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.tokens"
        ],
        [
            "LOAD_METHOD",
            "traced_file.tokens.get_text_range"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "CALL",
            "traced_file.tokens.get_text_range(n)"
        ],
        [
            "BINARY_SUBSCR",
            "traced_file.tokens.get_text_range(n)[0]"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_ATTR",
            "c.first_token"
        ],
        [
            "LOAD_ATTR",
            "c.first_token.startpos"
        ],
        [
            "LOAD_GLOBAL",
            "defaultdict"
        ],
        [
            "LOAD_GLOBAL",
            "_deep_dict"
        ],
        [
            "CALL",
            "defaultdict(_deep_dict)"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_GLOBAL",
            "_bad_codes"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code in _bad_codes"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_back"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "STORE_NAME",
            "\"\"\"\n    Corresponds to an iteration of a loop during a call, OR\n    the call itself (FrameInfo.iteration).\n    \"\"\""
        ],
        [
            "STORE_NAME",
            "    def __init__(self):\n        # Mapping of nodes (via node._tree_index) to the value of that\n        # node in this iteration. Only contains nodes within the corresponding\n        # loop or at the top of the function, but not in loops further within\n        # (those will be somewhere within self.loops)\n        # Therefore those nodes have at most one value.\n        self.vals = {}  # type: Dict[int, NodeValue]\n\n        # Mapping of loop nodes (via node._tree_index) to IterationLists\n        # for loops that happened during this iteration\n        self.loops = defaultdict(IterationList)  # type: Dict[int, IterationList]\n\n        # 0-based index of this iteration\n        self.index = None  # type: int\n        self.keep = False"
        ],
        [
            "STORE_NAME",
            "    def extract_iterations(self):\n        # type: () -> Dict[str, Union[int, Dict]]\n        return {\n            'index': self.index,\n            'loops': {\n                tree_index: [iteration.extract_iterations()\n                             for iteration in iteration_list]\n                for tree_index, iteration_list in self.loops.items()\n            }\n        }"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.vals"
        ],
        [
            "LOAD_GLOBAL",
            "defaultdict"
        ],
        [
            "LOAD_GLOBAL",
            "IterationList"
        ],
        [
            "CALL",
            "defaultdict(IterationList)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.loops"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.index"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.keep"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.index"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.loops"
        ],
        [
            "LOAD_METHOD",
            "self.loops.items"
        ],
        [
            "CALL",
            "self.loops.items()"
        ],
        [
            "CALL",
            "{\n                tree_index: [iteration.extract_iterations()\n                             for iteration in iteration_list]\n                for tree_index, iteration_list in self.loops.items()\n            }"
        ],
        [
            "LOAD_FAST",
            "{\n                tree_index: [iteration.extract_iterations()\n                             for iteration in iteration_list]\n                for tree_index, iteration_list in self.loops.items()\n            }"
        ],
        [
            "STORE_FAST",
            "tree_index"
        ],
        [
            "STORE_FAST",
            "iteration_list"
        ],
        [
            "LOAD_FAST",
            "tree_index"
        ],
        [
            "LOAD_FAST",
            "iteration_list"
        ],
        [
            "CALL",
            "[iteration.extract_iterations()\n                             for iteration in iteration_list]"
        ],
        [
            "LOAD_FAST",
            "[iteration.extract_iterations()\n                             for iteration in iteration_list]"
        ],
        [
            "STORE_FAST",
            "iteration"
        ],
        [
            "LOAD_FAST",
            "iteration"
        ],
        [
            "LOAD_METHOD",
            "iteration.extract_iterations"
        ],
        [
            "CALL",
            "iteration.extract_iterations()"
        ],
        [
            "STORE_NAME",
            "\"\"\"\n    A list of Iterations, corresponding to a run of a loop.\n    If the loop has many iterations, only contains the first and last few\n    and any in the middle where unique nodes had values, so that\n    any node which appeared during this loop exists in at least some iterations.\n    \"\"\""
        ],
        [
            "STORE_NAME",
            "side_len"
        ],
        [
            "STORE_NAME",
            "    def __init__(self):\n        # Contains the first few iterations\n        # and any after that have unique nodes in them\n        self.start = []  # type: List[Iteration]\n\n        # Contains the last few iterations\n        self.end = deque(maxlen=self.side_len)  # type: Deque[Iteration]\n\n        # Total number of iterations in the loop, not all of which\n        # are kept\n        self.length = 0  # type: int\n\n        # Number of times each node has been recorded in this loop\n        self.recorded = Counter()"
        ],
        [
            "STORE_NAME",
            "    def append(self, iteration):\n        # type: (Iteration) -> None\n        if self.length < self.side_len:\n            self.start.append(iteration)\n        else:\n            # If self.end is too long, the first element self.end[0]\n            # is about to be dropped by the deque. If that iteration\n            # should be kept because of some node that was recorded,\n            # add it to self.start\n            if len(self.end) >= self.side_len and self.end[0].keep:\n                self.start.append(self.end[0])\n\n            self.end.append(iteration)\n        iteration.index = self.length\n        self.length += 1"
        ],
        [
            "STORE_NAME",
            "    def __iter__(self):\n        # type: () -> Iterator[Iteration]\n        return chain(self.start, self.end)"
        ],
        [
            "STORE_NAME",
            "    def last(self):\n        # type: () -> Iteration\n        if self.end:\n            return self.end[-1]\n        else:\n            return self.start[-1]"
        ],
        [
            "STORE_NAME",
            "    def recorded_node(self, node):\n        # type: (ast.AST) -> None\n        if self.recorded[node] >= 2:\n            # We've already seen this node enough\n            return\n\n        # This node is new(ish), make sure we keep this iteration\n        self.last().keep = True\n        self.recorded[node] += 1"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.start"
        ],
        [
            "LOAD_GLOBAL",
            "deque"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.side_len"
        ],
        [
            "CALL",
            "deque(maxlen=self.side_len)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.end"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.length"
        ],
        [
            "LOAD_GLOBAL",
            "Counter"
        ],
        [
            "CALL",
            "Counter()"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.recorded"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.length"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.side_len"
        ],
        [
            "COMPARE_OP",
            "self.length < self.side_len"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.start"
        ],
        [
            "LOAD_METHOD",
            "self.start.append"
        ],
        [
            "LOAD_FAST",
            "iteration"
        ],
        [
            "CALL",
            "self.start.append(iteration)"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.end"
        ],
        [
            "CALL",
            "len(self.end)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.side_len"
        ],
        [
            "COMPARE_OP",
            "len(self.end) >= self.side_len"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.end"
        ],
        [
            "BINARY_SUBSCR",
            "self.end[0]"
        ],
        [
            "LOAD_ATTR",
            "self.end[0].keep"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.start"
        ],
        [
            "LOAD_METHOD",
            "self.start.append"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.end"
        ],
        [
            "BINARY_SUBSCR",
            "self.end[0]"
        ],
        [
            "CALL",
            "self.start.append(self.end[0])"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.end"
        ],
        [
            "LOAD_METHOD",
            "self.end.append"
        ],
        [
            "LOAD_FAST",
            "iteration"
        ],
        [
            "CALL",
            "self.end.append(iteration)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.length"
        ],
        [
            "LOAD_FAST",
            "iteration"
        ],
        [
            "STORE_ATTR",
            "iteration.index"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.length"
        ],
        [
            "BINARY_OP",
            "self.length += 1"
        ],
        [
            "STORE_ATTR",
            "self.length"
        ],
        [
            "LOAD_GLOBAL",
            "chain"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.start"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.end"
        ],
        [
            "CALL",
            "chain(self.start, self.end)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.end"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.end"
        ],
        [
            "BINARY_SUBSCR",
            "self.end[-1]"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.start"
        ],
        [
            "BINARY_SUBSCR",
            "self.start[-1]"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.recorded"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "BINARY_SUBSCR",
            "self.recorded[node]"
        ],
        [
            "COMPARE_OP",
            "self.recorded[node] >= 2"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.last"
        ],
        [
            "CALL",
            "self.last()"
        ],
        [
            "STORE_ATTR",
            "self.last().keep"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.recorded"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "BINARY_SUBSCR",
            "self.recorded[node]"
        ],
        [
            "BINARY_OP",
            "self.recorded[node] += 1"
        ],
        [
            "STORE_SUBSCR",
            "self.recorded[node]"
        ],
        [
            "LOAD_NAME",
            "type"
        ],
        [
            "CALL",
            "type(None)"
        ],
        [
            "LOAD_NAME",
            "bool"
        ],
        [
            "LOAD_NAME",
            "int"
        ],
        [
            "LOAD_NAME",
            "float"
        ],
        [
            "LOAD_NAME",
            "complex"
        ],
        [
            "STORE_NAME",
            "basic_types"
        ],
        [
            "LOAD_NAME",
            "PY2"
        ],
        [
            "LOAD_NAME",
            "basic_types"
        ],
        [
            "LOAD_NAME",
            "long"
        ],
        [
            "BINARY_OP",
            "basic_types += (long,)"
        ],
        [
            "STORE_NAME",
            "basic_types"
        ],
        [
            "LOAD_NAME",
            "basic_types"
        ],
        [
            "LOAD_NAME",
            "list"
        ],
        [
            "LOAD_NAME",
            "dict"
        ],
        [
            "LOAD_NAME",
            "tuple"
        ],
        [
            "LOAD_NAME",
            "set"
        ],
        [
            "LOAD_NAME",
            "frozenset"
        ],
        [
            "LOAD_NAME",
            "str"
        ],
        [
            "BINARY_OP",
            "basic_types + (list, dict, tuple, set, frozenset, str)"
        ],
        [
            "STORE_NAME",
            "special_types"
        ],
        [
            "LOAD_NAME",
            "PY2"
        ],
        [
            "LOAD_NAME",
            "special_types"
        ],
        [
            "LOAD_NAME",
            "PY2"
        ],
        [
            "LOAD_NAME",
            "unicode"
        ],
        [
            "LOAD_NAME",
            "bytes"
        ],
        [
            "BINARY_OP",
            "special_types += (unicode if PY2 else bytes,)"
        ],
        [
            "STORE_NAME",
            "special_types"
        ],
        [
            "LOAD_NAME",
            "len"
        ],
        [
            "LOAD_NAME",
            "special_types"
        ],
        [
            "CALL",
            "len(special_types)"
        ],
        [
            "STORE_NAME",
            "num_special_types"
        ],
        [
            "STORE_NAME",
            "    def __init__(self):\n        self.lock = Lock()\n        self.data = defaultdict(lambda: len(self.data))  # type: Dict[type, int]\n\n        for t in self.special_types:\n            _ = self.data[t]"
        ],
        [
            "STORE_NAME",
            "    def __getitem__(self, item):\n        t = correct_type(item)\n        with self.lock:\n            return self.data[t]"
        ],
        [
            "STORE_NAME",
            "    def names(self):\n        # type: () -> List[str]\n        rev = dict((v, k) for k, v in self.data.items())\n        return [safe_qualname(rev[i]) for i in range(len(rev))]"
        ],
        [
            "LOAD_GLOBAL",
            "Lock"
        ],
        [
            "CALL",
            "Lock()"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.lock"
        ],
        [
            "LOAD_GLOBAL",
            "defaultdict"
        ],
        [
            "CALL",
            "defaultdict(lambda: len(self.data))"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.data"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.special_types"
        ],
        [
            "STORE_FAST",
            "t"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.data"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "BINARY_SUBSCR",
            "self.data[t]"
        ],
        [
            "STORE_FAST",
            "_"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.data"
        ],
        [
            "CALL",
            "len(self.data)"
        ],
        [
            "LOAD_GLOBAL",
            "correct_type"
        ],
        [
            "LOAD_FAST",
            "item"
        ],
        [
            "CALL",
            "correct_type(item)"
        ],
        [
            "STORE_FAST",
            "t"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.lock"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.data"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "BINARY_SUBSCR",
            "self.data[t]"
        ],
        [
            "CALL",
            "        with self.lock:\n            return self.data[t]"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.data"
        ],
        [
            "LOAD_METHOD",
            "self.data.items"
        ],
        [
            "CALL",
            "self.data.items()"
        ],
        [
            "CALL",
            "((v, k) for k, v in self.data.items())"
        ],
        [
            "CALL",
            "dict((v, k) for k, v in self.data.items())"
        ],
        [
            "STORE_DEREF",
            "rev"
        ],
        [
            "LOAD_GLOBAL",
            "range"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_DEREF",
            "rev"
        ],
        [
            "CALL",
            "len(rev)"
        ],
        [
            "CALL",
            "range(len(rev))"
        ],
        [
            "CALL",
            "[safe_qualname(rev[i]) for i in range(len(rev))]"
        ],
        [
            "LOAD_FAST",
            "((v, k) for k, v in self.data.items())"
        ],
        [
            "STORE_FAST",
            "k"
        ],
        [
            "STORE_FAST",
            "v"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "LOAD_FAST",
            "k"
        ],
        [
            "LOAD_FAST",
            "[safe_qualname(rev[i]) for i in range(len(rev))]"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "LOAD_GLOBAL",
            "safe_qualname"
        ],
        [
            "LOAD_DEREF",
            "rev"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_SUBSCR",
            "rev[i]"
        ],
        [
            "CALL",
            "safe_qualname(rev[i])"
        ],
        [
            "STORE_NAME",
            "\"\"\"\n    The 'value' of a node during a particular iteration.\n    This can mean different things, see the classmethods.\n    Can also contain some metadata, including links to other calls.\n    \"\"\""
        ],
        [
            "STORE_NAME",
            "__slots__"
        ],
        [
            "STORE_NAME",
            "    def __init__(self, val_repr, type_index):\n        self.val_repr = val_repr  # type: str\n        self.type_index = type_index  # type: int\n        self.meta = None  # type: Optional[Dict[str, Any]]\n        self.children = None"
        ],
        [
            "STORE_NAME",
            "    def set_meta(self, key, value):\n        # type: (str, Any) -> None\n        self.meta = self.meta or {}\n        self.meta[key] = value"
        ],
        [
            "STORE_NAME",
            "    def add_child(self, samples, level, key, value):\n        # type: (dict, int, str, Any) -> None\n        self.children = self.children or []\n        self.children.append((key, NodeValue.expression(samples, value, level)))"
        ],
        [
            "STORE_NAME",
            "    def as_json(self):\n        result = [self.val_repr, self.type_index, self.meta or {}]  # type: list\n        if self.children:\n            result.extend(self.children)\n        return result"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def covered(cls):\n        \"\"\"\n        Represents a bit of code, usually a statement, that executed successfully but\n        doesn't have an actual value.\n        \"\"\"\n        return cls('', -2)"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def exception(cls, exc_value):\n        \"\"\"\n        Means that exc_value was raised by a node when executing, and not any inner node.\n        \"\"\"\n        return cls(exception_string(exc_value), -1)"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def expression(cls, samples, val, level):\n        # type: (dict, Any, int) -> NodeValue\n        \"\"\"\n        The value of an expression or one of its children, with attributes,\n        dictionary items, etc as children. Has a max depth of `level` levels.\n        \"\"\"\n        result = cls(cheap_repr(val), type_registry[val])\n        if isinstance(val, (TypeRegistry.basic_types, BirdsEye)):\n            return result\n\n        length = None\n        if not isinstance(val, QuerySet):  # len triggers a database query\n            try:\n                length = len(val)\n            except:\n                pass\n            else:\n                result.set_meta('len', length)\n\n        if isinstance(val, ModuleType):\n            level = min(level, 2)\n\n        add_child = partial(result.add_child, samples, level - 1)\n\n        if isinstance(val, (Series, ndarray)):\n            attrs = ['dtype']\n            if isinstance(val, ndarray):\n                attrs.append('shape')\n            for name in attrs:\n                try:\n                    attr = getattr(val, name)\n                except AttributeError:\n                    pass\n                else:\n                    add_child(name, attr)\n\n        if level >= 3 or level >= 2 and isinstance(val, Series):\n            sample_type = 'big'\n        else:\n            sample_type = 'small'\n\n        samples = samples[sample_type]\n\n        # Always expand DataFrames and Series regardless of level to\n        # make the table view of DataFrames work\n\n        if isinstance(val, DataFrame):\n            meta = {}\n            result.set_meta('dataframe', meta)\n\n            max_rows = samples['pandas_rows']\n            max_cols = samples['pandas_cols']\n\n            if length > max_rows + 2:\n                meta['row_break'] = max_rows // 2\n\n            columns = val.columns\n            num_cols = len(columns)\n            if num_cols > max_cols + 2:\n                meta['col_break'] = max_cols // 2\n\n            indices = set(_sample_indices(num_cols, max_cols))\n            for i, (formatted_name, label) in enumerate(zip(val.columns.format(sparsify=False),\n                                                            val.columns)):\n                if i in indices:\n                    add_child(formatted_name, val[label])\n\n            return result\n\n        if isinstance(val, Series):\n            for i in _sample_indices(length, samples['pandas_rows']):\n                try:\n                    k = val.index[i:i + 1].format(sparsify=False)[0]\n                    v = val.iloc[i]\n                except:\n                    pass\n                else:\n                    add_child(k, v)\n            return result\n\n        if (level <= 0 or\n                isinstance(val,\n                           (str, bytes, range)\n                           if PY3 else\n                           (str, unicode, xrange))):\n            return result\n\n        if isinstance(val, (Sequence, ndarray)) and length is not None:\n            for i in _sample_indices(length, samples['list']):\n                try:\n                    v = val[i]\n                except:\n                    pass\n                else:\n                    add_child(str(i), v)\n\n        if isinstance(val, Mapping):\n            for k, v in islice(_safe_iter(val, iteritems), samples['dict']):\n                add_child(cheap_repr(k), v)\n\n        if isinstance(val, Set):\n            vals = _safe_iter(val)\n            num_items = samples['set']\n            if length is None or length > num_items + 2:\n                vals = islice(vals, num_items)\n            for i, v in enumerate(vals):\n                add_child('<%s>' % i, v)\n\n        d = getattr(val, '__dict__', None)\n        if d:\n            for k in sorted(islice(_safe_iter(d),\n                                   samples['attributes']),\n                            key=str):\n                v = d[k]\n                if isinstance(v, TracedFile):\n                    continue\n                add_child(str(k), v)\n        else:\n            for s in sorted(getattr(type(val), '__slots__', None) or ()):\n                try:\n                    attr = getattr(val, s)\n                except AttributeError:\n                    pass\n                else:\n                    add_child(str(s), attr)\n        return result"
        ],
        [
            "LOAD_FAST",
            "val_repr"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.val_repr"
        ],
        [
            "LOAD_FAST",
            "type_index"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.type_index"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.meta"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.children"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.meta"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.meta"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.meta"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "STORE_SUBSCR",
            "self.meta[key]"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.children"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.children"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.children"
        ],
        [
            "LOAD_METHOD",
            "self.children.append"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "LOAD_GLOBAL",
            "NodeValue"
        ],
        [
            "LOAD_METHOD",
            "NodeValue.expression"
        ],
        [
            "LOAD_FAST",
            "samples"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "level"
        ],
        [
            "CALL",
            "NodeValue.expression(samples, value, level)"
        ],
        [
            "CALL",
            "self.children.append((key, NodeValue.expression(samples, value, level)))"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.val_repr"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.type_index"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.meta"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.children"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_METHOD",
            "result.extend"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.children"
        ],
        [
            "CALL",
            "result.extend(self.children)"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "CALL",
            "cls('', -2)"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_GLOBAL",
            "exception_string"
        ],
        [
            "LOAD_FAST",
            "exc_value"
        ],
        [
            "CALL",
            "exception_string(exc_value)"
        ],
        [
            "CALL",
            "cls(exception_string(exc_value), -1)"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_GLOBAL",
            "cheap_repr"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "CALL",
            "cheap_repr(val)"
        ],
        [
            "LOAD_GLOBAL",
            "type_registry"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "BINARY_SUBSCR",
            "type_registry[val]"
        ],
        [
            "CALL",
            "cls(cheap_repr(val), type_registry[val])"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_GLOBAL",
            "TypeRegistry"
        ],
        [
            "LOAD_ATTR",
            "TypeRegistry.basic_types"
        ],
        [
            "LOAD_GLOBAL",
            "BirdsEye"
        ],
        [
            "CALL",
            "isinstance(val, (TypeRegistry.basic_types, BirdsEye))"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "STORE_FAST",
            "length"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_GLOBAL",
            "QuerySet"
        ],
        [
            "CALL",
            "isinstance(val, QuerySet)"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "CALL",
            "len(val)"
        ],
        [
            "STORE_FAST",
            "length"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_METHOD",
            "result.set_meta"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "CALL",
            "result.set_meta('len', length)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_GLOBAL",
            "ModuleType"
        ],
        [
            "CALL",
            "isinstance(val, ModuleType)"
        ],
        [
            "LOAD_GLOBAL",
            "min"
        ],
        [
            "LOAD_FAST",
            "level"
        ],
        [
            "CALL",
            "min(level, 2)"
        ],
        [
            "STORE_FAST",
            "level"
        ],
        [
            "LOAD_GLOBAL",
            "partial"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_ATTR",
            "result.add_child"
        ],
        [
            "LOAD_FAST",
            "samples"
        ],
        [
            "LOAD_FAST",
            "level"
        ],
        [
            "BINARY_OP",
            "level - 1"
        ],
        [
            "CALL",
            "partial(result.add_child, samples, level - 1)"
        ],
        [
            "STORE_FAST",
            "add_child"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_GLOBAL",
            "Series"
        ],
        [
            "LOAD_GLOBAL",
            "ndarray"
        ],
        [
            "CALL",
            "isinstance(val, (Series, ndarray))"
        ],
        [
            "STORE_FAST",
            "attrs"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_GLOBAL",
            "ndarray"
        ],
        [
            "CALL",
            "isinstance(val, ndarray)"
        ],
        [
            "LOAD_FAST",
            "attrs"
        ],
        [
            "LOAD_METHOD",
            "attrs.append"
        ],
        [
            "CALL",
            "attrs.append('shape')"
        ],
        [
            "LOAD_FAST",
            "attrs"
        ],
        [
            "STORE_FAST",
            "name"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "CALL",
            "getattr(val, name)"
        ],
        [
            "STORE_FAST",
            "attr"
        ],
        [
            "LOAD_FAST",
            "add_child"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "attr"
        ],
        [
            "CALL",
            "add_child(name, attr)"
        ],
        [
            "LOAD_GLOBAL",
            "AttributeError"
        ],
        [
            "LOAD_FAST",
            "level"
        ],
        [
            "COMPARE_OP",
            "level >= 3"
        ],
        [
            "LOAD_FAST",
            "level"
        ],
        [
            "COMPARE_OP",
            "level >= 2"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_GLOBAL",
            "Series"
        ],
        [
            "CALL",
            "isinstance(val, Series)"
        ],
        [
            "STORE_FAST",
            "sample_type"
        ],
        [
            "STORE_FAST",
            "sample_type"
        ],
        [
            "LOAD_FAST",
            "samples"
        ],
        [
            "LOAD_FAST",
            "sample_type"
        ],
        [
            "BINARY_SUBSCR",
            "samples[sample_type]"
        ],
        [
            "STORE_FAST",
            "samples"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_GLOBAL",
            "DataFrame"
        ],
        [
            "CALL",
            "isinstance(val, DataFrame)"
        ],
        [
            "STORE_FAST",
            "meta"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_METHOD",
            "result.set_meta"
        ],
        [
            "LOAD_FAST",
            "meta"
        ],
        [
            "CALL",
            "result.set_meta('dataframe', meta)"
        ],
        [
            "LOAD_FAST",
            "samples"
        ],
        [
            "BINARY_SUBSCR",
            "samples['pandas_rows']"
        ],
        [
            "STORE_FAST",
            "max_rows"
        ],
        [
            "LOAD_FAST",
            "samples"
        ],
        [
            "BINARY_SUBSCR",
            "samples['pandas_cols']"
        ],
        [
            "STORE_FAST",
            "max_cols"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "LOAD_FAST",
            "max_rows"
        ],
        [
            "BINARY_OP",
            "max_rows + 2"
        ],
        [
            "COMPARE_OP",
            "length > max_rows + 2"
        ],
        [
            "LOAD_FAST",
            "max_rows"
        ],
        [
            "BINARY_OP",
            "max_rows // 2"
        ],
        [
            "LOAD_FAST",
            "meta"
        ],
        [
            "STORE_SUBSCR",
            "meta['row_break']"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_ATTR",
            "val.columns"
        ],
        [
            "STORE_FAST",
            "columns"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "columns"
        ],
        [
            "CALL",
            "len(columns)"
        ],
        [
            "STORE_FAST",
            "num_cols"
        ],
        [
            "LOAD_FAST",
            "num_cols"
        ],
        [
            "LOAD_FAST",
            "max_cols"
        ],
        [
            "BINARY_OP",
            "max_cols + 2"
        ],
        [
            "COMPARE_OP",
            "num_cols > max_cols + 2"
        ],
        [
            "LOAD_FAST",
            "max_cols"
        ],
        [
            "BINARY_OP",
            "max_cols // 2"
        ],
        [
            "LOAD_FAST",
            "meta"
        ],
        [
            "STORE_SUBSCR",
            "meta['col_break']"
        ],
        [
            "LOAD_GLOBAL",
            "set"
        ],
        [
            "LOAD_GLOBAL",
            "_sample_indices"
        ],
        [
            "LOAD_FAST",
            "num_cols"
        ],
        [
            "LOAD_FAST",
            "max_cols"
        ],
        [
            "CALL",
            "_sample_indices(num_cols, max_cols)"
        ],
        [
            "CALL",
            "set(_sample_indices(num_cols, max_cols))"
        ],
        [
            "STORE_FAST",
            "indices"
        ],
        [
            "LOAD_GLOBAL",
            "enumerate"
        ],
        [
            "LOAD_GLOBAL",
            "zip"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_ATTR",
            "val.columns"
        ],
        [
            "LOAD_METHOD",
            "val.columns.format"
        ],
        [
            "CALL",
            "val.columns.format(sparsify=False)"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_ATTR",
            "val.columns"
        ],
        [
            "CALL",
            "zip(val.columns.format(sparsify=False),\n                                                            val.columns)"
        ],
        [
            "CALL",
            "enumerate(zip(val.columns.format(sparsify=False),\n                                                            val.columns))"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "STORE_FAST",
            "formatted_name"
        ],
        [
            "STORE_FAST",
            "label"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "indices"
        ],
        [
            "CONTAINS_OP",
            "i in indices"
        ],
        [
            "LOAD_FAST",
            "add_child"
        ],
        [
            "LOAD_FAST",
            "formatted_name"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_FAST",
            "label"
        ],
        [
            "BINARY_SUBSCR",
            "val[label]"
        ],
        [
            "CALL",
            "add_child(formatted_name, val[label])"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_GLOBAL",
            "Series"
        ],
        [
            "CALL",
            "isinstance(val, Series)"
        ],
        [
            "LOAD_GLOBAL",
            "_sample_indices"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "LOAD_FAST",
            "samples"
        ],
        [
            "BINARY_SUBSCR",
            "samples['pandas_rows']"
        ],
        [
            "CALL",
            "_sample_indices(length, samples['pandas_rows'])"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_ATTR",
            "val.index"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_OP",
            "i + 1"
        ],
        [
            "BINARY_SUBSCR",
            "val.index[i:i + 1]"
        ],
        [
            "LOAD_METHOD",
            "val.index[i:i + 1].format"
        ],
        [
            "CALL",
            "val.index[i:i + 1].format(sparsify=False)"
        ],
        [
            "BINARY_SUBSCR",
            "val.index[i:i + 1].format(sparsify=False)[0]"
        ],
        [
            "STORE_FAST",
            "k"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_ATTR",
            "val.iloc"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_SUBSCR",
            "val.iloc[i]"
        ],
        [
            "STORE_FAST",
            "v"
        ],
        [
            "LOAD_FAST",
            "add_child"
        ],
        [
            "LOAD_FAST",
            "k"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "CALL",
            "add_child(k, v)"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "level"
        ],
        [
            "COMPARE_OP",
            "level <= 0"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_GLOBAL",
            "PY3"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_GLOBAL",
            "bytes"
        ],
        [
            "LOAD_GLOBAL",
            "range"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_GLOBAL",
            "unicode"
        ],
        [
            "LOAD_GLOBAL",
            "xrange"
        ],
        [
            "CALL",
            "isinstance(val,\n                           (str, bytes, range)\n                           if PY3 else\n                           (str, unicode, xrange))"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_GLOBAL",
            "Sequence"
        ],
        [
            "LOAD_GLOBAL",
            "ndarray"
        ],
        [
            "CALL",
            "isinstance(val, (Sequence, ndarray))"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "LOAD_GLOBAL",
            "_sample_indices"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "LOAD_FAST",
            "samples"
        ],
        [
            "BINARY_SUBSCR",
            "samples['list']"
        ],
        [
            "CALL",
            "_sample_indices(length, samples['list'])"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_SUBSCR",
            "val[i]"
        ],
        [
            "STORE_FAST",
            "v"
        ],
        [
            "LOAD_FAST",
            "add_child"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "CALL",
            "str(i)"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "CALL",
            "add_child(str(i), v)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_GLOBAL",
            "Mapping"
        ],
        [
            "CALL",
            "isinstance(val, Mapping)"
        ],
        [
            "LOAD_GLOBAL",
            "islice"
        ],
        [
            "LOAD_GLOBAL",
            "_safe_iter"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_GLOBAL",
            "iteritems"
        ],
        [
            "CALL",
            "_safe_iter(val, iteritems)"
        ],
        [
            "LOAD_FAST",
            "samples"
        ],
        [
            "BINARY_SUBSCR",
            "samples['dict']"
        ],
        [
            "CALL",
            "islice(_safe_iter(val, iteritems), samples['dict'])"
        ],
        [
            "STORE_FAST",
            "k"
        ],
        [
            "STORE_FAST",
            "v"
        ],
        [
            "LOAD_FAST",
            "add_child"
        ],
        [
            "LOAD_GLOBAL",
            "cheap_repr"
        ],
        [
            "LOAD_FAST",
            "k"
        ],
        [
            "CALL",
            "cheap_repr(k)"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "CALL",
            "add_child(cheap_repr(k), v)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_GLOBAL",
            "Set"
        ],
        [
            "CALL",
            "isinstance(val, Set)"
        ],
        [
            "LOAD_GLOBAL",
            "_safe_iter"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "CALL",
            "_safe_iter(val)"
        ],
        [
            "STORE_FAST",
            "vals"
        ],
        [
            "LOAD_FAST",
            "samples"
        ],
        [
            "BINARY_SUBSCR",
            "samples['set']"
        ],
        [
            "STORE_FAST",
            "num_items"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "LOAD_FAST",
            "num_items"
        ],
        [
            "BINARY_OP",
            "num_items + 2"
        ],
        [
            "COMPARE_OP",
            "length > num_items + 2"
        ],
        [
            "LOAD_GLOBAL",
            "islice"
        ],
        [
            "LOAD_FAST",
            "vals"
        ],
        [
            "LOAD_FAST",
            "num_items"
        ],
        [
            "CALL",
            "islice(vals, num_items)"
        ],
        [
            "STORE_FAST",
            "vals"
        ],
        [
            "LOAD_GLOBAL",
            "enumerate"
        ],
        [
            "LOAD_FAST",
            "vals"
        ],
        [
            "CALL",
            "enumerate(vals)"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "STORE_FAST",
            "v"
        ],
        [
            "LOAD_FAST",
            "add_child"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_OP",
            "'<%s>' % i"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "CALL",
            "add_child('<%s>' % i, v)"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "CALL",
            "getattr(val, '__dict__', None)"
        ],
        [
            "STORE_FAST",
            "d"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "LOAD_GLOBAL",
            "sorted"
        ],
        [
            "LOAD_GLOBAL",
            "islice"
        ],
        [
            "LOAD_GLOBAL",
            "_safe_iter"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "CALL",
            "_safe_iter(d)"
        ],
        [
            "LOAD_FAST",
            "samples"
        ],
        [
            "BINARY_SUBSCR",
            "samples['attributes']"
        ],
        [
            "CALL",
            "islice(_safe_iter(d),\n                                   samples['attributes'])"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "CALL",
            "sorted(islice(_safe_iter(d),\n                                   samples['attributes']),\n                            key=str)"
        ],
        [
            "STORE_FAST",
            "k"
        ],
        [
            "LOAD_FAST",
            "d"
        ],
        [
            "LOAD_FAST",
            "k"
        ],
        [
            "BINARY_SUBSCR",
            "d[k]"
        ],
        [
            "STORE_FAST",
            "v"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "LOAD_GLOBAL",
            "TracedFile"
        ],
        [
            "CALL",
            "isinstance(v, TracedFile)"
        ],
        [
            "LOAD_FAST",
            "add_child"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_FAST",
            "k"
        ],
        [
            "CALL",
            "str(k)"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "CALL",
            "add_child(str(k), v)"
        ],
        [
            "LOAD_GLOBAL",
            "sorted"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_GLOBAL",
            "type"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "CALL",
            "type(val)"
        ],
        [
            "CALL",
            "getattr(type(val), '__slots__', None)"
        ],
        [
            "CALL",
            "sorted(getattr(type(val), '__slots__', None) or ())"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "CALL",
            "getattr(val, s)"
        ],
        [
            "STORE_FAST",
            "attr"
        ],
        [
            "LOAD_FAST",
            "add_child"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "CALL",
            "str(s)"
        ],
        [
            "LOAD_FAST",
            "attr"
        ],
        [
            "CALL",
            "add_child(str(s), attr)"
        ],
        [
            "LOAD_GLOBAL",
            "AttributeError"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_FAST",
            "f"
        ],
        [
            "LOAD_FAST",
            "val"
        ],
        [
            "CALL",
            "f(val)"
        ],
        [
            "STORE_FAST",
            "x"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "LOAD_FAST",
            "max_length"
        ],
        [
            "BINARY_OP",
            "max_length + 2"
        ],
        [
            "COMPARE_OP",
            "length <= max_length + 2"
        ],
        [
            "LOAD_GLOBAL",
            "range"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "CALL",
            "range(length)"
        ],
        [
            "LOAD_GLOBAL",
            "chain"
        ],
        [
            "LOAD_GLOBAL",
            "range"
        ],
        [
            "LOAD_FAST",
            "max_length"
        ],
        [
            "BINARY_OP",
            "max_length // 2"
        ],
        [
            "CALL",
            "range(max_length // 2)"
        ],
        [
            "LOAD_GLOBAL",
            "range"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "LOAD_FAST",
            "max_length"
        ],
        [
            "BINARY_OP",
            "max_length // 2"
        ],
        [
            "BINARY_OP",
            "length - max_length // 2"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "CALL",
            "range(length - max_length // 2,\n                           length)"
        ],
        [
            "CALL",
            "chain(range(max_length // 2),\n                     range(length - max_length // 2,\n                           length))"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "len(x)"
        ],
        [
            "STORE_FAST",
            "n"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "COMPARE_OP",
            "n == 0"
        ],
        [
            "LOAD_GLOBAL",
            "repr"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "repr(x)"
        ],
        [
            "LOAD_FAST",
            "helper"
        ],
        [
            "LOAD_ATTR",
            "helper.level"
        ],
        [
            "BINARY_OP",
            "helper.level - 1"
        ],
        [
            "STORE_FAST",
            "newlevel"
        ],
        [
            "STORE_FAST",
            "pieces"
        ],
        [
            "LOAD_GLOBAL",
            "_repr_series_one_line"
        ],
        [
            "LOAD_ATTR",
            "_repr_series_one_line.maxparts"
        ],
        [
            "STORE_FAST",
            "maxparts"
        ],
        [
            "LOAD_GLOBAL",
            "_sample_indices"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "LOAD_FAST",
            "maxparts"
        ],
        [
            "CALL",
            "_sample_indices(n, maxparts)"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_ATTR",
            "x.index"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_OP",
            "i + 1"
        ],
        [
            "BINARY_SUBSCR",
            "x.index[i:i + 1]"
        ],
        [
            "LOAD_METHOD",
            "x.index[i:i + 1].format"
        ],
        [
            "CALL",
            "x.index[i:i + 1].format(sparsify=False)"
        ],
        [
            "BINARY_SUBSCR",
            "x.index[i:i + 1].format(sparsify=False)[0]"
        ],
        [
            "STORE_FAST",
            "k"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_ATTR",
            "x.iloc"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_SUBSCR",
            "x.iloc[i]"
        ],
        [
            "STORE_FAST",
            "v"
        ],
        [
            "LOAD_FAST",
            "pieces"
        ],
        [
            "LOAD_METHOD",
            "pieces.append"
        ],
        [
            "LOAD_FAST",
            "k"
        ],
        [
            "LOAD_GLOBAL",
            "cheap_repr"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "LOAD_FAST",
            "newlevel"
        ],
        [
            "CALL",
            "cheap_repr(v, newlevel)"
        ],
        [
            "BUILD_STRING",
            "'%s = %s' % (k, cheap_repr(v, newlevel))"
        ],
        [
            "CALL",
            "pieces.append('%s = %s' % (k, cheap_repr(v, newlevel)))"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "LOAD_FAST",
            "maxparts"
        ],
        [
            "BINARY_OP",
            "maxparts + 2"
        ],
        [
            "COMPARE_OP",
            "n > maxparts + 2"
        ],
        [
            "LOAD_FAST",
            "pieces"
        ],
        [
            "LOAD_METHOD",
            "pieces.insert"
        ],
        [
            "LOAD_FAST",
            "maxparts"
        ],
        [
            "BINARY_OP",
            "maxparts // 2"
        ],
        [
            "CALL",
            "pieces.insert(maxparts // 2, '...')"
        ],
        [
            "LOAD_METHOD",
            "'; '.join"
        ],
        [
            "LOAD_FAST",
            "pieces"
        ],
        [
            "CALL",
            "'; '.join(pieces)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.expr"
        ],
        [
            "CALL",
            "isinstance(node, ast.expr)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Num"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Str"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "CALL",
            "getattr(ast, 'NameConstant', ())"
        ],
        [
            "CALL",
            "isinstance(node, (ast.Num, ast.Str, getattr(ast, 'NameConstant', ())))"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "getattr(node, 'ctx', None)"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Store"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Del"
        ],
        [
            "CALL",
            "isinstance(getattr(node, 'ctx', None),\n                            (ast.Store, ast.Del))"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.UnaryOp"
        ],
        [
            "CALL",
            "isinstance(node, ast.UnaryOp)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.op"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.UAdd"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.USub"
        ],
        [
            "CALL",
            "isinstance(node.op, (ast.UAdd, ast.USub))"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.operand"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Num"
        ],
        [
            "CALL",
            "isinstance(node.operand, ast.Num)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.List"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Tuple"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Dict"
        ],
        [
            "CALL",
            "isinstance(node, (ast.List, ast.Tuple, ast.Dict))"
        ],
        [
            "LOAD_GLOBAL",
            "any"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.iter_child_nodes"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "ast.iter_child_nodes(node)"
        ],
        [
            "CALL",
            "(is_interesting_expression(n) for n in ast.iter_child_nodes(node))"
        ],
        [
            "CALL",
            "any(is_interesting_expression(n) for n in ast.iter_child_nodes(node))"
        ],
        [
            "UNARY_NOT",
            "not any(is_interesting_expression(n) for n in ast.iter_child_nodes(node))"
        ],
        [
            "UNARY_NOT",
            "not (isinstance(node, (ast.Num, ast.Str, getattr(ast, 'NameConstant', ()))) or\n                 isinstance(getattr(node, 'ctx', None),\n                            (ast.Store, ast.Del)) or\n                 (isinstance(node, ast.UnaryOp) and\n                  isinstance(node.op, (ast.UAdd, ast.USub)) and\n                  isinstance(node.operand, ast.Num)) or\n                 (isinstance(node, (ast.List, ast.Tuple, ast.Dict)) and\n                  not any(is_interesting_expression(n) for n in ast.iter_child_nodes(node))))"
        ],
        [
            "LOAD_FAST",
            "(is_interesting_expression(n) for n in ast.iter_child_nodes(node))"
        ],
        [
            "STORE_FAST",
            "n"
        ],
        [
            "LOAD_GLOBAL",
            "is_interesting_expression"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "CALL",
            "is_interesting_expression(n)"
        ],
        [
            "LOAD_GLOBAL",
            "cast"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_GLOBAL",
            "__builtins__"
        ],
        [
            "CALL",
            "cast(dict, __builtins__)"
        ],
        [
            "STORE_FAST",
            "builtins"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Name"
        ],
        [
            "CALL",
            "isinstance(node, ast.Name)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.id"
        ],
        [
            "LOAD_FAST",
            "builtins"
        ],
        [
            "CONTAINS_OP",
            "node.id in builtins"
        ],
        [
            "LOAD_FAST",
            "builtins"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.id"
        ],
        [
            "BINARY_SUBSCR",
            "builtins[node.id]"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "IS_OP",
            "builtins[node.id] is value"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "CALL",
            "getattr(ast, 'NameConstant', ())"
        ],
        [
            "CALL",
            "isinstance(node, getattr(ast, 'NameConstant', ()))"
        ]
    ],
    "configuration.py": [
        [
            "STORE_NAME",
            "import inspect"
        ],
        [
            "STORE_NAME",
            "import os"
        ],
        [
            "STORE_NAME",
            "import sys"
        ],
        [
            "STORE_NAME",
            "import threading"
        ],
        [
            "STORE_NAME",
            "from collections import Set, Mapping, Sequence"
        ],
        [
            "STORE_NAME",
            "from collections import Set, Mapping, Sequence"
        ],
        [
            "STORE_NAME",
            "from collections import Set, Mapping, Sequence"
        ],
        [
            "STORE_NAME",
            "from io import open"
        ],
        [
            "STORE_NAME",
            "import six"
        ],
        [
            "STORE_NAME",
            "import snoop as package"
        ],
        [
            "STORE_NAME",
            "from snoop.formatting import DefaultFormatter"
        ],
        [
            "STORE_NAME",
            "from snoop.pp_module import PP"
        ],
        [
            "STORE_NAME",
            "from snoop.tracer import Spy, Tracer"
        ],
        [
            "STORE_NAME",
            "from snoop.tracer import Spy, Tracer"
        ],
        [
            "STORE_NAME",
            "from snoop.utils import builtins as builtins_module, is_pathlike, shitcode, ensure_tuple, QuerySet"
        ],
        [
            "STORE_NAME",
            "from snoop.utils import builtins as builtins_module, is_pathlike, shitcode, ensure_tuple, QuerySet"
        ],
        [
            "STORE_NAME",
            "from snoop.utils import builtins as builtins_module, is_pathlike, shitcode, ensure_tuple, QuerySet"
        ],
        [
            "STORE_NAME",
            "from snoop.utils import builtins as builtins_module, is_pathlike, shitcode, ensure_tuple, QuerySet"
        ],
        [
            "STORE_NAME",
            "from snoop.utils import builtins as builtins_module, is_pathlike, shitcode, ensure_tuple, QuerySet"
        ],
        [
            "STORE_NAME",
            "import ctypes"
        ],
        [
            "LOAD_NAME",
            "ctypes"
        ],
        [
            "LOAD_ATTR",
            "ctypes.windll"
        ],
        [
            "LOAD_ATTR",
            "ctypes.windll.kernel32"
        ],
        [
            "STORE_NAME",
            "kernel32"
        ],
        [
            "LOAD_NAME",
            "kernel32"
        ],
        [
            "LOAD_METHOD",
            "kernel32.SetConsoleMode"
        ],
        [
            "LOAD_NAME",
            "kernel32"
        ],
        [
            "LOAD_METHOD",
            "kernel32.GetStdHandle"
        ],
        [
            "CALL",
            "kernel32.GetStdHandle(-11)"
        ],
        [
            "CALL",
            "kernel32.SetConsoleMode(kernel32.GetStdHandle(-11), 7)"
        ],
        [
            "STORE_NAME",
            "can_color"
        ],
        [
            "LOAD_NAME",
            "Exception"
        ],
        [
            "LOAD_NAME",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.name"
        ],
        [
            "COMPARE_OP",
            "os.name != 'nt'"
        ],
        [
            "STORE_NAME",
            "can_color"
        ],
        [
            "LOAD_NAME",
            "DefaultFormatter"
        ],
        [
            "STORE_NAME",
            "def install(\n        builtins=True,\n        snoop=\"snoop\",\n        pp=\"pp\",\n        spy=\"spy\",\n        out=None,\n        prefix='',\n        columns='time',\n        overwrite=False,\n        color=None,\n        enabled=True,\n        watch_extras=(),\n        replace_watch_extras=None,\n        formatter_class=DefaultFormatter,\n):\n    \"\"\"\n    Configure output, enable or disable, and add names to builtins. Parameters:\n    \n    - builtins: set to False to not add any names to builtins,\n        so importing will still be required.\n    - snoop, pp, and spy: set to other strings \n        to choose the names of these functions in builtins\n    - `out`: determines the output destination. By default this is stderr. You can also pass:\n        - A string or a `Path` object to write to a file at that location. By default this always will append to the file. Pass `overwrite=True` to clear the file initially.\n        - Anything with a `write` method, e.g. `sys.stdout` or a file object.\n        - Any callable with a single string argument, e.g. `logger.info`.\n    - `color`: determines whether the output includes escape characters to display colored text in the console. If you see weird characters in your output, your console doesn't support colors, so pass `color=False`.\n        - Code is syntax highlighted using [Pygments](http://pygments.org/), and this argument is passed as the style. You can choose a different color scheme by passing a string naming a style (see [this gallery](https://help.farbox.com/pygments.html)) or a style class. The default style is monokai.   \n        - By default this parameter is set to `out.isatty()`, which is usually true for stdout and stderr but will be false if they are redirected or piped. Pass `True` or a style if you want to force coloring.\n        - To see colors in the PyCharm Run window, edit the Run Configuration and tick \"Emulate terminal in output console\".\n    - `prefix`: Pass a string to start all snoop lines with that string so you can grep for them easily.\n    - `columns`: This specifies the columns at the start of each output line. You can pass a string with the names of built in columns separated by spaces or commas. These are the available columns:\n        - `time`: The current time. This is the only column by default.\n        - `thread`: The name of the current thread.  \n        - `thread_ident`: The [identifier](https://docs.python.org/3/library/threading.html#threading.Thread.ident) of the current thread, in case thread names are not unique.\n        - `file`: The filename (not the full path) of the current function.\n        - `full_file`: The full path to the file (also shown anyway when the function is called).\n        - `function`: The name of the current function.\n        - `function_qualname`: The qualified name of the current function.\n        \n        If you want a custom column, please open an issue to tell me what you're interested in! In the meantime, you can pass a list, where the elements are either strings or callables. The callables should take one argument, which will be an `Event` object. It has attributes `frame`, `event`, and `arg`, as specified in [`sys.settrace()`](https://docs.python.org/3/library/sys.html#sys.settrace), and other attributes which may change. \n    \"\"\"\n    \n    if builtins:\n        setattr(builtins_module, snoop, package.snoop)\n        setattr(builtins_module, pp, package.pp)\n        setattr(builtins_module, spy, package.spy)\n    config = Config(\n        out=out,\n        prefix=prefix,\n        columns=columns,\n        overwrite=overwrite,\n        color=color,\n        enabled=enabled,\n        watch_extras=watch_extras,\n        replace_watch_extras=replace_watch_extras,\n        formatter_class=formatter_class,\n    )\n    package.snoop.config = config\n    package.pp.config = config\n    package.spy.config = config"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class Config(object):\n    \"\"\"\"\n    If you need more control than the global `install` function, e.g. if you want to write to several different files in one process, you can create a `Config` object, e.g: `config = snoop.Config(out=filename)`. Then `config.snoop`, `config.pp` and `config.spy` will use that configuration rather than the global one.\n    \n    The arguments are the same as the arguments of `install()` relating to output configuration and `enabled`.\n    \"\"\"\n    \n    def __init__(\n            self,\n            out=None,\n            prefix='',\n            columns='time',\n            overwrite=False,\n            color=None,\n            enabled=True,\n            watch_extras=(),\n            replace_watch_extras=None,\n            formatter_class=DefaultFormatter,\n    ):\n        if can_color:\n            if color is None:\n                isatty = getattr(out or sys.stderr, 'isatty', lambda: False)\n                color = bool(isatty())\n        else:\n            color = False\n\n        self.write = get_write_function(out, overwrite)\n        self.formatter = formatter_class(prefix, columns, color)\n        self.enabled = enabled\n        self.pp = PP(self)\n\n        class ConfiguredTracer(Tracer):\n            config = self\n\n        self.snoop = ConfiguredTracer\n        self.spy = Spy(self)\n\n        self.last_frame = None\n        self.thread_local = threading.local()\n\n        if replace_watch_extras is not None:\n            self.watch_extras = ensure_tuple(replace_watch_extras)\n        else:\n            self.watch_extras = (len_shape_watch, dtype_watch) + ensure_tuple(watch_extras)"
        ],
        [
            "STORE_NAME",
            "class Config(object):\n    \"\"\"\"\n    If you need more control than the global `install` function, e.g. if you want to write to several different files in one process, you can create a `Config` object, e.g: `config = snoop.Config(out=filename)`. Then `config.snoop`, `config.pp` and `config.spy` will use that configuration rather than the global one.\n    \n    The arguments are the same as the arguments of `install()` relating to output configuration and `enabled`.\n    \"\"\"\n    \n    def __init__(\n            self,\n            out=None,\n            prefix='',\n            columns='time',\n            overwrite=False,\n            color=None,\n            enabled=True,\n            watch_extras=(),\n            replace_watch_extras=None,\n            formatter_class=DefaultFormatter,\n    ):\n        if can_color:\n            if color is None:\n                isatty = getattr(out or sys.stderr, 'isatty', lambda: False)\n                color = bool(isatty())\n        else:\n            color = False\n\n        self.write = get_write_function(out, overwrite)\n        self.formatter = formatter_class(prefix, columns, color)\n        self.enabled = enabled\n        self.pp = PP(self)\n\n        class ConfiguredTracer(Tracer):\n            config = self\n\n        self.snoop = ConfiguredTracer\n        self.spy = Spy(self)\n\n        self.last_frame = None\n        self.thread_local = threading.local()\n\n        if replace_watch_extras is not None:\n            self.watch_extras = ensure_tuple(replace_watch_extras)\n        else:\n            self.watch_extras = (len_shape_watch, dtype_watch) + ensure_tuple(watch_extras)"
        ],
        [
            "STORE_NAME",
            "def len_shape_watch(source, value):\n    try:\n        shape = value.shape\n    except Exception:\n        pass\n    else:\n        if not inspect.ismethod(shape):\n            return '{}.shape'.format(source), shape\n\n    if isinstance(value, QuerySet):\n        # Getting the length of a Django queryset evaluates it\n        return None\n\n    length = len(value)\n    if (\n            (isinstance(value, six.string_types)\n             and length < 50) or\n            (isinstance(value, (Mapping, Set, Sequence))\n             and length == 0)\n    ):\n        return None\n\n    return 'len({})'.format(source), length"
        ],
        [
            "STORE_NAME",
            "def dtype_watch(source, value):\n    dtype = value.dtype\n    if not inspect.ismethod(dtype):\n        return '{}.dtype'.format(source), dtype"
        ],
        [
            "STORE_NAME",
            "def get_write_function(output, overwrite):\n    is_path = (\n        isinstance(output, six.string_types)\n        or is_pathlike(output)\n    )\n    if is_path:\n        return FileWriter(output, overwrite).write\n    elif callable(output):\n        write = output\n    else:\n        def write(s):\n            stream = output\n\n            if stream is None:\n                stream = sys.stderr\n\n            try:\n                stream.write(s)\n            except UnicodeEncodeError:\n                # God damn Python 2\n                stream.write(shitcode(s))\n    return write"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class FileWriter(object):\n    def __init__(self, path, overwrite):\n        self.path = six.text_type(path)\n        self.overwrite = overwrite\n\n    def write(self, s):\n        with open(self.path, 'w' if self.overwrite else 'a', encoding='utf-8') as f:\n            f.write(s)\n        self.overwrite = False"
        ],
        [
            "STORE_NAME",
            "class FileWriter(object):\n    def __init__(self, path, overwrite):\n        self.path = six.text_type(path)\n        self.overwrite = overwrite\n\n    def write(self, s):\n        with open(self.path, 'w' if self.overwrite else 'a', encoding='utf-8') as f:\n            f.write(s)\n        self.overwrite = False"
        ],
        [
            "LOAD_FAST",
            "builtins"
        ],
        [
            "LOAD_GLOBAL",
            "setattr"
        ],
        [
            "LOAD_GLOBAL",
            "builtins_module"
        ],
        [
            "LOAD_FAST",
            "snoop"
        ],
        [
            "LOAD_GLOBAL",
            "package"
        ],
        [
            "LOAD_ATTR",
            "package.snoop"
        ],
        [
            "CALL",
            "setattr(builtins_module, snoop, package.snoop)"
        ],
        [
            "LOAD_GLOBAL",
            "setattr"
        ],
        [
            "LOAD_GLOBAL",
            "builtins_module"
        ],
        [
            "LOAD_FAST",
            "pp"
        ],
        [
            "LOAD_GLOBAL",
            "package"
        ],
        [
            "LOAD_ATTR",
            "package.pp"
        ],
        [
            "CALL",
            "setattr(builtins_module, pp, package.pp)"
        ],
        [
            "LOAD_GLOBAL",
            "setattr"
        ],
        [
            "LOAD_GLOBAL",
            "builtins_module"
        ],
        [
            "LOAD_FAST",
            "spy"
        ],
        [
            "LOAD_GLOBAL",
            "package"
        ],
        [
            "LOAD_ATTR",
            "package.spy"
        ],
        [
            "CALL",
            "setattr(builtins_module, spy, package.spy)"
        ],
        [
            "LOAD_GLOBAL",
            "Config"
        ],
        [
            "LOAD_FAST",
            "out"
        ],
        [
            "LOAD_FAST",
            "prefix"
        ],
        [
            "LOAD_FAST",
            "columns"
        ],
        [
            "LOAD_FAST",
            "overwrite"
        ],
        [
            "LOAD_FAST",
            "color"
        ],
        [
            "LOAD_FAST",
            "enabled"
        ],
        [
            "LOAD_FAST",
            "watch_extras"
        ],
        [
            "LOAD_FAST",
            "replace_watch_extras"
        ],
        [
            "LOAD_FAST",
            "formatter_class"
        ],
        [
            "CALL",
            "Config(\n        out=out,\n        prefix=prefix,\n        columns=columns,\n        overwrite=overwrite,\n        color=color,\n        enabled=enabled,\n        watch_extras=watch_extras,\n        replace_watch_extras=replace_watch_extras,\n        formatter_class=formatter_class,\n    )"
        ],
        [
            "STORE_FAST",
            "config"
        ],
        [
            "LOAD_FAST",
            "config"
        ],
        [
            "LOAD_GLOBAL",
            "package"
        ],
        [
            "LOAD_ATTR",
            "package.snoop"
        ],
        [
            "STORE_ATTR",
            "package.snoop.config"
        ],
        [
            "LOAD_FAST",
            "config"
        ],
        [
            "LOAD_GLOBAL",
            "package"
        ],
        [
            "LOAD_ATTR",
            "package.pp"
        ],
        [
            "STORE_ATTR",
            "package.pp.config"
        ],
        [
            "LOAD_FAST",
            "config"
        ],
        [
            "LOAD_GLOBAL",
            "package"
        ],
        [
            "LOAD_ATTR",
            "package.spy"
        ],
        [
            "STORE_ATTR",
            "package.spy.config"
        ],
        [
            "STORE_NAME",
            "\"\"\"\"\n    If you need more control than the global `install` function, e.g. if you want to write to several different files in one process, you can create a `Config` object, e.g: `config = snoop.Config(out=filename)`. Then `config.snoop`, `config.pp` and `config.spy` will use that configuration rather than the global one.\n    \n    The arguments are the same as the arguments of `install()` relating to output configuration and `enabled`.\n    \"\"\""
        ],
        [
            "LOAD_NAME",
            "DefaultFormatter"
        ],
        [
            "STORE_NAME",
            "    def __init__(\n            self,\n            out=None,\n            prefix='',\n            columns='time',\n            overwrite=False,\n            color=None,\n            enabled=True,\n            watch_extras=(),\n            replace_watch_extras=None,\n            formatter_class=DefaultFormatter,\n    ):\n        if can_color:\n            if color is None:\n                isatty = getattr(out or sys.stderr, 'isatty', lambda: False)\n                color = bool(isatty())\n        else:\n            color = False\n\n        self.write = get_write_function(out, overwrite)\n        self.formatter = formatter_class(prefix, columns, color)\n        self.enabled = enabled\n        self.pp = PP(self)\n\n        class ConfiguredTracer(Tracer):\n            config = self\n\n        self.snoop = ConfiguredTracer\n        self.spy = Spy(self)\n\n        self.last_frame = None\n        self.thread_local = threading.local()\n\n        if replace_watch_extras is not None:\n            self.watch_extras = ensure_tuple(replace_watch_extras)\n        else:\n            self.watch_extras = (len_shape_watch, dtype_watch) + ensure_tuple(watch_extras)"
        ],
        [
            "LOAD_GLOBAL",
            "can_color"
        ],
        [
            "LOAD_FAST",
            "color"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_FAST",
            "out"
        ],
        [
            "LOAD_GLOBAL",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.stderr"
        ],
        [
            "CALL",
            "getattr(out or sys.stderr, 'isatty', lambda: False)"
        ],
        [
            "STORE_FAST",
            "isatty"
        ],
        [
            "LOAD_GLOBAL",
            "bool"
        ],
        [
            "LOAD_FAST",
            "isatty"
        ],
        [
            "CALL",
            "isatty()"
        ],
        [
            "CALL",
            "bool(isatty())"
        ],
        [
            "STORE_FAST",
            "color"
        ],
        [
            "STORE_FAST",
            "color"
        ],
        [
            "LOAD_GLOBAL",
            "get_write_function"
        ],
        [
            "LOAD_FAST",
            "out"
        ],
        [
            "LOAD_FAST",
            "overwrite"
        ],
        [
            "CALL",
            "get_write_function(out, overwrite)"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.write"
        ],
        [
            "LOAD_FAST",
            "formatter_class"
        ],
        [
            "LOAD_FAST",
            "prefix"
        ],
        [
            "LOAD_FAST",
            "columns"
        ],
        [
            "LOAD_FAST",
            "color"
        ],
        [
            "CALL",
            "formatter_class(prefix, columns, color)"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.formatter"
        ],
        [
            "LOAD_FAST",
            "enabled"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.enabled"
        ],
        [
            "LOAD_GLOBAL",
            "PP"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "CALL",
            "PP(self)"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.pp"
        ],
        [
            "LOAD_GLOBAL",
            "Tracer"
        ],
        [
            "CALL",
            "        class ConfiguredTracer(Tracer):\n            config = self"
        ],
        [
            "STORE_FAST",
            "        class ConfiguredTracer(Tracer):\n            config = self"
        ],
        [
            "LOAD_FAST",
            "ConfiguredTracer"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.snoop"
        ],
        [
            "LOAD_GLOBAL",
            "Spy"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "CALL",
            "Spy(self)"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.spy"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.last_frame"
        ],
        [
            "LOAD_GLOBAL",
            "threading"
        ],
        [
            "LOAD_ATTR",
            "threading.local"
        ],
        [
            "CALL",
            "threading.local()"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.thread_local"
        ],
        [
            "LOAD_FAST",
            "replace_watch_extras"
        ],
        [
            "LOAD_GLOBAL",
            "ensure_tuple"
        ],
        [
            "LOAD_FAST",
            "replace_watch_extras"
        ],
        [
            "CALL",
            "ensure_tuple(replace_watch_extras)"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.watch_extras"
        ],
        [
            "LOAD_GLOBAL",
            "len_shape_watch"
        ],
        [
            "LOAD_GLOBAL",
            "dtype_watch"
        ],
        [
            "LOAD_GLOBAL",
            "ensure_tuple"
        ],
        [
            "LOAD_FAST",
            "watch_extras"
        ],
        [
            "CALL",
            "ensure_tuple(watch_extras)"
        ],
        [
            "BINARY_OP",
            "(len_shape_watch, dtype_watch) + ensure_tuple(watch_extras)"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.watch_extras"
        ],
        [
            "LOAD_CLASSDEREF",
            "self"
        ],
        [
            "STORE_NAME",
            "config"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_ATTR",
            "value.shape"
        ],
        [
            "STORE_FAST",
            "shape"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.ismethod"
        ],
        [
            "LOAD_FAST",
            "shape"
        ],
        [
            "CALL",
            "inspect.ismethod(shape)"
        ],
        [
            "LOAD_METHOD",
            "'{}.shape'.format"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CALL",
            "'{}.shape'.format(source)"
        ],
        [
            "LOAD_FAST",
            "shape"
        ],
        [
            "LOAD_GLOBAL",
            "Exception"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_GLOBAL",
            "QuerySet"
        ],
        [
            "CALL",
            "isinstance(value, QuerySet)"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "CALL",
            "len(value)"
        ],
        [
            "STORE_FAST",
            "length"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_GLOBAL",
            "six"
        ],
        [
            "LOAD_ATTR",
            "six.string_types"
        ],
        [
            "CALL",
            "isinstance(value, six.string_types)"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "COMPARE_OP",
            "length < 50"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_GLOBAL",
            "Mapping"
        ],
        [
            "LOAD_GLOBAL",
            "Set"
        ],
        [
            "LOAD_GLOBAL",
            "Sequence"
        ],
        [
            "CALL",
            "isinstance(value, (Mapping, Set, Sequence))"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "COMPARE_OP",
            "length == 0"
        ],
        [
            "LOAD_METHOD",
            "'len({})'.format"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CALL",
            "'len({})'.format(source)"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_ATTR",
            "value.dtype"
        ],
        [
            "STORE_FAST",
            "dtype"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.ismethod"
        ],
        [
            "LOAD_FAST",
            "dtype"
        ],
        [
            "CALL",
            "inspect.ismethod(dtype)"
        ],
        [
            "LOAD_METHOD",
            "'{}.dtype'.format"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CALL",
            "'{}.dtype'.format(source)"
        ],
        [
            "LOAD_FAST",
            "dtype"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_DEREF",
            "output"
        ],
        [
            "LOAD_GLOBAL",
            "six"
        ],
        [
            "LOAD_ATTR",
            "six.string_types"
        ],
        [
            "CALL",
            "isinstance(output, six.string_types)"
        ],
        [
            "LOAD_GLOBAL",
            "is_pathlike"
        ],
        [
            "LOAD_DEREF",
            "output"
        ],
        [
            "CALL",
            "is_pathlike(output)"
        ],
        [
            "STORE_FAST",
            "is_path"
        ],
        [
            "LOAD_FAST",
            "is_path"
        ],
        [
            "LOAD_GLOBAL",
            "FileWriter"
        ],
        [
            "LOAD_DEREF",
            "output"
        ],
        [
            "LOAD_FAST",
            "overwrite"
        ],
        [
            "CALL",
            "FileWriter(output, overwrite)"
        ],
        [
            "LOAD_ATTR",
            "FileWriter(output, overwrite).write"
        ],
        [
            "LOAD_GLOBAL",
            "callable"
        ],
        [
            "LOAD_DEREF",
            "output"
        ],
        [
            "CALL",
            "callable(output)"
        ],
        [
            "LOAD_DEREF",
            "output"
        ],
        [
            "STORE_FAST",
            "write"
        ],
        [
            "STORE_FAST",
            "        def write(s):\n            stream = output\n\n            if stream is None:\n                stream = sys.stderr\n\n            try:\n                stream.write(s)\n            except UnicodeEncodeError:\n                # God damn Python 2\n                stream.write(shitcode(s))"
        ],
        [
            "LOAD_FAST",
            "write"
        ],
        [
            "LOAD_DEREF",
            "output"
        ],
        [
            "STORE_FAST",
            "stream"
        ],
        [
            "LOAD_FAST",
            "stream"
        ],
        [
            "LOAD_GLOBAL",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.stderr"
        ],
        [
            "STORE_FAST",
            "stream"
        ],
        [
            "LOAD_FAST",
            "stream"
        ],
        [
            "LOAD_METHOD",
            "stream.write"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "CALL",
            "stream.write(s)"
        ],
        [
            "LOAD_GLOBAL",
            "UnicodeEncodeError"
        ],
        [
            "LOAD_FAST",
            "stream"
        ],
        [
            "LOAD_METHOD",
            "stream.write"
        ],
        [
            "LOAD_GLOBAL",
            "shitcode"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "CALL",
            "shitcode(s)"
        ],
        [
            "CALL",
            "stream.write(shitcode(s))"
        ],
        [
            "STORE_NAME",
            "    def __init__(self, path, overwrite):\n        self.path = six.text_type(path)\n        self.overwrite = overwrite"
        ],
        [
            "STORE_NAME",
            "    def write(self, s):\n        with open(self.path, 'w' if self.overwrite else 'a', encoding='utf-8') as f:\n            f.write(s)\n        self.overwrite = False"
        ],
        [
            "LOAD_GLOBAL",
            "six"
        ],
        [
            "LOAD_ATTR",
            "six.text_type"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "CALL",
            "six.text_type(path)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.path"
        ],
        [
            "LOAD_FAST",
            "overwrite"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.overwrite"
        ],
        [
            "LOAD_GLOBAL",
            "open"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.path"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.overwrite"
        ],
        [
            "CALL",
            "open(self.path, 'w' if self.overwrite else 'a', encoding='utf-8')"
        ],
        [
            "STORE_FAST",
            "f"
        ],
        [
            "LOAD_FAST",
            "f"
        ],
        [
            "LOAD_METHOD",
            "f.write"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "CALL",
            "f.write(s)"
        ],
        [
            "CALL",
            "        with open(self.path, 'w' if self.overwrite else 'a', encoding='utf-8') as f:\n            f.write(s)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.overwrite"
        ]
    ],
    "db.py": [
        [
            "STORE_NAME",
            "from __future__ import print_function, division, absolute_import"
        ],
        [
            "STORE_NAME",
            "from __future__ import print_function, division, absolute_import"
        ],
        [
            "STORE_NAME",
            "from __future__ import print_function, division, absolute_import"
        ],
        [
            "STORE_NAME",
            "import functools"
        ],
        [
            "STORE_NAME",
            "import sys"
        ],
        [
            "STORE_NAME",
            "from future import standard_library"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy.exc import OperationalError, InterfaceError, InternalError, ProgrammingError, ArgumentError"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy.exc import OperationalError, InterfaceError, InternalError, ProgrammingError, ArgumentError"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy.exc import OperationalError, InterfaceError, InternalError, ProgrammingError, ArgumentError"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy.exc import OperationalError, InterfaceError, InternalError, ProgrammingError, ArgumentError"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy.exc import OperationalError, InterfaceError, InternalError, ProgrammingError, ArgumentError"
        ],
        [
            "LOAD_NAME",
            "standard_library"
        ],
        [
            "LOAD_ATTR",
            "standard_library.install_aliases"
        ],
        [
            "CALL",
            "standard_library.install_aliases()"
        ],
        [
            "STORE_NAME",
            "import json"
        ],
        [
            "STORE_NAME",
            "import os"
        ],
        [
            "STORE_NAME",
            "from typing import List"
        ],
        [
            "STORE_NAME",
            "from contextlib import contextmanager"
        ],
        [
            "STORE_NAME",
            "from humanize import naturaltime"
        ],
        [
            "STORE_NAME",
            "from markupsafe import Markup"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy import Sequence, UniqueConstraint, create_engine, Column, Integer, Text, ForeignKey, DateTime, String, \\\n    Index"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy import Sequence, UniqueConstraint, create_engine, Column, Integer, Text, ForeignKey, DateTime, String, \\\n    Index"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy import Sequence, UniqueConstraint, create_engine, Column, Integer, Text, ForeignKey, DateTime, String, \\\n    Index"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy import Sequence, UniqueConstraint, create_engine, Column, Integer, Text, ForeignKey, DateTime, String, \\\n    Index"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy import Sequence, UniqueConstraint, create_engine, Column, Integer, Text, ForeignKey, DateTime, String, \\\n    Index"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy import Sequence, UniqueConstraint, create_engine, Column, Integer, Text, ForeignKey, DateTime, String, \\\n    Index"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy import Sequence, UniqueConstraint, create_engine, Column, Integer, Text, ForeignKey, DateTime, String, \\\n    Index"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy import Sequence, UniqueConstraint, create_engine, Column, Integer, Text, ForeignKey, DateTime, String, \\\n    Index"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy import Sequence, UniqueConstraint, create_engine, Column, Integer, Text, ForeignKey, DateTime, String, \\\n    Index"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy import Sequence, UniqueConstraint, create_engine, Column, Integer, Text, ForeignKey, DateTime, String, \\\n    Index"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy.ext.declarative import declarative_base, declared_attr"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy.ext.declarative import declarative_base, declared_attr"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy.orm import backref, relationship, sessionmaker"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy.orm import backref, relationship, sessionmaker"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy.orm import backref, relationship, sessionmaker"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy.dialects.mysql import LONGTEXT"
        ],
        [
            "STORE_NAME",
            "from littleutils import select_attrs, retry"
        ],
        [
            "STORE_NAME",
            "from littleutils import select_attrs, retry"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import IPYTHON_FILE_PATH, is_ipython_cell"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import IPYTHON_FILE_PATH, is_ipython_cell"
        ],
        [
            "STORE_NAME",
            "from sqlalchemy.dialects.mysql.base import RESERVED_WORDS"
        ],
        [
            "LOAD_NAME",
            "RESERVED_WORDS"
        ],
        [
            "LOAD_ATTR",
            "RESERVED_WORDS.add"
        ],
        [
            "CALL",
            "RESERVED_WORDS.add('function')"
        ],
        [
            "STORE_NAME",
            "DB_VERSION"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class Database(object):\n    def __init__(self, db_uri=None, _skip_version_check=False):\n        self.db_uri = db_uri = (\n                db_uri\n                or os.environ.get('BIRDSEYE_DB')\n                or os.path.join(os.path.expanduser('~'),\n                                '.birdseye.db'))\n\n        kwargs = dict(\n            pool_recycle=280,\n            echo=False,  # for convenience when debugging\n        )\n\n        try:\n            engine = create_engine(db_uri, **kwargs)\n        except ArgumentError:\n            db_uri = 'sqlite:///' + db_uri\n            engine = create_engine(db_uri, **kwargs)\n\n        self.engine = engine\n\n        self.Session = sessionmaker(bind=engine)\n\n        class Base(object):\n            @declared_attr\n            def __tablename__(cls):\n                return cls.__name__.lower()\n\n        Base = declarative_base(cls=Base)  # type: ignore\n\n        class KeyValue(Base):\n            key = Column(String(50), primary_key=True)\n            value = Column(Text)\n\n        db_self = self\n\n        class KeyValueStore(object):\n            def __getitem__(self, item):\n                with db_self.session_scope() as session:\n                    return (session\n                            .query(KeyValue.value)\n                            .filter_by(key=item)\n                            .scalar())\n\n            def __setitem__(self, key, value):\n                with db_self.session_scope() as session:\n                    session.query(KeyValue).filter_by(key=key).delete()\n                    session.add(KeyValue(key=key, value=str(value)))\n\n            __getattr__ = __getitem__\n            __setattr__ = __setitem__\n\n        LongText = LONGTEXT if engine.name == 'mysql' else Text\n\n        class Call(Base):\n            id = Column(String(length=32), primary_key=True)\n            function_id = Column(Integer, ForeignKey('function.id'), index=True)\n            function = relationship('Function', backref=backref('calls', lazy='dynamic'))\n            arguments = Column(Text)\n            return_value = Column(Text)\n            exception = Column(Text)\n            traceback = Column(Text)\n            data = Column(LongText)\n            start_time = Column(DateTime, index=True)\n\n            @property\n            def pretty_start_time(self):\n                return self._pretty_time(self.start_time)\n\n            @staticmethod\n            def _pretty_time(dt):\n                if not dt:\n                    return ''\n                return Markup('%s (%s)' % (\n                    dt.strftime('%Y-%m-%d&nbsp;%H:%M:%S'),\n                    naturaltime(dt)))\n\n            @property\n            def state_icon(self):\n                return Markup('<span class=\"glyphicon glyphicon-%s\" '\n                              'style=\"color: %s\"></span>' % (\n                                  ('ok', 'green') if self.success else\n                                  ('remove', 'red')))\n\n            @property\n            def success(self):\n                if self.exception:\n                    assert self.traceback\n                    assert self.return_value == 'None'\n                    return False\n                else:\n                    assert not self.traceback\n                    return True\n\n            @property\n            def result(self):\n                if self.success:\n                    return str(self.return_value)\n                else:\n                    return str(self.exception)\n\n            @property\n            def arguments_list(self):\n                return json.loads(self.arguments)\n\n            @property\n            def parsed_data(self):\n                return json.loads(self.data)\n\n            @staticmethod\n            def basic_dict(call):\n                return dict(arguments=call.arguments_list,\n                            **select_attrs(call, 'id function_id return_value traceback '\n                                                 'exception start_time'))\n\n            basic_columns = (id, function_id, return_value,\n                             traceback, exception, start_time, arguments)\n\n        class Function(Base):\n            id = Column(Integer, Sequence('function_id_seq'), primary_key=True)\n            file = Column(Text)\n            name = Column(Text)\n            type = Column(Text)  # function or module\n            html_body = Column(LongText)\n            lineno = Column(Integer)\n            data = Column(LongText)\n            hash = Column(String(length=64), index=True)\n            body_hash = Column(String(length=64), index=True)\n\n            __table_args__ = (\n                UniqueConstraint('hash',\n                                 name='everything_unique'),\n                Index('idx_file', 'file', mysql_length=256),\n                Index('idx_name', 'name', mysql_length=32),\n            )\n\n            @property\n            def parsed_data(self):\n                return json.loads(self.data)\n\n            @staticmethod\n            def basic_dict(func):\n                return select_attrs(func, 'file name lineno hash body_hash type')\n\n            basic_columns = (file, name, lineno, hash, body_hash, type)\n\n        self.Call = Call\n        self.Function = Function\n        self._KeyValue = KeyValue\n\n        self.key_value_store = kv = KeyValueStore()\n\n        if _skip_version_check:\n            return\n\n        if not self.table_exists(Function):\n            Base.metadata.create_all(engine)\n            kv.version = DB_VERSION\n        elif not self.table_exists(KeyValue) or int(kv.version) < DB_VERSION:\n            sys.exit('The birdseye database schema is out of date. '\n                     'Run \"python -m birdseye.clear_db\" to delete the existing tables.')\n\n    def table_exists(self, table):\n        return self.engine.dialect.has_table(self.engine, table.__name__)\n\n    def all_file_paths(self):\n        # type: () -> List[str]\n        with self.session_scope() as session:\n            paths = [f[0] for f in session.query(self.Function.file).distinct()\n                     if not is_ipython_cell(f[0])]\n        paths.sort()\n        if IPYTHON_FILE_PATH in paths:\n            paths.remove(IPYTHON_FILE_PATH)\n            paths.insert(0, IPYTHON_FILE_PATH)\n        return paths\n\n    def clear(self):\n        for model in [self.Call, self.Function, self._KeyValue]:\n            if self.table_exists(model):\n                model.__table__.drop(self.engine)\n\n    @contextmanager\n    def session_scope(self):\n        \"\"\"Provide a transactional scope around a series of operations.\"\"\"\n        session = self.Session()\n        try:\n            yield session\n            session.commit()\n        except:\n            session.rollback()\n            raise\n        finally:\n            session.close()\n\n    def provide_session(self, func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            with self.session_scope() as session:\n                return func(session, *args, **kwargs)\n\n        return retry_db(wrapper)"
        ],
        [
            "STORE_NAME",
            "class Database(object):\n    def __init__(self, db_uri=None, _skip_version_check=False):\n        self.db_uri = db_uri = (\n                db_uri\n                or os.environ.get('BIRDSEYE_DB')\n                or os.path.join(os.path.expanduser('~'),\n                                '.birdseye.db'))\n\n        kwargs = dict(\n            pool_recycle=280,\n            echo=False,  # for convenience when debugging\n        )\n\n        try:\n            engine = create_engine(db_uri, **kwargs)\n        except ArgumentError:\n            db_uri = 'sqlite:///' + db_uri\n            engine = create_engine(db_uri, **kwargs)\n\n        self.engine = engine\n\n        self.Session = sessionmaker(bind=engine)\n\n        class Base(object):\n            @declared_attr\n            def __tablename__(cls):\n                return cls.__name__.lower()\n\n        Base = declarative_base(cls=Base)  # type: ignore\n\n        class KeyValue(Base):\n            key = Column(String(50), primary_key=True)\n            value = Column(Text)\n\n        db_self = self\n\n        class KeyValueStore(object):\n            def __getitem__(self, item):\n                with db_self.session_scope() as session:\n                    return (session\n                            .query(KeyValue.value)\n                            .filter_by(key=item)\n                            .scalar())\n\n            def __setitem__(self, key, value):\n                with db_self.session_scope() as session:\n                    session.query(KeyValue).filter_by(key=key).delete()\n                    session.add(KeyValue(key=key, value=str(value)))\n\n            __getattr__ = __getitem__\n            __setattr__ = __setitem__\n\n        LongText = LONGTEXT if engine.name == 'mysql' else Text\n\n        class Call(Base):\n            id = Column(String(length=32), primary_key=True)\n            function_id = Column(Integer, ForeignKey('function.id'), index=True)\n            function = relationship('Function', backref=backref('calls', lazy='dynamic'))\n            arguments = Column(Text)\n            return_value = Column(Text)\n            exception = Column(Text)\n            traceback = Column(Text)\n            data = Column(LongText)\n            start_time = Column(DateTime, index=True)\n\n            @property\n            def pretty_start_time(self):\n                return self._pretty_time(self.start_time)\n\n            @staticmethod\n            def _pretty_time(dt):\n                if not dt:\n                    return ''\n                return Markup('%s (%s)' % (\n                    dt.strftime('%Y-%m-%d&nbsp;%H:%M:%S'),\n                    naturaltime(dt)))\n\n            @property\n            def state_icon(self):\n                return Markup('<span class=\"glyphicon glyphicon-%s\" '\n                              'style=\"color: %s\"></span>' % (\n                                  ('ok', 'green') if self.success else\n                                  ('remove', 'red')))\n\n            @property\n            def success(self):\n                if self.exception:\n                    assert self.traceback\n                    assert self.return_value == 'None'\n                    return False\n                else:\n                    assert not self.traceback\n                    return True\n\n            @property\n            def result(self):\n                if self.success:\n                    return str(self.return_value)\n                else:\n                    return str(self.exception)\n\n            @property\n            def arguments_list(self):\n                return json.loads(self.arguments)\n\n            @property\n            def parsed_data(self):\n                return json.loads(self.data)\n\n            @staticmethod\n            def basic_dict(call):\n                return dict(arguments=call.arguments_list,\n                            **select_attrs(call, 'id function_id return_value traceback '\n                                                 'exception start_time'))\n\n            basic_columns = (id, function_id, return_value,\n                             traceback, exception, start_time, arguments)\n\n        class Function(Base):\n            id = Column(Integer, Sequence('function_id_seq'), primary_key=True)\n            file = Column(Text)\n            name = Column(Text)\n            type = Column(Text)  # function or module\n            html_body = Column(LongText)\n            lineno = Column(Integer)\n            data = Column(LongText)\n            hash = Column(String(length=64), index=True)\n            body_hash = Column(String(length=64), index=True)\n\n            __table_args__ = (\n                UniqueConstraint('hash',\n                                 name='everything_unique'),\n                Index('idx_file', 'file', mysql_length=256),\n                Index('idx_name', 'name', mysql_length=32),\n            )\n\n            @property\n            def parsed_data(self):\n                return json.loads(self.data)\n\n            @staticmethod\n            def basic_dict(func):\n                return select_attrs(func, 'file name lineno hash body_hash type')\n\n            basic_columns = (file, name, lineno, hash, body_hash, type)\n\n        self.Call = Call\n        self.Function = Function\n        self._KeyValue = KeyValue\n\n        self.key_value_store = kv = KeyValueStore()\n\n        if _skip_version_check:\n            return\n\n        if not self.table_exists(Function):\n            Base.metadata.create_all(engine)\n            kv.version = DB_VERSION\n        elif not self.table_exists(KeyValue) or int(kv.version) < DB_VERSION:\n            sys.exit('The birdseye database schema is out of date. '\n                     'Run \"python -m birdseye.clear_db\" to delete the existing tables.')\n\n    def table_exists(self, table):\n        return self.engine.dialect.has_table(self.engine, table.__name__)\n\n    def all_file_paths(self):\n        # type: () -> List[str]\n        with self.session_scope() as session:\n            paths = [f[0] for f in session.query(self.Function.file).distinct()\n                     if not is_ipython_cell(f[0])]\n        paths.sort()\n        if IPYTHON_FILE_PATH in paths:\n            paths.remove(IPYTHON_FILE_PATH)\n            paths.insert(0, IPYTHON_FILE_PATH)\n        return paths\n\n    def clear(self):\n        for model in [self.Call, self.Function, self._KeyValue]:\n            if self.table_exists(model):\n                model.__table__.drop(self.engine)\n\n    @contextmanager\n    def session_scope(self):\n        \"\"\"Provide a transactional scope around a series of operations.\"\"\"\n        session = self.Session()\n        try:\n            yield session\n            session.commit()\n        except:\n            session.rollback()\n            raise\n        finally:\n            session.close()\n\n    def provide_session(self, func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            with self.session_scope() as session:\n                return func(session, *args, **kwargs)\n\n        return retry_db(wrapper)"
        ],
        [
            "LOAD_NAME",
            "retry"
        ],
        [
            "LOAD_NAME",
            "InterfaceError"
        ],
        [
            "LOAD_NAME",
            "OperationalError"
        ],
        [
            "LOAD_NAME",
            "InternalError"
        ],
        [
            "LOAD_NAME",
            "ProgrammingError"
        ],
        [
            "CALL",
            "retry(3, (InterfaceError, OperationalError, InternalError, ProgrammingError))"
        ],
        [
            "STORE_NAME",
            "retry_db"
        ],
        [
            "STORE_NAME",
            "    def __init__(self, db_uri=None, _skip_version_check=False):\n        self.db_uri = db_uri = (\n                db_uri\n                or os.environ.get('BIRDSEYE_DB')\n                or os.path.join(os.path.expanduser('~'),\n                                '.birdseye.db'))\n\n        kwargs = dict(\n            pool_recycle=280,\n            echo=False,  # for convenience when debugging\n        )\n\n        try:\n            engine = create_engine(db_uri, **kwargs)\n        except ArgumentError:\n            db_uri = 'sqlite:///' + db_uri\n            engine = create_engine(db_uri, **kwargs)\n\n        self.engine = engine\n\n        self.Session = sessionmaker(bind=engine)\n\n        class Base(object):\n            @declared_attr\n            def __tablename__(cls):\n                return cls.__name__.lower()\n\n        Base = declarative_base(cls=Base)  # type: ignore\n\n        class KeyValue(Base):\n            key = Column(String(50), primary_key=True)\n            value = Column(Text)\n\n        db_self = self\n\n        class KeyValueStore(object):\n            def __getitem__(self, item):\n                with db_self.session_scope() as session:\n                    return (session\n                            .query(KeyValue.value)\n                            .filter_by(key=item)\n                            .scalar())\n\n            def __setitem__(self, key, value):\n                with db_self.session_scope() as session:\n                    session.query(KeyValue).filter_by(key=key).delete()\n                    session.add(KeyValue(key=key, value=str(value)))\n\n            __getattr__ = __getitem__\n            __setattr__ = __setitem__\n\n        LongText = LONGTEXT if engine.name == 'mysql' else Text\n\n        class Call(Base):\n            id = Column(String(length=32), primary_key=True)\n            function_id = Column(Integer, ForeignKey('function.id'), index=True)\n            function = relationship('Function', backref=backref('calls', lazy='dynamic'))\n            arguments = Column(Text)\n            return_value = Column(Text)\n            exception = Column(Text)\n            traceback = Column(Text)\n            data = Column(LongText)\n            start_time = Column(DateTime, index=True)\n\n            @property\n            def pretty_start_time(self):\n                return self._pretty_time(self.start_time)\n\n            @staticmethod\n            def _pretty_time(dt):\n                if not dt:\n                    return ''\n                return Markup('%s (%s)' % (\n                    dt.strftime('%Y-%m-%d&nbsp;%H:%M:%S'),\n                    naturaltime(dt)))\n\n            @property\n            def state_icon(self):\n                return Markup('<span class=\"glyphicon glyphicon-%s\" '\n                              'style=\"color: %s\"></span>' % (\n                                  ('ok', 'green') if self.success else\n                                  ('remove', 'red')))\n\n            @property\n            def success(self):\n                if self.exception:\n                    assert self.traceback\n                    assert self.return_value == 'None'\n                    return False\n                else:\n                    assert not self.traceback\n                    return True\n\n            @property\n            def result(self):\n                if self.success:\n                    return str(self.return_value)\n                else:\n                    return str(self.exception)\n\n            @property\n            def arguments_list(self):\n                return json.loads(self.arguments)\n\n            @property\n            def parsed_data(self):\n                return json.loads(self.data)\n\n            @staticmethod\n            def basic_dict(call):\n                return dict(arguments=call.arguments_list,\n                            **select_attrs(call, 'id function_id return_value traceback '\n                                                 'exception start_time'))\n\n            basic_columns = (id, function_id, return_value,\n                             traceback, exception, start_time, arguments)\n\n        class Function(Base):\n            id = Column(Integer, Sequence('function_id_seq'), primary_key=True)\n            file = Column(Text)\n            name = Column(Text)\n            type = Column(Text)  # function or module\n            html_body = Column(LongText)\n            lineno = Column(Integer)\n            data = Column(LongText)\n            hash = Column(String(length=64), index=True)\n            body_hash = Column(String(length=64), index=True)\n\n            __table_args__ = (\n                UniqueConstraint('hash',\n                                 name='everything_unique'),\n                Index('idx_file', 'file', mysql_length=256),\n                Index('idx_name', 'name', mysql_length=32),\n            )\n\n            @property\n            def parsed_data(self):\n                return json.loads(self.data)\n\n            @staticmethod\n            def basic_dict(func):\n                return select_attrs(func, 'file name lineno hash body_hash type')\n\n            basic_columns = (file, name, lineno, hash, body_hash, type)\n\n        self.Call = Call\n        self.Function = Function\n        self._KeyValue = KeyValue\n\n        self.key_value_store = kv = KeyValueStore()\n\n        if _skip_version_check:\n            return\n\n        if not self.table_exists(Function):\n            Base.metadata.create_all(engine)\n            kv.version = DB_VERSION\n        elif not self.table_exists(KeyValue) or int(kv.version) < DB_VERSION:\n            sys.exit('The birdseye database schema is out of date. '\n                     'Run \"python -m birdseye.clear_db\" to delete the existing tables.')"
        ],
        [
            "STORE_NAME",
            "    def table_exists(self, table):\n        return self.engine.dialect.has_table(self.engine, table.__name__)"
        ],
        [
            "STORE_NAME",
            "    def all_file_paths(self):\n        # type: () -> List[str]\n        with self.session_scope() as session:\n            paths = [f[0] for f in session.query(self.Function.file).distinct()\n                     if not is_ipython_cell(f[0])]\n        paths.sort()\n        if IPYTHON_FILE_PATH in paths:\n            paths.remove(IPYTHON_FILE_PATH)\n            paths.insert(0, IPYTHON_FILE_PATH)\n        return paths"
        ],
        [
            "STORE_NAME",
            "    def clear(self):\n        for model in [self.Call, self.Function, self._KeyValue]:\n            if self.table_exists(model):\n                model.__table__.drop(self.engine)"
        ],
        [
            "LOAD_NAME",
            "contextmanager"
        ],
        [
            "CALL",
            "contextmanager"
        ],
        [
            "STORE_NAME",
            "    @contextmanager\n    def session_scope(self):\n        \"\"\"Provide a transactional scope around a series of operations.\"\"\"\n        session = self.Session()\n        try:\n            yield session\n            session.commit()\n        except:\n            session.rollback()\n            raise\n        finally:\n            session.close()"
        ],
        [
            "STORE_NAME",
            "    def provide_session(self, func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            with self.session_scope() as session:\n                return func(session, *args, **kwargs)\n\n        return retry_db(wrapper)"
        ],
        [
            "LOAD_FAST",
            "db_uri"
        ],
        [
            "LOAD_GLOBAL",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.environ"
        ],
        [
            "LOAD_METHOD",
            "os.environ.get"
        ],
        [
            "CALL",
            "os.environ.get('BIRDSEYE_DB')"
        ],
        [
            "LOAD_GLOBAL",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.join"
        ],
        [
            "LOAD_GLOBAL",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.expanduser"
        ],
        [
            "CALL",
            "os.path.expanduser('~')"
        ],
        [
            "CALL",
            "os.path.join(os.path.expanduser('~'),\n                                '.birdseye.db')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.db_uri"
        ],
        [
            "STORE_FAST",
            "db_uri"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "CALL",
            "dict(\n            pool_recycle=280,\n            echo=False,  # for convenience when debugging\n        )"
        ],
        [
            "STORE_FAST",
            "kwargs"
        ],
        [
            "LOAD_GLOBAL",
            "create_engine"
        ],
        [
            "LOAD_FAST",
            "db_uri"
        ],
        [
            "LOAD_FAST",
            "kwargs"
        ],
        [
            "CALL_FUNCTION_EX",
            "create_engine(db_uri, **kwargs)"
        ],
        [
            "STORE_FAST",
            "engine"
        ],
        [
            "LOAD_GLOBAL",
            "ArgumentError"
        ],
        [
            "LOAD_FAST",
            "db_uri"
        ],
        [
            "BINARY_OP",
            "'sqlite:///' + db_uri"
        ],
        [
            "STORE_FAST",
            "db_uri"
        ],
        [
            "LOAD_GLOBAL",
            "create_engine"
        ],
        [
            "LOAD_FAST",
            "db_uri"
        ],
        [
            "LOAD_FAST",
            "kwargs"
        ],
        [
            "CALL_FUNCTION_EX",
            "create_engine(db_uri, **kwargs)"
        ],
        [
            "STORE_FAST",
            "engine"
        ],
        [
            "LOAD_FAST",
            "engine"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.engine"
        ],
        [
            "LOAD_GLOBAL",
            "sessionmaker"
        ],
        [
            "LOAD_FAST",
            "engine"
        ],
        [
            "CALL",
            "sessionmaker(bind=engine)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.Session"
        ],
        [
            "LOAD_GLOBAL",
            "object"
        ],
        [
            "CALL",
            "        class Base(object):\n            @declared_attr\n            def __tablename__(cls):\n                return cls.__name__.lower()"
        ],
        [
            "STORE_FAST",
            "        class Base(object):\n            @declared_attr\n            def __tablename__(cls):\n                return cls.__name__.lower()"
        ],
        [
            "LOAD_GLOBAL",
            "declarative_base"
        ],
        [
            "LOAD_FAST",
            "Base"
        ],
        [
            "CALL",
            "declarative_base(cls=Base)"
        ],
        [
            "STORE_FAST",
            "Base"
        ],
        [
            "LOAD_FAST",
            "Base"
        ],
        [
            "CALL",
            "        class KeyValue(Base):\n            key = Column(String(50), primary_key=True)\n            value = Column(Text)"
        ],
        [
            "STORE_DEREF",
            "        class KeyValue(Base):\n            key = Column(String(50), primary_key=True)\n            value = Column(Text)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_DEREF",
            "db_self"
        ],
        [
            "LOAD_GLOBAL",
            "object"
        ],
        [
            "CALL",
            "        class KeyValueStore(object):\n            def __getitem__(self, item):\n                with db_self.session_scope() as session:\n                    return (session\n                            .query(KeyValue.value)\n                            .filter_by(key=item)\n                            .scalar())\n\n            def __setitem__(self, key, value):\n                with db_self.session_scope() as session:\n                    session.query(KeyValue).filter_by(key=key).delete()\n                    session.add(KeyValue(key=key, value=str(value)))\n\n            __getattr__ = __getitem__\n            __setattr__ = __setitem__"
        ],
        [
            "STORE_FAST",
            "        class KeyValueStore(object):\n            def __getitem__(self, item):\n                with db_self.session_scope() as session:\n                    return (session\n                            .query(KeyValue.value)\n                            .filter_by(key=item)\n                            .scalar())\n\n            def __setitem__(self, key, value):\n                with db_self.session_scope() as session:\n                    session.query(KeyValue).filter_by(key=key).delete()\n                    session.add(KeyValue(key=key, value=str(value)))\n\n            __getattr__ = __getitem__\n            __setattr__ = __setitem__"
        ],
        [
            "LOAD_FAST",
            "engine"
        ],
        [
            "LOAD_ATTR",
            "engine.name"
        ],
        [
            "COMPARE_OP",
            "engine.name == 'mysql'"
        ],
        [
            "LOAD_GLOBAL",
            "LONGTEXT"
        ],
        [
            "LOAD_GLOBAL",
            "Text"
        ],
        [
            "STORE_DEREF",
            "LongText"
        ],
        [
            "LOAD_FAST",
            "Base"
        ],
        [
            "CALL",
            "        class Call(Base):\n            id = Column(String(length=32), primary_key=True)\n            function_id = Column(Integer, ForeignKey('function.id'), index=True)\n            function = relationship('Function', backref=backref('calls', lazy='dynamic'))\n            arguments = Column(Text)\n            return_value = Column(Text)\n            exception = Column(Text)\n            traceback = Column(Text)\n            data = Column(LongText)\n            start_time = Column(DateTime, index=True)\n\n            @property\n            def pretty_start_time(self):\n                return self._pretty_time(self.start_time)\n\n            @staticmethod\n            def _pretty_time(dt):\n                if not dt:\n                    return ''\n                return Markup('%s (%s)' % (\n                    dt.strftime('%Y-%m-%d&nbsp;%H:%M:%S'),\n                    naturaltime(dt)))\n\n            @property\n            def state_icon(self):\n                return Markup('<span class=\"glyphicon glyphicon-%s\" '\n                              'style=\"color: %s\"></span>' % (\n                                  ('ok', 'green') if self.success else\n                                  ('remove', 'red')))\n\n            @property\n            def success(self):\n                if self.exception:\n                    assert self.traceback\n                    assert self.return_value == 'None'\n                    return False\n                else:\n                    assert not self.traceback\n                    return True\n\n            @property\n            def result(self):\n                if self.success:\n                    return str(self.return_value)\n                else:\n                    return str(self.exception)\n\n            @property\n            def arguments_list(self):\n                return json.loads(self.arguments)\n\n            @property\n            def parsed_data(self):\n                return json.loads(self.data)\n\n            @staticmethod\n            def basic_dict(call):\n                return dict(arguments=call.arguments_list,\n                            **select_attrs(call, 'id function_id return_value traceback '\n                                                 'exception start_time'))\n\n            basic_columns = (id, function_id, return_value,\n                             traceback, exception, start_time, arguments)"
        ],
        [
            "STORE_FAST",
            "        class Call(Base):\n            id = Column(String(length=32), primary_key=True)\n            function_id = Column(Integer, ForeignKey('function.id'), index=True)\n            function = relationship('Function', backref=backref('calls', lazy='dynamic'))\n            arguments = Column(Text)\n            return_value = Column(Text)\n            exception = Column(Text)\n            traceback = Column(Text)\n            data = Column(LongText)\n            start_time = Column(DateTime, index=True)\n\n            @property\n            def pretty_start_time(self):\n                return self._pretty_time(self.start_time)\n\n            @staticmethod\n            def _pretty_time(dt):\n                if not dt:\n                    return ''\n                return Markup('%s (%s)' % (\n                    dt.strftime('%Y-%m-%d&nbsp;%H:%M:%S'),\n                    naturaltime(dt)))\n\n            @property\n            def state_icon(self):\n                return Markup('<span class=\"glyphicon glyphicon-%s\" '\n                              'style=\"color: %s\"></span>' % (\n                                  ('ok', 'green') if self.success else\n                                  ('remove', 'red')))\n\n            @property\n            def success(self):\n                if self.exception:\n                    assert self.traceback\n                    assert self.return_value == 'None'\n                    return False\n                else:\n                    assert not self.traceback\n                    return True\n\n            @property\n            def result(self):\n                if self.success:\n                    return str(self.return_value)\n                else:\n                    return str(self.exception)\n\n            @property\n            def arguments_list(self):\n                return json.loads(self.arguments)\n\n            @property\n            def parsed_data(self):\n                return json.loads(self.data)\n\n            @staticmethod\n            def basic_dict(call):\n                return dict(arguments=call.arguments_list,\n                            **select_attrs(call, 'id function_id return_value traceback '\n                                                 'exception start_time'))\n\n            basic_columns = (id, function_id, return_value,\n                             traceback, exception, start_time, arguments)"
        ],
        [
            "LOAD_FAST",
            "Base"
        ],
        [
            "CALL",
            "        class Function(Base):\n            id = Column(Integer, Sequence('function_id_seq'), primary_key=True)\n            file = Column(Text)\n            name = Column(Text)\n            type = Column(Text)  # function or module\n            html_body = Column(LongText)\n            lineno = Column(Integer)\n            data = Column(LongText)\n            hash = Column(String(length=64), index=True)\n            body_hash = Column(String(length=64), index=True)\n\n            __table_args__ = (\n                UniqueConstraint('hash',\n                                 name='everything_unique'),\n                Index('idx_file', 'file', mysql_length=256),\n                Index('idx_name', 'name', mysql_length=32),\n            )\n\n            @property\n            def parsed_data(self):\n                return json.loads(self.data)\n\n            @staticmethod\n            def basic_dict(func):\n                return select_attrs(func, 'file name lineno hash body_hash type')\n\n            basic_columns = (file, name, lineno, hash, body_hash, type)"
        ],
        [
            "STORE_FAST",
            "        class Function(Base):\n            id = Column(Integer, Sequence('function_id_seq'), primary_key=True)\n            file = Column(Text)\n            name = Column(Text)\n            type = Column(Text)  # function or module\n            html_body = Column(LongText)\n            lineno = Column(Integer)\n            data = Column(LongText)\n            hash = Column(String(length=64), index=True)\n            body_hash = Column(String(length=64), index=True)\n\n            __table_args__ = (\n                UniqueConstraint('hash',\n                                 name='everything_unique'),\n                Index('idx_file', 'file', mysql_length=256),\n                Index('idx_name', 'name', mysql_length=32),\n            )\n\n            @property\n            def parsed_data(self):\n                return json.loads(self.data)\n\n            @staticmethod\n            def basic_dict(func):\n                return select_attrs(func, 'file name lineno hash body_hash type')\n\n            basic_columns = (file, name, lineno, hash, body_hash, type)"
        ],
        [
            "LOAD_FAST",
            "Call"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.Call"
        ],
        [
            "LOAD_FAST",
            "Function"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.Function"
        ],
        [
            "LOAD_DEREF",
            "KeyValue"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._KeyValue"
        ],
        [
            "LOAD_FAST",
            "KeyValueStore"
        ],
        [
            "CALL",
            "KeyValueStore()"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.key_value_store"
        ],
        [
            "STORE_FAST",
            "kv"
        ],
        [
            "LOAD_FAST",
            "_skip_version_check"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.table_exists"
        ],
        [
            "LOAD_FAST",
            "Function"
        ],
        [
            "CALL",
            "self.table_exists(Function)"
        ],
        [
            "LOAD_FAST",
            "Base"
        ],
        [
            "LOAD_ATTR",
            "Base.metadata"
        ],
        [
            "LOAD_METHOD",
            "Base.metadata.create_all"
        ],
        [
            "LOAD_FAST",
            "engine"
        ],
        [
            "CALL",
            "Base.metadata.create_all(engine)"
        ],
        [
            "LOAD_GLOBAL",
            "DB_VERSION"
        ],
        [
            "LOAD_FAST",
            "kv"
        ],
        [
            "STORE_ATTR",
            "kv.version"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.table_exists"
        ],
        [
            "LOAD_DEREF",
            "KeyValue"
        ],
        [
            "CALL",
            "self.table_exists(KeyValue)"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "LOAD_FAST",
            "kv"
        ],
        [
            "LOAD_ATTR",
            "kv.version"
        ],
        [
            "CALL",
            "int(kv.version)"
        ],
        [
            "LOAD_GLOBAL",
            "DB_VERSION"
        ],
        [
            "COMPARE_OP",
            "int(kv.version) < DB_VERSION"
        ],
        [
            "LOAD_GLOBAL",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.exit"
        ],
        [
            "CALL",
            "sys.exit('The birdseye database schema is out of date. '\n                     'Run \"python -m birdseye.clear_db\" to delete the existing tables.')"
        ],
        [
            "LOAD_NAME",
            "declared_attr"
        ],
        [
            "CALL",
            "declared_attr"
        ],
        [
            "STORE_NAME",
            "            @declared_attr\n            def __tablename__(cls):\n                return cls.__name__.lower()"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_ATTR",
            "cls.__name__"
        ],
        [
            "LOAD_METHOD",
            "cls.__name__.lower"
        ],
        [
            "CALL",
            "cls.__name__.lower()"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "String"
        ],
        [
            "CALL",
            "String(50)"
        ],
        [
            "CALL",
            "Column(String(50), primary_key=True)"
        ],
        [
            "STORE_NAME",
            "key"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "Text"
        ],
        [
            "CALL",
            "Column(Text)"
        ],
        [
            "STORE_NAME",
            "value"
        ],
        [
            "STORE_NAME",
            "            def __getitem__(self, item):\n                with db_self.session_scope() as session:\n                    return (session\n                            .query(KeyValue.value)\n                            .filter_by(key=item)\n                            .scalar())"
        ],
        [
            "STORE_NAME",
            "            def __setitem__(self, key, value):\n                with db_self.session_scope() as session:\n                    session.query(KeyValue).filter_by(key=key).delete()\n                    session.add(KeyValue(key=key, value=str(value)))"
        ],
        [
            "LOAD_NAME",
            "__getitem__"
        ],
        [
            "STORE_NAME",
            "__getattr__"
        ],
        [
            "LOAD_NAME",
            "__setitem__"
        ],
        [
            "STORE_NAME",
            "__setattr__"
        ],
        [
            "LOAD_DEREF",
            "db_self"
        ],
        [
            "LOAD_METHOD",
            "db_self.session_scope"
        ],
        [
            "CALL",
            "db_self.session_scope()"
        ],
        [
            "STORE_FAST",
            "session"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session\n                            .query"
        ],
        [
            "LOAD_DEREF",
            "KeyValue"
        ],
        [
            "LOAD_ATTR",
            "KeyValue.value"
        ],
        [
            "CALL",
            "session\n                            .query(KeyValue.value)"
        ],
        [
            "LOAD_METHOD",
            "session\n                            .query(KeyValue.value)\n                            .filter_by"
        ],
        [
            "LOAD_FAST",
            "item"
        ],
        [
            "CALL",
            "session\n                            .query(KeyValue.value)\n                            .filter_by(key=item)"
        ],
        [
            "LOAD_METHOD",
            "session\n                            .query(KeyValue.value)\n                            .filter_by(key=item)\n                            .scalar"
        ],
        [
            "CALL",
            "session\n                            .query(KeyValue.value)\n                            .filter_by(key=item)\n                            .scalar()"
        ],
        [
            "CALL",
            "                with db_self.session_scope() as session:\n                    return (session\n                            .query(KeyValue.value)\n                            .filter_by(key=item)\n                            .scalar())"
        ],
        [
            "LOAD_DEREF",
            "db_self"
        ],
        [
            "LOAD_METHOD",
            "db_self.session_scope"
        ],
        [
            "CALL",
            "db_self.session_scope()"
        ],
        [
            "STORE_FAST",
            "session"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "LOAD_DEREF",
            "KeyValue"
        ],
        [
            "CALL",
            "session.query(KeyValue)"
        ],
        [
            "LOAD_METHOD",
            "session.query(KeyValue).filter_by"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "CALL",
            "session.query(KeyValue).filter_by(key=key)"
        ],
        [
            "LOAD_METHOD",
            "session.query(KeyValue).filter_by(key=key).delete"
        ],
        [
            "CALL",
            "session.query(KeyValue).filter_by(key=key).delete()"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.add"
        ],
        [
            "LOAD_DEREF",
            "KeyValue"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "CALL",
            "str(value)"
        ],
        [
            "CALL",
            "KeyValue(key=key, value=str(value))"
        ],
        [
            "CALL",
            "session.add(KeyValue(key=key, value=str(value)))"
        ],
        [
            "CALL",
            "                with db_self.session_scope() as session:\n                    session.query(KeyValue).filter_by(key=key).delete()\n                    session.add(KeyValue(key=key, value=str(value)))"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "String"
        ],
        [
            "CALL",
            "String(length=32)"
        ],
        [
            "CALL",
            "Column(String(length=32), primary_key=True)"
        ],
        [
            "STORE_NAME",
            "id"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "Integer"
        ],
        [
            "LOAD_NAME",
            "ForeignKey"
        ],
        [
            "CALL",
            "ForeignKey('function.id')"
        ],
        [
            "CALL",
            "Column(Integer, ForeignKey('function.id'), index=True)"
        ],
        [
            "STORE_NAME",
            "function_id"
        ],
        [
            "LOAD_NAME",
            "relationship"
        ],
        [
            "LOAD_NAME",
            "backref"
        ],
        [
            "CALL",
            "backref('calls', lazy='dynamic')"
        ],
        [
            "CALL",
            "relationship('Function', backref=backref('calls', lazy='dynamic'))"
        ],
        [
            "STORE_NAME",
            "function"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "Text"
        ],
        [
            "CALL",
            "Column(Text)"
        ],
        [
            "STORE_NAME",
            "arguments"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "Text"
        ],
        [
            "CALL",
            "Column(Text)"
        ],
        [
            "STORE_NAME",
            "return_value"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "Text"
        ],
        [
            "CALL",
            "Column(Text)"
        ],
        [
            "STORE_NAME",
            "exception"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "Text"
        ],
        [
            "CALL",
            "Column(Text)"
        ],
        [
            "STORE_NAME",
            "traceback"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_CLASSDEREF",
            "LongText"
        ],
        [
            "CALL",
            "Column(LongText)"
        ],
        [
            "STORE_NAME",
            "data"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "DateTime"
        ],
        [
            "CALL",
            "Column(DateTime, index=True)"
        ],
        [
            "STORE_NAME",
            "start_time"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "            @property\n            def pretty_start_time(self):\n                return self._pretty_time(self.start_time)"
        ],
        [
            "LOAD_NAME",
            "staticmethod"
        ],
        [
            "CALL",
            "staticmethod"
        ],
        [
            "STORE_NAME",
            "            @staticmethod\n            def _pretty_time(dt):\n                if not dt:\n                    return ''\n                return Markup('%s (%s)' % (\n                    dt.strftime('%Y-%m-%d&nbsp;%H:%M:%S'),\n                    naturaltime(dt)))"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "            @property\n            def state_icon(self):\n                return Markup('<span class=\"glyphicon glyphicon-%s\" '\n                              'style=\"color: %s\"></span>' % (\n                                  ('ok', 'green') if self.success else\n                                  ('remove', 'red')))"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "            @property\n            def success(self):\n                if self.exception:\n                    assert self.traceback\n                    assert self.return_value == 'None'\n                    return False\n                else:\n                    assert not self.traceback\n                    return True"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "            @property\n            def result(self):\n                if self.success:\n                    return str(self.return_value)\n                else:\n                    return str(self.exception)"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "            @property\n            def arguments_list(self):\n                return json.loads(self.arguments)"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "            @property\n            def parsed_data(self):\n                return json.loads(self.data)"
        ],
        [
            "LOAD_NAME",
            "staticmethod"
        ],
        [
            "CALL",
            "staticmethod"
        ],
        [
            "STORE_NAME",
            "            @staticmethod\n            def basic_dict(call):\n                return dict(arguments=call.arguments_list,\n                            **select_attrs(call, 'id function_id return_value traceback '\n                                                 'exception start_time'))"
        ],
        [
            "LOAD_NAME",
            "id"
        ],
        [
            "LOAD_NAME",
            "function_id"
        ],
        [
            "LOAD_NAME",
            "return_value"
        ],
        [
            "LOAD_NAME",
            "traceback"
        ],
        [
            "LOAD_NAME",
            "exception"
        ],
        [
            "LOAD_NAME",
            "start_time"
        ],
        [
            "LOAD_NAME",
            "arguments"
        ],
        [
            "STORE_NAME",
            "basic_columns"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._pretty_time"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.start_time"
        ],
        [
            "CALL",
            "self._pretty_time(self.start_time)"
        ],
        [
            "LOAD_FAST",
            "dt"
        ],
        [
            "LOAD_GLOBAL",
            "Markup"
        ],
        [
            "LOAD_FAST",
            "dt"
        ],
        [
            "LOAD_METHOD",
            "dt.strftime"
        ],
        [
            "CALL",
            "dt.strftime('%Y-%m-%d&nbsp;%H:%M:%S')"
        ],
        [
            "LOAD_GLOBAL",
            "naturaltime"
        ],
        [
            "LOAD_FAST",
            "dt"
        ],
        [
            "CALL",
            "naturaltime(dt)"
        ],
        [
            "BUILD_STRING",
            "'%s (%s)' % (\n                    dt.strftime('%Y-%m-%d&nbsp;%H:%M:%S'),\n                    naturaltime(dt))"
        ],
        [
            "CALL",
            "Markup('%s (%s)' % (\n                    dt.strftime('%Y-%m-%d&nbsp;%H:%M:%S'),\n                    naturaltime(dt)))"
        ],
        [
            "LOAD_GLOBAL",
            "Markup"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.success"
        ],
        [
            "BINARY_OP",
            "'<span class=\"glyphicon glyphicon-%s\" '\n                              'style=\"color: %s\"></span>' % (\n                                  ('ok', 'green') if self.success else\n                                  ('remove', 'red'))"
        ],
        [
            "CALL",
            "Markup('<span class=\"glyphicon glyphicon-%s\" '\n                              'style=\"color: %s\"></span>' % (\n                                  ('ok', 'green') if self.success else\n                                  ('remove', 'red')))"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.exception"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.traceback"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.return_value"
        ],
        [
            "COMPARE_OP",
            "self.return_value == 'None'"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.traceback"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.success"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.return_value"
        ],
        [
            "CALL",
            "str(self.return_value)"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.exception"
        ],
        [
            "CALL",
            "str(self.exception)"
        ],
        [
            "LOAD_GLOBAL",
            "json"
        ],
        [
            "LOAD_ATTR",
            "json.loads"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.arguments"
        ],
        [
            "CALL",
            "json.loads(self.arguments)"
        ],
        [
            "LOAD_GLOBAL",
            "json"
        ],
        [
            "LOAD_ATTR",
            "json.loads"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.data"
        ],
        [
            "CALL",
            "json.loads(self.data)"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_FAST",
            "call"
        ],
        [
            "LOAD_ATTR",
            "call.arguments_list"
        ],
        [
            "LOAD_GLOBAL",
            "select_attrs"
        ],
        [
            "LOAD_FAST",
            "call"
        ],
        [
            "CALL",
            "select_attrs(call, 'id function_id return_value traceback '\n                                                 'exception start_time')"
        ],
        [
            "CALL_FUNCTION_EX",
            "dict(arguments=call.arguments_list,\n                            **select_attrs(call, 'id function_id return_value traceback '\n                                                 'exception start_time'))"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "Integer"
        ],
        [
            "LOAD_NAME",
            "Sequence"
        ],
        [
            "CALL",
            "Sequence('function_id_seq')"
        ],
        [
            "CALL",
            "Column(Integer, Sequence('function_id_seq'), primary_key=True)"
        ],
        [
            "STORE_NAME",
            "id"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "Text"
        ],
        [
            "CALL",
            "Column(Text)"
        ],
        [
            "STORE_NAME",
            "file"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "Text"
        ],
        [
            "CALL",
            "Column(Text)"
        ],
        [
            "STORE_NAME",
            "name"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "Text"
        ],
        [
            "CALL",
            "Column(Text)"
        ],
        [
            "STORE_NAME",
            "type"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_CLASSDEREF",
            "LongText"
        ],
        [
            "CALL",
            "Column(LongText)"
        ],
        [
            "STORE_NAME",
            "html_body"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "Integer"
        ],
        [
            "CALL",
            "Column(Integer)"
        ],
        [
            "STORE_NAME",
            "lineno"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_CLASSDEREF",
            "LongText"
        ],
        [
            "CALL",
            "Column(LongText)"
        ],
        [
            "STORE_NAME",
            "data"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "String"
        ],
        [
            "CALL",
            "String(length=64)"
        ],
        [
            "CALL",
            "Column(String(length=64), index=True)"
        ],
        [
            "STORE_NAME",
            "hash"
        ],
        [
            "LOAD_NAME",
            "Column"
        ],
        [
            "LOAD_NAME",
            "String"
        ],
        [
            "CALL",
            "String(length=64)"
        ],
        [
            "CALL",
            "Column(String(length=64), index=True)"
        ],
        [
            "STORE_NAME",
            "body_hash"
        ],
        [
            "LOAD_NAME",
            "UniqueConstraint"
        ],
        [
            "CALL",
            "UniqueConstraint('hash',\n                                 name='everything_unique')"
        ],
        [
            "LOAD_NAME",
            "Index"
        ],
        [
            "CALL",
            "Index('idx_file', 'file', mysql_length=256)"
        ],
        [
            "LOAD_NAME",
            "Index"
        ],
        [
            "CALL",
            "Index('idx_name', 'name', mysql_length=32)"
        ],
        [
            "STORE_NAME",
            "__table_args__"
        ],
        [
            "LOAD_NAME",
            "property"
        ],
        [
            "CALL",
            "property"
        ],
        [
            "STORE_NAME",
            "            @property\n            def parsed_data(self):\n                return json.loads(self.data)"
        ],
        [
            "LOAD_NAME",
            "staticmethod"
        ],
        [
            "CALL",
            "staticmethod"
        ],
        [
            "STORE_NAME",
            "            @staticmethod\n            def basic_dict(func):\n                return select_attrs(func, 'file name lineno hash body_hash type')"
        ],
        [
            "LOAD_NAME",
            "file"
        ],
        [
            "LOAD_NAME",
            "name"
        ],
        [
            "LOAD_NAME",
            "lineno"
        ],
        [
            "LOAD_NAME",
            "hash"
        ],
        [
            "LOAD_NAME",
            "body_hash"
        ],
        [
            "LOAD_NAME",
            "type"
        ],
        [
            "STORE_NAME",
            "basic_columns"
        ],
        [
            "LOAD_GLOBAL",
            "json"
        ],
        [
            "LOAD_ATTR",
            "json.loads"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.data"
        ],
        [
            "CALL",
            "json.loads(self.data)"
        ],
        [
            "LOAD_GLOBAL",
            "select_attrs"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "CALL",
            "select_attrs(func, 'file name lineno hash body_hash type')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.engine"
        ],
        [
            "LOAD_ATTR",
            "self.engine.dialect"
        ],
        [
            "LOAD_METHOD",
            "self.engine.dialect.has_table"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.engine"
        ],
        [
            "LOAD_FAST",
            "table"
        ],
        [
            "LOAD_ATTR",
            "table.__name__"
        ],
        [
            "CALL",
            "self.engine.dialect.has_table(self.engine, table.__name__)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.session_scope"
        ],
        [
            "CALL",
            "self.session_scope()"
        ],
        [
            "STORE_FAST",
            "session"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.Function"
        ],
        [
            "LOAD_ATTR",
            "self.Function.file"
        ],
        [
            "CALL",
            "session.query(self.Function.file)"
        ],
        [
            "LOAD_METHOD",
            "session.query(self.Function.file).distinct"
        ],
        [
            "CALL",
            "session.query(self.Function.file).distinct()"
        ],
        [
            "CALL",
            "[f[0] for f in session.query(self.Function.file).distinct()\n                     if not is_ipython_cell(f[0])]"
        ],
        [
            "STORE_FAST",
            "paths"
        ],
        [
            "CALL",
            "        with self.session_scope() as session:\n            paths = [f[0] for f in session.query(self.Function.file).distinct()\n                     if not is_ipython_cell(f[0])]"
        ],
        [
            "LOAD_FAST",
            "paths"
        ],
        [
            "LOAD_METHOD",
            "paths.sort"
        ],
        [
            "CALL",
            "paths.sort()"
        ],
        [
            "LOAD_GLOBAL",
            "IPYTHON_FILE_PATH"
        ],
        [
            "LOAD_FAST",
            "paths"
        ],
        [
            "CONTAINS_OP",
            "IPYTHON_FILE_PATH in paths"
        ],
        [
            "LOAD_FAST",
            "paths"
        ],
        [
            "LOAD_METHOD",
            "paths.remove"
        ],
        [
            "LOAD_GLOBAL",
            "IPYTHON_FILE_PATH"
        ],
        [
            "CALL",
            "paths.remove(IPYTHON_FILE_PATH)"
        ],
        [
            "LOAD_FAST",
            "paths"
        ],
        [
            "LOAD_METHOD",
            "paths.insert"
        ],
        [
            "LOAD_GLOBAL",
            "IPYTHON_FILE_PATH"
        ],
        [
            "CALL",
            "paths.insert(0, IPYTHON_FILE_PATH)"
        ],
        [
            "LOAD_FAST",
            "paths"
        ],
        [
            "LOAD_FAST",
            "[f[0] for f in session.query(self.Function.file).distinct()\n                     if not is_ipython_cell(f[0])]"
        ],
        [
            "STORE_FAST",
            "f"
        ],
        [
            "LOAD_GLOBAL",
            "is_ipython_cell"
        ],
        [
            "LOAD_FAST",
            "f"
        ],
        [
            "BINARY_SUBSCR",
            "f[0]"
        ],
        [
            "CALL",
            "is_ipython_cell(f[0])"
        ],
        [
            "LOAD_FAST",
            "f"
        ],
        [
            "BINARY_SUBSCR",
            "f[0]"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.Call"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.Function"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._KeyValue"
        ],
        [
            "STORE_FAST",
            "model"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.table_exists"
        ],
        [
            "LOAD_FAST",
            "model"
        ],
        [
            "CALL",
            "self.table_exists(model)"
        ],
        [
            "LOAD_FAST",
            "model"
        ],
        [
            "LOAD_ATTR",
            "model.__table__"
        ],
        [
            "LOAD_METHOD",
            "model.__table__.drop"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.engine"
        ],
        [
            "CALL",
            "model.__table__.drop(self.engine)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.Session"
        ],
        [
            "CALL",
            "self.Session()"
        ],
        [
            "STORE_FAST",
            "session"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.commit"
        ],
        [
            "CALL",
            "session.commit()"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.rollback"
        ],
        [
            "CALL",
            "session.rollback()"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.close"
        ],
        [
            "CALL",
            "session.close()"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.close"
        ],
        [
            "CALL",
            "session.close()"
        ],
        [
            "LOAD_GLOBAL",
            "functools"
        ],
        [
            "LOAD_ATTR",
            "functools.wraps"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "CALL",
            "functools.wraps(func)"
        ],
        [
            "CALL",
            "functools.wraps(func)"
        ],
        [
            "STORE_FAST",
            "        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            with self.session_scope() as session:\n                return func(session, *args, **kwargs)"
        ],
        [
            "LOAD_GLOBAL",
            "retry_db"
        ],
        [
            "LOAD_FAST",
            "wrapper"
        ],
        [
            "CALL",
            "retry_db(wrapper)"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.session_scope"
        ],
        [
            "CALL",
            "self.session_scope()"
        ],
        [
            "STORE_FAST",
            "session"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_FAST",
            "kwargs"
        ],
        [
            "CALL_FUNCTION_EX",
            "func(session, *args, **kwargs)"
        ],
        [
            "CALL",
            "            with self.session_scope() as session:\n                return func(session, *args, **kwargs)"
        ]
    ],
    "executing.py": [
        [
            "STORE_NAME",
            "\"\"\"\nGet information about what a frame is currently doing. Typical usage:\n\n    import executing\n\n    node = executing.Source.executing(frame).node\n    # node will be an AST node or None\n\"\"\""
        ],
        [
            "STORE_NAME",
            "import __future__"
        ],
        [
            "STORE_NAME",
            "import ast"
        ],
        [
            "STORE_NAME",
            "import dis"
        ],
        [
            "STORE_NAME",
            "import functools"
        ],
        [
            "STORE_NAME",
            "import inspect"
        ],
        [
            "STORE_NAME",
            "import io"
        ],
        [
            "STORE_NAME",
            "import linecache"
        ],
        [
            "STORE_NAME",
            "import sys"
        ],
        [
            "STORE_NAME",
            "from collections import defaultdict, namedtuple, Sized"
        ],
        [
            "STORE_NAME",
            "from collections import defaultdict, namedtuple, Sized"
        ],
        [
            "STORE_NAME",
            "from collections import defaultdict, namedtuple, Sized"
        ],
        [
            "STORE_NAME",
            "from itertools import islice"
        ],
        [
            "STORE_NAME",
            "from lib2to3.pgen2.tokenize import cookie_re as encoding_pattern"
        ],
        [
            "STORE_NAME",
            "from operator import attrgetter"
        ],
        [
            "STORE_NAME",
            "from threading import RLock"
        ],
        [
            "STORE_NAME",
            "__all__"
        ],
        [
            "LOAD_NAME",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.version_info"
        ],
        [
            "BINARY_SUBSCR",
            "sys.version_info[0]"
        ],
        [
            "COMPARE_OP",
            "sys.version_info[0] == 3"
        ],
        [
            "STORE_NAME",
            "PY3"
        ],
        [
            "LOAD_NAME",
            "PY3"
        ],
        [
            "STORE_NAME",
            "from functools import lru_cache"
        ],
        [
            "STORE_NAME",
            "from tokenize import detect_encoding"
        ],
        [
            "LOAD_NAME",
            "lru_cache"
        ],
        [
            "CALL",
            "lru_cache(maxsize=None)"
        ],
        [
            "STORE_NAME",
            "cache"
        ],
        [
            "LOAD_NAME",
            "str"
        ],
        [
            "STORE_NAME",
            "text_type"
        ],
        [
            "STORE_NAME",
            "from lib2to3.pgen2.tokenize import detect_encoding"
        ],
        [
            "STORE_NAME",
            "    def cache(func):\n        d = {}\n\n        @functools.wraps(func)\n        def wrapper(*args):\n            if args in d:\n                return d[args]\n            result = d[args] = func(*args)\n            return result\n\n        return wrapper"
        ],
        [
            "LOAD_NAME",
            "unicode"
        ],
        [
            "STORE_NAME",
            "text_type"
        ],
        [
            "LOAD_NAME",
            "dis"
        ],
        [
            "LOAD_ATTR",
            "dis.get_instructions"
        ],
        [
            "STORE_NAME",
            "get_instructions"
        ],
        [
            "LOAD_NAME",
            "AttributeError"
        ],
        [
            "LOAD_NAME",
            "namedtuple"
        ],
        [
            "CALL",
            "namedtuple('Instruction', 'offset argval opname')"
        ],
        [
            "STORE_NAME",
            "Instruction"
        ],
        [
            "STORE_NAME",
            "from dis import HAVE_ARGUMENT, EXTENDED_ARG, hasconst, opname"
        ],
        [
            "STORE_NAME",
            "from dis import HAVE_ARGUMENT, EXTENDED_ARG, hasconst, opname"
        ],
        [
            "STORE_NAME",
            "from dis import HAVE_ARGUMENT, EXTENDED_ARG, hasconst, opname"
        ],
        [
            "STORE_NAME",
            "from dis import HAVE_ARGUMENT, EXTENDED_ARG, hasconst, opname"
        ],
        [
            "STORE_NAME",
            "    def get_instructions(co):\n        code = co.co_code\n        n = len(code)\n        i = 0\n        extended_arg = 0\n        while i < n:\n            offset = i\n            c = code[i]\n            op = ord(c)\n            argval = None\n            i = i + 1\n            if op >= HAVE_ARGUMENT:\n                oparg = ord(code[i]) + ord(code[i + 1]) * 256 + extended_arg\n                extended_arg = 0\n                i = i + 2\n                if op == EXTENDED_ARG:\n                    extended_arg = oparg * 65536\n\n                if op in hasconst:\n                    argval = co.co_consts[oparg]\n            yield Instruction(offset, argval, opname[op])"
        ],
        [
            "LOAD_NAME",
            "Exception"
        ],
        [
            "CALL",
            "class NotOneValueFound(Exception):\n    pass"
        ],
        [
            "STORE_NAME",
            "class NotOneValueFound(Exception):\n    pass"
        ],
        [
            "STORE_NAME",
            "def only(it):\n    if isinstance(it, Sized):\n        if len(it) != 1:\n            raise NotOneValueFound('Expected one value, found %s' % len(it))\n        # noinspection PyTypeChecker\n        return list(it)[0]\n\n    lst = tuple(islice(it, 2))\n    if len(lst) == 0:\n        raise NotOneValueFound('Expected one value, found 0')\n    if len(lst) > 1:\n        raise NotOneValueFound('Expected one value, found several')\n    return lst[0]"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class Source(object):\n    \"\"\"\n    The source code of a single file and associated metadata.\n\n    The main method of interest is the classmethod `executing(frame)`.\n\n    If you want an instance of this class, don't construct it.\n    Ideally use the classmethod `for_frame(frame)`.\n    If you don't have a frame, use `for_filename(filename [, module_globals])`.\n    These methods cache instances by filename, so at most one instance exists per filename.\n\n    Attributes:\n        - filename\n        - text\n        - tree: AST parsed from text, or None if text is not valid Python\n            All nodes in the tree have an extra `parent` attribute\n\n    Other methods of interest:\n        - statements_at_line\n        - asttokens\n        - code_qualname\n    \"\"\"\n\n    def __init__(self, filename, text):\n        \"\"\"\n        Don't call this constructor, see the class docstring.\n        \"\"\"\n\n        self.filename = filename\n\n        if not isinstance(text, text_type):\n            text = self.decode_source(text)\n        self.text = text\n\n        if PY3:\n            ast_text = text\n        else:\n            # In python 2 it's a syntax error to parse unicode\n            # with an encoding declaration, so we remove it but\n            # leave empty lines in its place to keep line numbers the same\n            ast_text = ''.join([\n                '\\n' if i < 2 and encoding_pattern.match(line)\n                else line\n                for i, line in enumerate(text.splitlines(True))\n            ])\n\n        self._nodes_by_line = defaultdict(list)\n        self.tree = None\n        self._qualnames = {}\n\n        if text:\n            try:\n                self.tree = ast.parse(ast_text, filename=filename)\n            except SyntaxError:\n                pass\n            else:\n                for node in ast.walk(self.tree):\n                    for child in ast.iter_child_nodes(node):\n                        child.parent = node\n                    if hasattr(node, 'lineno'):\n                        self._nodes_by_line[node.lineno].append(node)\n\n                visitor = QualnameVisitor()\n                visitor.visit(self.tree)\n                self._qualnames = visitor.qualnames\n\n    @classmethod\n    def for_frame(cls, frame):\n        \"\"\"\n        Returns the `Source` object corresponding to the file the frame is executing in.\n        \"\"\"\n        return cls.for_filename(frame.f_code.co_filename, frame.f_globals or {})\n\n    @classmethod\n    def for_filename(cls, filename, module_globals=None):\n        source_cache = cls._class_local('__source_cache', {})\n        try:\n            return source_cache[filename]\n        except KeyError:\n            pass\n\n        lines = linecache.getlines(filename, module_globals)\n        result = source_cache[filename] = cls(filename, ''.join(lines))\n        return result\n\n    @classmethod\n    def lazycache(cls, frame):\n        if hasattr(linecache, 'lazycache'):\n            linecache.lazycache(frame.f_code.co_filename, frame.f_globals)\n\n    @classmethod\n    def executing(cls, frame):\n        \"\"\"\n        Returns an `Executing` object representing the operation\n        currently executing in the given frame.\n        \"\"\"\n        key = (frame.f_code, frame.f_lasti)\n        executing_cache = cls._class_local('__executing_cache', {})\n\n        try:\n            args = executing_cache[key]\n        except KeyError:\n            source = cls.for_frame(frame)\n            node = stmts = None\n            if source.tree:\n                stmts = source.statements_at_line(frame.f_lineno)\n                try:\n                    node = NodeFinder(frame, stmts, source.tree).result\n                except Exception:\n                    raise\n                else:\n                    new_stmts = {statement_containing_node(node)}\n                    assert new_stmts <= stmts\n                    stmts = new_stmts\n\n            args = source, node, stmts\n            executing_cache[key] = args\n\n        return Executing(frame, *args)\n\n    @classmethod\n    def _class_local(cls, name, default):\n        \"\"\"\n        Returns an attribute directly associated with this class\n        (as opposed to subclasses), setting default if necessary\n        \"\"\"\n        # classes have a mappingproxy preventing us from using setdefault\n        result = cls.__dict__.get(name, default)\n        setattr(cls, name, result)\n        return result\n\n    @cache\n    def statements_at_line(self, lineno):\n        \"\"\"\n        Returns the statement nodes overlapping the given line.\n\n        Returns at most one statement unless semicolons are present.\n\n        If the `text` attribute is not valid python, meaning\n        `tree` is None, returns an empty set.\n\n        Otherwise, `Source.for_frame(frame).statements_at_line(frame.f_lineno)`\n        should return at least one statement.\n        \"\"\"\n\n        return {\n            statement_containing_node(node)\n            for node in\n            self._nodes_by_line[lineno]\n        }\n\n    @cache\n    def asttokens(self):\n        \"\"\"\n        Returns an ASTTokens object for getting the source of specific AST nodes.\n\n        See http://asttokens.readthedocs.io/en/latest/api-index.html\n        \"\"\"\n        from asttokens import ASTTokens  # must be installed separately\n        return ASTTokens(\n            self.text,\n            tree=self.tree,\n            filename=self.filename,\n        )\n\n    @staticmethod\n    def decode_source(source):\n        if isinstance(source, bytes):\n            encoding, _ = detect_encoding(io.BytesIO(source).readline)\n            source = source.decode(encoding)\n        return source\n\n    def code_qualname(self, code):\n        \"\"\"\n        Imitates the __qualname__ attribute of functions for code objects.\n        Given:\n\n            - A function `func`\n            - A frame `frame` for an execution of `func`, meaning:\n                `frame.f_code is func.__code__`\n\n        `Source.for_frame(frame).code_qualname(frame.f_code)`\n        will be equal to `func.__qualname__`*. Works for Python 2 as well,\n        where of course no `__qualname__` attribute exists.\n\n        Falls back to `code.co_name` if there is no appropriate qualname.\n\n        Based on https://github.com/wbolster/qualname\n\n        (* unless `func` is a lambda\n        nested inside another lambda on the same line, in which case\n        the outer lambda's qualname will be returned for the codes\n        of both lambdas)\n        \"\"\"\n        assert code.co_filename == self.filename\n        return self._qualnames.get((code.co_name, code.co_firstlineno), code.co_name)"
        ],
        [
            "STORE_NAME",
            "class Source(object):\n    \"\"\"\n    The source code of a single file and associated metadata.\n\n    The main method of interest is the classmethod `executing(frame)`.\n\n    If you want an instance of this class, don't construct it.\n    Ideally use the classmethod `for_frame(frame)`.\n    If you don't have a frame, use `for_filename(filename [, module_globals])`.\n    These methods cache instances by filename, so at most one instance exists per filename.\n\n    Attributes:\n        - filename\n        - text\n        - tree: AST parsed from text, or None if text is not valid Python\n            All nodes in the tree have an extra `parent` attribute\n\n    Other methods of interest:\n        - statements_at_line\n        - asttokens\n        - code_qualname\n    \"\"\"\n\n    def __init__(self, filename, text):\n        \"\"\"\n        Don't call this constructor, see the class docstring.\n        \"\"\"\n\n        self.filename = filename\n\n        if not isinstance(text, text_type):\n            text = self.decode_source(text)\n        self.text = text\n\n        if PY3:\n            ast_text = text\n        else:\n            # In python 2 it's a syntax error to parse unicode\n            # with an encoding declaration, so we remove it but\n            # leave empty lines in its place to keep line numbers the same\n            ast_text = ''.join([\n                '\\n' if i < 2 and encoding_pattern.match(line)\n                else line\n                for i, line in enumerate(text.splitlines(True))\n            ])\n\n        self._nodes_by_line = defaultdict(list)\n        self.tree = None\n        self._qualnames = {}\n\n        if text:\n            try:\n                self.tree = ast.parse(ast_text, filename=filename)\n            except SyntaxError:\n                pass\n            else:\n                for node in ast.walk(self.tree):\n                    for child in ast.iter_child_nodes(node):\n                        child.parent = node\n                    if hasattr(node, 'lineno'):\n                        self._nodes_by_line[node.lineno].append(node)\n\n                visitor = QualnameVisitor()\n                visitor.visit(self.tree)\n                self._qualnames = visitor.qualnames\n\n    @classmethod\n    def for_frame(cls, frame):\n        \"\"\"\n        Returns the `Source` object corresponding to the file the frame is executing in.\n        \"\"\"\n        return cls.for_filename(frame.f_code.co_filename, frame.f_globals or {})\n\n    @classmethod\n    def for_filename(cls, filename, module_globals=None):\n        source_cache = cls._class_local('__source_cache', {})\n        try:\n            return source_cache[filename]\n        except KeyError:\n            pass\n\n        lines = linecache.getlines(filename, module_globals)\n        result = source_cache[filename] = cls(filename, ''.join(lines))\n        return result\n\n    @classmethod\n    def lazycache(cls, frame):\n        if hasattr(linecache, 'lazycache'):\n            linecache.lazycache(frame.f_code.co_filename, frame.f_globals)\n\n    @classmethod\n    def executing(cls, frame):\n        \"\"\"\n        Returns an `Executing` object representing the operation\n        currently executing in the given frame.\n        \"\"\"\n        key = (frame.f_code, frame.f_lasti)\n        executing_cache = cls._class_local('__executing_cache', {})\n\n        try:\n            args = executing_cache[key]\n        except KeyError:\n            source = cls.for_frame(frame)\n            node = stmts = None\n            if source.tree:\n                stmts = source.statements_at_line(frame.f_lineno)\n                try:\n                    node = NodeFinder(frame, stmts, source.tree).result\n                except Exception:\n                    raise\n                else:\n                    new_stmts = {statement_containing_node(node)}\n                    assert new_stmts <= stmts\n                    stmts = new_stmts\n\n            args = source, node, stmts\n            executing_cache[key] = args\n\n        return Executing(frame, *args)\n\n    @classmethod\n    def _class_local(cls, name, default):\n        \"\"\"\n        Returns an attribute directly associated with this class\n        (as opposed to subclasses), setting default if necessary\n        \"\"\"\n        # classes have a mappingproxy preventing us from using setdefault\n        result = cls.__dict__.get(name, default)\n        setattr(cls, name, result)\n        return result\n\n    @cache\n    def statements_at_line(self, lineno):\n        \"\"\"\n        Returns the statement nodes overlapping the given line.\n\n        Returns at most one statement unless semicolons are present.\n\n        If the `text` attribute is not valid python, meaning\n        `tree` is None, returns an empty set.\n\n        Otherwise, `Source.for_frame(frame).statements_at_line(frame.f_lineno)`\n        should return at least one statement.\n        \"\"\"\n\n        return {\n            statement_containing_node(node)\n            for node in\n            self._nodes_by_line[lineno]\n        }\n\n    @cache\n    def asttokens(self):\n        \"\"\"\n        Returns an ASTTokens object for getting the source of specific AST nodes.\n\n        See http://asttokens.readthedocs.io/en/latest/api-index.html\n        \"\"\"\n        from asttokens import ASTTokens  # must be installed separately\n        return ASTTokens(\n            self.text,\n            tree=self.tree,\n            filename=self.filename,\n        )\n\n    @staticmethod\n    def decode_source(source):\n        if isinstance(source, bytes):\n            encoding, _ = detect_encoding(io.BytesIO(source).readline)\n            source = source.decode(encoding)\n        return source\n\n    def code_qualname(self, code):\n        \"\"\"\n        Imitates the __qualname__ attribute of functions for code objects.\n        Given:\n\n            - A function `func`\n            - A frame `frame` for an execution of `func`, meaning:\n                `frame.f_code is func.__code__`\n\n        `Source.for_frame(frame).code_qualname(frame.f_code)`\n        will be equal to `func.__qualname__`*. Works for Python 2 as well,\n        where of course no `__qualname__` attribute exists.\n\n        Falls back to `code.co_name` if there is no appropriate qualname.\n\n        Based on https://github.com/wbolster/qualname\n\n        (* unless `func` is a lambda\n        nested inside another lambda on the same line, in which case\n        the outer lambda's qualname will be returned for the codes\n        of both lambdas)\n        \"\"\"\n        assert code.co_filename == self.filename\n        return self._qualnames.get((code.co_name, code.co_firstlineno), code.co_name)"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class Executing(object):\n    \"\"\"\n    Information about the operation a frame is currently executing.\n\n    Generally you will just want `node`, which is the AST node being executed,\n    or None if it's unknown.\n    Currently `node` can only be an `ast.Call` object, other operations\n    will be supported in future.\n    \"\"\"\n\n    def __init__(self, frame, source, node, stmts):\n        self.frame = frame\n        self.source = source\n        self.node = node\n        self.statements = stmts\n\n    def code_qualname(self):\n        return self.source.code_qualname(self.frame.f_code)\n\n    def text(self):\n        return self.source.asttokens().get_text(self.node)\n\n    def text_range(self):\n        return self.source.asttokens().get_text_range(self.node)"
        ],
        [
            "STORE_NAME",
            "class Executing(object):\n    \"\"\"\n    Information about the operation a frame is currently executing.\n\n    Generally you will just want `node`, which is the AST node being executed,\n    or None if it's unknown.\n    Currently `node` can only be an `ast.Call` object, other operations\n    will be supported in future.\n    \"\"\"\n\n    def __init__(self, frame, source, node, stmts):\n        self.frame = frame\n        self.source = source\n        self.node = node\n        self.statements = stmts\n\n    def code_qualname(self):\n        return self.source.code_qualname(self.frame.f_code)\n\n    def text(self):\n        return self.source.asttokens().get_text(self.node)\n\n    def text_range(self):\n        return self.source.asttokens().get_text_range(self.node)"
        ],
        [
            "LOAD_NAME",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.NodeVisitor"
        ],
        [
            "CALL",
            "class QualnameVisitor(ast.NodeVisitor):\n    def __init__(self):\n        super(QualnameVisitor, self).__init__()\n        self.stack = []\n        self.qualnames = {}\n\n    def visit_FunctionDef(self, node, name=None):\n        name = name or node.name\n        self.stack.append(name)\n        self.qualnames.setdefault((name, node.lineno), \".\".join(self.stack))\n\n        self.stack.append('<locals>')\n        if isinstance(node, ast.Lambda):\n            children = [node.body]\n        else:\n            children = node.body\n        for child in children:\n            self.visit(child)\n        self.stack.pop()\n        self.stack.pop()\n\n        # Find lambdas in the function definition outside the body,\n        # e.g. decorators or default arguments\n        # Based on iter_child_nodes\n        for field, child in ast.iter_fields(node):\n            if field == 'body':\n                continue\n            if isinstance(child, ast.AST):\n                self.visit(child)\n            elif isinstance(child, list):\n                for grandchild in child:\n                    if isinstance(grandchild, ast.AST):\n                        self.visit(grandchild)\n\n    def visit_Lambda(self, node):\n        self.visit_FunctionDef(node, '<lambda>')\n\n    def visit_ClassDef(self, node):\n        self.stack.append(node.name)\n        self.generic_visit(node)\n        self.stack.pop()"
        ],
        [
            "STORE_NAME",
            "class QualnameVisitor(ast.NodeVisitor):\n    def __init__(self):\n        super(QualnameVisitor, self).__init__()\n        self.stack = []\n        self.qualnames = {}\n\n    def visit_FunctionDef(self, node, name=None):\n        name = name or node.name\n        self.stack.append(name)\n        self.qualnames.setdefault((name, node.lineno), \".\".join(self.stack))\n\n        self.stack.append('<locals>')\n        if isinstance(node, ast.Lambda):\n            children = [node.body]\n        else:\n            children = node.body\n        for child in children:\n            self.visit(child)\n        self.stack.pop()\n        self.stack.pop()\n\n        # Find lambdas in the function definition outside the body,\n        # e.g. decorators or default arguments\n        # Based on iter_child_nodes\n        for field, child in ast.iter_fields(node):\n            if field == 'body':\n                continue\n            if isinstance(child, ast.AST):\n                self.visit(child)\n            elif isinstance(child, list):\n                for grandchild in child:\n                    if isinstance(grandchild, ast.AST):\n                        self.visit(grandchild)\n\n    def visit_Lambda(self, node):\n        self.visit_FunctionDef(node, '<lambda>')\n\n    def visit_ClassDef(self, node):\n        self.stack.append(node.name)\n        self.generic_visit(node)\n        self.stack.pop()"
        ],
        [
            "LOAD_NAME",
            "sum"
        ],
        [
            "LOAD_NAME",
            "__future__"
        ],
        [
            "LOAD_ATTR",
            "__future__.all_feature_names"
        ],
        [
            "CALL",
            "(\n    getattr(__future__, fname).compiler_flag\n    for fname in __future__.all_feature_names\n)"
        ],
        [
            "CALL",
            "sum(\n    getattr(__future__, fname).compiler_flag\n    for fname in __future__.all_feature_names\n)"
        ],
        [
            "STORE_NAME",
            "future_flags"
        ],
        [
            "STORE_NAME",
            "def compile_similar_to(source, matching_code):\n    return compile(\n        source,\n        matching_code.co_filename,\n        'exec',\n        flags=future_flags & matching_code.co_flags,\n        dont_inherit=True,\n    )"
        ],
        [
            "STORE_NAME",
            "sentinel"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class NodeFinder(object):\n    def __init__(self, frame, stmts, tree):\n        self.frame = frame\n        self.tree = tree\n\n        b = frame.f_code.co_code[frame.f_lasti]\n        if not PY3:\n            b = ord(b)\n        op_name = dis.opname[b]\n\n        if op_name.startswith('CALL_'):\n            typ = ast.Call\n        elif op_name == 'BINARY_SUBSCR':\n            typ = ast.Subscript\n        elif op_name.startswith('BINARY_'):\n            typ = ast.BinOp\n        elif op_name.startswith('UNARY_'):\n            typ = ast.UnaryOp\n        elif op_name in ('LOAD_ATTR', 'LOAD_METHOD', 'LOOKUP_METHOD'):\n            typ = ast.Attribute\n        elif op_name == 'COMPARE_OP':\n            typ = ast.Compare\n        else:\n            raise RuntimeError(op_name)\n\n        with lock:\n            exprs = {\n                node\n                for stmt in stmts\n                for node in ast.walk(stmt)\n                if isinstance(node, typ)\n                if not (hasattr(node, \"ctx\") and not isinstance(node.ctx, ast.Load))\n            }\n\n            self.result = only(list(self.matching_nodes(exprs)))\n\n    def matching_nodes(self, exprs):\n        for i, expr in enumerate(exprs):\n            setter = get_setter(expr)\n            replacement = ast.BinOp(\n                left=expr,\n                op=ast.Pow(),\n                right=ast.Str(s=sentinel),\n            )\n            ast.fix_missing_locations(replacement)\n            setter(replacement)\n            try:\n                instructions = self.compile_instructions()\n            except SyntaxError:\n                continue\n            finally:\n                setter(expr)\n            indices = [\n                i\n                for i, instruction in enumerate(instructions)\n                if instruction.argval == sentinel\n            ]\n            if not indices:\n                continue\n            arg_index = only(indices) - 1\n            while instructions[arg_index].opname == 'EXTENDED_ARG':\n                arg_index -= 1\n\n            if instructions[arg_index].offset == self.frame.f_lasti:\n                yield expr\n\n    def compile_instructions(self):\n        module_code = compile_similar_to(self.tree, self.frame.f_code)\n        code = only(find_codes(module_code, self.frame.f_code))\n        return list(get_instructions(code))"
        ],
        [
            "STORE_NAME",
            "class NodeFinder(object):\n    def __init__(self, frame, stmts, tree):\n        self.frame = frame\n        self.tree = tree\n\n        b = frame.f_code.co_code[frame.f_lasti]\n        if not PY3:\n            b = ord(b)\n        op_name = dis.opname[b]\n\n        if op_name.startswith('CALL_'):\n            typ = ast.Call\n        elif op_name == 'BINARY_SUBSCR':\n            typ = ast.Subscript\n        elif op_name.startswith('BINARY_'):\n            typ = ast.BinOp\n        elif op_name.startswith('UNARY_'):\n            typ = ast.UnaryOp\n        elif op_name in ('LOAD_ATTR', 'LOAD_METHOD', 'LOOKUP_METHOD'):\n            typ = ast.Attribute\n        elif op_name == 'COMPARE_OP':\n            typ = ast.Compare\n        else:\n            raise RuntimeError(op_name)\n\n        with lock:\n            exprs = {\n                node\n                for stmt in stmts\n                for node in ast.walk(stmt)\n                if isinstance(node, typ)\n                if not (hasattr(node, \"ctx\") and not isinstance(node.ctx, ast.Load))\n            }\n\n            self.result = only(list(self.matching_nodes(exprs)))\n\n    def matching_nodes(self, exprs):\n        for i, expr in enumerate(exprs):\n            setter = get_setter(expr)\n            replacement = ast.BinOp(\n                left=expr,\n                op=ast.Pow(),\n                right=ast.Str(s=sentinel),\n            )\n            ast.fix_missing_locations(replacement)\n            setter(replacement)\n            try:\n                instructions = self.compile_instructions()\n            except SyntaxError:\n                continue\n            finally:\n                setter(expr)\n            indices = [\n                i\n                for i, instruction in enumerate(instructions)\n                if instruction.argval == sentinel\n            ]\n            if not indices:\n                continue\n            arg_index = only(indices) - 1\n            while instructions[arg_index].opname == 'EXTENDED_ARG':\n                arg_index -= 1\n\n            if instructions[arg_index].offset == self.frame.f_lasti:\n                yield expr\n\n    def compile_instructions(self):\n        module_code = compile_similar_to(self.tree, self.frame.f_code)\n        code = only(find_codes(module_code, self.frame.f_code))\n        return list(get_instructions(code))"
        ],
        [
            "STORE_NAME",
            "def get_setter(node):\n    parent = node.parent\n    for name, field in ast.iter_fields(parent):\n        if field is node:\n            return lambda new_node: setattr(parent, name, new_node)\n        elif isinstance(field, list):\n            for i, item in enumerate(field):\n                if item is node:\n                    def setter(new_node):\n                        field[i] = new_node\n\n                    return setter"
        ],
        [
            "LOAD_NAME",
            "RLock"
        ],
        [
            "CALL",
            "RLock()"
        ],
        [
            "STORE_NAME",
            "lock"
        ],
        [
            "STORE_NAME",
            "def find_codes(root_code, matching):\n    def matches(c):\n        return all(\n            f(c) == f(matching)\n            for f in [\n                attrgetter('co_firstlineno'),\n                attrgetter('co_name'),\n                code_names,\n            ]\n        )\n\n    code_options = []\n    if matches(root_code):\n        code_options.append(root_code)\n\n    def finder(code):\n        for const in code.co_consts:\n            if not inspect.iscode(const):\n                continue\n\n            if matches(const):\n                code_options.append(const)\n            finder(const)\n\n    finder(root_code)\n    return code_options"
        ],
        [
            "STORE_NAME",
            "def code_names(code):\n    return frozenset().union(\n        code.co_names,\n        code.co_varnames,\n        code.co_freevars,\n        code.co_cellvars,\n    )"
        ],
        [
            "LOAD_NAME",
            "cache"
        ],
        [
            "CALL",
            "cache"
        ],
        [
            "STORE_NAME",
            "@cache\ndef statement_containing_node(node):\n    while not isinstance(node, ast.stmt):\n        node = node.parent\n    return node"
        ],
        [
            "STORE_DEREF",
            "d"
        ],
        [
            "LOAD_GLOBAL",
            "functools"
        ],
        [
            "LOAD_ATTR",
            "functools.wraps"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "CALL",
            "functools.wraps(func)"
        ],
        [
            "CALL",
            "functools.wraps(func)"
        ],
        [
            "STORE_FAST",
            "        @functools.wraps(func)\n        def wrapper(*args):\n            if args in d:\n                return d[args]\n            result = d[args] = func(*args)\n            return result"
        ],
        [
            "LOAD_FAST",
            "wrapper"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_DEREF",
            "d"
        ],
        [
            "CONTAINS_OP",
            "args in d"
        ],
        [
            "LOAD_DEREF",
            "d"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "BINARY_SUBSCR",
            "d[args]"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "CALL_FUNCTION_EX",
            "func(*args)"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_DEREF",
            "d"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "STORE_SUBSCR",
            "d[args]"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "co"
        ],
        [
            "LOAD_ATTR",
            "co.co_code"
        ],
        [
            "STORE_FAST",
            "code"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "CALL",
            "len(code)"
        ],
        [
            "STORE_FAST",
            "n"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "STORE_FAST",
            "extended_arg"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "COMPARE_OP",
            "i < n"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "STORE_FAST",
            "offset"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_SUBSCR",
            "code[i]"
        ],
        [
            "STORE_FAST",
            "c"
        ],
        [
            "LOAD_GLOBAL",
            "ord"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "CALL",
            "ord(c)"
        ],
        [
            "STORE_FAST",
            "op"
        ],
        [
            "STORE_FAST",
            "argval"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_OP",
            "i + 1"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "op"
        ],
        [
            "LOAD_GLOBAL",
            "HAVE_ARGUMENT"
        ],
        [
            "COMPARE_OP",
            "op >= HAVE_ARGUMENT"
        ],
        [
            "LOAD_GLOBAL",
            "ord"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_SUBSCR",
            "code[i]"
        ],
        [
            "CALL",
            "ord(code[i])"
        ],
        [
            "LOAD_GLOBAL",
            "ord"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_OP",
            "i + 1"
        ],
        [
            "BINARY_SUBSCR",
            "code[i + 1]"
        ],
        [
            "CALL",
            "ord(code[i + 1])"
        ],
        [
            "BINARY_OP",
            "ord(code[i + 1]) * 256"
        ],
        [
            "BINARY_OP",
            "ord(code[i]) + ord(code[i + 1]) * 256"
        ],
        [
            "LOAD_FAST",
            "extended_arg"
        ],
        [
            "BINARY_OP",
            "ord(code[i]) + ord(code[i + 1]) * 256 + extended_arg"
        ],
        [
            "STORE_FAST",
            "oparg"
        ],
        [
            "STORE_FAST",
            "extended_arg"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_OP",
            "i + 2"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "op"
        ],
        [
            "LOAD_GLOBAL",
            "EXTENDED_ARG"
        ],
        [
            "COMPARE_OP",
            "op == EXTENDED_ARG"
        ],
        [
            "LOAD_FAST",
            "oparg"
        ],
        [
            "BINARY_OP",
            "oparg * 65536"
        ],
        [
            "STORE_FAST",
            "extended_arg"
        ],
        [
            "LOAD_FAST",
            "op"
        ],
        [
            "LOAD_GLOBAL",
            "hasconst"
        ],
        [
            "CONTAINS_OP",
            "op in hasconst"
        ],
        [
            "LOAD_FAST",
            "co"
        ],
        [
            "LOAD_ATTR",
            "co.co_consts"
        ],
        [
            "LOAD_FAST",
            "oparg"
        ],
        [
            "BINARY_SUBSCR",
            "co.co_consts[oparg]"
        ],
        [
            "STORE_FAST",
            "argval"
        ],
        [
            "LOAD_GLOBAL",
            "Instruction"
        ],
        [
            "LOAD_FAST",
            "offset"
        ],
        [
            "LOAD_FAST",
            "argval"
        ],
        [
            "LOAD_GLOBAL",
            "opname"
        ],
        [
            "LOAD_FAST",
            "op"
        ],
        [
            "BINARY_SUBSCR",
            "opname[op]"
        ],
        [
            "CALL",
            "Instruction(offset, argval, opname[op])"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "COMPARE_OP",
            "i < n"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "it"
        ],
        [
            "LOAD_GLOBAL",
            "Sized"
        ],
        [
            "CALL",
            "isinstance(it, Sized)"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "it"
        ],
        [
            "CALL",
            "len(it)"
        ],
        [
            "COMPARE_OP",
            "len(it) != 1"
        ],
        [
            "LOAD_GLOBAL",
            "NotOneValueFound"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "it"
        ],
        [
            "CALL",
            "len(it)"
        ],
        [
            "BINARY_OP",
            "'Expected one value, found %s' % len(it)"
        ],
        [
            "CALL",
            "NotOneValueFound('Expected one value, found %s' % len(it))"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_FAST",
            "it"
        ],
        [
            "CALL",
            "list(it)"
        ],
        [
            "BINARY_SUBSCR",
            "list(it)[0]"
        ],
        [
            "LOAD_GLOBAL",
            "tuple"
        ],
        [
            "LOAD_GLOBAL",
            "islice"
        ],
        [
            "LOAD_FAST",
            "it"
        ],
        [
            "CALL",
            "islice(it, 2)"
        ],
        [
            "CALL",
            "tuple(islice(it, 2))"
        ],
        [
            "STORE_FAST",
            "lst"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "lst"
        ],
        [
            "CALL",
            "len(lst)"
        ],
        [
            "COMPARE_OP",
            "len(lst) == 0"
        ],
        [
            "LOAD_GLOBAL",
            "NotOneValueFound"
        ],
        [
            "CALL",
            "NotOneValueFound('Expected one value, found 0')"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "lst"
        ],
        [
            "CALL",
            "len(lst)"
        ],
        [
            "COMPARE_OP",
            "len(lst) > 1"
        ],
        [
            "LOAD_GLOBAL",
            "NotOneValueFound"
        ],
        [
            "CALL",
            "NotOneValueFound('Expected one value, found several')"
        ],
        [
            "LOAD_FAST",
            "lst"
        ],
        [
            "BINARY_SUBSCR",
            "lst[0]"
        ],
        [
            "STORE_NAME",
            "\"\"\"\n    The source code of a single file and associated metadata.\n\n    The main method of interest is the classmethod `executing(frame)`.\n\n    If you want an instance of this class, don't construct it.\n    Ideally use the classmethod `for_frame(frame)`.\n    If you don't have a frame, use `for_filename(filename [, module_globals])`.\n    These methods cache instances by filename, so at most one instance exists per filename.\n\n    Attributes:\n        - filename\n        - text\n        - tree: AST parsed from text, or None if text is not valid Python\n            All nodes in the tree have an extra `parent` attribute\n\n    Other methods of interest:\n        - statements_at_line\n        - asttokens\n        - code_qualname\n    \"\"\""
        ],
        [
            "STORE_NAME",
            "    def __init__(self, filename, text):\n        \"\"\"\n        Don't call this constructor, see the class docstring.\n        \"\"\"\n\n        self.filename = filename\n\n        if not isinstance(text, text_type):\n            text = self.decode_source(text)\n        self.text = text\n\n        if PY3:\n            ast_text = text\n        else:\n            # In python 2 it's a syntax error to parse unicode\n            # with an encoding declaration, so we remove it but\n            # leave empty lines in its place to keep line numbers the same\n            ast_text = ''.join([\n                '\\n' if i < 2 and encoding_pattern.match(line)\n                else line\n                for i, line in enumerate(text.splitlines(True))\n            ])\n\n        self._nodes_by_line = defaultdict(list)\n        self.tree = None\n        self._qualnames = {}\n\n        if text:\n            try:\n                self.tree = ast.parse(ast_text, filename=filename)\n            except SyntaxError:\n                pass\n            else:\n                for node in ast.walk(self.tree):\n                    for child in ast.iter_child_nodes(node):\n                        child.parent = node\n                    if hasattr(node, 'lineno'):\n                        self._nodes_by_line[node.lineno].append(node)\n\n                visitor = QualnameVisitor()\n                visitor.visit(self.tree)\n                self._qualnames = visitor.qualnames"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def for_frame(cls, frame):\n        \"\"\"\n        Returns the `Source` object corresponding to the file the frame is executing in.\n        \"\"\"\n        return cls.for_filename(frame.f_code.co_filename, frame.f_globals or {})"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def for_filename(cls, filename, module_globals=None):\n        source_cache = cls._class_local('__source_cache', {})\n        try:\n            return source_cache[filename]\n        except KeyError:\n            pass\n\n        lines = linecache.getlines(filename, module_globals)\n        result = source_cache[filename] = cls(filename, ''.join(lines))\n        return result"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def lazycache(cls, frame):\n        if hasattr(linecache, 'lazycache'):\n            linecache.lazycache(frame.f_code.co_filename, frame.f_globals)"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def executing(cls, frame):\n        \"\"\"\n        Returns an `Executing` object representing the operation\n        currently executing in the given frame.\n        \"\"\"\n        key = (frame.f_code, frame.f_lasti)\n        executing_cache = cls._class_local('__executing_cache', {})\n\n        try:\n            args = executing_cache[key]\n        except KeyError:\n            source = cls.for_frame(frame)\n            node = stmts = None\n            if source.tree:\n                stmts = source.statements_at_line(frame.f_lineno)\n                try:\n                    node = NodeFinder(frame, stmts, source.tree).result\n                except Exception:\n                    raise\n                else:\n                    new_stmts = {statement_containing_node(node)}\n                    assert new_stmts <= stmts\n                    stmts = new_stmts\n\n            args = source, node, stmts\n            executing_cache[key] = args\n\n        return Executing(frame, *args)"
        ],
        [
            "LOAD_NAME",
            "classmethod"
        ],
        [
            "CALL",
            "classmethod"
        ],
        [
            "STORE_NAME",
            "    @classmethod\n    def _class_local(cls, name, default):\n        \"\"\"\n        Returns an attribute directly associated with this class\n        (as opposed to subclasses), setting default if necessary\n        \"\"\"\n        # classes have a mappingproxy preventing us from using setdefault\n        result = cls.__dict__.get(name, default)\n        setattr(cls, name, result)\n        return result"
        ],
        [
            "LOAD_NAME",
            "cache"
        ],
        [
            "CALL",
            "cache"
        ],
        [
            "STORE_NAME",
            "    @cache\n    def statements_at_line(self, lineno):\n        \"\"\"\n        Returns the statement nodes overlapping the given line.\n\n        Returns at most one statement unless semicolons are present.\n\n        If the `text` attribute is not valid python, meaning\n        `tree` is None, returns an empty set.\n\n        Otherwise, `Source.for_frame(frame).statements_at_line(frame.f_lineno)`\n        should return at least one statement.\n        \"\"\"\n\n        return {\n            statement_containing_node(node)\n            for node in\n            self._nodes_by_line[lineno]\n        }"
        ],
        [
            "LOAD_NAME",
            "cache"
        ],
        [
            "CALL",
            "cache"
        ],
        [
            "STORE_NAME",
            "    @cache\n    def asttokens(self):\n        \"\"\"\n        Returns an ASTTokens object for getting the source of specific AST nodes.\n\n        See http://asttokens.readthedocs.io/en/latest/api-index.html\n        \"\"\"\n        from asttokens import ASTTokens  # must be installed separately\n        return ASTTokens(\n            self.text,\n            tree=self.tree,\n            filename=self.filename,\n        )"
        ],
        [
            "LOAD_NAME",
            "staticmethod"
        ],
        [
            "CALL",
            "staticmethod"
        ],
        [
            "STORE_NAME",
            "    @staticmethod\n    def decode_source(source):\n        if isinstance(source, bytes):\n            encoding, _ = detect_encoding(io.BytesIO(source).readline)\n            source = source.decode(encoding)\n        return source"
        ],
        [
            "STORE_NAME",
            "    def code_qualname(self, code):\n        \"\"\"\n        Imitates the __qualname__ attribute of functions for code objects.\n        Given:\n\n            - A function `func`\n            - A frame `frame` for an execution of `func`, meaning:\n                `frame.f_code is func.__code__`\n\n        `Source.for_frame(frame).code_qualname(frame.f_code)`\n        will be equal to `func.__qualname__`*. Works for Python 2 as well,\n        where of course no `__qualname__` attribute exists.\n\n        Falls back to `code.co_name` if there is no appropriate qualname.\n\n        Based on https://github.com/wbolster/qualname\n\n        (* unless `func` is a lambda\n        nested inside another lambda on the same line, in which case\n        the outer lambda's qualname will be returned for the codes\n        of both lambdas)\n        \"\"\"\n        assert code.co_filename == self.filename\n        return self._qualnames.get((code.co_name, code.co_firstlineno), code.co_name)"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.filename"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "text"
        ],
        [
            "LOAD_GLOBAL",
            "text_type"
        ],
        [
            "CALL",
            "isinstance(text, text_type)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.decode_source"
        ],
        [
            "LOAD_FAST",
            "text"
        ],
        [
            "CALL",
            "self.decode_source(text)"
        ],
        [
            "STORE_FAST",
            "text"
        ],
        [
            "LOAD_FAST",
            "text"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.text"
        ],
        [
            "LOAD_GLOBAL",
            "PY3"
        ],
        [
            "LOAD_FAST",
            "text"
        ],
        [
            "STORE_FAST",
            "ast_text"
        ],
        [
            "LOAD_METHOD",
            "''.join"
        ],
        [
            "LOAD_GLOBAL",
            "enumerate"
        ],
        [
            "LOAD_FAST",
            "text"
        ],
        [
            "LOAD_METHOD",
            "text.splitlines"
        ],
        [
            "CALL",
            "text.splitlines(True)"
        ],
        [
            "CALL",
            "enumerate(text.splitlines(True))"
        ],
        [
            "CALL",
            "[\n                '\\n' if i < 2 and encoding_pattern.match(line)\n                else line\n                for i, line in enumerate(text.splitlines(True))\n            ]"
        ],
        [
            "CALL",
            "''.join([\n                '\\n' if i < 2 and encoding_pattern.match(line)\n                else line\n                for i, line in enumerate(text.splitlines(True))\n            ])"
        ],
        [
            "STORE_FAST",
            "ast_text"
        ],
        [
            "LOAD_GLOBAL",
            "defaultdict"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "CALL",
            "defaultdict(list)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._nodes_by_line"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.tree"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._qualnames"
        ],
        [
            "LOAD_FAST",
            "text"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.parse"
        ],
        [
            "LOAD_FAST",
            "ast_text"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "CALL",
            "ast.parse(ast_text, filename=filename)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.tree"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.walk"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.tree"
        ],
        [
            "CALL",
            "ast.walk(self.tree)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.iter_child_nodes"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "ast.iter_child_nodes(node)"
        ],
        [
            "STORE_FAST",
            "child"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "child"
        ],
        [
            "STORE_ATTR",
            "child.parent"
        ],
        [
            "LOAD_GLOBAL",
            "hasattr"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "hasattr(node, 'lineno')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._nodes_by_line"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.lineno"
        ],
        [
            "BINARY_SUBSCR",
            "self._nodes_by_line[node.lineno]"
        ],
        [
            "LOAD_METHOD",
            "self._nodes_by_line[node.lineno].append"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "self._nodes_by_line[node.lineno].append(node)"
        ],
        [
            "LOAD_GLOBAL",
            "QualnameVisitor"
        ],
        [
            "CALL",
            "QualnameVisitor()"
        ],
        [
            "STORE_FAST",
            "visitor"
        ],
        [
            "LOAD_FAST",
            "visitor"
        ],
        [
            "LOAD_METHOD",
            "visitor.visit"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.tree"
        ],
        [
            "CALL",
            "visitor.visit(self.tree)"
        ],
        [
            "LOAD_FAST",
            "visitor"
        ],
        [
            "LOAD_ATTR",
            "visitor.qualnames"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._qualnames"
        ],
        [
            "LOAD_GLOBAL",
            "SyntaxError"
        ],
        [
            "LOAD_FAST",
            "[\n                '\\n' if i < 2 and encoding_pattern.match(line)\n                else line\n                for i, line in enumerate(text.splitlines(True))\n            ]"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "STORE_FAST",
            "line"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "COMPARE_OP",
            "i < 2"
        ],
        [
            "LOAD_GLOBAL",
            "encoding_pattern"
        ],
        [
            "LOAD_ATTR",
            "encoding_pattern.match"
        ],
        [
            "LOAD_FAST",
            "line"
        ],
        [
            "CALL",
            "encoding_pattern.match(line)"
        ],
        [
            "LOAD_FAST",
            "line"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_METHOD",
            "cls.for_filename"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_filename"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_globals"
        ],
        [
            "CALL",
            "cls.for_filename(frame.f_code.co_filename, frame.f_globals or {})"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_METHOD",
            "cls._class_local"
        ],
        [
            "CALL",
            "cls._class_local('__source_cache', {})"
        ],
        [
            "STORE_FAST",
            "source_cache"
        ],
        [
            "LOAD_FAST",
            "source_cache"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "BINARY_SUBSCR",
            "source_cache[filename]"
        ],
        [
            "LOAD_GLOBAL",
            "KeyError"
        ],
        [
            "LOAD_GLOBAL",
            "linecache"
        ],
        [
            "LOAD_ATTR",
            "linecache.getlines"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "module_globals"
        ],
        [
            "CALL",
            "linecache.getlines(filename, module_globals)"
        ],
        [
            "STORE_FAST",
            "lines"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_METHOD",
            "''.join"
        ],
        [
            "LOAD_FAST",
            "lines"
        ],
        [
            "CALL",
            "''.join(lines)"
        ],
        [
            "CALL",
            "cls(filename, ''.join(lines))"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "source_cache"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "STORE_SUBSCR",
            "source_cache[filename]"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_GLOBAL",
            "hasattr"
        ],
        [
            "LOAD_GLOBAL",
            "linecache"
        ],
        [
            "CALL",
            "hasattr(linecache, 'lazycache')"
        ],
        [
            "LOAD_GLOBAL",
            "linecache"
        ],
        [
            "LOAD_ATTR",
            "linecache.lazycache"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_filename"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_globals"
        ],
        [
            "CALL",
            "linecache.lazycache(frame.f_code.co_filename, frame.f_globals)"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_lasti"
        ],
        [
            "STORE_FAST",
            "key"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_METHOD",
            "cls._class_local"
        ],
        [
            "CALL",
            "cls._class_local('__executing_cache', {})"
        ],
        [
            "STORE_FAST",
            "executing_cache"
        ],
        [
            "LOAD_FAST",
            "executing_cache"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "BINARY_SUBSCR",
            "executing_cache[key]"
        ],
        [
            "STORE_FAST",
            "args"
        ],
        [
            "LOAD_GLOBAL",
            "KeyError"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_METHOD",
            "cls.for_frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "cls.for_frame(frame)"
        ],
        [
            "STORE_FAST",
            "source"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "STORE_FAST",
            "stmts"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_ATTR",
            "source.tree"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_METHOD",
            "source.statements_at_line"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_lineno"
        ],
        [
            "CALL",
            "source.statements_at_line(frame.f_lineno)"
        ],
        [
            "STORE_FAST",
            "stmts"
        ],
        [
            "LOAD_GLOBAL",
            "NodeFinder"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "stmts"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_ATTR",
            "source.tree"
        ],
        [
            "CALL",
            "NodeFinder(frame, stmts, source.tree)"
        ],
        [
            "LOAD_ATTR",
            "NodeFinder(frame, stmts, source.tree).result"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "statement_containing_node"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "statement_containing_node(node)"
        ],
        [
            "STORE_FAST",
            "new_stmts"
        ],
        [
            "LOAD_FAST",
            "new_stmts"
        ],
        [
            "LOAD_FAST",
            "stmts"
        ],
        [
            "COMPARE_OP",
            "new_stmts <= stmts"
        ],
        [
            "LOAD_FAST",
            "new_stmts"
        ],
        [
            "STORE_FAST",
            "stmts"
        ],
        [
            "LOAD_GLOBAL",
            "Exception"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "stmts"
        ],
        [
            "STORE_FAST",
            "args"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_FAST",
            "executing_cache"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "STORE_SUBSCR",
            "executing_cache[key]"
        ],
        [
            "LOAD_GLOBAL",
            "Executing"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "CALL_FUNCTION_EX",
            "Executing(frame, *args)"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_ATTR",
            "cls.__dict__"
        ],
        [
            "LOAD_METHOD",
            "cls.__dict__.get"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "default"
        ],
        [
            "CALL",
            "cls.__dict__.get(name, default)"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_GLOBAL",
            "setattr"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "CALL",
            "setattr(cls, name, result)"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._nodes_by_line"
        ],
        [
            "LOAD_FAST",
            "lineno"
        ],
        [
            "BINARY_SUBSCR",
            "self._nodes_by_line[lineno]"
        ],
        [
            "CALL",
            "{\n            statement_containing_node(node)\n            for node in\n            self._nodes_by_line[lineno]\n        }"
        ],
        [
            "LOAD_FAST",
            "{\n            statement_containing_node(node)\n            for node in\n            self._nodes_by_line[lineno]\n        }"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "statement_containing_node"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "statement_containing_node(node)"
        ],
        [
            "STORE_FAST",
            "from asttokens import ASTTokens"
        ],
        [
            "LOAD_FAST",
            "ASTTokens"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.text"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.tree"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.filename"
        ],
        [
            "CALL",
            "ASTTokens(\n            self.text,\n            tree=self.tree,\n            filename=self.filename,\n        )"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_GLOBAL",
            "bytes"
        ],
        [
            "CALL",
            "isinstance(source, bytes)"
        ],
        [
            "LOAD_GLOBAL",
            "detect_encoding"
        ],
        [
            "LOAD_GLOBAL",
            "io"
        ],
        [
            "LOAD_ATTR",
            "io.BytesIO"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CALL",
            "io.BytesIO(source)"
        ],
        [
            "LOAD_ATTR",
            "io.BytesIO(source).readline"
        ],
        [
            "CALL",
            "detect_encoding(io.BytesIO(source).readline)"
        ],
        [
            "STORE_FAST",
            "encoding"
        ],
        [
            "STORE_FAST",
            "_"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_METHOD",
            "source.decode"
        ],
        [
            "LOAD_FAST",
            "encoding"
        ],
        [
            "CALL",
            "source.decode(encoding)"
        ],
        [
            "STORE_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_filename"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.filename"
        ],
        [
            "COMPARE_OP",
            "code.co_filename == self.filename"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._qualnames"
        ],
        [
            "LOAD_METHOD",
            "self._qualnames.get"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_name"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_firstlineno"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_name"
        ],
        [
            "CALL",
            "self._qualnames.get((code.co_name, code.co_firstlineno), code.co_name)"
        ],
        [
            "STORE_NAME",
            "\"\"\"\n    Information about the operation a frame is currently executing.\n\n    Generally you will just want `node`, which is the AST node being executed,\n    or None if it's unknown.\n    Currently `node` can only be an `ast.Call` object, other operations\n    will be supported in future.\n    \"\"\""
        ],
        [
            "STORE_NAME",
            "    def __init__(self, frame, source, node, stmts):\n        self.frame = frame\n        self.source = source\n        self.node = node\n        self.statements = stmts"
        ],
        [
            "STORE_NAME",
            "    def code_qualname(self):\n        return self.source.code_qualname(self.frame.f_code)"
        ],
        [
            "STORE_NAME",
            "    def text(self):\n        return self.source.asttokens().get_text(self.node)"
        ],
        [
            "STORE_NAME",
            "    def text_range(self):\n        return self.source.asttokens().get_text_range(self.node)"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.frame"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.source"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.node"
        ],
        [
            "LOAD_FAST",
            "stmts"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.statements"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.source"
        ],
        [
            "LOAD_METHOD",
            "self.source.code_qualname"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.frame"
        ],
        [
            "LOAD_ATTR",
            "self.frame.f_code"
        ],
        [
            "CALL",
            "self.source.code_qualname(self.frame.f_code)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.source"
        ],
        [
            "LOAD_METHOD",
            "self.source.asttokens"
        ],
        [
            "CALL",
            "self.source.asttokens()"
        ],
        [
            "LOAD_METHOD",
            "self.source.asttokens().get_text"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.node"
        ],
        [
            "CALL",
            "self.source.asttokens().get_text(self.node)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.source"
        ],
        [
            "LOAD_METHOD",
            "self.source.asttokens"
        ],
        [
            "CALL",
            "self.source.asttokens()"
        ],
        [
            "LOAD_METHOD",
            "self.source.asttokens().get_text_range"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.node"
        ],
        [
            "CALL",
            "self.source.asttokens().get_text_range(self.node)"
        ],
        [
            "STORE_NAME",
            "    def __init__(self):\n        super(QualnameVisitor, self).__init__()\n        self.stack = []\n        self.qualnames = {}"
        ],
        [
            "STORE_NAME",
            "    def visit_FunctionDef(self, node, name=None):\n        name = name or node.name\n        self.stack.append(name)\n        self.qualnames.setdefault((name, node.lineno), \".\".join(self.stack))\n\n        self.stack.append('<locals>')\n        if isinstance(node, ast.Lambda):\n            children = [node.body]\n        else:\n            children = node.body\n        for child in children:\n            self.visit(child)\n        self.stack.pop()\n        self.stack.pop()\n\n        # Find lambdas in the function definition outside the body,\n        # e.g. decorators or default arguments\n        # Based on iter_child_nodes\n        for field, child in ast.iter_fields(node):\n            if field == 'body':\n                continue\n            if isinstance(child, ast.AST):\n                self.visit(child)\n            elif isinstance(child, list):\n                for grandchild in child:\n                    if isinstance(grandchild, ast.AST):\n                        self.visit(grandchild)"
        ],
        [
            "STORE_NAME",
            "    def visit_Lambda(self, node):\n        self.visit_FunctionDef(node, '<lambda>')"
        ],
        [
            "STORE_NAME",
            "    def visit_ClassDef(self, node):\n        self.stack.append(node.name)\n        self.generic_visit(node)\n        self.stack.pop()"
        ],
        [
            "STORE_NAME",
            "    def visit_ClassDef(self, node):\n        self.stack.append(node.name)\n        self.generic_visit(node)\n        self.stack.pop()"
        ],
        [
            "LOAD_GLOBAL",
            "super"
        ],
        [
            "LOAD_GLOBAL",
            "QualnameVisitor"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "super(QualnameVisitor, self)"
        ],
        [
            "LOAD_METHOD",
            "super(QualnameVisitor, self).__init__"
        ],
        [
            "CALL",
            "super(QualnameVisitor, self).__init__()"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.stack"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.qualnames"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.name"
        ],
        [
            "STORE_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_METHOD",
            "self.stack.append"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "CALL",
            "self.stack.append(name)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.qualnames"
        ],
        [
            "LOAD_METHOD",
            "self.qualnames.setdefault"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.lineno"
        ],
        [
            "LOAD_METHOD",
            "\".\".join"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "CALL",
            "\".\".join(self.stack)"
        ],
        [
            "CALL",
            "self.qualnames.setdefault((name, node.lineno), \".\".join(self.stack))"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_METHOD",
            "self.stack.append"
        ],
        [
            "CALL",
            "self.stack.append('<locals>')"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Lambda"
        ],
        [
            "CALL",
            "isinstance(node, ast.Lambda)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.body"
        ],
        [
            "STORE_FAST",
            "children"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.body"
        ],
        [
            "STORE_FAST",
            "children"
        ],
        [
            "LOAD_FAST",
            "children"
        ],
        [
            "STORE_FAST",
            "child"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.visit"
        ],
        [
            "LOAD_FAST",
            "child"
        ],
        [
            "CALL",
            "self.visit(child)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_METHOD",
            "self.stack.pop"
        ],
        [
            "CALL",
            "self.stack.pop()"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_METHOD",
            "self.stack.pop"
        ],
        [
            "CALL",
            "self.stack.pop()"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.iter_fields"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "ast.iter_fields(node)"
        ],
        [
            "STORE_FAST",
            "field"
        ],
        [
            "STORE_FAST",
            "child"
        ],
        [
            "LOAD_FAST",
            "field"
        ],
        [
            "COMPARE_OP",
            "field == 'body'"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "child"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.AST"
        ],
        [
            "CALL",
            "isinstance(child, ast.AST)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.visit"
        ],
        [
            "LOAD_FAST",
            "child"
        ],
        [
            "CALL",
            "self.visit(child)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "child"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "CALL",
            "isinstance(child, list)"
        ],
        [
            "LOAD_FAST",
            "child"
        ],
        [
            "STORE_FAST",
            "grandchild"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "grandchild"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.AST"
        ],
        [
            "CALL",
            "isinstance(grandchild, ast.AST)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.visit"
        ],
        [
            "LOAD_FAST",
            "grandchild"
        ],
        [
            "CALL",
            "self.visit(grandchild)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.visit_FunctionDef"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "self.visit_FunctionDef(node, '<lambda>')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_METHOD",
            "self.stack.append"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.name"
        ],
        [
            "CALL",
            "self.stack.append(node.name)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.generic_visit"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "self.generic_visit(node)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_METHOD",
            "self.stack.pop"
        ],
        [
            "CALL",
            "self.stack.pop()"
        ],
        [
            "LOAD_FAST",
            "(\n    getattr(__future__, fname).compiler_flag\n    for fname in __future__.all_feature_names\n)"
        ],
        [
            "STORE_FAST",
            "fname"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_GLOBAL",
            "__future__"
        ],
        [
            "LOAD_FAST",
            "fname"
        ],
        [
            "CALL",
            "getattr(__future__, fname)"
        ],
        [
            "LOAD_ATTR",
            "getattr(__future__, fname).compiler_flag"
        ],
        [
            "LOAD_GLOBAL",
            "compile"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "matching_code"
        ],
        [
            "LOAD_ATTR",
            "matching_code.co_filename"
        ],
        [
            "LOAD_GLOBAL",
            "future_flags"
        ],
        [
            "LOAD_FAST",
            "matching_code"
        ],
        [
            "LOAD_ATTR",
            "matching_code.co_flags"
        ],
        [
            "BINARY_OP",
            "future_flags & matching_code.co_flags"
        ],
        [
            "CALL",
            "compile(\n        source,\n        matching_code.co_filename,\n        'exec',\n        flags=future_flags & matching_code.co_flags,\n        dont_inherit=True,\n    )"
        ],
        [
            "STORE_NAME",
            "    def __init__(self, frame, stmts, tree):\n        self.frame = frame\n        self.tree = tree\n\n        b = frame.f_code.co_code[frame.f_lasti]\n        if not PY3:\n            b = ord(b)\n        op_name = dis.opname[b]\n\n        if op_name.startswith('CALL_'):\n            typ = ast.Call\n        elif op_name == 'BINARY_SUBSCR':\n            typ = ast.Subscript\n        elif op_name.startswith('BINARY_'):\n            typ = ast.BinOp\n        elif op_name.startswith('UNARY_'):\n            typ = ast.UnaryOp\n        elif op_name in ('LOAD_ATTR', 'LOAD_METHOD', 'LOOKUP_METHOD'):\n            typ = ast.Attribute\n        elif op_name == 'COMPARE_OP':\n            typ = ast.Compare\n        else:\n            raise RuntimeError(op_name)\n\n        with lock:\n            exprs = {\n                node\n                for stmt in stmts\n                for node in ast.walk(stmt)\n                if isinstance(node, typ)\n                if not (hasattr(node, \"ctx\") and not isinstance(node.ctx, ast.Load))\n            }\n\n            self.result = only(list(self.matching_nodes(exprs)))"
        ],
        [
            "STORE_NAME",
            "    def matching_nodes(self, exprs):\n        for i, expr in enumerate(exprs):\n            setter = get_setter(expr)\n            replacement = ast.BinOp(\n                left=expr,\n                op=ast.Pow(),\n                right=ast.Str(s=sentinel),\n            )\n            ast.fix_missing_locations(replacement)\n            setter(replacement)\n            try:\n                instructions = self.compile_instructions()\n            except SyntaxError:\n                continue\n            finally:\n                setter(expr)\n            indices = [\n                i\n                for i, instruction in enumerate(instructions)\n                if instruction.argval == sentinel\n            ]\n            if not indices:\n                continue\n            arg_index = only(indices) - 1\n            while instructions[arg_index].opname == 'EXTENDED_ARG':\n                arg_index -= 1\n\n            if instructions[arg_index].offset == self.frame.f_lasti:\n                yield expr"
        ],
        [
            "STORE_NAME",
            "    def compile_instructions(self):\n        module_code = compile_similar_to(self.tree, self.frame.f_code)\n        code = only(find_codes(module_code, self.frame.f_code))\n        return list(get_instructions(code))"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.frame"
        ],
        [
            "LOAD_FAST",
            "tree"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.tree"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_code"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_lasti"
        ],
        [
            "BINARY_SUBSCR",
            "frame.f_code.co_code[frame.f_lasti]"
        ],
        [
            "STORE_FAST",
            "b"
        ],
        [
            "LOAD_GLOBAL",
            "PY3"
        ],
        [
            "LOAD_GLOBAL",
            "ord"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "CALL",
            "ord(b)"
        ],
        [
            "STORE_FAST",
            "b"
        ],
        [
            "LOAD_GLOBAL",
            "dis"
        ],
        [
            "LOAD_ATTR",
            "dis.opname"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "BINARY_SUBSCR",
            "dis.opname[b]"
        ],
        [
            "STORE_FAST",
            "op_name"
        ],
        [
            "LOAD_FAST",
            "op_name"
        ],
        [
            "LOAD_METHOD",
            "op_name.startswith"
        ],
        [
            "CALL",
            "op_name.startswith('CALL_')"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Call"
        ],
        [
            "STORE_DEREF",
            "typ"
        ],
        [
            "LOAD_FAST",
            "op_name"
        ],
        [
            "COMPARE_OP",
            "op_name == 'BINARY_SUBSCR'"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Subscript"
        ],
        [
            "STORE_DEREF",
            "typ"
        ],
        [
            "LOAD_FAST",
            "op_name"
        ],
        [
            "LOAD_METHOD",
            "op_name.startswith"
        ],
        [
            "CALL",
            "op_name.startswith('BINARY_')"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.BinOp"
        ],
        [
            "STORE_DEREF",
            "typ"
        ],
        [
            "LOAD_FAST",
            "op_name"
        ],
        [
            "LOAD_METHOD",
            "op_name.startswith"
        ],
        [
            "CALL",
            "op_name.startswith('UNARY_')"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.UnaryOp"
        ],
        [
            "STORE_DEREF",
            "typ"
        ],
        [
            "LOAD_FAST",
            "op_name"
        ],
        [
            "CONTAINS_OP",
            "op_name in ('LOAD_ATTR', 'LOAD_METHOD', 'LOOKUP_METHOD')"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Attribute"
        ],
        [
            "STORE_DEREF",
            "typ"
        ],
        [
            "LOAD_FAST",
            "op_name"
        ],
        [
            "COMPARE_OP",
            "op_name == 'COMPARE_OP'"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Compare"
        ],
        [
            "STORE_DEREF",
            "typ"
        ],
        [
            "LOAD_GLOBAL",
            "RuntimeError"
        ],
        [
            "LOAD_FAST",
            "op_name"
        ],
        [
            "CALL",
            "RuntimeError(op_name)"
        ],
        [
            "LOAD_GLOBAL",
            "lock"
        ],
        [
            "LOAD_FAST",
            "stmts"
        ],
        [
            "CALL",
            "{\n                node\n                for stmt in stmts\n                for node in ast.walk(stmt)\n                if isinstance(node, typ)\n                if not (hasattr(node, \"ctx\") and not isinstance(node.ctx, ast.Load))\n            }"
        ],
        [
            "STORE_FAST",
            "exprs"
        ],
        [
            "LOAD_GLOBAL",
            "only"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.matching_nodes"
        ],
        [
            "LOAD_FAST",
            "exprs"
        ],
        [
            "CALL",
            "self.matching_nodes(exprs)"
        ],
        [
            "CALL",
            "list(self.matching_nodes(exprs))"
        ],
        [
            "CALL",
            "only(list(self.matching_nodes(exprs)))"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.result"
        ],
        [
            "CALL",
            "        with lock:\n            exprs = {\n                node\n                for stmt in stmts\n                for node in ast.walk(stmt)\n                if isinstance(node, typ)\n                if not (hasattr(node, \"ctx\") and not isinstance(node.ctx, ast.Load))\n            }\n\n            self.result = only(list(self.matching_nodes(exprs)))"
        ],
        [
            "LOAD_FAST",
            "{\n                node\n                for stmt in stmts\n                for node in ast.walk(stmt)\n                if isinstance(node, typ)\n                if not (hasattr(node, \"ctx\") and not isinstance(node.ctx, ast.Load))\n            }"
        ],
        [
            "STORE_FAST",
            "stmt"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.walk"
        ],
        [
            "LOAD_FAST",
            "stmt"
        ],
        [
            "CALL",
            "ast.walk(stmt)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_DEREF",
            "typ"
        ],
        [
            "CALL",
            "isinstance(node, typ)"
        ],
        [
            "LOAD_GLOBAL",
            "hasattr"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "hasattr(node, \"ctx\")"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.ctx"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Load"
        ],
        [
            "CALL",
            "isinstance(node.ctx, ast.Load)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "enumerate"
        ],
        [
            "LOAD_FAST",
            "exprs"
        ],
        [
            "CALL",
            "enumerate(exprs)"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "STORE_FAST",
            "expr"
        ],
        [
            "LOAD_GLOBAL",
            "get_setter"
        ],
        [
            "LOAD_FAST",
            "expr"
        ],
        [
            "CALL",
            "get_setter(expr)"
        ],
        [
            "STORE_FAST",
            "setter"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.BinOp"
        ],
        [
            "LOAD_FAST",
            "expr"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Pow"
        ],
        [
            "CALL",
            "ast.Pow()"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Str"
        ],
        [
            "LOAD_GLOBAL",
            "sentinel"
        ],
        [
            "CALL",
            "ast.Str(s=sentinel)"
        ],
        [
            "CALL",
            "ast.BinOp(\n                left=expr,\n                op=ast.Pow(),\n                right=ast.Str(s=sentinel),\n            )"
        ],
        [
            "STORE_FAST",
            "replacement"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.fix_missing_locations"
        ],
        [
            "LOAD_FAST",
            "replacement"
        ],
        [
            "CALL",
            "ast.fix_missing_locations(replacement)"
        ],
        [
            "LOAD_FAST",
            "setter"
        ],
        [
            "LOAD_FAST",
            "replacement"
        ],
        [
            "CALL",
            "setter(replacement)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.compile_instructions"
        ],
        [
            "CALL",
            "self.compile_instructions()"
        ],
        [
            "STORE_FAST",
            "instructions"
        ],
        [
            "LOAD_GLOBAL",
            "SyntaxError"
        ],
        [
            "LOAD_FAST",
            "setter"
        ],
        [
            "LOAD_FAST",
            "expr"
        ],
        [
            "CALL",
            "setter(expr)"
        ],
        [
            "LOAD_FAST",
            "setter"
        ],
        [
            "LOAD_FAST",
            "expr"
        ],
        [
            "CALL",
            "setter(expr)"
        ],
        [
            "LOAD_FAST",
            "setter"
        ],
        [
            "LOAD_FAST",
            "expr"
        ],
        [
            "CALL",
            "setter(expr)"
        ],
        [
            "LOAD_GLOBAL",
            "enumerate"
        ],
        [
            "LOAD_FAST",
            "instructions"
        ],
        [
            "CALL",
            "enumerate(instructions)"
        ],
        [
            "CALL",
            "[\n                i\n                for i, instruction in enumerate(instructions)\n                if instruction.argval == sentinel\n            ]"
        ],
        [
            "STORE_FAST",
            "indices"
        ],
        [
            "LOAD_FAST",
            "indices"
        ],
        [
            "LOAD_GLOBAL",
            "only"
        ],
        [
            "LOAD_FAST",
            "indices"
        ],
        [
            "CALL",
            "only(indices)"
        ],
        [
            "BINARY_OP",
            "only(indices) - 1"
        ],
        [
            "STORE_FAST",
            "arg_index"
        ],
        [
            "LOAD_FAST",
            "instructions"
        ],
        [
            "LOAD_FAST",
            "arg_index"
        ],
        [
            "BINARY_SUBSCR",
            "instructions[arg_index]"
        ],
        [
            "LOAD_ATTR",
            "instructions[arg_index].opname"
        ],
        [
            "COMPARE_OP",
            "instructions[arg_index].opname == 'EXTENDED_ARG'"
        ],
        [
            "LOAD_FAST",
            "arg_index"
        ],
        [
            "BINARY_OP",
            "arg_index -= 1"
        ],
        [
            "STORE_FAST",
            "arg_index"
        ],
        [
            "LOAD_FAST",
            "instructions"
        ],
        [
            "LOAD_FAST",
            "arg_index"
        ],
        [
            "BINARY_SUBSCR",
            "instructions[arg_index]"
        ],
        [
            "LOAD_ATTR",
            "instructions[arg_index].opname"
        ],
        [
            "COMPARE_OP",
            "instructions[arg_index].opname == 'EXTENDED_ARG'"
        ],
        [
            "LOAD_FAST",
            "instructions"
        ],
        [
            "LOAD_FAST",
            "arg_index"
        ],
        [
            "BINARY_SUBSCR",
            "instructions[arg_index]"
        ],
        [
            "LOAD_ATTR",
            "instructions[arg_index].offset"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.frame"
        ],
        [
            "LOAD_ATTR",
            "self.frame.f_lasti"
        ],
        [
            "COMPARE_OP",
            "instructions[arg_index].offset == self.frame.f_lasti"
        ],
        [
            "LOAD_FAST",
            "expr"
        ],
        [
            "LOAD_FAST",
            "[\n                i\n                for i, instruction in enumerate(instructions)\n                if instruction.argval == sentinel\n            ]"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "STORE_FAST",
            "instruction"
        ],
        [
            "LOAD_FAST",
            "instruction"
        ],
        [
            "LOAD_ATTR",
            "instruction.argval"
        ],
        [
            "LOAD_GLOBAL",
            "sentinel"
        ],
        [
            "COMPARE_OP",
            "instruction.argval == sentinel"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "LOAD_GLOBAL",
            "compile_similar_to"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.tree"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.frame"
        ],
        [
            "LOAD_ATTR",
            "self.frame.f_code"
        ],
        [
            "CALL",
            "compile_similar_to(self.tree, self.frame.f_code)"
        ],
        [
            "STORE_FAST",
            "module_code"
        ],
        [
            "LOAD_GLOBAL",
            "only"
        ],
        [
            "LOAD_GLOBAL",
            "find_codes"
        ],
        [
            "LOAD_FAST",
            "module_code"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.frame"
        ],
        [
            "LOAD_ATTR",
            "self.frame.f_code"
        ],
        [
            "CALL",
            "find_codes(module_code, self.frame.f_code)"
        ],
        [
            "CALL",
            "only(find_codes(module_code, self.frame.f_code))"
        ],
        [
            "STORE_FAST",
            "code"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_GLOBAL",
            "get_instructions"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "CALL",
            "get_instructions(code)"
        ],
        [
            "CALL",
            "list(get_instructions(code))"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "STORE_DEREF",
            "parent"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.iter_fields"
        ],
        [
            "LOAD_DEREF",
            "parent"
        ],
        [
            "CALL",
            "ast.iter_fields(parent)"
        ],
        [
            "STORE_DEREF",
            "name"
        ],
        [
            "STORE_DEREF",
            "field"
        ],
        [
            "LOAD_DEREF",
            "field"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "IS_OP",
            "field is node"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_DEREF",
            "field"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "CALL",
            "isinstance(field, list)"
        ],
        [
            "LOAD_GLOBAL",
            "enumerate"
        ],
        [
            "LOAD_DEREF",
            "field"
        ],
        [
            "CALL",
            "enumerate(field)"
        ],
        [
            "STORE_DEREF",
            "i"
        ],
        [
            "STORE_FAST",
            "item"
        ],
        [
            "LOAD_FAST",
            "item"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "IS_OP",
            "item is node"
        ],
        [
            "STORE_FAST",
            "                    def setter(new_node):\n                        field[i] = new_node"
        ],
        [
            "LOAD_FAST",
            "setter"
        ],
        [
            "LOAD_GLOBAL",
            "setattr"
        ],
        [
            "LOAD_DEREF",
            "parent"
        ],
        [
            "LOAD_DEREF",
            "name"
        ],
        [
            "LOAD_FAST",
            "new_node"
        ],
        [
            "CALL",
            "setattr(parent, name, new_node)"
        ],
        [
            "LOAD_FAST",
            "new_node"
        ],
        [
            "LOAD_DEREF",
            "field"
        ],
        [
            "LOAD_DEREF",
            "i"
        ],
        [
            "STORE_SUBSCR",
            "field[i]"
        ],
        [
            "STORE_DEREF",
            "    def matches(c):\n        return all(\n            f(c) == f(matching)\n            for f in [\n                attrgetter('co_firstlineno'),\n                attrgetter('co_name'),\n                code_names,\n            ]\n        )"
        ],
        [
            "STORE_DEREF",
            "code_options"
        ],
        [
            "LOAD_DEREF",
            "matches"
        ],
        [
            "LOAD_FAST",
            "root_code"
        ],
        [
            "CALL",
            "matches(root_code)"
        ],
        [
            "LOAD_DEREF",
            "code_options"
        ],
        [
            "LOAD_METHOD",
            "code_options.append"
        ],
        [
            "LOAD_FAST",
            "root_code"
        ],
        [
            "CALL",
            "code_options.append(root_code)"
        ],
        [
            "STORE_DEREF",
            "    def finder(code):\n        for const in code.co_consts:\n            if not inspect.iscode(const):\n                continue\n\n            if matches(const):\n                code_options.append(const)\n            finder(const)"
        ],
        [
            "LOAD_DEREF",
            "finder"
        ],
        [
            "LOAD_FAST",
            "root_code"
        ],
        [
            "CALL",
            "finder(root_code)"
        ],
        [
            "LOAD_DEREF",
            "code_options"
        ],
        [
            "LOAD_GLOBAL",
            "all"
        ],
        [
            "LOAD_GLOBAL",
            "attrgetter"
        ],
        [
            "CALL",
            "attrgetter('co_firstlineno')"
        ],
        [
            "LOAD_GLOBAL",
            "attrgetter"
        ],
        [
            "CALL",
            "attrgetter('co_name')"
        ],
        [
            "LOAD_GLOBAL",
            "code_names"
        ],
        [
            "CALL",
            "(\n            f(c) == f(matching)\n            for f in [\n                attrgetter('co_firstlineno'),\n                attrgetter('co_name'),\n                code_names,\n            ]\n        )"
        ],
        [
            "CALL",
            "all(\n            f(c) == f(matching)\n            for f in [\n                attrgetter('co_firstlineno'),\n                attrgetter('co_name'),\n                code_names,\n            ]\n        )"
        ],
        [
            "LOAD_FAST",
            "(\n            f(c) == f(matching)\n            for f in [\n                attrgetter('co_firstlineno'),\n                attrgetter('co_name'),\n                code_names,\n            ]\n        )"
        ],
        [
            "STORE_FAST",
            "f"
        ],
        [
            "LOAD_FAST",
            "f"
        ],
        [
            "LOAD_DEREF",
            "c"
        ],
        [
            "CALL",
            "f(c)"
        ],
        [
            "LOAD_FAST",
            "f"
        ],
        [
            "LOAD_DEREF",
            "matching"
        ],
        [
            "CALL",
            "f(matching)"
        ],
        [
            "COMPARE_OP",
            "f(c) == f(matching)"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_consts"
        ],
        [
            "STORE_FAST",
            "const"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.iscode"
        ],
        [
            "LOAD_FAST",
            "const"
        ],
        [
            "CALL",
            "inspect.iscode(const)"
        ],
        [
            "LOAD_DEREF",
            "matches"
        ],
        [
            "LOAD_FAST",
            "const"
        ],
        [
            "CALL",
            "matches(const)"
        ],
        [
            "LOAD_DEREF",
            "code_options"
        ],
        [
            "LOAD_METHOD",
            "code_options.append"
        ],
        [
            "LOAD_FAST",
            "const"
        ],
        [
            "CALL",
            "code_options.append(const)"
        ],
        [
            "LOAD_DEREF",
            "finder"
        ],
        [
            "LOAD_FAST",
            "const"
        ],
        [
            "CALL",
            "finder(const)"
        ],
        [
            "LOAD_GLOBAL",
            "frozenset"
        ],
        [
            "CALL",
            "frozenset()"
        ],
        [
            "LOAD_METHOD",
            "frozenset().union"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_names"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_varnames"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_freevars"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_cellvars"
        ],
        [
            "CALL",
            "frozenset().union(\n        code.co_names,\n        code.co_varnames,\n        code.co_freevars,\n        code.co_cellvars,\n    )"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.stmt"
        ],
        [
            "CALL",
            "isinstance(node, ast.stmt)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.stmt"
        ],
        [
            "CALL",
            "isinstance(node, ast.stmt)"
        ],
        [
            "LOAD_FAST",
            "node"
        ]
    ],
    "import_hook.py": [
        [
            "STORE_NAME",
            "import logging"
        ],
        [
            "STORE_NAME",
            "import sys"
        ],
        [
            "STORE_NAME",
            "from importlib.util import spec_from_loader"
        ],
        [
            "STORE_NAME",
            "import ast"
        ],
        [
            "CALL",
            "class BirdsEyeLoader:\n\n    def __init__(self, spec, source, deep):\n        self._spec = spec\n        self.source = source\n        self.deep = deep\n\n    def create_module(self, spec):\n        pass\n\n    def exec_module(self, module):\n        from birdseye.bird import eye\n        eye.exec_string(\n            source=self.source,\n            filename=self._spec.origin,\n            globs=module.__dict__,\n            locs=module.__dict__,\n            deep=self.deep,\n        )\n\n    def get_filename(self, fullname):\n        return self._spec.loader.get_filename(fullname)\n\n    def is_package(self, fullname):\n        return self._spec.loader.is_package(fullname)"
        ],
        [
            "STORE_NAME",
            "class BirdsEyeLoader:\n\n    def __init__(self, spec, source, deep):\n        self._spec = spec\n        self.source = source\n        self.deep = deep\n\n    def create_module(self, spec):\n        pass\n\n    def exec_module(self, module):\n        from birdseye.bird import eye\n        eye.exec_string(\n            source=self.source,\n            filename=self._spec.origin,\n            globs=module.__dict__,\n            locs=module.__dict__,\n            deep=self.deep,\n        )\n\n    def get_filename(self, fullname):\n        return self._spec.loader.get_filename(fullname)\n\n    def is_package(self, fullname):\n        return self._spec.loader.is_package(fullname)"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class BirdsEyeFinder(object):\n    \"\"\"Loads a module and looks for tracing inside, only providing a loader\n    if it finds some.\n    \"\"\"\n\n    def _find_plain_spec(self, fullname, path, target):\n        \"\"\"Try to find the original module using all the\n        remaining meta_path finders.\"\"\"\n        spec = None\n        for finder in sys.meta_path:\n            # when testing with pytest, it installs a finder that for\n            # some yet unknown reasons makes birdseye\n            # fail. For now it will just avoid using it and pass to\n            # the next one\n            if finder is self or 'pytest' in finder.__module__:\n                continue\n            if hasattr(finder, 'find_spec'):\n                spec = finder.find_spec(fullname, path, target=target)\n            elif hasattr(finder, 'load_module'):\n                spec = spec_from_loader(fullname, finder)\n\n            if spec is not None and spec.origin != 'builtin':\n                return spec\n\n    def find_spec(self, fullname, path, target=None):\n        spec = self._find_plain_spec(fullname, path, target)\n        if spec is None or not (hasattr(spec.loader, 'get_source') and\n                                callable(spec.loader.get_source)):  # noqa: E128\n            if fullname != 'org':\n                # stdlib pickle.py at line 94 contains a ``from\n                # org.python.core for Jython which is always failing,\n                # of course\n                logging.debug('Failed finding spec for %s', fullname)\n            return\n\n        try:\n            source = spec.loader.get_source(fullname)\n        except ImportError:\n            logging.debug('Loader for %s was unable to find the sources',\n                          fullname)\n            return\n        except Exception:\n            logging.exception('Loader for %s raised an error', fullname)\n            return\n\n        if not source or 'birdseye' not in source:\n            return\n\n        deep, trace_stmt = should_trace(source)\n\n        if not trace_stmt:\n            return\n\n        loader = BirdsEyeLoader(spec, source, deep)\n        return spec_from_loader(fullname, loader)"
        ],
        [
            "STORE_NAME",
            "class BirdsEyeFinder(object):\n    \"\"\"Loads a module and looks for tracing inside, only providing a loader\n    if it finds some.\n    \"\"\"\n\n    def _find_plain_spec(self, fullname, path, target):\n        \"\"\"Try to find the original module using all the\n        remaining meta_path finders.\"\"\"\n        spec = None\n        for finder in sys.meta_path:\n            # when testing with pytest, it installs a finder that for\n            # some yet unknown reasons makes birdseye\n            # fail. For now it will just avoid using it and pass to\n            # the next one\n            if finder is self or 'pytest' in finder.__module__:\n                continue\n            if hasattr(finder, 'find_spec'):\n                spec = finder.find_spec(fullname, path, target=target)\n            elif hasattr(finder, 'load_module'):\n                spec = spec_from_loader(fullname, finder)\n\n            if spec is not None and spec.origin != 'builtin':\n                return spec\n\n    def find_spec(self, fullname, path, target=None):\n        spec = self._find_plain_spec(fullname, path, target)\n        if spec is None or not (hasattr(spec.loader, 'get_source') and\n                                callable(spec.loader.get_source)):  # noqa: E128\n            if fullname != 'org':\n                # stdlib pickle.py at line 94 contains a ``from\n                # org.python.core for Jython which is always failing,\n                # of course\n                logging.debug('Failed finding spec for %s', fullname)\n            return\n\n        try:\n            source = spec.loader.get_source(fullname)\n        except ImportError:\n            logging.debug('Loader for %s was unable to find the sources',\n                          fullname)\n            return\n        except Exception:\n            logging.exception('Loader for %s raised an error', fullname)\n            return\n\n        if not source or 'birdseye' not in source:\n            return\n\n        deep, trace_stmt = should_trace(source)\n\n        if not trace_stmt:\n            return\n\n        loader = BirdsEyeLoader(spec, source, deep)\n        return spec_from_loader(fullname, loader)"
        ],
        [
            "STORE_NAME",
            "def should_trace(source):\n    trace_stmt = None\n    deep = False\n    for stmt in ast.parse(source).body:\n        if isinstance(stmt, ast.Import):\n            for alias in stmt.names:\n                if alias.name.startswith('birdseye.trace_module'):\n                    trace_stmt = stmt\n                    if alias.name.endswith('deep'):\n                        deep = True\n\n        if isinstance(stmt, ast.ImportFrom) and stmt.module == 'birdseye':\n            for alias in stmt.names:\n                if alias.name.startswith('trace_module'):\n                    trace_stmt = stmt\n                    if alias.name.endswith('deep'):\n                        deep = True\n    return deep, trace_stmt"
        ],
        [
            "STORE_NAME",
            "    def __init__(self, spec, source, deep):\n        self._spec = spec\n        self.source = source\n        self.deep = deep"
        ],
        [
            "STORE_NAME",
            "    def create_module(self, spec):\n        pass"
        ],
        [
            "STORE_NAME",
            "    def exec_module(self, module):\n        from birdseye.bird import eye\n        eye.exec_string(\n            source=self.source,\n            filename=self._spec.origin,\n            globs=module.__dict__,\n            locs=module.__dict__,\n            deep=self.deep,\n        )"
        ],
        [
            "STORE_NAME",
            "    def get_filename(self, fullname):\n        return self._spec.loader.get_filename(fullname)"
        ],
        [
            "STORE_NAME",
            "    def is_package(self, fullname):\n        return self._spec.loader.is_package(fullname)"
        ],
        [
            "LOAD_FAST",
            "spec"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self._spec"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.source"
        ],
        [
            "LOAD_FAST",
            "deep"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.deep"
        ],
        [
            "STORE_FAST",
            "from birdseye.bird import eye"
        ],
        [
            "LOAD_FAST",
            "eye"
        ],
        [
            "LOAD_METHOD",
            "eye.exec_string"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.source"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._spec"
        ],
        [
            "LOAD_ATTR",
            "self._spec.origin"
        ],
        [
            "LOAD_FAST",
            "module"
        ],
        [
            "LOAD_ATTR",
            "module.__dict__"
        ],
        [
            "LOAD_FAST",
            "module"
        ],
        [
            "LOAD_ATTR",
            "module.__dict__"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.deep"
        ],
        [
            "CALL",
            "eye.exec_string(\n            source=self.source,\n            filename=self._spec.origin,\n            globs=module.__dict__,\n            locs=module.__dict__,\n            deep=self.deep,\n        )"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._spec"
        ],
        [
            "LOAD_ATTR",
            "self._spec.loader"
        ],
        [
            "LOAD_METHOD",
            "self._spec.loader.get_filename"
        ],
        [
            "LOAD_FAST",
            "fullname"
        ],
        [
            "CALL",
            "self._spec.loader.get_filename(fullname)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._spec"
        ],
        [
            "LOAD_ATTR",
            "self._spec.loader"
        ],
        [
            "LOAD_METHOD",
            "self._spec.loader.is_package"
        ],
        [
            "LOAD_FAST",
            "fullname"
        ],
        [
            "CALL",
            "self._spec.loader.is_package(fullname)"
        ],
        [
            "STORE_NAME",
            "\"\"\"Loads a module and looks for tracing inside, only providing a loader\n    if it finds some.\n    \"\"\""
        ],
        [
            "STORE_NAME",
            "    def _find_plain_spec(self, fullname, path, target):\n        \"\"\"Try to find the original module using all the\n        remaining meta_path finders.\"\"\"\n        spec = None\n        for finder in sys.meta_path:\n            # when testing with pytest, it installs a finder that for\n            # some yet unknown reasons makes birdseye\n            # fail. For now it will just avoid using it and pass to\n            # the next one\n            if finder is self or 'pytest' in finder.__module__:\n                continue\n            if hasattr(finder, 'find_spec'):\n                spec = finder.find_spec(fullname, path, target=target)\n            elif hasattr(finder, 'load_module'):\n                spec = spec_from_loader(fullname, finder)\n\n            if spec is not None and spec.origin != 'builtin':\n                return spec"
        ],
        [
            "STORE_NAME",
            "    def find_spec(self, fullname, path, target=None):\n        spec = self._find_plain_spec(fullname, path, target)\n        if spec is None or not (hasattr(spec.loader, 'get_source') and\n                                callable(spec.loader.get_source)):  # noqa: E128\n            if fullname != 'org':\n                # stdlib pickle.py at line 94 contains a ``from\n                # org.python.core for Jython which is always failing,\n                # of course\n                logging.debug('Failed finding spec for %s', fullname)\n            return\n\n        try:\n            source = spec.loader.get_source(fullname)\n        except ImportError:\n            logging.debug('Loader for %s was unable to find the sources',\n                          fullname)\n            return\n        except Exception:\n            logging.exception('Loader for %s raised an error', fullname)\n            return\n\n        if not source or 'birdseye' not in source:\n            return\n\n        deep, trace_stmt = should_trace(source)\n\n        if not trace_stmt:\n            return\n\n        loader = BirdsEyeLoader(spec, source, deep)\n        return spec_from_loader(fullname, loader)"
        ],
        [
            "STORE_FAST",
            "spec"
        ],
        [
            "LOAD_GLOBAL",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.meta_path"
        ],
        [
            "STORE_FAST",
            "finder"
        ],
        [
            "LOAD_FAST",
            "finder"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "IS_OP",
            "finder is self"
        ],
        [
            "LOAD_FAST",
            "finder"
        ],
        [
            "LOAD_ATTR",
            "finder.__module__"
        ],
        [
            "CONTAINS_OP",
            "'pytest' in finder.__module__"
        ],
        [
            "LOAD_GLOBAL",
            "hasattr"
        ],
        [
            "LOAD_FAST",
            "finder"
        ],
        [
            "CALL",
            "hasattr(finder, 'find_spec')"
        ],
        [
            "LOAD_FAST",
            "finder"
        ],
        [
            "LOAD_METHOD",
            "finder.find_spec"
        ],
        [
            "LOAD_FAST",
            "fullname"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_FAST",
            "target"
        ],
        [
            "CALL",
            "finder.find_spec(fullname, path, target=target)"
        ],
        [
            "STORE_FAST",
            "spec"
        ],
        [
            "LOAD_GLOBAL",
            "hasattr"
        ],
        [
            "LOAD_FAST",
            "finder"
        ],
        [
            "CALL",
            "hasattr(finder, 'load_module')"
        ],
        [
            "LOAD_GLOBAL",
            "spec_from_loader"
        ],
        [
            "LOAD_FAST",
            "fullname"
        ],
        [
            "LOAD_FAST",
            "finder"
        ],
        [
            "CALL",
            "spec_from_loader(fullname, finder)"
        ],
        [
            "STORE_FAST",
            "spec"
        ],
        [
            "LOAD_FAST",
            "spec"
        ],
        [
            "LOAD_FAST",
            "spec"
        ],
        [
            "LOAD_ATTR",
            "spec.origin"
        ],
        [
            "COMPARE_OP",
            "spec.origin != 'builtin'"
        ],
        [
            "LOAD_FAST",
            "spec"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._find_plain_spec"
        ],
        [
            "LOAD_FAST",
            "fullname"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_FAST",
            "target"
        ],
        [
            "CALL",
            "self._find_plain_spec(fullname, path, target)"
        ],
        [
            "STORE_FAST",
            "spec"
        ],
        [
            "LOAD_FAST",
            "spec"
        ],
        [
            "LOAD_GLOBAL",
            "hasattr"
        ],
        [
            "LOAD_FAST",
            "spec"
        ],
        [
            "LOAD_ATTR",
            "spec.loader"
        ],
        [
            "CALL",
            "hasattr(spec.loader, 'get_source')"
        ],
        [
            "LOAD_GLOBAL",
            "callable"
        ],
        [
            "LOAD_FAST",
            "spec"
        ],
        [
            "LOAD_ATTR",
            "spec.loader"
        ],
        [
            "LOAD_ATTR",
            "spec.loader.get_source"
        ],
        [
            "CALL",
            "callable(spec.loader.get_source)"
        ],
        [
            "LOAD_FAST",
            "fullname"
        ],
        [
            "COMPARE_OP",
            "fullname != 'org'"
        ],
        [
            "LOAD_GLOBAL",
            "logging"
        ],
        [
            "LOAD_ATTR",
            "logging.debug"
        ],
        [
            "LOAD_FAST",
            "fullname"
        ],
        [
            "CALL",
            "logging.debug('Failed finding spec for %s', fullname)"
        ],
        [
            "LOAD_FAST",
            "spec"
        ],
        [
            "LOAD_ATTR",
            "spec.loader"
        ],
        [
            "LOAD_METHOD",
            "spec.loader.get_source"
        ],
        [
            "LOAD_FAST",
            "fullname"
        ],
        [
            "CALL",
            "spec.loader.get_source(fullname)"
        ],
        [
            "STORE_FAST",
            "source"
        ],
        [
            "LOAD_GLOBAL",
            "ImportError"
        ],
        [
            "LOAD_GLOBAL",
            "logging"
        ],
        [
            "LOAD_ATTR",
            "logging.debug"
        ],
        [
            "LOAD_FAST",
            "fullname"
        ],
        [
            "CALL",
            "logging.debug('Loader for %s was unable to find the sources',\n                          fullname)"
        ],
        [
            "LOAD_GLOBAL",
            "Exception"
        ],
        [
            "LOAD_GLOBAL",
            "logging"
        ],
        [
            "LOAD_ATTR",
            "logging.exception"
        ],
        [
            "LOAD_FAST",
            "fullname"
        ],
        [
            "CALL",
            "logging.exception('Loader for %s raised an error', fullname)"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CONTAINS_OP",
            "'birdseye' not in source"
        ],
        [
            "LOAD_GLOBAL",
            "should_trace"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CALL",
            "should_trace(source)"
        ],
        [
            "STORE_FAST",
            "deep"
        ],
        [
            "STORE_FAST",
            "trace_stmt"
        ],
        [
            "LOAD_FAST",
            "trace_stmt"
        ],
        [
            "LOAD_GLOBAL",
            "BirdsEyeLoader"
        ],
        [
            "LOAD_FAST",
            "spec"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "deep"
        ],
        [
            "CALL",
            "BirdsEyeLoader(spec, source, deep)"
        ],
        [
            "STORE_FAST",
            "loader"
        ],
        [
            "LOAD_GLOBAL",
            "spec_from_loader"
        ],
        [
            "LOAD_FAST",
            "fullname"
        ],
        [
            "LOAD_FAST",
            "loader"
        ],
        [
            "CALL",
            "spec_from_loader(fullname, loader)"
        ],
        [
            "STORE_FAST",
            "trace_stmt"
        ],
        [
            "STORE_FAST",
            "deep"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.parse"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CALL",
            "ast.parse(source)"
        ],
        [
            "LOAD_ATTR",
            "ast.parse(source).body"
        ],
        [
            "STORE_FAST",
            "stmt"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "stmt"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Import"
        ],
        [
            "CALL",
            "isinstance(stmt, ast.Import)"
        ],
        [
            "LOAD_FAST",
            "stmt"
        ],
        [
            "LOAD_ATTR",
            "stmt.names"
        ],
        [
            "STORE_FAST",
            "alias"
        ],
        [
            "LOAD_FAST",
            "alias"
        ],
        [
            "LOAD_ATTR",
            "alias.name"
        ],
        [
            "LOAD_METHOD",
            "alias.name.startswith"
        ],
        [
            "CALL",
            "alias.name.startswith('birdseye.trace_module')"
        ],
        [
            "LOAD_FAST",
            "stmt"
        ],
        [
            "STORE_FAST",
            "trace_stmt"
        ],
        [
            "LOAD_FAST",
            "alias"
        ],
        [
            "LOAD_ATTR",
            "alias.name"
        ],
        [
            "LOAD_METHOD",
            "alias.name.endswith"
        ],
        [
            "CALL",
            "alias.name.endswith('deep')"
        ],
        [
            "STORE_FAST",
            "deep"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "stmt"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.ImportFrom"
        ],
        [
            "CALL",
            "isinstance(stmt, ast.ImportFrom)"
        ],
        [
            "LOAD_FAST",
            "stmt"
        ],
        [
            "LOAD_ATTR",
            "stmt.module"
        ],
        [
            "COMPARE_OP",
            "stmt.module == 'birdseye'"
        ],
        [
            "LOAD_FAST",
            "stmt"
        ],
        [
            "LOAD_ATTR",
            "stmt.names"
        ],
        [
            "STORE_FAST",
            "alias"
        ],
        [
            "LOAD_FAST",
            "alias"
        ],
        [
            "LOAD_ATTR",
            "alias.name"
        ],
        [
            "LOAD_METHOD",
            "alias.name.startswith"
        ],
        [
            "CALL",
            "alias.name.startswith('trace_module')"
        ],
        [
            "LOAD_FAST",
            "stmt"
        ],
        [
            "STORE_FAST",
            "trace_stmt"
        ],
        [
            "LOAD_FAST",
            "alias"
        ],
        [
            "LOAD_ATTR",
            "alias.name"
        ],
        [
            "LOAD_METHOD",
            "alias.name.endswith"
        ],
        [
            "CALL",
            "alias.name.endswith('deep')"
        ],
        [
            "STORE_FAST",
            "deep"
        ],
        [
            "LOAD_FAST",
            "deep"
        ],
        [
            "LOAD_FAST",
            "trace_stmt"
        ]
    ],
    "ipython.py": [
        [
            "STORE_NAME",
            "import inspect"
        ],
        [
            "STORE_NAME",
            "import socket"
        ],
        [
            "STORE_NAME",
            "import sys"
        ],
        [
            "STORE_NAME",
            "from io import BytesIO, StringIO"
        ],
        [
            "STORE_NAME",
            "from io import BytesIO, StringIO"
        ],
        [
            "STORE_NAME",
            "from threading import current_thread, Thread"
        ],
        [
            "STORE_NAME",
            "from threading import current_thread, Thread"
        ],
        [
            "STORE_NAME",
            "from uuid import uuid4"
        ],
        [
            "STORE_NAME",
            "from IPython.core.display import HTML, display"
        ],
        [
            "STORE_NAME",
            "from IPython.core.display import HTML, display"
        ],
        [
            "STORE_NAME",
            "from IPython.core.magic import Magics, cell_magic, magics_class"
        ],
        [
            "STORE_NAME",
            "from IPython.core.magic import Magics, cell_magic, magics_class"
        ],
        [
            "STORE_NAME",
            "from IPython.core.magic import Magics, cell_magic, magics_class"
        ],
        [
            "STORE_NAME",
            "from jinja2 import Environment, PackageLoader, select_autoescape"
        ],
        [
            "STORE_NAME",
            "from jinja2 import Environment, PackageLoader, select_autoescape"
        ],
        [
            "STORE_NAME",
            "from jinja2 import Environment, PackageLoader, select_autoescape"
        ],
        [
            "STORE_NAME",
            "from traitlets import Unicode, Int, Bool"
        ],
        [
            "STORE_NAME",
            "from traitlets import Unicode, Int, Bool"
        ],
        [
            "STORE_NAME",
            "from traitlets import Unicode, Int, Bool"
        ],
        [
            "STORE_NAME",
            "from werkzeug.local import LocalProxy"
        ],
        [
            "STORE_NAME",
            "from werkzeug.serving import ThreadingMixIn"
        ],
        [
            "STORE_NAME",
            "from birdseye.bird import PY2, Database"
        ],
        [
            "STORE_NAME",
            "from birdseye.bird import PY2, Database"
        ],
        [
            "STORE_NAME",
            "from birdseye import server, eye"
        ],
        [
            "STORE_NAME",
            "from birdseye import server, eye"
        ],
        [
            "LOAD_NAME",
            "PY2"
        ],
        [
            "LOAD_NAME",
            "BytesIO"
        ],
        [
            "LOAD_NAME",
            "StringIO"
        ],
        [
            "STORE_NAME",
            "fake_stream"
        ],
        [
            "STORE_NAME",
            "thread_proxies"
        ],
        [
            "STORE_NAME",
            "def stream_proxy(original):\n    def p():\n        frame = inspect.currentframe()\n        while frame:\n            if frame.f_code == ThreadingMixIn.process_request_thread.__code__:\n                return fake_stream()\n            frame = frame.f_back\n        return thread_proxies.get(current_thread().ident,\n                                  original)\n\n    return LocalProxy(p)"
        ],
        [
            "LOAD_NAME",
            "stream_proxy"
        ],
        [
            "LOAD_NAME",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.stderr"
        ],
        [
            "CALL",
            "stream_proxy(sys.stderr)"
        ],
        [
            "LOAD_NAME",
            "sys"
        ],
        [
            "STORE_ATTR",
            "sys.stderr"
        ],
        [
            "LOAD_NAME",
            "stream_proxy"
        ],
        [
            "LOAD_NAME",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.stdout"
        ],
        [
            "CALL",
            "stream_proxy(sys.stdout)"
        ],
        [
            "LOAD_NAME",
            "sys"
        ],
        [
            "STORE_ATTR",
            "sys.stdout"
        ],
        [
            "STORE_NAME",
            "def run_server(port, bind_host, show_server_output):\n    if not show_server_output:\n        thread_proxies[current_thread().ident] = fake_stream()\n    try:\n        server.app.run(\n            debug=True,\n            port=port,\n            host=bind_host,\n            use_reloader=False,\n        )\n    except socket.error:\n        pass"
        ],
        [
            "LOAD_NAME",
            "Environment"
        ],
        [
            "LOAD_NAME",
            "PackageLoader"
        ],
        [
            "CALL",
            "PackageLoader('birdseye', 'templates')"
        ],
        [
            "LOAD_NAME",
            "select_autoescape"
        ],
        [
            "CALL",
            "select_autoescape(['html', 'xml'])"
        ],
        [
            "CALL",
            "Environment(\n    loader=PackageLoader('birdseye', 'templates'),\n    autoescape=select_autoescape(['html', 'xml'])\n)"
        ],
        [
            "STORE_NAME",
            "templates_env"
        ],
        [
            "LOAD_NAME",
            "magics_class"
        ],
        [
            "LOAD_NAME",
            "Magics"
        ],
        [
            "CALL",
            "@magics_class\nclass BirdsEyeMagics(Magics):\n    server_url = Unicode(\n        u'', config=True,\n        help='If set, a server will not be automatically started by %%eye. '\n             'The iframe containing birdseye output will use this value as the base '\n             'of its URL.'\n    )\n\n    port = Int(\n        7777, config=True,\n        help='Port number for the server started by %%eye.'\n    )\n\n    bind_host = Unicode(\n        '127.0.0.1', config=True,\n        help='Host that the server started by %%eye listens on. '\n             'Set to 0.0.0.0 to make it accessible anywhere.'\n    )\n\n    show_server_output = Bool(\n        False, config=True,\n        help='Set to True to show stdout and stderr from the server started by %%eye.'\n    )\n\n    db_url = Unicode(\n        u'', config=True,\n        help='The database URL that the server started by %%eye reads from. '\n             'Equivalent to the environment variable BIRDSEYE_DB.'\n    )\n\n    @cell_magic\n    def eye(self, _line, cell):\n        if not self.server_url:\n            server.db = Database(self.db_url)\n            server.Function = server.db.Function\n            server.Call = server.db.Call\n            server.Session = server.db.Session\n            Thread(\n                target=run_server,\n                args=(\n                    self.port,\n                    self.bind_host,\n                    self.show_server_output,\n                ),\n            ).start()\n\n        eye.db = Database(self.db_url)\n\n        def callback(call_id):\n            \"\"\"\n            Always executes after the cell, whether or not an exception is raised\n            in the user code.\n            \"\"\"\n            if call_id is None:  # probably means a bug\n                return\n\n            html = HTML(templates_env.get_template('ipython_iframe.html').render(\n                call_id=call_id,\n                url=self.server_url.rstrip('/'),\n                port=self.port,\n                container_id=uuid4().hex,\n            ))\n\n            # noinspection PyTypeChecker\n            display(html)\n\n        value = eye.exec_ipython_cell(cell, callback)\n        # Display the value as would happen if the %eye magic wasn't there\n        return value"
        ],
        [
            "CALL",
            "magics_class"
        ],
        [
            "STORE_NAME",
            "@magics_class\nclass BirdsEyeMagics(Magics):\n    server_url = Unicode(\n        u'', config=True,\n        help='If set, a server will not be automatically started by %%eye. '\n             'The iframe containing birdseye output will use this value as the base '\n             'of its URL.'\n    )\n\n    port = Int(\n        7777, config=True,\n        help='Port number for the server started by %%eye.'\n    )\n\n    bind_host = Unicode(\n        '127.0.0.1', config=True,\n        help='Host that the server started by %%eye listens on. '\n             'Set to 0.0.0.0 to make it accessible anywhere.'\n    )\n\n    show_server_output = Bool(\n        False, config=True,\n        help='Set to True to show stdout and stderr from the server started by %%eye.'\n    )\n\n    db_url = Unicode(\n        u'', config=True,\n        help='The database URL that the server started by %%eye reads from. '\n             'Equivalent to the environment variable BIRDSEYE_DB.'\n    )\n\n    @cell_magic\n    def eye(self, _line, cell):\n        if not self.server_url:\n            server.db = Database(self.db_url)\n            server.Function = server.db.Function\n            server.Call = server.db.Call\n            server.Session = server.db.Session\n            Thread(\n                target=run_server,\n                args=(\n                    self.port,\n                    self.bind_host,\n                    self.show_server_output,\n                ),\n            ).start()\n\n        eye.db = Database(self.db_url)\n\n        def callback(call_id):\n            \"\"\"\n            Always executes after the cell, whether or not an exception is raised\n            in the user code.\n            \"\"\"\n            if call_id is None:  # probably means a bug\n                return\n\n            html = HTML(templates_env.get_template('ipython_iframe.html').render(\n                call_id=call_id,\n                url=self.server_url.rstrip('/'),\n                port=self.port,\n                container_id=uuid4().hex,\n            ))\n\n            # noinspection PyTypeChecker\n            display(html)\n\n        value = eye.exec_ipython_cell(cell, callback)\n        # Display the value as would happen if the %eye magic wasn't there\n        return value"
        ],
        [
            "STORE_FAST",
            "    def p():\n        frame = inspect.currentframe()\n        while frame:\n            if frame.f_code == ThreadingMixIn.process_request_thread.__code__:\n                return fake_stream()\n            frame = frame.f_back\n        return thread_proxies.get(current_thread().ident,\n                                  original)"
        ],
        [
            "LOAD_GLOBAL",
            "LocalProxy"
        ],
        [
            "LOAD_FAST",
            "p"
        ],
        [
            "CALL",
            "LocalProxy(p)"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.currentframe"
        ],
        [
            "CALL",
            "inspect.currentframe()"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_GLOBAL",
            "ThreadingMixIn"
        ],
        [
            "LOAD_ATTR",
            "ThreadingMixIn.process_request_thread"
        ],
        [
            "LOAD_ATTR",
            "ThreadingMixIn.process_request_thread.__code__"
        ],
        [
            "COMPARE_OP",
            "frame.f_code == ThreadingMixIn.process_request_thread.__code__"
        ],
        [
            "LOAD_GLOBAL",
            "fake_stream"
        ],
        [
            "CALL",
            "fake_stream()"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_back"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_GLOBAL",
            "thread_proxies"
        ],
        [
            "LOAD_METHOD",
            "thread_proxies.get"
        ],
        [
            "LOAD_GLOBAL",
            "current_thread"
        ],
        [
            "CALL",
            "current_thread()"
        ],
        [
            "LOAD_ATTR",
            "current_thread().ident"
        ],
        [
            "LOAD_DEREF",
            "original"
        ],
        [
            "CALL",
            "thread_proxies.get(current_thread().ident,\n                                  original)"
        ],
        [
            "LOAD_FAST",
            "show_server_output"
        ],
        [
            "LOAD_GLOBAL",
            "fake_stream"
        ],
        [
            "CALL",
            "fake_stream()"
        ],
        [
            "LOAD_GLOBAL",
            "thread_proxies"
        ],
        [
            "LOAD_GLOBAL",
            "current_thread"
        ],
        [
            "CALL",
            "current_thread()"
        ],
        [
            "LOAD_ATTR",
            "current_thread().ident"
        ],
        [
            "STORE_SUBSCR",
            "thread_proxies[current_thread().ident]"
        ],
        [
            "LOAD_GLOBAL",
            "server"
        ],
        [
            "LOAD_ATTR",
            "server.app"
        ],
        [
            "LOAD_METHOD",
            "server.app.run"
        ],
        [
            "LOAD_FAST",
            "port"
        ],
        [
            "LOAD_FAST",
            "bind_host"
        ],
        [
            "CALL",
            "server.app.run(\n            debug=True,\n            port=port,\n            host=bind_host,\n            use_reloader=False,\n        )"
        ],
        [
            "LOAD_GLOBAL",
            "socket"
        ],
        [
            "LOAD_ATTR",
            "socket.error"
        ],
        [
            "LOAD_NAME",
            "Unicode"
        ],
        [
            "CALL",
            "Unicode(\n        u'', config=True,\n        help='If set, a server will not be automatically started by %%eye. '\n             'The iframe containing birdseye output will use this value as the base '\n             'of its URL.'\n    )"
        ],
        [
            "STORE_NAME",
            "server_url"
        ],
        [
            "LOAD_NAME",
            "Int"
        ],
        [
            "CALL",
            "Int(\n        7777, config=True,\n        help='Port number for the server started by %%eye.'\n    )"
        ],
        [
            "STORE_NAME",
            "port"
        ],
        [
            "LOAD_NAME",
            "Unicode"
        ],
        [
            "CALL",
            "Unicode(\n        '127.0.0.1', config=True,\n        help='Host that the server started by %%eye listens on. '\n             'Set to 0.0.0.0 to make it accessible anywhere.'\n    )"
        ],
        [
            "STORE_NAME",
            "bind_host"
        ],
        [
            "LOAD_NAME",
            "Bool"
        ],
        [
            "CALL",
            "Bool(\n        False, config=True,\n        help='Set to True to show stdout and stderr from the server started by %%eye.'\n    )"
        ],
        [
            "STORE_NAME",
            "show_server_output"
        ],
        [
            "LOAD_NAME",
            "Unicode"
        ],
        [
            "CALL",
            "Unicode(\n        u'', config=True,\n        help='The database URL that the server started by %%eye reads from. '\n             'Equivalent to the environment variable BIRDSEYE_DB.'\n    )"
        ],
        [
            "STORE_NAME",
            "db_url"
        ],
        [
            "LOAD_NAME",
            "cell_magic"
        ],
        [
            "CALL",
            "cell_magic"
        ],
        [
            "STORE_NAME",
            "    @cell_magic\n    def eye(self, _line, cell):\n        if not self.server_url:\n            server.db = Database(self.db_url)\n            server.Function = server.db.Function\n            server.Call = server.db.Call\n            server.Session = server.db.Session\n            Thread(\n                target=run_server,\n                args=(\n                    self.port,\n                    self.bind_host,\n                    self.show_server_output,\n                ),\n            ).start()\n\n        eye.db = Database(self.db_url)\n\n        def callback(call_id):\n            \"\"\"\n            Always executes after the cell, whether or not an exception is raised\n            in the user code.\n            \"\"\"\n            if call_id is None:  # probably means a bug\n                return\n\n            html = HTML(templates_env.get_template('ipython_iframe.html').render(\n                call_id=call_id,\n                url=self.server_url.rstrip('/'),\n                port=self.port,\n                container_id=uuid4().hex,\n            ))\n\n            # noinspection PyTypeChecker\n            display(html)\n\n        value = eye.exec_ipython_cell(cell, callback)\n        # Display the value as would happen if the %eye magic wasn't there\n        return value"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.server_url"
        ],
        [
            "LOAD_GLOBAL",
            "Database"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.db_url"
        ],
        [
            "CALL",
            "Database(self.db_url)"
        ],
        [
            "LOAD_GLOBAL",
            "server"
        ],
        [
            "STORE_ATTR",
            "server.db"
        ],
        [
            "LOAD_GLOBAL",
            "server"
        ],
        [
            "LOAD_ATTR",
            "server.db"
        ],
        [
            "LOAD_ATTR",
            "server.db.Function"
        ],
        [
            "LOAD_GLOBAL",
            "server"
        ],
        [
            "STORE_ATTR",
            "server.Function"
        ],
        [
            "LOAD_GLOBAL",
            "server"
        ],
        [
            "LOAD_ATTR",
            "server.db"
        ],
        [
            "LOAD_ATTR",
            "server.db.Call"
        ],
        [
            "LOAD_GLOBAL",
            "server"
        ],
        [
            "STORE_ATTR",
            "server.Call"
        ],
        [
            "LOAD_GLOBAL",
            "server"
        ],
        [
            "LOAD_ATTR",
            "server.db"
        ],
        [
            "LOAD_ATTR",
            "server.db.Session"
        ],
        [
            "LOAD_GLOBAL",
            "server"
        ],
        [
            "STORE_ATTR",
            "server.Session"
        ],
        [
            "LOAD_GLOBAL",
            "Thread"
        ],
        [
            "LOAD_GLOBAL",
            "run_server"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.port"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.bind_host"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.show_server_output"
        ],
        [
            "CALL",
            "Thread(\n                target=run_server,\n                args=(\n                    self.port,\n                    self.bind_host,\n                    self.show_server_output,\n                ),\n            )"
        ],
        [
            "LOAD_METHOD",
            "Thread(\n                target=run_server,\n                args=(\n                    self.port,\n                    self.bind_host,\n                    self.show_server_output,\n                ),\n            ).start"
        ],
        [
            "CALL",
            "Thread(\n                target=run_server,\n                args=(\n                    self.port,\n                    self.bind_host,\n                    self.show_server_output,\n                ),\n            ).start()"
        ],
        [
            "LOAD_GLOBAL",
            "Database"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.db_url"
        ],
        [
            "CALL",
            "Database(self.db_url)"
        ],
        [
            "LOAD_GLOBAL",
            "eye"
        ],
        [
            "STORE_ATTR",
            "eye.db"
        ],
        [
            "STORE_FAST",
            "        def callback(call_id):\n            \"\"\"\n            Always executes after the cell, whether or not an exception is raised\n            in the user code.\n            \"\"\"\n            if call_id is None:  # probably means a bug\n                return\n\n            html = HTML(templates_env.get_template('ipython_iframe.html').render(\n                call_id=call_id,\n                url=self.server_url.rstrip('/'),\n                port=self.port,\n                container_id=uuid4().hex,\n            ))\n\n            # noinspection PyTypeChecker\n            display(html)"
        ],
        [
            "LOAD_GLOBAL",
            "eye"
        ],
        [
            "LOAD_ATTR",
            "eye.exec_ipython_cell"
        ],
        [
            "LOAD_FAST",
            "cell"
        ],
        [
            "LOAD_FAST",
            "callback"
        ],
        [
            "CALL",
            "eye.exec_ipython_cell(cell, callback)"
        ],
        [
            "STORE_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "call_id"
        ],
        [
            "LOAD_GLOBAL",
            "HTML"
        ],
        [
            "LOAD_GLOBAL",
            "templates_env"
        ],
        [
            "LOAD_METHOD",
            "templates_env.get_template"
        ],
        [
            "CALL",
            "templates_env.get_template('ipython_iframe.html')"
        ],
        [
            "LOAD_METHOD",
            "templates_env.get_template('ipython_iframe.html').render"
        ],
        [
            "LOAD_FAST",
            "call_id"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.server_url"
        ],
        [
            "LOAD_METHOD",
            "self.server_url.rstrip"
        ],
        [
            "CALL",
            "self.server_url.rstrip('/')"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.port"
        ],
        [
            "LOAD_GLOBAL",
            "uuid4"
        ],
        [
            "CALL",
            "uuid4()"
        ],
        [
            "LOAD_ATTR",
            "uuid4().hex"
        ],
        [
            "CALL",
            "templates_env.get_template('ipython_iframe.html').render(\n                call_id=call_id,\n                url=self.server_url.rstrip('/'),\n                port=self.port,\n                container_id=uuid4().hex,\n            )"
        ],
        [
            "CALL",
            "HTML(templates_env.get_template('ipython_iframe.html').render(\n                call_id=call_id,\n                url=self.server_url.rstrip('/'),\n                port=self.port,\n                container_id=uuid4().hex,\n            ))"
        ],
        [
            "STORE_FAST",
            "html"
        ],
        [
            "LOAD_GLOBAL",
            "display"
        ],
        [
            "LOAD_FAST",
            "html"
        ],
        [
            "CALL",
            "display(html)"
        ]
    ],
    "server.py": [
        [
            "STORE_NAME",
            "from __future__ import print_function, division, absolute_import"
        ],
        [
            "STORE_NAME",
            "from __future__ import print_function, division, absolute_import"
        ],
        [
            "STORE_NAME",
            "from __future__ import print_function, division, absolute_import"
        ],
        [
            "STORE_NAME",
            "import json"
        ],
        [
            "STORE_NAME",
            "from collections import OrderedDict"
        ],
        [
            "STORE_NAME",
            "from functools import partial"
        ],
        [
            "STORE_NAME",
            "from os.path import basename"
        ],
        [
            "STORE_NAME",
            "from future import standard_library"
        ],
        [
            "STORE_NAME",
            "from littleutils import DecentJSONEncoder, withattrs, group_by_attr"
        ],
        [
            "STORE_NAME",
            "from littleutils import DecentJSONEncoder, withattrs, group_by_attr"
        ],
        [
            "STORE_NAME",
            "from littleutils import DecentJSONEncoder, withattrs, group_by_attr"
        ],
        [
            "LOAD_NAME",
            "standard_library"
        ],
        [
            "LOAD_ATTR",
            "standard_library.install_aliases"
        ],
        [
            "CALL",
            "standard_library.install_aliases()"
        ],
        [
            "STORE_NAME",
            "import argparse"
        ],
        [
            "STORE_NAME",
            "import os"
        ],
        [
            "STORE_NAME",
            "import sys"
        ],
        [
            "STORE_NAME",
            "from flask import Flask, request, jsonify, url_for"
        ],
        [
            "STORE_NAME",
            "from flask import Flask, request, jsonify, url_for"
        ],
        [
            "STORE_NAME",
            "from flask import Flask, request, jsonify, url_for"
        ],
        [
            "STORE_NAME",
            "from flask import Flask, request, jsonify, url_for"
        ],
        [
            "STORE_NAME",
            "from flask.templating import render_template"
        ],
        [
            "STORE_NAME",
            "from flask_humanize import Humanize"
        ],
        [
            "STORE_NAME",
            "from werkzeug.routing import PathConverter"
        ],
        [
            "STORE_NAME",
            "import sqlalchemy"
        ],
        [
            "STORE_NAME",
            "from birdseye.db import Database"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import short_path, IPYTHON_FILE_PATH, fix_abs_path, is_ipython_cell"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import short_path, IPYTHON_FILE_PATH, fix_abs_path, is_ipython_cell"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import short_path, IPYTHON_FILE_PATH, fix_abs_path, is_ipython_cell"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import short_path, IPYTHON_FILE_PATH, fix_abs_path, is_ipython_cell"
        ],
        [
            "LOAD_NAME",
            "Flask"
        ],
        [
            "CALL",
            "Flask('birdseye')"
        ],
        [
            "STORE_NAME",
            "app"
        ],
        [
            "LOAD_NAME",
            "app"
        ],
        [
            "LOAD_ATTR",
            "app.jinja_env"
        ],
        [
            "STORE_ATTR",
            "app.jinja_env.auto_reload"
        ],
        [
            "LOAD_NAME",
            "Humanize"
        ],
        [
            "LOAD_NAME",
            "app"
        ],
        [
            "CALL",
            "Humanize(app)"
        ],
        [
            "LOAD_NAME",
            "PathConverter"
        ],
        [
            "CALL",
            "class FileConverter(PathConverter):\n    regex = '.*?'"
        ],
        [
            "STORE_NAME",
            "class FileConverter(PathConverter):\n    regex = '.*?'"
        ],
        [
            "LOAD_NAME",
            "FileConverter"
        ],
        [
            "LOAD_NAME",
            "app"
        ],
        [
            "LOAD_ATTR",
            "app.url_map"
        ],
        [
            "LOAD_ATTR",
            "app.url_map.converters"
        ],
        [
            "STORE_SUBSCR",
            "app.url_map.converters['file']"
        ],
        [
            "LOAD_NAME",
            "Database"
        ],
        [
            "CALL",
            "Database()"
        ],
        [
            "STORE_NAME",
            "db"
        ],
        [
            "LOAD_NAME",
            "db"
        ],
        [
            "LOAD_ATTR",
            "db.Session"
        ],
        [
            "STORE_NAME",
            "Session"
        ],
        [
            "LOAD_NAME",
            "db"
        ],
        [
            "LOAD_ATTR",
            "db.Function"
        ],
        [
            "STORE_NAME",
            "Function"
        ],
        [
            "LOAD_NAME",
            "db"
        ],
        [
            "LOAD_ATTR",
            "db.Call"
        ],
        [
            "STORE_NAME",
            "Call"
        ],
        [
            "LOAD_NAME",
            "app"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL",
            "app.route('/')"
        ],
        [
            "LOAD_NAME",
            "db"
        ],
        [
            "LOAD_ATTR",
            "db.provide_session"
        ],
        [
            "CALL",
            "db.provide_session"
        ],
        [
            "CALL",
            "app.route('/')"
        ],
        [
            "STORE_NAME",
            "@app.route('/')\n@db.provide_session\ndef index(session):\n    all_paths = db.all_file_paths()\n\n    recent_calls = (session.query(*(Call.basic_columns + Function.basic_columns))\n                        .join(Function)\n                        .order_by(Call.start_time.desc())[:100])\n\n    files = OrderedDict()\n\n    for row in recent_calls:\n        if is_ipython_cell(row.file):\n            continue\n        files.setdefault(\n            row.file, OrderedDict()\n        ).setdefault(\n            row.name, row\n        )\n\n    for path in all_paths:\n        files.setdefault(\n            path, OrderedDict()\n        )\n\n    short = partial(short_path, all_paths=all_paths)\n\n    return render_template('index.html',\n                           short=short,\n                           files=files)"
        ],
        [
            "LOAD_NAME",
            "app"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL",
            "app.route('/file/<file:path>')"
        ],
        [
            "LOAD_NAME",
            "db"
        ],
        [
            "LOAD_ATTR",
            "db.provide_session"
        ],
        [
            "CALL",
            "db.provide_session"
        ],
        [
            "CALL",
            "app.route('/file/<file:path>')"
        ],
        [
            "STORE_NAME",
            "@app.route('/file/<file:path>')\n@db.provide_session\ndef file_view(session, path):\n    path = fix_abs_path(path)\n\n    # Get all calls and functions in this file\n    filtered_calls = (session.query(*(Call.basic_columns + Function.basic_columns))\n                      .join(Function)\n                      .filter_by(file=path)\n                      .subquery('filtered_calls'))\n\n    # Get the latest call *time* for each function in the file\n    latest_calls = session.query(\n        filtered_calls.c.name,\n        sqlalchemy.func.max(filtered_calls.c.start_time).label('maxtime')\n    ).group_by(\n        filtered_calls.c.name,\n    ).subquery('latest_calls')\n\n    # Get the latest call for each function\n    query = session.query(filtered_calls).join(\n        latest_calls,\n        sqlalchemy.and_(\n            filtered_calls.c.name == latest_calls.c.name,\n            filtered_calls.c.start_time == latest_calls.c.maxtime,\n        )\n    ).order_by(filtered_calls.c.start_time.desc())\n    funcs = group_by_attr(query, 'type')\n\n    # Add any functions which were never called\n    all_funcs = sorted(session.query(Function.name, Function.type)\n                       .filter_by(file=path)\n                       .distinct())\n    func_names = {row.name for row in query}\n    for func in all_funcs:\n        if func.name not in func_names:\n            funcs[func.type].append(func)\n\n    return render_template('file.html',\n                           funcs=funcs,\n                           is_ipython=path == IPYTHON_FILE_PATH,\n                           full_path=path,\n                           short_path=basename(path))"
        ],
        [
            "LOAD_NAME",
            "app"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL",
            "app.route('/file/<file:path>/__function__/<func_name>')"
        ],
        [
            "LOAD_NAME",
            "db"
        ],
        [
            "LOAD_ATTR",
            "db.provide_session"
        ],
        [
            "CALL",
            "db.provide_session"
        ],
        [
            "CALL",
            "app.route('/file/<file:path>/__function__/<func_name>')"
        ],
        [
            "STORE_NAME",
            "@app.route('/file/<file:path>/__function__/<func_name>')\n@db.provide_session\ndef func_view(session, path, func_name):\n    path = fix_abs_path(path)\n    query = get_calls(session, path, func_name, 200)\n    if query:\n        func = query[0]\n        calls = [withattrs(Call(), **row._asdict()) for row in query]\n    else:\n        func = session.query(Function).filter_by(file=path, name=func_name)[0]\n        calls = None\n\n    return render_template('function.html',\n                           func=func,\n                           short_path=basename(path),\n                           calls=calls)"
        ],
        [
            "LOAD_NAME",
            "app"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL",
            "app.route('/api/file/<file:path>/__function__/<func_name>/latest_call/')"
        ],
        [
            "LOAD_NAME",
            "db"
        ],
        [
            "LOAD_ATTR",
            "db.provide_session"
        ],
        [
            "CALL",
            "db.provide_session"
        ],
        [
            "CALL",
            "app.route('/api/file/<file:path>/__function__/<func_name>/latest_call/')"
        ],
        [
            "STORE_NAME",
            "@app.route('/api/file/<file:path>/__function__/<func_name>/latest_call/')\n@db.provide_session\ndef latest_call(session, path, func_name):\n    path = fix_abs_path(path)\n    call = get_calls(session, path, func_name, 1)[0]\n    return jsonify(dict(\n        id=call.id,\n        url=url_for(call_view.__name__,\n                    call_id=call.id),\n    ))"
        ],
        [
            "STORE_NAME",
            "def get_calls(session, path, func_name, limit):\n    return (session.query(*(Call.basic_columns + Function.basic_columns))\n                .join(Function)\n                .filter_by(file=path, name=func_name)\n                .order_by(Call.start_time.desc())[:limit])"
        ],
        [
            "LOAD_NAME",
            "db"
        ],
        [
            "LOAD_ATTR",
            "db.provide_session"
        ],
        [
            "CALL",
            "db.provide_session"
        ],
        [
            "STORE_NAME",
            "@db.provide_session\ndef base_call_view(session, call_id, template):\n    call = session.query(Call).filter_by(id=call_id).one()\n    func = call.function\n    return render_template(template,\n                           short_path=basename(func.file),\n                           call=call,\n                           func=func)"
        ],
        [
            "LOAD_NAME",
            "app"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL",
            "app.route('/call/<call_id>')"
        ],
        [
            "CALL",
            "app.route('/call/<call_id>')"
        ],
        [
            "STORE_NAME",
            "@app.route('/call/<call_id>')\ndef call_view(call_id):\n    return base_call_view(call_id, 'call.html')"
        ],
        [
            "LOAD_NAME",
            "app"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL",
            "app.route('/ipython_call/<call_id>')"
        ],
        [
            "CALL",
            "app.route('/ipython_call/<call_id>')"
        ],
        [
            "STORE_NAME",
            "@app.route('/ipython_call/<call_id>')\ndef ipython_call_view(call_id):\n    return base_call_view(call_id, 'ipython_call.html')"
        ],
        [
            "LOAD_NAME",
            "app"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL",
            "app.route('/ipython_iframe/<call_id>')"
        ],
        [
            "CALL",
            "app.route('/ipython_iframe/<call_id>')"
        ],
        [
            "STORE_NAME",
            "@app.route('/ipython_iframe/<call_id>')\ndef ipython_iframe_view(call_id):\n    \"\"\"\n    This view isn't generally used, it's just an easy way to play with the template\n    without a notebook.\n    \"\"\"\n    return render_template('ipython_iframe.html',\n                           container_id='1234',\n                           port=7777,\n                           call_id=call_id)"
        ],
        [
            "LOAD_NAME",
            "app"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL",
            "app.route('/kill', methods=['POST'])"
        ],
        [
            "CALL",
            "app.route('/kill', methods=['POST'])"
        ],
        [
            "STORE_NAME",
            "@app.route('/kill', methods=['POST'])\ndef kill():\n    func = request.environ.get('werkzeug.server.shutdown')\n    if func is None:\n        raise RuntimeError('Not running with the Werkzeug Server')\n    func()\n    return 'Server shutting down...'"
        ],
        [
            "LOAD_NAME",
            "app"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL",
            "app.route('/api/call/<call_id>')"
        ],
        [
            "LOAD_NAME",
            "db"
        ],
        [
            "LOAD_ATTR",
            "db.provide_session"
        ],
        [
            "CALL",
            "db.provide_session"
        ],
        [
            "CALL",
            "app.route('/api/call/<call_id>')"
        ],
        [
            "STORE_NAME",
            "@app.route('/api/call/<call_id>')\n@db.provide_session\ndef api_call_view(session, call_id):\n    call = session.query(Call).filter_by(id=call_id).one()\n    func = call.function\n    return DecentJSONEncoder().encode(dict(\n        call=dict(data=call.parsed_data, **Call.basic_dict(call)),\n        function=dict(data=func.parsed_data, **Function.basic_dict(func))))"
        ],
        [
            "LOAD_NAME",
            "app"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL",
            "app.route('/api/calls_by_body_hash/<body_hash>')"
        ],
        [
            "LOAD_NAME",
            "db"
        ],
        [
            "LOAD_ATTR",
            "db.provide_session"
        ],
        [
            "CALL",
            "db.provide_session"
        ],
        [
            "CALL",
            "app.route('/api/calls_by_body_hash/<body_hash>')"
        ],
        [
            "STORE_NAME",
            "@app.route('/api/calls_by_body_hash/<body_hash>')\n@db.provide_session\ndef calls_by_body_hash(session, body_hash):\n    query = (session.query(*Call.basic_columns + (Function.data,))\n                 .join(Function)\n                 .filter_by(body_hash=body_hash)\n                 .order_by(Call.start_time.desc())[:200])\n\n    calls = [Call.basic_dict(withattrs(Call(), **row._asdict()))\n             for row in query]\n\n    function_data_set = {row.data for row in query}\n    ranges = set()\n    loop_ranges = set()\n    for function_data in function_data_set:\n        function_data = json.loads(function_data)\n\n        def add(key, ranges_set):\n            for node in function_data[key]:\n                ranges_set.add((node['start'], node['end']))\n\n        add('node_ranges', ranges)\n\n        # All functions are expected to have the same set\n        # of loop nodes\n        current_loop_ranges = set()\n        add('loop_ranges', current_loop_ranges)\n        assert loop_ranges in (set(), current_loop_ranges)\n        loop_ranges = current_loop_ranges\n\n    ranges = [dict(start=start, end=end) for start, end in ranges]\n    loop_ranges = [dict(start=start, end=end) for start, end in loop_ranges]\n\n    return DecentJSONEncoder().encode(dict(\n        calls=calls, ranges=ranges, loop_ranges=loop_ranges))"
        ],
        [
            "LOAD_NAME",
            "app"
        ],
        [
            "LOAD_METHOD",
            "app.route"
        ],
        [
            "CALL",
            "app.route('/api/body_hashes_present/', methods=['POST'])"
        ],
        [
            "LOAD_NAME",
            "db"
        ],
        [
            "LOAD_ATTR",
            "db.provide_session"
        ],
        [
            "CALL",
            "db.provide_session"
        ],
        [
            "CALL",
            "app.route('/api/body_hashes_present/', methods=['POST'])"
        ],
        [
            "STORE_NAME",
            "@app.route('/api/body_hashes_present/', methods=['POST'])\n@db.provide_session\ndef body_hashes_present(session):\n    hashes = request.get_json()\n    query = (session.query(Function.body_hash, sqlalchemy.func.count(Call.id))\n             .outerjoin(Call)\n             .filter(Function.body_hash.in_(hashes))\n             .group_by(Function.body_hash))\n    return DecentJSONEncoder().encode([\n        dict(hash=h, count=count)\n        for h, count in query\n    ])"
        ],
        [
            "LOAD_NAME",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.argv"
        ],
        [
            "BINARY_SUBSCR",
            "sys.argv[1:]"
        ],
        [
            "STORE_NAME",
            "def main(argv=sys.argv[1:]):\n    # Support legacy CLI where there was just one positional argument: the port\n    if len(argv) == 1 and argv[0].isdigit():\n        argv.insert(0, '--port')\n\n    parser = argparse.ArgumentParser(description=\"Bird's Eye: A graphical Python debugger\")\n    parser.add_argument('-p', '--port', help='HTTP port, default is 7777', default=7777, type=int)\n    parser.add_argument('--host', help=\"HTTP host, default is 'localhost'\", default='localhost')\n\n    args = parser.parse_args(argv)\n    app.run(\n        port=args.port,\n        host=args.host,\n        use_reloader=os.environ.get('BIRDSEYE_RELOADER') == '1',\n    )"
        ],
        [
            "LOAD_NAME",
            "__name__"
        ],
        [
            "COMPARE_OP",
            "__name__ == '__main__'"
        ],
        [
            "LOAD_NAME",
            "main"
        ],
        [
            "CALL",
            "main()"
        ],
        [
            "STORE_NAME",
            "regex"
        ],
        [
            "LOAD_GLOBAL",
            "db"
        ],
        [
            "LOAD_METHOD",
            "db.all_file_paths"
        ],
        [
            "CALL",
            "db.all_file_paths()"
        ],
        [
            "STORE_FAST",
            "all_paths"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_ATTR",
            "session.query"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "LOAD_ATTR",
            "Call.basic_columns"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "LOAD_ATTR",
            "Function.basic_columns"
        ],
        [
            "BINARY_OP",
            "Call.basic_columns + Function.basic_columns"
        ],
        [
            "CALL_FUNCTION_EX",
            "session.query(*(Call.basic_columns + Function.basic_columns))"
        ],
        [
            "LOAD_METHOD",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                        .join"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "CALL",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                        .join(Function)"
        ],
        [
            "LOAD_METHOD",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                        .join(Function)\n                        .order_by"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "LOAD_ATTR",
            "Call.start_time"
        ],
        [
            "LOAD_METHOD",
            "Call.start_time.desc"
        ],
        [
            "CALL",
            "Call.start_time.desc()"
        ],
        [
            "CALL",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                        .join(Function)\n                        .order_by(Call.start_time.desc())"
        ],
        [
            "BINARY_SUBSCR",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                        .join(Function)\n                        .order_by(Call.start_time.desc())[:100]"
        ],
        [
            "STORE_FAST",
            "recent_calls"
        ],
        [
            "LOAD_GLOBAL",
            "OrderedDict"
        ],
        [
            "CALL",
            "OrderedDict()"
        ],
        [
            "STORE_FAST",
            "files"
        ],
        [
            "LOAD_FAST",
            "recent_calls"
        ],
        [
            "STORE_FAST",
            "row"
        ],
        [
            "LOAD_GLOBAL",
            "is_ipython_cell"
        ],
        [
            "LOAD_FAST",
            "row"
        ],
        [
            "LOAD_ATTR",
            "row.file"
        ],
        [
            "CALL",
            "is_ipython_cell(row.file)"
        ],
        [
            "LOAD_FAST",
            "files"
        ],
        [
            "LOAD_METHOD",
            "files.setdefault"
        ],
        [
            "LOAD_FAST",
            "row"
        ],
        [
            "LOAD_ATTR",
            "row.file"
        ],
        [
            "LOAD_GLOBAL",
            "OrderedDict"
        ],
        [
            "CALL",
            "OrderedDict()"
        ],
        [
            "CALL",
            "files.setdefault(\n            row.file, OrderedDict()\n        )"
        ],
        [
            "LOAD_METHOD",
            "files.setdefault(\n            row.file, OrderedDict()\n        ).setdefault"
        ],
        [
            "LOAD_FAST",
            "row"
        ],
        [
            "LOAD_ATTR",
            "row.name"
        ],
        [
            "LOAD_FAST",
            "row"
        ],
        [
            "CALL",
            "files.setdefault(\n            row.file, OrderedDict()\n        )"
        ],
        [
            "LOAD_FAST",
            "all_paths"
        ],
        [
            "STORE_FAST",
            "path"
        ],
        [
            "LOAD_FAST",
            "files"
        ],
        [
            "LOAD_METHOD",
            "files.setdefault"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_GLOBAL",
            "OrderedDict"
        ],
        [
            "CALL",
            "OrderedDict()"
        ],
        [
            "CALL",
            "files.setdefault(\n            path, OrderedDict()\n        )"
        ],
        [
            "LOAD_GLOBAL",
            "partial"
        ],
        [
            "LOAD_GLOBAL",
            "short_path"
        ],
        [
            "LOAD_FAST",
            "all_paths"
        ],
        [
            "CALL",
            "partial(short_path, all_paths=all_paths)"
        ],
        [
            "STORE_FAST",
            "short"
        ],
        [
            "LOAD_GLOBAL",
            "render_template"
        ],
        [
            "LOAD_FAST",
            "short"
        ],
        [
            "LOAD_FAST",
            "files"
        ],
        [
            "CALL",
            "render_template('index.html',\n                           short=short,\n                           files=files)"
        ],
        [
            "LOAD_GLOBAL",
            "fix_abs_path"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "CALL",
            "fix_abs_path(path)"
        ],
        [
            "STORE_FAST",
            "path"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_ATTR",
            "session.query"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "LOAD_ATTR",
            "Call.basic_columns"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "LOAD_ATTR",
            "Function.basic_columns"
        ],
        [
            "BINARY_OP",
            "Call.basic_columns + Function.basic_columns"
        ],
        [
            "CALL_FUNCTION_EX",
            "session.query(*(Call.basic_columns + Function.basic_columns))"
        ],
        [
            "LOAD_METHOD",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                      .join"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "CALL",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                      .join(Function)"
        ],
        [
            "LOAD_METHOD",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                      .join(Function)\n                      .filter_by"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "CALL",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                      .join(Function)\n                      .filter_by(file=path)"
        ],
        [
            "LOAD_METHOD",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                      .join(Function)\n                      .filter_by(file=path)\n                      .subquery"
        ],
        [
            "CALL",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                      .join(Function)\n                      .filter_by(file=path)\n                      .subquery('filtered_calls')"
        ],
        [
            "STORE_FAST",
            "filtered_calls"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "LOAD_FAST",
            "filtered_calls"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c.name"
        ],
        [
            "LOAD_GLOBAL",
            "sqlalchemy"
        ],
        [
            "LOAD_ATTR",
            "sqlalchemy.func"
        ],
        [
            "LOAD_METHOD",
            "sqlalchemy.func.max"
        ],
        [
            "LOAD_FAST",
            "filtered_calls"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c.start_time"
        ],
        [
            "CALL",
            "sqlalchemy.func.max(filtered_calls.c.start_time)"
        ],
        [
            "LOAD_METHOD",
            "sqlalchemy.func.max(filtered_calls.c.start_time).label"
        ],
        [
            "CALL",
            "sqlalchemy.func.max(filtered_calls.c.start_time).label('maxtime')"
        ],
        [
            "CALL",
            "session.query(\n        filtered_calls.c.name,\n        sqlalchemy.func.max(filtered_calls.c.start_time).label('maxtime')\n    )"
        ],
        [
            "LOAD_METHOD",
            "session.query(\n        filtered_calls.c.name,\n        sqlalchemy.func.max(filtered_calls.c.start_time).label('maxtime')\n    ).group_by"
        ],
        [
            "LOAD_FAST",
            "filtered_calls"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c.name"
        ],
        [
            "CALL",
            "session.query(\n        filtered_calls.c.name,\n        sqlalchemy.func.max(filtered_calls.c.start_time).label('maxtime')\n    )"
        ],
        [
            "LOAD_METHOD",
            "session.query(\n        filtered_calls.c.name,\n        sqlalchemy.func.max(filtered_calls.c.start_time).label('maxtime')\n    ).group_by(\n        filtered_calls.c.name,\n    ).subquery"
        ],
        [
            "CALL",
            "session.query(\n        filtered_calls.c.name,\n        sqlalchemy.func.max(filtered_calls.c.start_time).label('maxtime')\n    ).group_by(\n        filtered_calls.c.name,\n    ).subquery('latest_calls')"
        ],
        [
            "STORE_FAST",
            "latest_calls"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "LOAD_FAST",
            "filtered_calls"
        ],
        [
            "CALL",
            "session.query(filtered_calls)"
        ],
        [
            "LOAD_METHOD",
            "session.query(filtered_calls).join"
        ],
        [
            "LOAD_FAST",
            "latest_calls"
        ],
        [
            "LOAD_GLOBAL",
            "sqlalchemy"
        ],
        [
            "LOAD_ATTR",
            "sqlalchemy.and_"
        ],
        [
            "LOAD_FAST",
            "filtered_calls"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c.name"
        ],
        [
            "LOAD_FAST",
            "latest_calls"
        ],
        [
            "LOAD_ATTR",
            "latest_calls.c"
        ],
        [
            "LOAD_ATTR",
            "latest_calls.c.name"
        ],
        [
            "COMPARE_OP",
            "filtered_calls.c.name == latest_calls.c.name"
        ],
        [
            "LOAD_FAST",
            "filtered_calls"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c.start_time"
        ],
        [
            "LOAD_FAST",
            "latest_calls"
        ],
        [
            "LOAD_ATTR",
            "latest_calls.c"
        ],
        [
            "LOAD_ATTR",
            "latest_calls.c.maxtime"
        ],
        [
            "COMPARE_OP",
            "filtered_calls.c.start_time == latest_calls.c.maxtime"
        ],
        [
            "CALL",
            "sqlalchemy.and_(\n            filtered_calls.c.name == latest_calls.c.name,\n            filtered_calls.c.start_time == latest_calls.c.maxtime,\n        )"
        ],
        [
            "CALL",
            "session.query(filtered_calls).join(\n        latest_calls,\n        sqlalchemy.and_(\n            filtered_calls.c.name == latest_calls.c.name,\n            filtered_calls.c.start_time == latest_calls.c.maxtime,\n        )\n    )"
        ],
        [
            "LOAD_METHOD",
            "session.query(filtered_calls).join(\n        latest_calls,\n        sqlalchemy.and_(\n            filtered_calls.c.name == latest_calls.c.name,\n            filtered_calls.c.start_time == latest_calls.c.maxtime,\n        )\n    ).order_by"
        ],
        [
            "LOAD_FAST",
            "filtered_calls"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c"
        ],
        [
            "LOAD_ATTR",
            "filtered_calls.c.start_time"
        ],
        [
            "LOAD_METHOD",
            "filtered_calls.c.start_time.desc"
        ],
        [
            "CALL",
            "filtered_calls.c.start_time.desc()"
        ],
        [
            "CALL",
            "session.query(filtered_calls).join(\n        latest_calls,\n        sqlalchemy.and_(\n            filtered_calls.c.name == latest_calls.c.name,\n            filtered_calls.c.start_time == latest_calls.c.maxtime,\n        )\n    ).order_by(filtered_calls.c.start_time.desc())"
        ],
        [
            "STORE_FAST",
            "query"
        ],
        [
            "LOAD_GLOBAL",
            "group_by_attr"
        ],
        [
            "LOAD_FAST",
            "query"
        ],
        [
            "CALL",
            "group_by_attr(query, 'type')"
        ],
        [
            "STORE_FAST",
            "funcs"
        ],
        [
            "LOAD_GLOBAL",
            "sorted"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "LOAD_ATTR",
            "Function.name"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "LOAD_ATTR",
            "Function.type"
        ],
        [
            "CALL",
            "session.query(Function.name, Function.type)"
        ],
        [
            "LOAD_METHOD",
            "session.query(Function.name, Function.type)\n                       .filter_by"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "CALL",
            "session.query(Function.name, Function.type)\n                       .filter_by(file=path)"
        ],
        [
            "LOAD_METHOD",
            "session.query(Function.name, Function.type)\n                       .filter_by(file=path)\n                       .distinct"
        ],
        [
            "CALL",
            "session.query(Function.name, Function.type)\n                       .filter_by(file=path)\n                       .distinct()"
        ],
        [
            "CALL",
            "sorted(session.query(Function.name, Function.type)\n                       .filter_by(file=path)\n                       .distinct())"
        ],
        [
            "STORE_FAST",
            "all_funcs"
        ],
        [
            "LOAD_FAST",
            "query"
        ],
        [
            "CALL",
            "{row.name for row in query}"
        ],
        [
            "STORE_FAST",
            "func_names"
        ],
        [
            "LOAD_FAST",
            "all_funcs"
        ],
        [
            "STORE_FAST",
            "func"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.name"
        ],
        [
            "LOAD_FAST",
            "func_names"
        ],
        [
            "CONTAINS_OP",
            "func.name not in func_names"
        ],
        [
            "LOAD_FAST",
            "funcs"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.type"
        ],
        [
            "BINARY_SUBSCR",
            "funcs[func.type]"
        ],
        [
            "LOAD_METHOD",
            "funcs[func.type].append"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "CALL",
            "funcs[func.type].append(func)"
        ],
        [
            "LOAD_GLOBAL",
            "render_template"
        ],
        [
            "LOAD_FAST",
            "funcs"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_GLOBAL",
            "IPYTHON_FILE_PATH"
        ],
        [
            "COMPARE_OP",
            "path == IPYTHON_FILE_PATH"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_GLOBAL",
            "basename"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "CALL",
            "basename(path)"
        ],
        [
            "CALL",
            "render_template('file.html',\n                           funcs=funcs,\n                           is_ipython=path == IPYTHON_FILE_PATH,\n                           full_path=path,\n                           short_path=basename(path))"
        ],
        [
            "LOAD_FAST",
            "{row.name for row in query}"
        ],
        [
            "STORE_FAST",
            "row"
        ],
        [
            "LOAD_FAST",
            "row"
        ],
        [
            "LOAD_ATTR",
            "row.name"
        ],
        [
            "LOAD_GLOBAL",
            "fix_abs_path"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "CALL",
            "fix_abs_path(path)"
        ],
        [
            "STORE_FAST",
            "path"
        ],
        [
            "LOAD_GLOBAL",
            "get_calls"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_FAST",
            "func_name"
        ],
        [
            "CALL",
            "get_calls(session, path, func_name, 200)"
        ],
        [
            "STORE_FAST",
            "query"
        ],
        [
            "LOAD_FAST",
            "query"
        ],
        [
            "LOAD_FAST",
            "query"
        ],
        [
            "BINARY_SUBSCR",
            "query[0]"
        ],
        [
            "STORE_FAST",
            "func"
        ],
        [
            "LOAD_FAST",
            "query"
        ],
        [
            "CALL",
            "[withattrs(Call(), **row._asdict()) for row in query]"
        ],
        [
            "STORE_FAST",
            "calls"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "CALL",
            "session.query(Function)"
        ],
        [
            "LOAD_METHOD",
            "session.query(Function).filter_by"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_FAST",
            "func_name"
        ],
        [
            "CALL",
            "session.query(Function).filter_by(file=path, name=func_name)"
        ],
        [
            "BINARY_SUBSCR",
            "session.query(Function).filter_by(file=path, name=func_name)[0]"
        ],
        [
            "STORE_FAST",
            "func"
        ],
        [
            "STORE_FAST",
            "calls"
        ],
        [
            "LOAD_GLOBAL",
            "render_template"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "LOAD_GLOBAL",
            "basename"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "CALL",
            "basename(path)"
        ],
        [
            "LOAD_FAST",
            "calls"
        ],
        [
            "CALL",
            "render_template('function.html',\n                           func=func,\n                           short_path=basename(path),\n                           calls=calls)"
        ],
        [
            "LOAD_FAST",
            "[withattrs(Call(), **row._asdict()) for row in query]"
        ],
        [
            "STORE_FAST",
            "row"
        ],
        [
            "LOAD_GLOBAL",
            "withattrs"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "CALL",
            "Call()"
        ],
        [
            "LOAD_FAST",
            "row"
        ],
        [
            "LOAD_METHOD",
            "row._asdict"
        ],
        [
            "CALL",
            "row._asdict()"
        ],
        [
            "CALL_FUNCTION_EX",
            "withattrs(Call(), **row._asdict())"
        ],
        [
            "LOAD_GLOBAL",
            "fix_abs_path"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "CALL",
            "fix_abs_path(path)"
        ],
        [
            "STORE_FAST",
            "path"
        ],
        [
            "LOAD_GLOBAL",
            "get_calls"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_FAST",
            "func_name"
        ],
        [
            "CALL",
            "get_calls(session, path, func_name, 1)"
        ],
        [
            "BINARY_SUBSCR",
            "get_calls(session, path, func_name, 1)[0]"
        ],
        [
            "STORE_FAST",
            "call"
        ],
        [
            "LOAD_GLOBAL",
            "jsonify"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_FAST",
            "call"
        ],
        [
            "LOAD_ATTR",
            "call.id"
        ],
        [
            "LOAD_GLOBAL",
            "url_for"
        ],
        [
            "LOAD_GLOBAL",
            "call_view"
        ],
        [
            "LOAD_ATTR",
            "call_view.__name__"
        ],
        [
            "LOAD_FAST",
            "call"
        ],
        [
            "LOAD_ATTR",
            "call.id"
        ],
        [
            "CALL",
            "url_for(call_view.__name__,\n                    call_id=call.id)"
        ],
        [
            "CALL",
            "dict(\n        id=call.id,\n        url=url_for(call_view.__name__,\n                    call_id=call.id),\n    )"
        ],
        [
            "CALL",
            "jsonify(dict(\n        id=call.id,\n        url=url_for(call_view.__name__,\n                    call_id=call.id),\n    ))"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_ATTR",
            "session.query"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "LOAD_ATTR",
            "Call.basic_columns"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "LOAD_ATTR",
            "Function.basic_columns"
        ],
        [
            "BINARY_OP",
            "Call.basic_columns + Function.basic_columns"
        ],
        [
            "CALL_FUNCTION_EX",
            "session.query(*(Call.basic_columns + Function.basic_columns))"
        ],
        [
            "LOAD_METHOD",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                .join"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "CALL",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                .join(Function)"
        ],
        [
            "LOAD_METHOD",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                .join(Function)\n                .filter_by"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_FAST",
            "func_name"
        ],
        [
            "CALL",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                .join(Function)\n                .filter_by(file=path, name=func_name)"
        ],
        [
            "LOAD_METHOD",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                .join(Function)\n                .filter_by(file=path, name=func_name)\n                .order_by"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "LOAD_ATTR",
            "Call.start_time"
        ],
        [
            "LOAD_METHOD",
            "Call.start_time.desc"
        ],
        [
            "CALL",
            "Call.start_time.desc()"
        ],
        [
            "CALL",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                .join(Function)\n                .filter_by(file=path, name=func_name)\n                .order_by(Call.start_time.desc())"
        ],
        [
            "LOAD_FAST",
            "limit"
        ],
        [
            "BINARY_SUBSCR",
            "session.query(*(Call.basic_columns + Function.basic_columns))\n                .join(Function)\n                .filter_by(file=path, name=func_name)\n                .order_by(Call.start_time.desc())[:limit]"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "CALL",
            "session.query(Call)"
        ],
        [
            "LOAD_METHOD",
            "session.query(Call).filter_by"
        ],
        [
            "LOAD_FAST",
            "call_id"
        ],
        [
            "CALL",
            "session.query(Call).filter_by(id=call_id)"
        ],
        [
            "LOAD_METHOD",
            "session.query(Call).filter_by(id=call_id).one"
        ],
        [
            "CALL",
            "session.query(Call).filter_by(id=call_id).one()"
        ],
        [
            "STORE_FAST",
            "call"
        ],
        [
            "LOAD_FAST",
            "call"
        ],
        [
            "LOAD_ATTR",
            "call.function"
        ],
        [
            "STORE_FAST",
            "func"
        ],
        [
            "LOAD_GLOBAL",
            "render_template"
        ],
        [
            "LOAD_FAST",
            "template"
        ],
        [
            "LOAD_GLOBAL",
            "basename"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.file"
        ],
        [
            "CALL",
            "basename(func.file)"
        ],
        [
            "LOAD_FAST",
            "call"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "CALL",
            "render_template(template,\n                           short_path=basename(func.file),\n                           call=call,\n                           func=func)"
        ],
        [
            "LOAD_GLOBAL",
            "base_call_view"
        ],
        [
            "LOAD_FAST",
            "call_id"
        ],
        [
            "CALL",
            "base_call_view(call_id, 'call.html')"
        ],
        [
            "LOAD_GLOBAL",
            "base_call_view"
        ],
        [
            "LOAD_FAST",
            "call_id"
        ],
        [
            "CALL",
            "base_call_view(call_id, 'ipython_call.html')"
        ],
        [
            "LOAD_GLOBAL",
            "render_template"
        ],
        [
            "LOAD_FAST",
            "call_id"
        ],
        [
            "CALL",
            "render_template('ipython_iframe.html',\n                           container_id='1234',\n                           port=7777,\n                           call_id=call_id)"
        ],
        [
            "LOAD_GLOBAL",
            "request"
        ],
        [
            "LOAD_ATTR",
            "request.environ"
        ],
        [
            "LOAD_METHOD",
            "request.environ.get"
        ],
        [
            "CALL",
            "request.environ.get('werkzeug.server.shutdown')"
        ],
        [
            "STORE_FAST",
            "func"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "LOAD_GLOBAL",
            "RuntimeError"
        ],
        [
            "CALL",
            "RuntimeError('Not running with the Werkzeug Server')"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "CALL",
            "func()"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "CALL",
            "session.query(Call)"
        ],
        [
            "LOAD_METHOD",
            "session.query(Call).filter_by"
        ],
        [
            "LOAD_FAST",
            "call_id"
        ],
        [
            "CALL",
            "session.query(Call).filter_by(id=call_id)"
        ],
        [
            "LOAD_METHOD",
            "session.query(Call).filter_by(id=call_id).one"
        ],
        [
            "CALL",
            "session.query(Call).filter_by(id=call_id).one()"
        ],
        [
            "STORE_FAST",
            "call"
        ],
        [
            "LOAD_FAST",
            "call"
        ],
        [
            "LOAD_ATTR",
            "call.function"
        ],
        [
            "STORE_FAST",
            "func"
        ],
        [
            "LOAD_GLOBAL",
            "DecentJSONEncoder"
        ],
        [
            "CALL",
            "DecentJSONEncoder()"
        ],
        [
            "LOAD_METHOD",
            "DecentJSONEncoder().encode"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_FAST",
            "call"
        ],
        [
            "LOAD_ATTR",
            "call.parsed_data"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "LOAD_METHOD",
            "Call.basic_dict"
        ],
        [
            "LOAD_FAST",
            "call"
        ],
        [
            "CALL",
            "Call.basic_dict(call)"
        ],
        [
            "CALL_FUNCTION_EX",
            "dict(data=call.parsed_data, **Call.basic_dict(call))"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.parsed_data"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "LOAD_METHOD",
            "Function.basic_dict"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "CALL",
            "Function.basic_dict(func)"
        ],
        [
            "CALL_FUNCTION_EX",
            "dict(data=func.parsed_data, **Function.basic_dict(func))"
        ],
        [
            "CALL",
            "dict(\n        call=dict(data=call.parsed_data, **Call.basic_dict(call)),\n        function=dict(data=func.parsed_data, **Function.basic_dict(func)))"
        ],
        [
            "CALL",
            "DecentJSONEncoder().encode(dict(\n        call=dict(data=call.parsed_data, **Call.basic_dict(call)),\n        function=dict(data=func.parsed_data, **Function.basic_dict(func))))"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_ATTR",
            "session.query"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "LOAD_ATTR",
            "Call.basic_columns"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "LOAD_ATTR",
            "Function.data"
        ],
        [
            "BINARY_OP",
            "Call.basic_columns + (Function.data,)"
        ],
        [
            "CALL_FUNCTION_EX",
            "session.query(*Call.basic_columns + (Function.data,))"
        ],
        [
            "LOAD_METHOD",
            "session.query(*Call.basic_columns + (Function.data,))\n                 .join"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "CALL",
            "session.query(*Call.basic_columns + (Function.data,))\n                 .join(Function)"
        ],
        [
            "LOAD_METHOD",
            "session.query(*Call.basic_columns + (Function.data,))\n                 .join(Function)\n                 .filter_by"
        ],
        [
            "LOAD_FAST",
            "body_hash"
        ],
        [
            "CALL",
            "session.query(*Call.basic_columns + (Function.data,))\n                 .join(Function)\n                 .filter_by(body_hash=body_hash)"
        ],
        [
            "LOAD_METHOD",
            "session.query(*Call.basic_columns + (Function.data,))\n                 .join(Function)\n                 .filter_by(body_hash=body_hash)\n                 .order_by"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "LOAD_ATTR",
            "Call.start_time"
        ],
        [
            "LOAD_METHOD",
            "Call.start_time.desc"
        ],
        [
            "CALL",
            "Call.start_time.desc()"
        ],
        [
            "CALL",
            "session.query(*Call.basic_columns + (Function.data,))\n                 .join(Function)\n                 .filter_by(body_hash=body_hash)\n                 .order_by(Call.start_time.desc())"
        ],
        [
            "BINARY_SUBSCR",
            "session.query(*Call.basic_columns + (Function.data,))\n                 .join(Function)\n                 .filter_by(body_hash=body_hash)\n                 .order_by(Call.start_time.desc())[:200]"
        ],
        [
            "STORE_FAST",
            "query"
        ],
        [
            "LOAD_FAST",
            "query"
        ],
        [
            "CALL",
            "[Call.basic_dict(withattrs(Call(), **row._asdict()))\n             for row in query]"
        ],
        [
            "STORE_FAST",
            "calls"
        ],
        [
            "LOAD_FAST",
            "query"
        ],
        [
            "CALL",
            "{row.data for row in query}"
        ],
        [
            "STORE_FAST",
            "function_data_set"
        ],
        [
            "LOAD_GLOBAL",
            "set"
        ],
        [
            "CALL",
            "set()"
        ],
        [
            "STORE_FAST",
            "ranges"
        ],
        [
            "LOAD_GLOBAL",
            "set"
        ],
        [
            "CALL",
            "set()"
        ],
        [
            "STORE_FAST",
            "loop_ranges"
        ],
        [
            "LOAD_FAST",
            "function_data_set"
        ],
        [
            "STORE_DEREF",
            "function_data"
        ],
        [
            "LOAD_GLOBAL",
            "json"
        ],
        [
            "LOAD_ATTR",
            "json.loads"
        ],
        [
            "LOAD_DEREF",
            "function_data"
        ],
        [
            "CALL",
            "json.loads(function_data)"
        ],
        [
            "STORE_DEREF",
            "function_data"
        ],
        [
            "STORE_FAST",
            "        def add(key, ranges_set):\n            for node in function_data[key]:\n                ranges_set.add((node['start'], node['end']))"
        ],
        [
            "LOAD_FAST",
            "add"
        ],
        [
            "LOAD_FAST",
            "ranges"
        ],
        [
            "CALL",
            "add('node_ranges', ranges)"
        ],
        [
            "LOAD_GLOBAL",
            "set"
        ],
        [
            "CALL",
            "set()"
        ],
        [
            "STORE_FAST",
            "current_loop_ranges"
        ],
        [
            "LOAD_FAST",
            "add"
        ],
        [
            "LOAD_FAST",
            "current_loop_ranges"
        ],
        [
            "CALL",
            "add('loop_ranges', current_loop_ranges)"
        ],
        [
            "LOAD_FAST",
            "loop_ranges"
        ],
        [
            "LOAD_GLOBAL",
            "set"
        ],
        [
            "CALL",
            "set()"
        ],
        [
            "LOAD_FAST",
            "current_loop_ranges"
        ],
        [
            "CONTAINS_OP",
            "loop_ranges in (set(), current_loop_ranges)"
        ],
        [
            "LOAD_FAST",
            "current_loop_ranges"
        ],
        [
            "STORE_FAST",
            "loop_ranges"
        ],
        [
            "LOAD_FAST",
            "ranges"
        ],
        [
            "CALL",
            "[dict(start=start, end=end) for start, end in ranges]"
        ],
        [
            "STORE_FAST",
            "ranges"
        ],
        [
            "LOAD_FAST",
            "loop_ranges"
        ],
        [
            "CALL",
            "[dict(start=start, end=end) for start, end in loop_ranges]"
        ],
        [
            "STORE_FAST",
            "loop_ranges"
        ],
        [
            "LOAD_GLOBAL",
            "DecentJSONEncoder"
        ],
        [
            "CALL",
            "DecentJSONEncoder()"
        ],
        [
            "LOAD_METHOD",
            "DecentJSONEncoder().encode"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_FAST",
            "calls"
        ],
        [
            "LOAD_FAST",
            "ranges"
        ],
        [
            "LOAD_FAST",
            "loop_ranges"
        ],
        [
            "CALL",
            "dict(\n        calls=calls, ranges=ranges, loop_ranges=loop_ranges)"
        ],
        [
            "CALL",
            "DecentJSONEncoder().encode(dict(\n        calls=calls, ranges=ranges, loop_ranges=loop_ranges))"
        ],
        [
            "LOAD_FAST",
            "[Call.basic_dict(withattrs(Call(), **row._asdict()))\n             for row in query]"
        ],
        [
            "STORE_FAST",
            "row"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "LOAD_METHOD",
            "Call.basic_dict"
        ],
        [
            "LOAD_GLOBAL",
            "withattrs"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "CALL",
            "Call()"
        ],
        [
            "LOAD_FAST",
            "row"
        ],
        [
            "LOAD_METHOD",
            "row._asdict"
        ],
        [
            "CALL",
            "row._asdict()"
        ],
        [
            "CALL_FUNCTION_EX",
            "withattrs(Call(), **row._asdict())"
        ],
        [
            "CALL",
            "Call.basic_dict(withattrs(Call(), **row._asdict()))"
        ],
        [
            "LOAD_FAST",
            "{row.data for row in query}"
        ],
        [
            "STORE_FAST",
            "row"
        ],
        [
            "LOAD_FAST",
            "row"
        ],
        [
            "LOAD_ATTR",
            "row.data"
        ],
        [
            "LOAD_DEREF",
            "function_data"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "BINARY_SUBSCR",
            "function_data[key]"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "ranges_set"
        ],
        [
            "LOAD_METHOD",
            "ranges_set.add"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "BINARY_SUBSCR",
            "node['start']"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "BINARY_SUBSCR",
            "node['end']"
        ],
        [
            "CALL",
            "ranges_set.add((node['start'], node['end']))"
        ],
        [
            "LOAD_FAST",
            "[dict(start=start, end=end) for start, end in ranges]"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "STORE_FAST",
            "end"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "end"
        ],
        [
            "CALL",
            "dict(start=start, end=end)"
        ],
        [
            "LOAD_FAST",
            "[dict(start=start, end=end) for start, end in loop_ranges]"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "STORE_FAST",
            "end"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "end"
        ],
        [
            "CALL",
            "dict(start=start, end=end)"
        ],
        [
            "LOAD_GLOBAL",
            "request"
        ],
        [
            "LOAD_ATTR",
            "request.get_json"
        ],
        [
            "CALL",
            "request.get_json()"
        ],
        [
            "STORE_FAST",
            "hashes"
        ],
        [
            "LOAD_FAST",
            "session"
        ],
        [
            "LOAD_METHOD",
            "session.query"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "LOAD_ATTR",
            "Function.body_hash"
        ],
        [
            "LOAD_GLOBAL",
            "sqlalchemy"
        ],
        [
            "LOAD_ATTR",
            "sqlalchemy.func"
        ],
        [
            "LOAD_METHOD",
            "sqlalchemy.func.count"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "LOAD_ATTR",
            "Call.id"
        ],
        [
            "CALL",
            "sqlalchemy.func.count(Call.id)"
        ],
        [
            "CALL",
            "session.query(Function.body_hash, sqlalchemy.func.count(Call.id))"
        ],
        [
            "LOAD_METHOD",
            "session.query(Function.body_hash, sqlalchemy.func.count(Call.id))\n             .outerjoin"
        ],
        [
            "LOAD_GLOBAL",
            "Call"
        ],
        [
            "CALL",
            "session.query(Function.body_hash, sqlalchemy.func.count(Call.id))\n             .outerjoin(Call)"
        ],
        [
            "LOAD_METHOD",
            "session.query(Function.body_hash, sqlalchemy.func.count(Call.id))\n             .outerjoin(Call)\n             .filter"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "LOAD_ATTR",
            "Function.body_hash"
        ],
        [
            "LOAD_METHOD",
            "Function.body_hash.in_"
        ],
        [
            "LOAD_FAST",
            "hashes"
        ],
        [
            "CALL",
            "Function.body_hash.in_(hashes)"
        ],
        [
            "CALL",
            "session.query(Function.body_hash, sqlalchemy.func.count(Call.id))\n             .outerjoin(Call)\n             .filter(Function.body_hash.in_(hashes))"
        ],
        [
            "LOAD_METHOD",
            "session.query(Function.body_hash, sqlalchemy.func.count(Call.id))\n             .outerjoin(Call)\n             .filter(Function.body_hash.in_(hashes))\n             .group_by"
        ],
        [
            "LOAD_GLOBAL",
            "Function"
        ],
        [
            "LOAD_ATTR",
            "Function.body_hash"
        ],
        [
            "CALL",
            "session.query(Function.body_hash, sqlalchemy.func.count(Call.id))\n             .outerjoin(Call)\n             .filter(Function.body_hash.in_(hashes))\n             .group_by(Function.body_hash)"
        ],
        [
            "STORE_FAST",
            "query"
        ],
        [
            "LOAD_GLOBAL",
            "DecentJSONEncoder"
        ],
        [
            "CALL",
            "DecentJSONEncoder()"
        ],
        [
            "LOAD_METHOD",
            "DecentJSONEncoder().encode"
        ],
        [
            "LOAD_FAST",
            "query"
        ],
        [
            "CALL",
            "[\n        dict(hash=h, count=count)\n        for h, count in query\n    ]"
        ],
        [
            "CALL",
            "DecentJSONEncoder().encode([\n        dict(hash=h, count=count)\n        for h, count in query\n    ])"
        ],
        [
            "LOAD_FAST",
            "[\n        dict(hash=h, count=count)\n        for h, count in query\n    ]"
        ],
        [
            "STORE_FAST",
            "h"
        ],
        [
            "STORE_FAST",
            "count"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_FAST",
            "h"
        ],
        [
            "LOAD_FAST",
            "count"
        ],
        [
            "CALL",
            "dict(hash=h, count=count)"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "argv"
        ],
        [
            "CALL",
            "len(argv)"
        ],
        [
            "COMPARE_OP",
            "len(argv) == 1"
        ],
        [
            "LOAD_FAST",
            "argv"
        ],
        [
            "BINARY_SUBSCR",
            "argv[0]"
        ],
        [
            "LOAD_METHOD",
            "argv[0].isdigit"
        ],
        [
            "CALL",
            "argv[0].isdigit()"
        ],
        [
            "LOAD_FAST",
            "argv"
        ],
        [
            "LOAD_METHOD",
            "argv.insert"
        ],
        [
            "CALL",
            "argv.insert(0, '--port')"
        ],
        [
            "LOAD_GLOBAL",
            "argparse"
        ],
        [
            "LOAD_ATTR",
            "argparse.ArgumentParser"
        ],
        [
            "CALL",
            "argparse.ArgumentParser(description=\"Bird's Eye: A graphical Python debugger\")"
        ],
        [
            "STORE_FAST",
            "parser"
        ],
        [
            "LOAD_FAST",
            "parser"
        ],
        [
            "LOAD_METHOD",
            "parser.add_argument"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "CALL",
            "parser.add_argument('-p', '--port', help='HTTP port, default is 7777', default=7777, type=int)"
        ],
        [
            "LOAD_FAST",
            "parser"
        ],
        [
            "LOAD_METHOD",
            "parser.add_argument"
        ],
        [
            "CALL",
            "parser.add_argument('--host', help=\"HTTP host, default is 'localhost'\", default='localhost')"
        ],
        [
            "LOAD_FAST",
            "parser"
        ],
        [
            "LOAD_METHOD",
            "parser.parse_args"
        ],
        [
            "LOAD_FAST",
            "argv"
        ],
        [
            "CALL",
            "parser.parse_args(argv)"
        ],
        [
            "STORE_FAST",
            "args"
        ],
        [
            "LOAD_GLOBAL",
            "app"
        ],
        [
            "LOAD_METHOD",
            "app.run"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_ATTR",
            "args.port"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_ATTR",
            "args.host"
        ],
        [
            "LOAD_GLOBAL",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.environ"
        ],
        [
            "LOAD_METHOD",
            "os.environ.get"
        ],
        [
            "CALL",
            "os.environ.get('BIRDSEYE_RELOADER')"
        ],
        [
            "COMPARE_OP",
            "os.environ.get('BIRDSEYE_RELOADER') == '1'"
        ],
        [
            "CALL",
            "app.run(\n        port=args.port,\n        host=args.host,\n        use_reloader=os.environ.get('BIRDSEYE_RELOADER') == '1',\n    )"
        ]
    ],
    "tests.py": [
        [
            "STORE_NAME",
            "from __future__ import print_function, division"
        ],
        [
            "STORE_NAME",
            "from __future__ import print_function, division"
        ],
        [
            "STORE_NAME",
            "import ast"
        ],
        [
            "STORE_NAME",
            "import inspect"
        ],
        [
            "STORE_NAME",
            "import os"
        ],
        [
            "STORE_NAME",
            "import sys"
        ],
        [
            "STORE_NAME",
            "import tempfile"
        ],
        [
            "STORE_NAME",
            "import time"
        ],
        [
            "STORE_NAME",
            "import unittest"
        ],
        [
            "STORE_NAME",
            "from executing import Source, only, PY3, NotOneValueFound, get_instructions"
        ],
        [
            "STORE_NAME",
            "from executing import Source, only, PY3, NotOneValueFound, get_instructions"
        ],
        [
            "STORE_NAME",
            "from executing import Source, only, PY3, NotOneValueFound, get_instructions"
        ],
        [
            "STORE_NAME",
            "from executing import Source, only, PY3, NotOneValueFound, get_instructions"
        ],
        [
            "STORE_NAME",
            "from executing import Source, only, PY3, NotOneValueFound, get_instructions"
        ],
        [
            "LOAD_NAME",
            "unittest"
        ],
        [
            "LOAD_ATTR",
            "unittest.TestCase"
        ],
        [
            "CALL",
            "class TestStuff(unittest.TestCase):\n\n    # noinspection PyTrailingSemicolon\n    def test_semicolons(self):\n        # @formatter:off\n        tester(1); tester(2); tester(3)\n        tester(9\n               ); tester(\n            8); tester(\n            99\n        ); tester(33); tester([4,\n                               5, 6, [\n                                7]])\n        # @formatter:on\n\n    def test_decorator(self):\n        @empty_decorator\n        @decorator_with_args(tester('123'), x=int())\n        @tester(list(tuple([1, 2])), returns=empty_decorator)\n        @tester(\n            list(\n                tuple(\n                    [3, 4])),\n            returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(\n            str(),\n            x=int())\n        @tester(list(tuple([5, 6])), returns=empty_decorator)\n        @tester(list(tuple([7, 8])), returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(tester('sdf'), x=tester('123234'))\n        def foo():\n            pass\n\n    def test_comprehensions(self):\n        # Comprehensions can be separated if they contain different names\n        str([{tester(x) for x in [1]}, {tester(y) for y in [1]}])\n        # or are on different lines\n        str([{tester(x) for x in [1]},\n             {tester(x) for x in [1]}])\n        # or are of different types\n        str([{tester(x) for x in [1]}, list(tester(x) for x in [1])])\n        # but not if everything is the same\n        # noinspection PyTypeChecker\n        # with self.assertRaises((AttributeError, NotOneValueFound)):\n        #     str([{tester(x) for x in [1]}, {tester(x) for x in [2]}])\n\n    def test_lambda(self):\n        self.assertEqual(\n            (lambda x: (tester(x), tester(x)))(tester(3)),\n            (3, 3),\n        )\n        (lambda: (lambda: tester(1))())()\n        self.assertEqual(\n            (lambda: [tester(x) for x in tester([1, 2])])(),\n            [1, 2],\n        )\n\n    def test_closures_and_nested_comprehensions(self):\n        x = 1\n        # @formatter:off\n        str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n        def foo():\n            y = 2\n            str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            def bar():\n                z = 3\n                str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y+z): {tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            bar()\n\n        foo()\n        # @formatter:on\n\n    def test_indirect_call(self):\n        dict(x=tester)['x'](tester)(3, check_func=False)\n\n    def test_compound_statements(self):\n        with self.assertRaises(TypeError):\n            try:\n                for _ in tester([1, 2, 3]):\n                    while tester(0):\n                        pass\n                    else:\n                        tester(4)\n                else:\n                    tester(5)\n                    raise ValueError\n            except tester(ValueError):\n                tester(9)\n                raise TypeError\n            finally:\n                tester(10)\n\n        # PyCharm getting confused somehow?\n        # noinspection PyUnreachableCode\n        str()\n\n        with self.assertRaises(tester(Exception)):\n            if tester(0):\n                pass\n            elif tester(0):\n                pass\n            elif tester(1 / 0):\n                pass\n\n    def test_generator(self):\n        def gen():\n            for x in [1, 2]:\n                yield tester(x)\n\n        gen2 = (tester(x) for x in tester([1, 2]))\n\n        assert list(gen()) == list(gen2) == [1, 2]\n\n    def test_future_import(self):\n        tester(4)\n\n    def test_many_calls(self):\n        node = None\n        start = time.time()\n        for i in range(10000):\n            new_node = Source.executing(inspect.currentframe()).node\n            if node is None:\n                node = new_node\n            else:\n                self.assertIs(node, new_node)\n        self.assertLess(time.time() - start, 1)\n\n    def test_decode_source(self):\n        def check(source, encoding, exception=None, matches=True):\n            encoded = source.encode(encoding)\n            if exception:\n                with self.assertRaises(exception):\n                    Source.decode_source(encoded)\n            else:\n                decoded = Source.decode_source(encoded)\n                if matches:\n                    self.assertEqual(decoded, source)\n                else:\n                    self.assertNotEqual(decoded, source)\n\n        check(u'# coding=utf8\\n\u00e9', 'utf8')\n        check(u'# coding=gbk\\n\u00e9', 'gbk')\n\n        check(u'# coding=utf8\\n\u00e9', 'gbk', exception=UnicodeDecodeError)\n        check(u'# coding=gbk\\n\u00e9', 'utf8', matches=False)\n\n        # In Python 3 the default encoding is assumed to be UTF8\n        if PY3:\n            check(u'\u00e9', 'utf8')\n            check(u'\u00e9', 'gbk', exception=SyntaxError)\n\n    def test_multiline_strings(self):\n        tester('a')\n        tester('''\n            ab''')\n        tester('''\n                    abc\n                    def\n                    '''\n               )\n        str([\n            tester(\n                '''\n                123\n                456\n                '''\n            ),\n            tester(\n                '''\n                345\n                456786\n                '''\n            ),\n        ])\n        tester(\n            [\n                '''\n                123\n                456\n                '''\n                '''\n                345\n                456786\n                '''\n                ,\n                '''\n                123\n                456\n                ''',\n                '''\n                345\n                456786\n                '''\n            ]\n        )\n\n    def test_multiple_statements_on_one_line(self):\n        if tester(1): tester(2)\n        for _ in tester([1, 2]): tester(3)\n\n    def assert_qualname(self, func, qn, check_actual_qualname=True):\n        qualname = Source.for_filename(__file__).code_qualname(func.__code__)\n        self.assertEqual(qn, qualname)\n        if PY3 and check_actual_qualname:\n            self.assertEqual(qn, func.__qualname__)\n        self.assertTrue(qn.endswith(func.__name__))\n\n    def test_qualname(self):\n        self.assert_qualname(C.f, 'C.f')\n        self.assert_qualname(C.D.g, 'C.D.g')\n        self.assert_qualname(f, 'f')\n        self.assert_qualname(f(), 'f.<locals>.g')\n        self.assert_qualname(C.D.h(), 'C.D.h.<locals>.i.<locals>.j')\n        self.assert_qualname(lamb, '<lambda>')\n        foo = lambda_maker()\n        self.assert_qualname(foo, 'lambda_maker.<locals>.foo')\n        self.assert_qualname(foo.x, 'lambda_maker.<locals>.<lambda>')\n        self.assert_qualname(foo(), 'lambda_maker.<locals>.foo.<locals>.<lambda>')\n        self.assert_qualname(foo()(), 'lambda_maker.<locals>.foo.<locals>.<lambda>', check_actual_qualname=False)\n\n    def test_extended_arg(self):\n        source = 'tester(6)\\n%s\\ntester(9)' % list(range(66000))\n        _, filename = tempfile.mkstemp()\n        code = compile(source, filename, 'exec')\n        with open(filename, 'w') as outfile:\n            outfile.write(source)\n        exec(code)\n\n    def test_only(self):\n        for n in range(5):\n            gen = (i for i in range(n))\n            if n == 1:\n                self.assertEqual(only(gen), 0)\n            else:\n                with self.assertRaises(NotOneValueFound):\n                    only(gen)\n\n    def test_invalid_python(self):\n        path = os.path.join(os.path.dirname(__file__), 'not_code.txt', )\n        source = Source.for_filename(path)\n        self.assertIsNone(source.tree)\n\n    def test_executing_methods(self):\n        frame = inspect.currentframe()\n        executing = Source.executing(frame)\n        self.assertEqual(executing.code_qualname(), 'TestStuff.test_executing_methods')\n        if 'pypy' not in sys.version.lower():\n            text = 'Source.executing(frame)'\n            self.assertEqual(executing.text(), text)\n            start, end = executing.text_range()\n            self.assertEqual(executing.source.text[start:end], text)\n\n    def test_attr(self):\n        c = C()\n        c.x = c.y = tester\n        str((c.x.x, c.x.y, c.y.x, c.y.y, c.x.asd, c.y.qwe))"
        ],
        [
            "STORE_NAME",
            "class TestStuff(unittest.TestCase):\n\n    # noinspection PyTrailingSemicolon\n    def test_semicolons(self):\n        # @formatter:off\n        tester(1); tester(2); tester(3)\n        tester(9\n               ); tester(\n            8); tester(\n            99\n        ); tester(33); tester([4,\n                               5, 6, [\n                                7]])\n        # @formatter:on\n\n    def test_decorator(self):\n        @empty_decorator\n        @decorator_with_args(tester('123'), x=int())\n        @tester(list(tuple([1, 2])), returns=empty_decorator)\n        @tester(\n            list(\n                tuple(\n                    [3, 4])),\n            returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(\n            str(),\n            x=int())\n        @tester(list(tuple([5, 6])), returns=empty_decorator)\n        @tester(list(tuple([7, 8])), returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(tester('sdf'), x=tester('123234'))\n        def foo():\n            pass\n\n    def test_comprehensions(self):\n        # Comprehensions can be separated if they contain different names\n        str([{tester(x) for x in [1]}, {tester(y) for y in [1]}])\n        # or are on different lines\n        str([{tester(x) for x in [1]},\n             {tester(x) for x in [1]}])\n        # or are of different types\n        str([{tester(x) for x in [1]}, list(tester(x) for x in [1])])\n        # but not if everything is the same\n        # noinspection PyTypeChecker\n        # with self.assertRaises((AttributeError, NotOneValueFound)):\n        #     str([{tester(x) for x in [1]}, {tester(x) for x in [2]}])\n\n    def test_lambda(self):\n        self.assertEqual(\n            (lambda x: (tester(x), tester(x)))(tester(3)),\n            (3, 3),\n        )\n        (lambda: (lambda: tester(1))())()\n        self.assertEqual(\n            (lambda: [tester(x) for x in tester([1, 2])])(),\n            [1, 2],\n        )\n\n    def test_closures_and_nested_comprehensions(self):\n        x = 1\n        # @formatter:off\n        str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n        def foo():\n            y = 2\n            str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            def bar():\n                z = 3\n                str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y+z): {tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            bar()\n\n        foo()\n        # @formatter:on\n\n    def test_indirect_call(self):\n        dict(x=tester)['x'](tester)(3, check_func=False)\n\n    def test_compound_statements(self):\n        with self.assertRaises(TypeError):\n            try:\n                for _ in tester([1, 2, 3]):\n                    while tester(0):\n                        pass\n                    else:\n                        tester(4)\n                else:\n                    tester(5)\n                    raise ValueError\n            except tester(ValueError):\n                tester(9)\n                raise TypeError\n            finally:\n                tester(10)\n\n        # PyCharm getting confused somehow?\n        # noinspection PyUnreachableCode\n        str()\n\n        with self.assertRaises(tester(Exception)):\n            if tester(0):\n                pass\n            elif tester(0):\n                pass\n            elif tester(1 / 0):\n                pass\n\n    def test_generator(self):\n        def gen():\n            for x in [1, 2]:\n                yield tester(x)\n\n        gen2 = (tester(x) for x in tester([1, 2]))\n\n        assert list(gen()) == list(gen2) == [1, 2]\n\n    def test_future_import(self):\n        tester(4)\n\n    def test_many_calls(self):\n        node = None\n        start = time.time()\n        for i in range(10000):\n            new_node = Source.executing(inspect.currentframe()).node\n            if node is None:\n                node = new_node\n            else:\n                self.assertIs(node, new_node)\n        self.assertLess(time.time() - start, 1)\n\n    def test_decode_source(self):\n        def check(source, encoding, exception=None, matches=True):\n            encoded = source.encode(encoding)\n            if exception:\n                with self.assertRaises(exception):\n                    Source.decode_source(encoded)\n            else:\n                decoded = Source.decode_source(encoded)\n                if matches:\n                    self.assertEqual(decoded, source)\n                else:\n                    self.assertNotEqual(decoded, source)\n\n        check(u'# coding=utf8\\n\u00e9', 'utf8')\n        check(u'# coding=gbk\\n\u00e9', 'gbk')\n\n        check(u'# coding=utf8\\n\u00e9', 'gbk', exception=UnicodeDecodeError)\n        check(u'# coding=gbk\\n\u00e9', 'utf8', matches=False)\n\n        # In Python 3 the default encoding is assumed to be UTF8\n        if PY3:\n            check(u'\u00e9', 'utf8')\n            check(u'\u00e9', 'gbk', exception=SyntaxError)\n\n    def test_multiline_strings(self):\n        tester('a')\n        tester('''\n            ab''')\n        tester('''\n                    abc\n                    def\n                    '''\n               )\n        str([\n            tester(\n                '''\n                123\n                456\n                '''\n            ),\n            tester(\n                '''\n                345\n                456786\n                '''\n            ),\n        ])\n        tester(\n            [\n                '''\n                123\n                456\n                '''\n                '''\n                345\n                456786\n                '''\n                ,\n                '''\n                123\n                456\n                ''',\n                '''\n                345\n                456786\n                '''\n            ]\n        )\n\n    def test_multiple_statements_on_one_line(self):\n        if tester(1): tester(2)\n        for _ in tester([1, 2]): tester(3)\n\n    def assert_qualname(self, func, qn, check_actual_qualname=True):\n        qualname = Source.for_filename(__file__).code_qualname(func.__code__)\n        self.assertEqual(qn, qualname)\n        if PY3 and check_actual_qualname:\n            self.assertEqual(qn, func.__qualname__)\n        self.assertTrue(qn.endswith(func.__name__))\n\n    def test_qualname(self):\n        self.assert_qualname(C.f, 'C.f')\n        self.assert_qualname(C.D.g, 'C.D.g')\n        self.assert_qualname(f, 'f')\n        self.assert_qualname(f(), 'f.<locals>.g')\n        self.assert_qualname(C.D.h(), 'C.D.h.<locals>.i.<locals>.j')\n        self.assert_qualname(lamb, '<lambda>')\n        foo = lambda_maker()\n        self.assert_qualname(foo, 'lambda_maker.<locals>.foo')\n        self.assert_qualname(foo.x, 'lambda_maker.<locals>.<lambda>')\n        self.assert_qualname(foo(), 'lambda_maker.<locals>.foo.<locals>.<lambda>')\n        self.assert_qualname(foo()(), 'lambda_maker.<locals>.foo.<locals>.<lambda>', check_actual_qualname=False)\n\n    def test_extended_arg(self):\n        source = 'tester(6)\\n%s\\ntester(9)' % list(range(66000))\n        _, filename = tempfile.mkstemp()\n        code = compile(source, filename, 'exec')\n        with open(filename, 'w') as outfile:\n            outfile.write(source)\n        exec(code)\n\n    def test_only(self):\n        for n in range(5):\n            gen = (i for i in range(n))\n            if n == 1:\n                self.assertEqual(only(gen), 0)\n            else:\n                with self.assertRaises(NotOneValueFound):\n                    only(gen)\n\n    def test_invalid_python(self):\n        path = os.path.join(os.path.dirname(__file__), 'not_code.txt', )\n        source = Source.for_filename(path)\n        self.assertIsNone(source.tree)\n\n    def test_executing_methods(self):\n        frame = inspect.currentframe()\n        executing = Source.executing(frame)\n        self.assertEqual(executing.code_qualname(), 'TestStuff.test_executing_methods')\n        if 'pypy' not in sys.version.lower():\n            text = 'Source.executing(frame)'\n            self.assertEqual(executing.text(), text)\n            start, end = executing.text_range()\n            self.assertEqual(executing.source.text[start:end], text)\n\n    def test_attr(self):\n        c = C()\n        c.x = c.y = tester\n        str((c.x.x, c.x.y, c.y.x, c.y.y, c.x.asd, c.y.qwe))"
        ],
        [
            "LOAD_NAME",
            "unittest"
        ],
        [
            "LOAD_ATTR",
            "unittest.TestCase"
        ],
        [
            "CALL",
            "class TestFile(unittest.TestCase):\n    def test_file(self):\n        source = Source.for_frame(inspect.currentframe())\n        code = compile(source.text, source.filename, 'exec')\n        instructions = get_instructions(code)\n        lineno = None\n        for inst in instructions:\n            if inst.starts_line is not None:\n                lineno = inst.starts_line\n            if not inst.opname.startswith(\n                    ('BINARY_', 'UNARY_', 'LOAD_ATTR', 'LOAD_METHOD', 'LOOKUP_METHOD', 'COMPARE_OP')):\n                continue\n            frame = C()\n            frame.f_lasti = inst.offset\n            frame.f_code = code\n            frame.f_globals = globals()\n            frame.f_lineno = lineno\n            print(inst.opname)\n            assert Source.executing(frame).node is not None"
        ],
        [
            "STORE_NAME",
            "class TestFile(unittest.TestCase):\n    def test_file(self):\n        source = Source.for_frame(inspect.currentframe())\n        code = compile(source.text, source.filename, 'exec')\n        instructions = get_instructions(code)\n        lineno = None\n        for inst in instructions:\n            if inst.starts_line is not None:\n                lineno = inst.starts_line\n            if not inst.opname.startswith(\n                    ('BINARY_', 'UNARY_', 'LOAD_ATTR', 'LOAD_METHOD', 'LOOKUP_METHOD', 'COMPARE_OP')):\n                continue\n            frame = C()\n            frame.f_lasti = inst.offset\n            frame.f_code = code\n            frame.f_globals = globals()\n            frame.f_lineno = lineno\n            print(inst.opname)\n            assert Source.executing(frame).node is not None"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class C(object):\n    @staticmethod\n    def f():\n        pass\n\n    class D(object):\n        @staticmethod\n        def g():\n            pass\n\n        @staticmethod\n        def h():\n            def i():\n                def j():\n                    pass\n\n                return j\n\n            return i()"
        ],
        [
            "STORE_NAME",
            "class C(object):\n    @staticmethod\n    def f():\n        pass\n\n    class D(object):\n        @staticmethod\n        def g():\n            pass\n\n        @staticmethod\n        def h():\n            def i():\n                def j():\n                    pass\n\n                return j\n\n            return i()"
        ],
        [
            "LOAD_NAME",
            "TestFile"
        ],
        [
            "CALL",
            "TestFile()"
        ],
        [
            "LOAD_METHOD",
            "TestFile().test_file"
        ],
        [
            "CALL",
            "TestFile().test_file()"
        ],
        [
            "STORE_NAME",
            "def f():\n    def g():\n        pass\n\n    return g"
        ],
        [
            "STORE_NAME",
            "def lambda_maker():\n    def assign(x):\n        def decorator(func):\n            func.x = x\n            return func\n\n        return decorator\n\n    @assign(lambda: 1)\n    def foo():\n        return lambda: lambda: 3\n\n    return foo"
        ],
        [
            "STORE_NAME",
            "lamb"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class Tester(object):\n    def get_node(self, typ):\n        frame = inspect.currentframe().f_back.f_back\n        Source.lazycache(frame)\n        node = Source.executing(frame).node\n        assert isinstance(node, typ), (node, typ)\n        return node\n\n    def check(self, node, value):\n        frame = inspect.currentframe().f_back.f_back\n        result = eval(\n            compile(ast.Expression(node), frame.f_code.co_filename, 'eval'),\n            frame.f_globals,\n            frame.f_locals,\n        )\n        assert result == value, (result, value)\n\n    def __call__(self, arg, check_func=True, returns=None):\n        call = self.get_node(ast.Call)\n        self.check(call.args[0], arg)\n        if check_func:\n            self.check(call.func, self)\n        if returns is None:\n            return arg\n        return returns\n\n    def __getattr__(self, item):\n        node = self.get_node(ast.Attribute)\n        self.check(node.value, self)\n        assert node.attr == item\n        return self\n\n    def __getitem__(self, item):\n        node = self.get_node(ast.Subscript)\n        self.check(node.value, self)\n        self.check(node.slice.value, item)\n        return self\n\n    def __add__(self, other):\n        node = self.get_node(ast.BinOp)\n        self.check(node.left, self)\n        self.check(node.right, other)\n        return self\n\n    __pow__ = __mul__ = __sub__ = __add__\n\n    def __invert__(self):\n        node = self.get_node(ast.UnaryOp)\n        self.check(node.operand, self)\n        return self\n\n    __neg__ = __pos__ = __invert__\n\n    def __lt__(self, other):\n        node = self.get_node(ast.Compare)\n        self.check(node.left, self)\n        self.check(node.comparators[0], other)\n        return self\n\n    __ne__ = __ge__ = __lt__"
        ],
        [
            "STORE_NAME",
            "class Tester(object):\n    def get_node(self, typ):\n        frame = inspect.currentframe().f_back.f_back\n        Source.lazycache(frame)\n        node = Source.executing(frame).node\n        assert isinstance(node, typ), (node, typ)\n        return node\n\n    def check(self, node, value):\n        frame = inspect.currentframe().f_back.f_back\n        result = eval(\n            compile(ast.Expression(node), frame.f_code.co_filename, 'eval'),\n            frame.f_globals,\n            frame.f_locals,\n        )\n        assert result == value, (result, value)\n\n    def __call__(self, arg, check_func=True, returns=None):\n        call = self.get_node(ast.Call)\n        self.check(call.args[0], arg)\n        if check_func:\n            self.check(call.func, self)\n        if returns is None:\n            return arg\n        return returns\n\n    def __getattr__(self, item):\n        node = self.get_node(ast.Attribute)\n        self.check(node.value, self)\n        assert node.attr == item\n        return self\n\n    def __getitem__(self, item):\n        node = self.get_node(ast.Subscript)\n        self.check(node.value, self)\n        self.check(node.slice.value, item)\n        return self\n\n    def __add__(self, other):\n        node = self.get_node(ast.BinOp)\n        self.check(node.left, self)\n        self.check(node.right, other)\n        return self\n\n    __pow__ = __mul__ = __sub__ = __add__\n\n    def __invert__(self):\n        node = self.get_node(ast.UnaryOp)\n        self.check(node.operand, self)\n        return self\n\n    __neg__ = __pos__ = __invert__\n\n    def __lt__(self, other):\n        node = self.get_node(ast.Compare)\n        self.check(node.left, self)\n        self.check(node.comparators[0], other)\n        return self\n\n    __ne__ = __ge__ = __lt__"
        ],
        [
            "LOAD_NAME",
            "Tester"
        ],
        [
            "CALL",
            "Tester()"
        ],
        [
            "STORE_NAME",
            "tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "CALL",
            "tester([1, 2, 3])"
        ],
        [
            "COMPARE_OP",
            "tester([1, 2, 3]) == [1, 2, 3]"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "LOAD_ATTR",
            "tester.asd"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "IS_OP",
            "tester.asd is tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "BINARY_SUBSCR",
            "tester[19]"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "IS_OP",
            "tester[19] is tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "BINARY_OP",
            "tester ** 4"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "IS_OP",
            "tester ** 4 is tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "BINARY_OP",
            "tester * 3"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "IS_OP",
            "tester * 3 is tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "BINARY_OP",
            "tester - 2"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "IS_OP",
            "tester - 2 is tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "BINARY_OP",
            "tester + 1"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "IS_OP",
            "tester + 1 is tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "UNARY_NEGATIVE",
            "-tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "IS_OP",
            "-tester is tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "UNARY_POSITIVE",
            "+tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "IS_OP",
            "+tester is tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "UNARY_INVERT",
            "~tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "IS_OP",
            "~tester is tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "COMPARE_OP",
            "tester < 7"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "IS_OP",
            "(tester < 7) is tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "COMPARE_OP",
            "tester >= 78"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "IS_OP",
            "(tester >= 78) is tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "COMPARE_OP",
            "tester != 79"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "IS_OP",
            "(tester != 79) is tester"
        ],
        [
            "LOAD_NAME",
            "tester"
        ],
        [
            "LOAD_METHOD",
            "tester.foo"
        ],
        [
            "CALL",
            "tester.foo(45, False)"
        ],
        [
            "COMPARE_OP",
            "tester.foo(45, False) == 45"
        ],
        [
            "STORE_NAME",
            "def empty_decorator(func):\n    return func"
        ],
        [
            "STORE_NAME",
            "def decorator_with_args(*_, **__):\n    return empty_decorator"
        ],
        [
            "LOAD_NAME",
            "__name__"
        ],
        [
            "COMPARE_OP",
            "__name__ == '__main__'"
        ],
        [
            "LOAD_NAME",
            "unittest"
        ],
        [
            "LOAD_ATTR",
            "unittest.main"
        ],
        [
            "CALL",
            "unittest.main()"
        ],
        [
            "STORE_NAME",
            "    def test_semicolons(self):\n        # @formatter:off\n        tester(1); tester(2); tester(3)\n        tester(9\n               ); tester(\n            8); tester(\n            99\n        ); tester(33); tester([4,\n                               5, 6, [\n                                7]])"
        ],
        [
            "STORE_NAME",
            "    def test_decorator(self):\n        @empty_decorator\n        @decorator_with_args(tester('123'), x=int())\n        @tester(list(tuple([1, 2])), returns=empty_decorator)\n        @tester(\n            list(\n                tuple(\n                    [3, 4])),\n            returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(\n            str(),\n            x=int())\n        @tester(list(tuple([5, 6])), returns=empty_decorator)\n        @tester(list(tuple([7, 8])), returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(tester('sdf'), x=tester('123234'))\n        def foo():\n            pass"
        ],
        [
            "STORE_NAME",
            "    def test_comprehensions(self):\n        # Comprehensions can be separated if they contain different names\n        str([{tester(x) for x in [1]}, {tester(y) for y in [1]}])\n        # or are on different lines\n        str([{tester(x) for x in [1]},\n             {tester(x) for x in [1]}])\n        # or are of different types\n        str([{tester(x) for x in [1]}, list(tester(x) for x in [1])])"
        ],
        [
            "STORE_NAME",
            "    def test_lambda(self):\n        self.assertEqual(\n            (lambda x: (tester(x), tester(x)))(tester(3)),\n            (3, 3),\n        )\n        (lambda: (lambda: tester(1))())()\n        self.assertEqual(\n            (lambda: [tester(x) for x in tester([1, 2])])(),\n            [1, 2],\n        )"
        ],
        [
            "STORE_NAME",
            "    def test_closures_and_nested_comprehensions(self):\n        x = 1\n        # @formatter:off\n        str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n        def foo():\n            y = 2\n            str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            def bar():\n                z = 3\n                str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y+z): {tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            bar()\n\n        foo()"
        ],
        [
            "STORE_NAME",
            "    def test_indirect_call(self):\n        dict(x=tester)['x'](tester)(3, check_func=False)"
        ],
        [
            "STORE_NAME",
            "    def test_compound_statements(self):\n        with self.assertRaises(TypeError):\n            try:\n                for _ in tester([1, 2, 3]):\n                    while tester(0):\n                        pass\n                    else:\n                        tester(4)\n                else:\n                    tester(5)\n                    raise ValueError\n            except tester(ValueError):\n                tester(9)\n                raise TypeError\n            finally:\n                tester(10)\n\n        # PyCharm getting confused somehow?\n        # noinspection PyUnreachableCode\n        str()\n\n        with self.assertRaises(tester(Exception)):\n            if tester(0):\n                pass\n            elif tester(0):\n                pass\n            elif tester(1 / 0):\n                pass"
        ],
        [
            "STORE_NAME",
            "    def test_generator(self):\n        def gen():\n            for x in [1, 2]:\n                yield tester(x)\n\n        gen2 = (tester(x) for x in tester([1, 2]))\n\n        assert list(gen()) == list(gen2) == [1, 2]"
        ],
        [
            "STORE_NAME",
            "    def test_future_import(self):\n        tester(4)"
        ],
        [
            "STORE_NAME",
            "    def test_many_calls(self):\n        node = None\n        start = time.time()\n        for i in range(10000):\n            new_node = Source.executing(inspect.currentframe()).node\n            if node is None:\n                node = new_node\n            else:\n                self.assertIs(node, new_node)\n        self.assertLess(time.time() - start, 1)"
        ],
        [
            "STORE_NAME",
            "    def test_decode_source(self):\n        def check(source, encoding, exception=None, matches=True):\n            encoded = source.encode(encoding)\n            if exception:\n                with self.assertRaises(exception):\n                    Source.decode_source(encoded)\n            else:\n                decoded = Source.decode_source(encoded)\n                if matches:\n                    self.assertEqual(decoded, source)\n                else:\n                    self.assertNotEqual(decoded, source)\n\n        check(u'# coding=utf8\\n\u00e9', 'utf8')\n        check(u'# coding=gbk\\n\u00e9', 'gbk')\n\n        check(u'# coding=utf8\\n\u00e9', 'gbk', exception=UnicodeDecodeError)\n        check(u'# coding=gbk\\n\u00e9', 'utf8', matches=False)\n\n        # In Python 3 the default encoding is assumed to be UTF8\n        if PY3:\n            check(u'\u00e9', 'utf8')\n            check(u'\u00e9', 'gbk', exception=SyntaxError)"
        ],
        [
            "STORE_NAME",
            "    def test_multiline_strings(self):\n        tester('a')\n        tester('''\n            ab''')\n        tester('''\n                    abc\n                    def\n                    '''\n               )\n        str([\n            tester(\n                '''\n                123\n                456\n                '''\n            ),\n            tester(\n                '''\n                345\n                456786\n                '''\n            ),\n        ])\n        tester(\n            [\n                '''\n                123\n                456\n                '''\n                '''\n                345\n                456786\n                '''\n                ,\n                '''\n                123\n                456\n                ''',\n                '''\n                345\n                456786\n                '''\n            ]\n        )"
        ],
        [
            "STORE_NAME",
            "    def test_multiple_statements_on_one_line(self):\n        if tester(1): tester(2)\n        for _ in tester([1, 2]): tester(3)"
        ],
        [
            "STORE_NAME",
            "    def assert_qualname(self, func, qn, check_actual_qualname=True):\n        qualname = Source.for_filename(__file__).code_qualname(func.__code__)\n        self.assertEqual(qn, qualname)\n        if PY3 and check_actual_qualname:\n            self.assertEqual(qn, func.__qualname__)\n        self.assertTrue(qn.endswith(func.__name__))"
        ],
        [
            "STORE_NAME",
            "    def test_qualname(self):\n        self.assert_qualname(C.f, 'C.f')\n        self.assert_qualname(C.D.g, 'C.D.g')\n        self.assert_qualname(f, 'f')\n        self.assert_qualname(f(), 'f.<locals>.g')\n        self.assert_qualname(C.D.h(), 'C.D.h.<locals>.i.<locals>.j')\n        self.assert_qualname(lamb, '<lambda>')\n        foo = lambda_maker()\n        self.assert_qualname(foo, 'lambda_maker.<locals>.foo')\n        self.assert_qualname(foo.x, 'lambda_maker.<locals>.<lambda>')\n        self.assert_qualname(foo(), 'lambda_maker.<locals>.foo.<locals>.<lambda>')\n        self.assert_qualname(foo()(), 'lambda_maker.<locals>.foo.<locals>.<lambda>', check_actual_qualname=False)"
        ],
        [
            "STORE_NAME",
            "    def test_extended_arg(self):\n        source = 'tester(6)\\n%s\\ntester(9)' % list(range(66000))\n        _, filename = tempfile.mkstemp()\n        code = compile(source, filename, 'exec')\n        with open(filename, 'w') as outfile:\n            outfile.write(source)\n        exec(code)"
        ],
        [
            "STORE_NAME",
            "    def test_only(self):\n        for n in range(5):\n            gen = (i for i in range(n))\n            if n == 1:\n                self.assertEqual(only(gen), 0)\n            else:\n                with self.assertRaises(NotOneValueFound):\n                    only(gen)"
        ],
        [
            "STORE_NAME",
            "    def test_invalid_python(self):\n        path = os.path.join(os.path.dirname(__file__), 'not_code.txt', )\n        source = Source.for_filename(path)\n        self.assertIsNone(source.tree)"
        ],
        [
            "STORE_NAME",
            "    def test_executing_methods(self):\n        frame = inspect.currentframe()\n        executing = Source.executing(frame)\n        self.assertEqual(executing.code_qualname(), 'TestStuff.test_executing_methods')\n        if 'pypy' not in sys.version.lower():\n            text = 'Source.executing(frame)'\n            self.assertEqual(executing.text(), text)\n            start, end = executing.text_range()\n            self.assertEqual(executing.source.text[start:end], text)"
        ],
        [
            "STORE_NAME",
            "    def test_attr(self):\n        c = C()\n        c.x = c.y = tester\n        str((c.x.x, c.x.y, c.y.x, c.y.y, c.x.asd, c.y.qwe))"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(1)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(2)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(3)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(9\n               )"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(\n            8)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(\n            99\n        )"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(33)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([4,\n                               5, 6, [\n                                7]])"
        ],
        [
            "LOAD_GLOBAL",
            "empty_decorator"
        ],
        [
            "LOAD_GLOBAL",
            "decorator_with_args"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester('123')"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "CALL",
            "int()"
        ],
        [
            "CALL",
            "decorator_with_args(tester('123'), x=int())"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_GLOBAL",
            "tuple"
        ],
        [
            "CALL",
            "tuple([1, 2])"
        ],
        [
            "CALL",
            "list(tuple([1, 2]))"
        ],
        [
            "LOAD_GLOBAL",
            "empty_decorator"
        ],
        [
            "CALL",
            "tester(list(tuple([1, 2])), returns=empty_decorator)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_GLOBAL",
            "tuple"
        ],
        [
            "CALL",
            "tuple(\n                    [3, 4])"
        ],
        [
            "CALL",
            "list(\n                tuple(\n                    [3, 4]))"
        ],
        [
            "LOAD_GLOBAL",
            "empty_decorator"
        ],
        [
            "CALL",
            "tester(\n            list(\n                tuple(\n                    [3, 4])),\n            returns=empty_decorator)"
        ],
        [
            "LOAD_GLOBAL",
            "empty_decorator"
        ],
        [
            "LOAD_GLOBAL",
            "decorator_with_args"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "CALL",
            "str()"
        ],
        [
            "LOAD_GLOBAL",
            "int"
        ],
        [
            "CALL",
            "int()"
        ],
        [
            "CALL",
            "decorator_with_args(\n            str(),\n            x=int())"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_GLOBAL",
            "tuple"
        ],
        [
            "CALL",
            "tuple([5, 6])"
        ],
        [
            "CALL",
            "list(tuple([5, 6]))"
        ],
        [
            "LOAD_GLOBAL",
            "empty_decorator"
        ],
        [
            "CALL",
            "tester(list(tuple([5, 6])), returns=empty_decorator)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_GLOBAL",
            "tuple"
        ],
        [
            "CALL",
            "tuple([7, 8])"
        ],
        [
            "CALL",
            "list(tuple([7, 8]))"
        ],
        [
            "LOAD_GLOBAL",
            "empty_decorator"
        ],
        [
            "CALL",
            "tester(list(tuple([7, 8])), returns=empty_decorator)"
        ],
        [
            "LOAD_GLOBAL",
            "empty_decorator"
        ],
        [
            "LOAD_GLOBAL",
            "decorator_with_args"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester('sdf')"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester('123234')"
        ],
        [
            "CALL",
            "decorator_with_args(tester('sdf'), x=tester('123234'))"
        ],
        [
            "CALL",
            "decorator_with_args(tester('sdf'), x=tester('123234'))"
        ],
        [
            "CALL",
            "empty_decorator"
        ],
        [
            "CALL",
            "tester(list(tuple([7, 8])), returns=empty_decorator)"
        ],
        [
            "CALL",
            "tester(list(tuple([5, 6])), returns=empty_decorator)"
        ],
        [
            "CALL",
            "decorator_with_args(\n            str(),\n            x=int())"
        ],
        [
            "CALL",
            "empty_decorator"
        ],
        [
            "CALL",
            "tester(\n            list(\n                tuple(\n                    [3, 4])),\n            returns=empty_decorator)"
        ],
        [
            "CALL",
            "tester(list(tuple([1, 2])), returns=empty_decorator)"
        ],
        [
            "CALL",
            "decorator_with_args(tester('123'), x=int())"
        ],
        [
            "CALL",
            "empty_decorator"
        ],
        [
            "STORE_FAST",
            "        @empty_decorator\n        @decorator_with_args(tester('123'), x=int())\n        @tester(list(tuple([1, 2])), returns=empty_decorator)\n        @tester(\n            list(\n                tuple(\n                    [3, 4])),\n            returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(\n            str(),\n            x=int())\n        @tester(list(tuple([5, 6])), returns=empty_decorator)\n        @tester(list(tuple([7, 8])), returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(tester('sdf'), x=tester('123234'))\n        def foo():\n            pass"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "CALL",
            "{tester(x) for x in [1]}"
        ],
        [
            "CALL",
            "{tester(y) for y in [1]}"
        ],
        [
            "CALL",
            "str([{tester(x) for x in [1]}, {tester(y) for y in [1]}])"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "CALL",
            "{tester(x) for x in [1]}"
        ],
        [
            "CALL",
            "{tester(x) for x in [1]}"
        ],
        [
            "CALL",
            "str([{tester(x) for x in [1]},\n             {tester(x) for x in [1]}])"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "CALL",
            "{tester(x) for x in [1]}"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "CALL",
            "(tester(x) for x in [1])"
        ],
        [
            "CALL",
            "list(tester(x) for x in [1])"
        ],
        [
            "CALL",
            "str([{tester(x) for x in [1]}, list(tester(x) for x in [1])])"
        ],
        [
            "LOAD_FAST",
            "{tester(x) for x in [1]}"
        ],
        [
            "STORE_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "tester(x)"
        ],
        [
            "LOAD_FAST",
            "{tester(y) for y in [1]}"
        ],
        [
            "STORE_FAST",
            "y"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "y"
        ],
        [
            "CALL",
            "tester(y)"
        ],
        [
            "LOAD_FAST",
            "{tester(x) for x in [1]}"
        ],
        [
            "STORE_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "tester(x)"
        ],
        [
            "LOAD_FAST",
            "{tester(x) for x in [1]}"
        ],
        [
            "STORE_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "tester(x)"
        ],
        [
            "LOAD_FAST",
            "{tester(x) for x in [1]}"
        ],
        [
            "STORE_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "tester(x)"
        ],
        [
            "LOAD_FAST",
            "(tester(x) for x in [1])"
        ],
        [
            "STORE_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "tester(x)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertEqual"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(3)"
        ],
        [
            "CALL",
            "(lambda x: (tester(x), tester(x)))(tester(3))"
        ],
        [
            "CALL",
            "self.assertEqual(\n            (lambda x: (tester(x), tester(x)))(tester(3)),\n            (3, 3),\n        )"
        ],
        [
            "CALL",
            "(lambda: (lambda: tester(1))())()"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertEqual"
        ],
        [
            "CALL",
            "(lambda: [tester(x) for x in tester([1, 2])])()"
        ],
        [
            "CALL",
            "self.assertEqual(\n            (lambda: [tester(x) for x in tester([1, 2])])(),\n            [1, 2],\n        )"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "tester(x)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "tester(x)"
        ],
        [
            "CALL",
            "(lambda: tester(1))()"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(1)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([1, 2])"
        ],
        [
            "CALL",
            "[tester(x) for x in tester([1, 2])]"
        ],
        [
            "LOAD_FAST",
            "[tester(x) for x in tester([1, 2])]"
        ],
        [
            "STORE_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "tester(x)"
        ],
        [
            "STORE_DEREF",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([5, 6])"
        ],
        [
            "CALL",
            "{tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "CALL",
            "str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
        ],
        [
            "STORE_FAST",
            "        def foo():\n            y = 2\n            str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            def bar():\n                z = 3\n                str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y+z): {tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            bar()"
        ],
        [
            "LOAD_FAST",
            "foo"
        ],
        [
            "CALL",
            "foo()"
        ],
        [
            "LOAD_FAST",
            "{tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "STORE_FAST",
            "a"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "a"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "a+x"
        ],
        [
            "CALL",
            "tester(a+x)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([3, 4])"
        ],
        [
            "CALL",
            "{tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "LOAD_FAST",
            "{tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "STORE_FAST",
            "b"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "b+x"
        ],
        [
            "CALL",
            "tester(b+x)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([1, 2])"
        ],
        [
            "CALL",
            "{tester(c+x) for c in tester([1, 2])}"
        ],
        [
            "LOAD_FAST",
            "{tester(c+x) for c in tester([1, 2])}"
        ],
        [
            "STORE_FAST",
            "c"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "c+x"
        ],
        [
            "CALL",
            "tester(c+x)"
        ],
        [
            "STORE_DEREF",
            "y"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([5, 6])"
        ],
        [
            "CALL",
            "{tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "CALL",
            "str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([5, 6])"
        ],
        [
            "CALL",
            "{tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "CALL",
            "str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([5, 6])"
        ],
        [
            "CALL",
            "{tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "CALL",
            "str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
        ],
        [
            "STORE_FAST",
            "            def bar():\n                z = 3\n                str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y+z): {tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
        ],
        [
            "LOAD_FAST",
            "bar"
        ],
        [
            "CALL",
            "bar()"
        ],
        [
            "LOAD_FAST",
            "{tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "STORE_FAST",
            "a"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "a"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "a+x"
        ],
        [
            "CALL",
            "tester(a+x)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([3, 4])"
        ],
        [
            "CALL",
            "{tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "LOAD_FAST",
            "{tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "STORE_FAST",
            "b"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "b+x"
        ],
        [
            "CALL",
            "tester(b+x)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([1, 2])"
        ],
        [
            "CALL",
            "{tester(c+x) for c in tester([1, 2])}"
        ],
        [
            "LOAD_FAST",
            "{tester(c+x) for c in tester([1, 2])}"
        ],
        [
            "STORE_FAST",
            "c"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "c+x"
        ],
        [
            "CALL",
            "tester(c+x)"
        ],
        [
            "LOAD_FAST",
            "{tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "STORE_FAST",
            "a"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "a"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "a+y"
        ],
        [
            "CALL",
            "tester(a+y)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([3, 4])"
        ],
        [
            "CALL",
            "{tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "LOAD_FAST",
            "{tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "STORE_FAST",
            "b"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "b+y"
        ],
        [
            "CALL",
            "tester(b+y)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([1, 2])"
        ],
        [
            "CALL",
            "{tester(c+y) for c in tester([1, 2])}"
        ],
        [
            "LOAD_FAST",
            "{tester(c+y) for c in tester([1, 2])}"
        ],
        [
            "STORE_FAST",
            "c"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "c+y"
        ],
        [
            "CALL",
            "tester(c+y)"
        ],
        [
            "LOAD_FAST",
            "{tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "STORE_FAST",
            "a"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "a"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "a+x"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "a+x+y"
        ],
        [
            "CALL",
            "tester(a+x+y)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([3, 4])"
        ],
        [
            "CALL",
            "{tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "LOAD_FAST",
            "{tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "STORE_FAST",
            "b"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "b+x"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "b+x+y"
        ],
        [
            "CALL",
            "tester(b+x+y)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([1, 2])"
        ],
        [
            "CALL",
            "{tester(c+x+y) for c in tester([1, 2])}"
        ],
        [
            "LOAD_FAST",
            "{tester(c+x+y) for c in tester([1, 2])}"
        ],
        [
            "STORE_FAST",
            "c"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "c+x"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "c+x+y"
        ],
        [
            "CALL",
            "tester(c+x+y)"
        ],
        [
            "STORE_DEREF",
            "z"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([5, 6])"
        ],
        [
            "CALL",
            "{tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "CALL",
            "str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([5, 6])"
        ],
        [
            "CALL",
            "{tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "CALL",
            "str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([5, 6])"
        ],
        [
            "CALL",
            "{tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "CALL",
            "str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([5, 6])"
        ],
        [
            "CALL",
            "{tester(a+x+y+z): {tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "CALL",
            "str({tester(a+x+y+z): {tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
        ],
        [
            "LOAD_FAST",
            "{tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "STORE_FAST",
            "a"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "a"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "a+x"
        ],
        [
            "CALL",
            "tester(a+x)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([3, 4])"
        ],
        [
            "CALL",
            "{tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "LOAD_FAST",
            "{tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "STORE_FAST",
            "b"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "b+x"
        ],
        [
            "CALL",
            "tester(b+x)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([1, 2])"
        ],
        [
            "CALL",
            "{tester(c+x) for c in tester([1, 2])}"
        ],
        [
            "LOAD_FAST",
            "{tester(c+x) for c in tester([1, 2])}"
        ],
        [
            "STORE_FAST",
            "c"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "c+x"
        ],
        [
            "CALL",
            "tester(c+x)"
        ],
        [
            "LOAD_FAST",
            "{tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "STORE_FAST",
            "a"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "a"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "a+y"
        ],
        [
            "CALL",
            "tester(a+y)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([3, 4])"
        ],
        [
            "CALL",
            "{tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "LOAD_FAST",
            "{tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "STORE_FAST",
            "b"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "b+y"
        ],
        [
            "CALL",
            "tester(b+y)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([1, 2])"
        ],
        [
            "CALL",
            "{tester(c+y) for c in tester([1, 2])}"
        ],
        [
            "LOAD_FAST",
            "{tester(c+y) for c in tester([1, 2])}"
        ],
        [
            "STORE_FAST",
            "c"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "c+y"
        ],
        [
            "CALL",
            "tester(c+y)"
        ],
        [
            "LOAD_FAST",
            "{tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "STORE_FAST",
            "a"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "a"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "a+x"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "a+x+y"
        ],
        [
            "CALL",
            "tester(a+x+y)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([3, 4])"
        ],
        [
            "CALL",
            "{tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "LOAD_FAST",
            "{tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "STORE_FAST",
            "b"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "b+x"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "b+x+y"
        ],
        [
            "CALL",
            "tester(b+x+y)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([1, 2])"
        ],
        [
            "CALL",
            "{tester(c+x+y) for c in tester([1, 2])}"
        ],
        [
            "LOAD_FAST",
            "{tester(c+x+y) for c in tester([1, 2])}"
        ],
        [
            "STORE_FAST",
            "c"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "c+x"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "c+x+y"
        ],
        [
            "CALL",
            "tester(c+x+y)"
        ],
        [
            "LOAD_FAST",
            "{tester(a+x+y+z): {tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
        ],
        [
            "STORE_FAST",
            "a"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "a"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "a+x"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "a+x+y"
        ],
        [
            "LOAD_DEREF",
            "z"
        ],
        [
            "BINARY_OP",
            "a+x+y+z"
        ],
        [
            "CALL",
            "tester(a+x+y+z)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([3, 4])"
        ],
        [
            "CALL",
            "{tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "LOAD_FAST",
            "{tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])}"
        ],
        [
            "STORE_FAST",
            "b"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "b"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "b+x"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "b+x+y"
        ],
        [
            "LOAD_DEREF",
            "z"
        ],
        [
            "BINARY_OP",
            "b+x+y+z"
        ],
        [
            "CALL",
            "tester(b+x+y+z)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([1, 2])"
        ],
        [
            "CALL",
            "{tester(c+x+y+z) for c in tester([1, 2])}"
        ],
        [
            "LOAD_FAST",
            "{tester(c+x+y+z) for c in tester([1, 2])}"
        ],
        [
            "STORE_FAST",
            "c"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "BINARY_OP",
            "c+x"
        ],
        [
            "LOAD_DEREF",
            "y"
        ],
        [
            "BINARY_OP",
            "c+x+y"
        ],
        [
            "LOAD_DEREF",
            "z"
        ],
        [
            "BINARY_OP",
            "c+x+y+z"
        ],
        [
            "CALL",
            "tester(c+x+y+z)"
        ],
        [
            "LOAD_GLOBAL",
            "dict"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "dict(x=tester)"
        ],
        [
            "BINARY_SUBSCR",
            "dict(x=tester)['x']"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "dict(x=tester)['x'](tester)"
        ],
        [
            "CALL",
            "dict(x=tester)['x'](tester)(3, check_func=False)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertRaises"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "CALL",
            "self.assertRaises(TypeError)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([1, 2, 3])"
        ],
        [
            "STORE_FAST",
            "_"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(0)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(0)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(4)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(5)"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "tester(ValueError)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(9)"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(10)"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "CALL",
            "str()"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertRaises"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_GLOBAL",
            "Exception"
        ],
        [
            "CALL",
            "tester(Exception)"
        ],
        [
            "CALL",
            "self.assertRaises(tester(Exception))"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(0)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(0)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "BINARY_OP",
            "1 / 0"
        ],
        [
            "CALL",
            "tester(1 / 0)"
        ],
        [
            "CALL",
            "        with self.assertRaises(tester(Exception)):\n            if tester(0):\n                pass\n            elif tester(0):\n                pass\n            elif tester(1 / 0):\n                pass"
        ],
        [
            "STORE_FAST",
            "        def gen():\n            for x in [1, 2]:\n                yield tester(x)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([1, 2])"
        ],
        [
            "CALL",
            "(tester(x) for x in tester([1, 2]))"
        ],
        [
            "STORE_FAST",
            "gen2"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_FAST",
            "gen"
        ],
        [
            "CALL",
            "gen()"
        ],
        [
            "CALL",
            "list(gen())"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_FAST",
            "gen2"
        ],
        [
            "CALL",
            "list(gen2)"
        ],
        [
            "COMPARE_OP",
            "assert list(gen()) == list(gen2) == [1, 2]"
        ],
        [
            "COMPARE_OP",
            "assert list(gen()) == list(gen2) == [1, 2]"
        ],
        [
            "STORE_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "tester(x)"
        ],
        [
            "LOAD_FAST",
            "(tester(x) for x in tester([1, 2]))"
        ],
        [
            "STORE_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "tester(x)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(4)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "time"
        ],
        [
            "LOAD_ATTR",
            "time.time"
        ],
        [
            "CALL",
            "time.time()"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "LOAD_GLOBAL",
            "range"
        ],
        [
            "CALL",
            "range(10000)"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "LOAD_GLOBAL",
            "Source"
        ],
        [
            "LOAD_ATTR",
            "Source.executing"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.currentframe"
        ],
        [
            "CALL",
            "inspect.currentframe()"
        ],
        [
            "CALL",
            "Source.executing(inspect.currentframe())"
        ],
        [
            "LOAD_ATTR",
            "Source.executing(inspect.currentframe()).node"
        ],
        [
            "STORE_FAST",
            "new_node"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "new_node"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertIs"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "new_node"
        ],
        [
            "CALL",
            "self.assertIs(node, new_node)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertLess"
        ],
        [
            "LOAD_GLOBAL",
            "time"
        ],
        [
            "LOAD_ATTR",
            "time.time"
        ],
        [
            "CALL",
            "time.time()"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "BINARY_OP",
            "time.time() - start"
        ],
        [
            "CALL",
            "self.assertLess(time.time() - start, 1)"
        ],
        [
            "STORE_FAST",
            "        def check(source, encoding, exception=None, matches=True):\n            encoded = source.encode(encoding)\n            if exception:\n                with self.assertRaises(exception):\n                    Source.decode_source(encoded)\n            else:\n                decoded = Source.decode_source(encoded)\n                if matches:\n                    self.assertEqual(decoded, source)\n                else:\n                    self.assertNotEqual(decoded, source)"
        ],
        [
            "LOAD_FAST",
            "check"
        ],
        [
            "CALL",
            "check(u'# coding=utf8\\n\u00e9', 'utf8')"
        ],
        [
            "LOAD_FAST",
            "check"
        ],
        [
            "CALL",
            "check(u'# coding=gbk\\n\u00e9', 'gbk')"
        ],
        [
            "LOAD_FAST",
            "check"
        ],
        [
            "LOAD_GLOBAL",
            "UnicodeDecodeError"
        ],
        [
            "CALL",
            "check(u'# coding=utf8\\n\u00e9', 'gbk', exception=UnicodeDecodeError)"
        ],
        [
            "LOAD_FAST",
            "check"
        ],
        [
            "CALL",
            "check(u'# coding=gbk\\n\u00e9', 'utf8', matches=False)"
        ],
        [
            "LOAD_GLOBAL",
            "PY3"
        ],
        [
            "LOAD_FAST",
            "check"
        ],
        [
            "CALL",
            "check(u'\u00e9', 'utf8')"
        ],
        [
            "LOAD_FAST",
            "check"
        ],
        [
            "LOAD_GLOBAL",
            "SyntaxError"
        ],
        [
            "CALL",
            "check(u'\u00e9', 'gbk', exception=SyntaxError)"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_METHOD",
            "source.encode"
        ],
        [
            "LOAD_FAST",
            "encoding"
        ],
        [
            "CALL",
            "source.encode(encoding)"
        ],
        [
            "STORE_FAST",
            "encoded"
        ],
        [
            "LOAD_FAST",
            "exception"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertRaises"
        ],
        [
            "LOAD_FAST",
            "exception"
        ],
        [
            "CALL",
            "self.assertRaises(exception)"
        ],
        [
            "LOAD_GLOBAL",
            "Source"
        ],
        [
            "LOAD_ATTR",
            "Source.decode_source"
        ],
        [
            "LOAD_FAST",
            "encoded"
        ],
        [
            "CALL",
            "Source.decode_source(encoded)"
        ],
        [
            "CALL",
            "                with self.assertRaises(exception):\n                    Source.decode_source(encoded)"
        ],
        [
            "LOAD_GLOBAL",
            "Source"
        ],
        [
            "LOAD_ATTR",
            "Source.decode_source"
        ],
        [
            "LOAD_FAST",
            "encoded"
        ],
        [
            "CALL",
            "Source.decode_source(encoded)"
        ],
        [
            "STORE_FAST",
            "decoded"
        ],
        [
            "LOAD_FAST",
            "matches"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertEqual"
        ],
        [
            "LOAD_FAST",
            "decoded"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CALL",
            "self.assertEqual(decoded, source)"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertNotEqual"
        ],
        [
            "LOAD_FAST",
            "decoded"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CALL",
            "self.assertNotEqual(decoded, source)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester('a')"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester('''\n            ab''')"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester('''\n                    abc\n                    def\n                    '''\n               )"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(\n                '''\n                123\n                456\n                '''\n            )"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(\n                '''\n                345\n                456786\n                '''\n            )"
        ],
        [
            "CALL",
            "str([\n            tester(\n                '''\n                123\n                456\n                '''\n            ),\n            tester(\n                '''\n                345\n                456786\n                '''\n            ),\n        ])"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(\n            [\n                '''\n                123\n                456\n                '''\n                '''\n                345\n                456786\n                '''\n                ,\n                '''\n                123\n                456\n                ''',\n                '''\n                345\n                456786\n                '''\n            ]\n        )"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(1)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(2)"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester([1, 2])"
        ],
        [
            "STORE_FAST",
            "_"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "CALL",
            "tester(3)"
        ],
        [
            "LOAD_GLOBAL",
            "Source"
        ],
        [
            "LOAD_ATTR",
            "Source.for_filename"
        ],
        [
            "LOAD_GLOBAL",
            "__file__"
        ],
        [
            "CALL",
            "Source.for_filename(__file__)"
        ],
        [
            "LOAD_METHOD",
            "Source.for_filename(__file__).code_qualname"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.__code__"
        ],
        [
            "CALL",
            "Source.for_filename(__file__).code_qualname(func.__code__)"
        ],
        [
            "STORE_FAST",
            "qualname"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertEqual"
        ],
        [
            "LOAD_FAST",
            "qn"
        ],
        [
            "LOAD_FAST",
            "qualname"
        ],
        [
            "CALL",
            "self.assertEqual(qn, qualname)"
        ],
        [
            "LOAD_GLOBAL",
            "PY3"
        ],
        [
            "LOAD_FAST",
            "check_actual_qualname"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertEqual"
        ],
        [
            "LOAD_FAST",
            "qn"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.__qualname__"
        ],
        [
            "CALL",
            "self.assertEqual(qn, func.__qualname__)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertTrue"
        ],
        [
            "LOAD_FAST",
            "qn"
        ],
        [
            "LOAD_METHOD",
            "qn.endswith"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.__name__"
        ],
        [
            "CALL",
            "qn.endswith(func.__name__)"
        ],
        [
            "CALL",
            "self.assertTrue(qn.endswith(func.__name__))"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assert_qualname"
        ],
        [
            "LOAD_GLOBAL",
            "C"
        ],
        [
            "LOAD_ATTR",
            "C.f"
        ],
        [
            "CALL",
            "self.assert_qualname(C.f, 'C.f')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assert_qualname"
        ],
        [
            "LOAD_GLOBAL",
            "C"
        ],
        [
            "LOAD_ATTR",
            "C.D"
        ],
        [
            "LOAD_ATTR",
            "C.D.g"
        ],
        [
            "CALL",
            "self.assert_qualname(C.D.g, 'C.D.g')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assert_qualname"
        ],
        [
            "LOAD_GLOBAL",
            "f"
        ],
        [
            "CALL",
            "self.assert_qualname(f, 'f')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assert_qualname"
        ],
        [
            "LOAD_GLOBAL",
            "f"
        ],
        [
            "CALL",
            "f()"
        ],
        [
            "CALL",
            "self.assert_qualname(f(), 'f.<locals>.g')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assert_qualname"
        ],
        [
            "LOAD_GLOBAL",
            "C"
        ],
        [
            "LOAD_ATTR",
            "C.D"
        ],
        [
            "LOAD_METHOD",
            "C.D.h"
        ],
        [
            "CALL",
            "C.D.h()"
        ],
        [
            "CALL",
            "self.assert_qualname(C.D.h(), 'C.D.h.<locals>.i.<locals>.j')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assert_qualname"
        ],
        [
            "LOAD_GLOBAL",
            "lamb"
        ],
        [
            "CALL",
            "self.assert_qualname(lamb, '<lambda>')"
        ],
        [
            "LOAD_GLOBAL",
            "lambda_maker"
        ],
        [
            "CALL",
            "lambda_maker()"
        ],
        [
            "STORE_FAST",
            "foo"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assert_qualname"
        ],
        [
            "LOAD_FAST",
            "foo"
        ],
        [
            "CALL",
            "self.assert_qualname(foo, 'lambda_maker.<locals>.foo')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assert_qualname"
        ],
        [
            "LOAD_FAST",
            "foo"
        ],
        [
            "LOAD_ATTR",
            "foo.x"
        ],
        [
            "CALL",
            "self.assert_qualname(foo.x, 'lambda_maker.<locals>.<lambda>')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assert_qualname"
        ],
        [
            "LOAD_FAST",
            "foo"
        ],
        [
            "CALL",
            "foo()"
        ],
        [
            "CALL",
            "self.assert_qualname(foo(), 'lambda_maker.<locals>.foo.<locals>.<lambda>')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assert_qualname"
        ],
        [
            "LOAD_FAST",
            "foo"
        ],
        [
            "CALL",
            "foo()"
        ],
        [
            "CALL",
            "foo()()"
        ],
        [
            "CALL",
            "self.assert_qualname(foo()(), 'lambda_maker.<locals>.foo.<locals>.<lambda>', check_actual_qualname=False)"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_GLOBAL",
            "range"
        ],
        [
            "CALL",
            "range(66000)"
        ],
        [
            "CALL",
            "list(range(66000))"
        ],
        [
            "BINARY_OP",
            "'tester(6)\\n%s\\ntester(9)' % list(range(66000))"
        ],
        [
            "STORE_FAST",
            "source"
        ],
        [
            "LOAD_GLOBAL",
            "tempfile"
        ],
        [
            "LOAD_ATTR",
            "tempfile.mkstemp"
        ],
        [
            "CALL",
            "tempfile.mkstemp()"
        ],
        [
            "STORE_FAST",
            "_"
        ],
        [
            "STORE_FAST",
            "filename"
        ],
        [
            "LOAD_GLOBAL",
            "compile"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "CALL",
            "compile(source, filename, 'exec')"
        ],
        [
            "STORE_FAST",
            "code"
        ],
        [
            "LOAD_GLOBAL",
            "open"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "CALL",
            "open(filename, 'w')"
        ],
        [
            "STORE_FAST",
            "outfile"
        ],
        [
            "LOAD_FAST",
            "outfile"
        ],
        [
            "LOAD_METHOD",
            "outfile.write"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CALL",
            "outfile.write(source)"
        ],
        [
            "CALL",
            "        with open(filename, 'w') as outfile:\n            outfile.write(source)"
        ],
        [
            "LOAD_GLOBAL",
            "exec"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "CALL",
            "exec(code)"
        ],
        [
            "LOAD_GLOBAL",
            "range"
        ],
        [
            "CALL",
            "range(5)"
        ],
        [
            "STORE_FAST",
            "n"
        ],
        [
            "LOAD_GLOBAL",
            "range"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "CALL",
            "range(n)"
        ],
        [
            "CALL",
            "(i for i in range(n))"
        ],
        [
            "STORE_FAST",
            "gen"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "COMPARE_OP",
            "n == 1"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertEqual"
        ],
        [
            "LOAD_GLOBAL",
            "only"
        ],
        [
            "LOAD_FAST",
            "gen"
        ],
        [
            "CALL",
            "only(gen)"
        ],
        [
            "CALL",
            "self.assertEqual(only(gen), 0)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertRaises"
        ],
        [
            "LOAD_GLOBAL",
            "NotOneValueFound"
        ],
        [
            "CALL",
            "self.assertRaises(NotOneValueFound)"
        ],
        [
            "LOAD_GLOBAL",
            "only"
        ],
        [
            "LOAD_FAST",
            "gen"
        ],
        [
            "CALL",
            "only(gen)"
        ],
        [
            "CALL",
            "                with self.assertRaises(NotOneValueFound):\n                    only(gen)"
        ],
        [
            "LOAD_FAST",
            "(i for i in range(n))"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "LOAD_GLOBAL",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.join"
        ],
        [
            "LOAD_GLOBAL",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.dirname"
        ],
        [
            "LOAD_GLOBAL",
            "__file__"
        ],
        [
            "CALL",
            "os.path.dirname(__file__)"
        ],
        [
            "CALL",
            "os.path.join(os.path.dirname(__file__), 'not_code.txt', )"
        ],
        [
            "STORE_FAST",
            "path"
        ],
        [
            "LOAD_GLOBAL",
            "Source"
        ],
        [
            "LOAD_ATTR",
            "Source.for_filename"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "CALL",
            "Source.for_filename(path)"
        ],
        [
            "STORE_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertIsNone"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_ATTR",
            "source.tree"
        ],
        [
            "CALL",
            "self.assertIsNone(source.tree)"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.currentframe"
        ],
        [
            "CALL",
            "inspect.currentframe()"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_GLOBAL",
            "Source"
        ],
        [
            "LOAD_ATTR",
            "Source.executing"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "Source.executing(frame)"
        ],
        [
            "STORE_FAST",
            "executing"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertEqual"
        ],
        [
            "LOAD_FAST",
            "executing"
        ],
        [
            "LOAD_METHOD",
            "executing.code_qualname"
        ],
        [
            "CALL",
            "executing.code_qualname()"
        ],
        [
            "CALL",
            "self.assertEqual(executing.code_qualname(), 'TestStuff.test_executing_methods')"
        ],
        [
            "LOAD_GLOBAL",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.version"
        ],
        [
            "LOAD_METHOD",
            "sys.version.lower"
        ],
        [
            "CALL",
            "sys.version.lower()"
        ],
        [
            "CONTAINS_OP",
            "'pypy' not in sys.version.lower()"
        ],
        [
            "STORE_FAST",
            "text"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertEqual"
        ],
        [
            "LOAD_FAST",
            "executing"
        ],
        [
            "LOAD_METHOD",
            "executing.text"
        ],
        [
            "CALL",
            "executing.text()"
        ],
        [
            "LOAD_FAST",
            "text"
        ],
        [
            "CALL",
            "self.assertEqual(executing.text(), text)"
        ],
        [
            "LOAD_FAST",
            "executing"
        ],
        [
            "LOAD_METHOD",
            "executing.text_range"
        ],
        [
            "CALL",
            "executing.text_range()"
        ],
        [
            "STORE_FAST",
            "start"
        ],
        [
            "STORE_FAST",
            "end"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.assertEqual"
        ],
        [
            "LOAD_FAST",
            "executing"
        ],
        [
            "LOAD_ATTR",
            "executing.source"
        ],
        [
            "LOAD_ATTR",
            "executing.source.text"
        ],
        [
            "LOAD_FAST",
            "start"
        ],
        [
            "LOAD_FAST",
            "end"
        ],
        [
            "BINARY_SUBSCR",
            "executing.source.text[start:end]"
        ],
        [
            "LOAD_FAST",
            "text"
        ],
        [
            "CALL",
            "self.assertEqual(executing.source.text[start:end], text)"
        ],
        [
            "LOAD_GLOBAL",
            "C"
        ],
        [
            "CALL",
            "C()"
        ],
        [
            "STORE_FAST",
            "c"
        ],
        [
            "LOAD_GLOBAL",
            "tester"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "STORE_ATTR",
            "c.x"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "STORE_ATTR",
            "c.y"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_ATTR",
            "c.x"
        ],
        [
            "LOAD_ATTR",
            "c.x.x"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_ATTR",
            "c.x"
        ],
        [
            "LOAD_ATTR",
            "c.x.y"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_ATTR",
            "c.y"
        ],
        [
            "LOAD_ATTR",
            "c.y.x"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_ATTR",
            "c.y"
        ],
        [
            "LOAD_ATTR",
            "c.y.y"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_ATTR",
            "c.x"
        ],
        [
            "LOAD_ATTR",
            "c.x.asd"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_ATTR",
            "c.y"
        ],
        [
            "LOAD_ATTR",
            "c.y.qwe"
        ],
        [
            "CALL",
            "str((c.x.x, c.x.y, c.y.x, c.y.y, c.x.asd, c.y.qwe))"
        ],
        [
            "STORE_NAME",
            "    def test_file(self):\n        source = Source.for_frame(inspect.currentframe())\n        code = compile(source.text, source.filename, 'exec')\n        instructions = get_instructions(code)\n        lineno = None\n        for inst in instructions:\n            if inst.starts_line is not None:\n                lineno = inst.starts_line\n            if not inst.opname.startswith(\n                    ('BINARY_', 'UNARY_', 'LOAD_ATTR', 'LOAD_METHOD', 'LOOKUP_METHOD', 'COMPARE_OP')):\n                continue\n            frame = C()\n            frame.f_lasti = inst.offset\n            frame.f_code = code\n            frame.f_globals = globals()\n            frame.f_lineno = lineno\n            print(inst.opname)\n            assert Source.executing(frame).node is not None"
        ],
        [
            "LOAD_GLOBAL",
            "Source"
        ],
        [
            "LOAD_ATTR",
            "Source.for_frame"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.currentframe"
        ],
        [
            "CALL",
            "inspect.currentframe()"
        ],
        [
            "CALL",
            "Source.for_frame(inspect.currentframe())"
        ],
        [
            "STORE_FAST",
            "source"
        ],
        [
            "LOAD_GLOBAL",
            "compile"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_ATTR",
            "source.text"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_ATTR",
            "source.filename"
        ],
        [
            "CALL",
            "compile(source.text, source.filename, 'exec')"
        ],
        [
            "STORE_FAST",
            "code"
        ],
        [
            "LOAD_GLOBAL",
            "get_instructions"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "CALL",
            "get_instructions(code)"
        ],
        [
            "STORE_FAST",
            "instructions"
        ],
        [
            "STORE_FAST",
            "lineno"
        ],
        [
            "LOAD_FAST",
            "instructions"
        ],
        [
            "STORE_FAST",
            "inst"
        ],
        [
            "LOAD_FAST",
            "inst"
        ],
        [
            "LOAD_ATTR",
            "inst.starts_line"
        ],
        [
            "LOAD_FAST",
            "inst"
        ],
        [
            "LOAD_ATTR",
            "inst.starts_line"
        ],
        [
            "STORE_FAST",
            "lineno"
        ],
        [
            "LOAD_FAST",
            "inst"
        ],
        [
            "LOAD_ATTR",
            "inst.opname"
        ],
        [
            "LOAD_METHOD",
            "inst.opname.startswith"
        ],
        [
            "CALL",
            "inst.opname.startswith(\n                    ('BINARY_', 'UNARY_', 'LOAD_ATTR', 'LOAD_METHOD', 'LOOKUP_METHOD', 'COMPARE_OP'))"
        ],
        [
            "LOAD_GLOBAL",
            "C"
        ],
        [
            "CALL",
            "C()"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "inst"
        ],
        [
            "LOAD_ATTR",
            "inst.offset"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "STORE_ATTR",
            "frame.f_lasti"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "STORE_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_GLOBAL",
            "globals"
        ],
        [
            "CALL",
            "globals()"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "STORE_ATTR",
            "frame.f_globals"
        ],
        [
            "LOAD_FAST",
            "lineno"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "STORE_ATTR",
            "frame.f_lineno"
        ],
        [
            "LOAD_GLOBAL",
            "print"
        ],
        [
            "LOAD_FAST",
            "inst"
        ],
        [
            "LOAD_ATTR",
            "inst.opname"
        ],
        [
            "CALL",
            "print(inst.opname)"
        ],
        [
            "LOAD_GLOBAL",
            "Source"
        ],
        [
            "LOAD_ATTR",
            "Source.executing"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "Source.executing(frame)"
        ],
        [
            "LOAD_ATTR",
            "Source.executing(frame).node"
        ],
        [
            "LOAD_NAME",
            "staticmethod"
        ],
        [
            "CALL",
            "staticmethod"
        ],
        [
            "STORE_NAME",
            "    @staticmethod\n    def f():\n        pass"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "    class D(object):\n        @staticmethod\n        def g():\n            pass\n\n        @staticmethod\n        def h():\n            def i():\n                def j():\n                    pass\n\n                return j\n\n            return i()"
        ],
        [
            "STORE_NAME",
            "    class D(object):\n        @staticmethod\n        def g():\n            pass\n\n        @staticmethod\n        def h():\n            def i():\n                def j():\n                    pass\n\n                return j\n\n            return i()"
        ],
        [
            "LOAD_NAME",
            "staticmethod"
        ],
        [
            "CALL",
            "staticmethod"
        ],
        [
            "STORE_NAME",
            "        @staticmethod\n        def g():\n            pass"
        ],
        [
            "LOAD_NAME",
            "staticmethod"
        ],
        [
            "CALL",
            "staticmethod"
        ],
        [
            "STORE_NAME",
            "        @staticmethod\n        def h():\n            def i():\n                def j():\n                    pass\n\n                return j\n\n            return i()"
        ],
        [
            "STORE_FAST",
            "            def i():\n                def j():\n                    pass\n\n                return j"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "CALL",
            "i()"
        ],
        [
            "STORE_FAST",
            "                def j():\n                    pass"
        ],
        [
            "LOAD_FAST",
            "j"
        ],
        [
            "STORE_FAST",
            "    def g():\n        pass"
        ],
        [
            "LOAD_FAST",
            "g"
        ],
        [
            "STORE_FAST",
            "    def assign(x):\n        def decorator(func):\n            func.x = x\n            return func\n\n        return decorator"
        ],
        [
            "LOAD_FAST",
            "assign"
        ],
        [
            "CALL",
            "assign(lambda: 1)"
        ],
        [
            "CALL",
            "assign(lambda: 1)"
        ],
        [
            "STORE_FAST",
            "    @assign(lambda: 1)\n    def foo():\n        return lambda: lambda: 3"
        ],
        [
            "LOAD_FAST",
            "foo"
        ],
        [
            "STORE_FAST",
            "        def decorator(func):\n            func.x = x\n            return func"
        ],
        [
            "LOAD_FAST",
            "decorator"
        ],
        [
            "LOAD_DEREF",
            "x"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "STORE_ATTR",
            "func.x"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "STORE_NAME",
            "    def get_node(self, typ):\n        frame = inspect.currentframe().f_back.f_back\n        Source.lazycache(frame)\n        node = Source.executing(frame).node\n        assert isinstance(node, typ), (node, typ)\n        return node"
        ],
        [
            "STORE_NAME",
            "    def check(self, node, value):\n        frame = inspect.currentframe().f_back.f_back\n        result = eval(\n            compile(ast.Expression(node), frame.f_code.co_filename, 'eval'),\n            frame.f_globals,\n            frame.f_locals,\n        )\n        assert result == value, (result, value)"
        ],
        [
            "STORE_NAME",
            "    def __call__(self, arg, check_func=True, returns=None):\n        call = self.get_node(ast.Call)\n        self.check(call.args[0], arg)\n        if check_func:\n            self.check(call.func, self)\n        if returns is None:\n            return arg\n        return returns"
        ],
        [
            "STORE_NAME",
            "    def __getattr__(self, item):\n        node = self.get_node(ast.Attribute)\n        self.check(node.value, self)\n        assert node.attr == item\n        return self"
        ],
        [
            "STORE_NAME",
            "    def __getitem__(self, item):\n        node = self.get_node(ast.Subscript)\n        self.check(node.value, self)\n        self.check(node.slice.value, item)\n        return self"
        ],
        [
            "STORE_NAME",
            "    def __add__(self, other):\n        node = self.get_node(ast.BinOp)\n        self.check(node.left, self)\n        self.check(node.right, other)\n        return self"
        ],
        [
            "LOAD_NAME",
            "__add__"
        ],
        [
            "STORE_NAME",
            "__pow__"
        ],
        [
            "STORE_NAME",
            "__mul__"
        ],
        [
            "STORE_NAME",
            "__sub__"
        ],
        [
            "STORE_NAME",
            "    def __invert__(self):\n        node = self.get_node(ast.UnaryOp)\n        self.check(node.operand, self)\n        return self"
        ],
        [
            "LOAD_NAME",
            "__invert__"
        ],
        [
            "STORE_NAME",
            "__neg__"
        ],
        [
            "STORE_NAME",
            "__pos__"
        ],
        [
            "STORE_NAME",
            "    def __lt__(self, other):\n        node = self.get_node(ast.Compare)\n        self.check(node.left, self)\n        self.check(node.comparators[0], other)\n        return self"
        ],
        [
            "LOAD_NAME",
            "__lt__"
        ],
        [
            "STORE_NAME",
            "__ne__"
        ],
        [
            "STORE_NAME",
            "__ge__"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.currentframe"
        ],
        [
            "CALL",
            "inspect.currentframe()"
        ],
        [
            "LOAD_ATTR",
            "inspect.currentframe().f_back"
        ],
        [
            "LOAD_ATTR",
            "inspect.currentframe().f_back.f_back"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_GLOBAL",
            "Source"
        ],
        [
            "LOAD_ATTR",
            "Source.lazycache"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "Source.lazycache(frame)"
        ],
        [
            "LOAD_GLOBAL",
            "Source"
        ],
        [
            "LOAD_ATTR",
            "Source.executing"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "Source.executing(frame)"
        ],
        [
            "LOAD_ATTR",
            "Source.executing(frame).node"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "typ"
        ],
        [
            "CALL",
            "isinstance(node, typ)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "typ"
        ],
        [
            "CALL",
            "assert isinstance(node, typ), (node, typ)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.currentframe"
        ],
        [
            "CALL",
            "inspect.currentframe()"
        ],
        [
            "LOAD_ATTR",
            "inspect.currentframe().f_back"
        ],
        [
            "LOAD_ATTR",
            "inspect.currentframe().f_back.f_back"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_GLOBAL",
            "eval"
        ],
        [
            "LOAD_GLOBAL",
            "compile"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Expression"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "ast.Expression(node)"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_filename"
        ],
        [
            "CALL",
            "compile(ast.Expression(node), frame.f_code.co_filename, 'eval')"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_globals"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_locals"
        ],
        [
            "CALL",
            "eval(\n            compile(ast.Expression(node), frame.f_code.co_filename, 'eval'),\n            frame.f_globals,\n            frame.f_locals,\n        )"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "COMPARE_OP",
            "result == value"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "CALL",
            "assert result == value, (result, value)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.get_node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Call"
        ],
        [
            "CALL",
            "self.get_node(ast.Call)"
        ],
        [
            "STORE_FAST",
            "call"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_FAST",
            "call"
        ],
        [
            "LOAD_ATTR",
            "call.args"
        ],
        [
            "BINARY_SUBSCR",
            "call.args[0]"
        ],
        [
            "LOAD_FAST",
            "arg"
        ],
        [
            "CALL",
            "self.check(call.args[0], arg)"
        ],
        [
            "LOAD_FAST",
            "check_func"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_FAST",
            "call"
        ],
        [
            "LOAD_ATTR",
            "call.func"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "self.check(call.func, self)"
        ],
        [
            "LOAD_FAST",
            "returns"
        ],
        [
            "LOAD_FAST",
            "arg"
        ],
        [
            "LOAD_FAST",
            "returns"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.get_node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Attribute"
        ],
        [
            "CALL",
            "self.get_node(ast.Attribute)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.value"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "self.check(node.value, self)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.attr"
        ],
        [
            "LOAD_FAST",
            "item"
        ],
        [
            "COMPARE_OP",
            "node.attr == item"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.get_node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Subscript"
        ],
        [
            "CALL",
            "self.get_node(ast.Subscript)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.value"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "self.check(node.value, self)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.slice"
        ],
        [
            "LOAD_ATTR",
            "node.slice.value"
        ],
        [
            "LOAD_FAST",
            "item"
        ],
        [
            "CALL",
            "self.check(node.slice.value, item)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.get_node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.BinOp"
        ],
        [
            "CALL",
            "self.get_node(ast.BinOp)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.left"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "self.check(node.left, self)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.right"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "CALL",
            "self.check(node.right, other)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.get_node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.UnaryOp"
        ],
        [
            "CALL",
            "self.get_node(ast.UnaryOp)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.operand"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "self.check(node.operand, self)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.get_node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Compare"
        ],
        [
            "CALL",
            "self.get_node(ast.Compare)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.left"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "self.check(node.left, self)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.check"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.comparators"
        ],
        [
            "BINARY_SUBSCR",
            "node.comparators[0]"
        ],
        [
            "LOAD_FAST",
            "other"
        ],
        [
            "CALL",
            "self.check(node.comparators[0], other)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "LOAD_GLOBAL",
            "empty_decorator"
        ]
    ],
    "tracer.py": [
        [
            "STORE_NAME",
            "\"\"\"\nThis module provides the generic functionality of tracing code by\nmodifying its AST. Eventually this will become a separate package.\nThis is similar to the standard library module bdb, while birdseye\nitself would correspond to pdb.\nMost of the work is in TreeTracerBase.\n\"\"\""
        ],
        [
            "STORE_NAME",
            "from __future__ import print_function, division, absolute_import"
        ],
        [
            "STORE_NAME",
            "from __future__ import print_function, division, absolute_import"
        ],
        [
            "STORE_NAME",
            "from __future__ import print_function, division, absolute_import"
        ],
        [
            "STORE_NAME",
            "from future import standard_library"
        ],
        [
            "LOAD_NAME",
            "standard_library"
        ],
        [
            "LOAD_ATTR",
            "standard_library.install_aliases"
        ],
        [
            "CALL",
            "standard_library.install_aliases()"
        ],
        [
            "STORE_NAME",
            "import ast"
        ],
        [
            "STORE_NAME",
            "import inspect"
        ],
        [
            "STORE_NAME",
            "import sys"
        ],
        [
            "STORE_NAME",
            "from collections import namedtuple, defaultdict"
        ],
        [
            "STORE_NAME",
            "from collections import namedtuple, defaultdict"
        ],
        [
            "STORE_NAME",
            "from copy import deepcopy"
        ],
        [
            "STORE_NAME",
            "from functools import partial, update_wrapper, wraps"
        ],
        [
            "STORE_NAME",
            "from functools import partial, update_wrapper, wraps"
        ],
        [
            "STORE_NAME",
            "from functools import partial, update_wrapper, wraps"
        ],
        [
            "STORE_NAME",
            "from itertools import takewhile"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
        ],
        [
            "STORE_NAME",
            "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
        ],
        [
            "STORE_NAME",
            "from types import FrameType, TracebackType, CodeType, FunctionType"
        ],
        [
            "STORE_NAME",
            "from types import FrameType, TracebackType, CodeType, FunctionType"
        ],
        [
            "STORE_NAME",
            "from types import FrameType, TracebackType, CodeType, FunctionType"
        ],
        [
            "STORE_NAME",
            "from types import FrameType, TracebackType, CodeType, FunctionType"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import PY3, Type, is_lambda, lru_cache, read_source_file, is_ipython_cell, \\\n    is_future_import"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import PY3, Type, is_lambda, lru_cache, read_source_file, is_ipython_cell, \\\n    is_future_import"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import PY3, Type, is_lambda, lru_cache, read_source_file, is_ipython_cell, \\\n    is_future_import"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import PY3, Type, is_lambda, lru_cache, read_source_file, is_ipython_cell, \\\n    is_future_import"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import PY3, Type, is_lambda, lru_cache, read_source_file, is_ipython_cell, \\\n    is_future_import"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import PY3, Type, is_lambda, lru_cache, read_source_file, is_ipython_cell, \\\n    is_future_import"
        ],
        [
            "STORE_NAME",
            "from birdseye.utils import PY3, Type, is_lambda, lru_cache, read_source_file, is_ipython_cell, \\\n    is_future_import"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class TracedFile(object):\n    \"\"\"\n    An instance of this class corresponds to a single .py file.\n    It contains some useful data in the following attributes:\n\n    - filename: name of the source file\n    - source: textual contents of the file\n    - root: root of the original Abstract Syntax Tree (AST) of the source,\n            where the nodes of this tree have an additional handy attribute:\n            - parent: parent of the node, so this node is a child node of its parent\n    - tracer: instance of TreeTracerBase\n    - code: executable code object compiled from the modified AST\n    \"\"\"\n\n    is_ipython_cell = False\n\n    def __init__(self, tracer, source, filename, flags):\n        # type: (TreeTracerBase, str, str, int) -> None\n        # Here the source code is parsed, modified, and compiled\n        self.root = compile(source, filename, 'exec', ast.PyCF_ONLY_AST | flags, dont_inherit=True)  # type: ast.Module\n\n        self.nodes = []  # type: List[ast.AST]\n\n        self.set_basic_node_attributes()\n\n        new_root = tracer.parse_extra(self.root, source, filename)\n        if new_root is not None:\n            self.root = new_root\n\n        self.set_basic_node_attributes()\n        self.set_enter_call_nodes()\n\n        new_root = deepcopy(self.root)\n        new_root = _NodeVisitor().visit(new_root)\n\n        self.code = compile(new_root, filename, \"exec\", dont_inherit=True, flags=flags)  # type: CodeType\n        self.tracer = tracer\n        self.source = source\n        self.filename = filename\n\n    def set_basic_node_attributes(self):\n        self.nodes = []  # type: List[ast.AST]\n        for node in ast.walk(self.root):  # type: ast.AST\n            for child in ast.iter_child_nodes(node):\n                child.parent = node\n            node._tree_index = len(self.nodes)\n            self.nodes.append(node)\n\n        # Mark __future__ imports and anything before (i.e. module docstrings)\n        # to be ignored by the AST transformer\n        for i, stmt in enumerate(self.root.body):\n            if is_future_import(stmt):\n                for s in self.root.body[:i + 1]:\n                    for node in ast.walk(s):\n                        node._visit_ignore = True\n\n    def set_enter_call_nodes(self):\n        for node in self.nodes:\n            if isinstance(node, (ast.Module, ast.FunctionDef)):\n                for stmt in node.body:\n                    if not is_future_import(stmt):\n                        stmt._enter_call_node = True\n                        break"
        ],
        [
            "STORE_NAME",
            "class TracedFile(object):\n    \"\"\"\n    An instance of this class corresponds to a single .py file.\n    It contains some useful data in the following attributes:\n\n    - filename: name of the source file\n    - source: textual contents of the file\n    - root: root of the original Abstract Syntax Tree (AST) of the source,\n            where the nodes of this tree have an additional handy attribute:\n            - parent: parent of the node, so this node is a child node of its parent\n    - tracer: instance of TreeTracerBase\n    - code: executable code object compiled from the modified AST\n    \"\"\"\n\n    is_ipython_cell = False\n\n    def __init__(self, tracer, source, filename, flags):\n        # type: (TreeTracerBase, str, str, int) -> None\n        # Here the source code is parsed, modified, and compiled\n        self.root = compile(source, filename, 'exec', ast.PyCF_ONLY_AST | flags, dont_inherit=True)  # type: ast.Module\n\n        self.nodes = []  # type: List[ast.AST]\n\n        self.set_basic_node_attributes()\n\n        new_root = tracer.parse_extra(self.root, source, filename)\n        if new_root is not None:\n            self.root = new_root\n\n        self.set_basic_node_attributes()\n        self.set_enter_call_nodes()\n\n        new_root = deepcopy(self.root)\n        new_root = _NodeVisitor().visit(new_root)\n\n        self.code = compile(new_root, filename, \"exec\", dont_inherit=True, flags=flags)  # type: CodeType\n        self.tracer = tracer\n        self.source = source\n        self.filename = filename\n\n    def set_basic_node_attributes(self):\n        self.nodes = []  # type: List[ast.AST]\n        for node in ast.walk(self.root):  # type: ast.AST\n            for child in ast.iter_child_nodes(node):\n                child.parent = node\n            node._tree_index = len(self.nodes)\n            self.nodes.append(node)\n\n        # Mark __future__ imports and anything before (i.e. module docstrings)\n        # to be ignored by the AST transformer\n        for i, stmt in enumerate(self.root.body):\n            if is_future_import(stmt):\n                for s in self.root.body[:i + 1]:\n                    for node in ast.walk(s):\n                        node._visit_ignore = True\n\n    def set_enter_call_nodes(self):\n        for node in self.nodes:\n            if isinstance(node, (ast.Module, ast.FunctionDef)):\n                for stmt in node.body:\n                    if not is_future_import(stmt):\n                        stmt._enter_call_node = True\n                        break"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class FrameInfo(object):\n    \"\"\"\n    Contains extra data about an execution frame.\n    Can be obtained from the stack attribute of a TreeTracerBase instance\n    \"\"\"\n    def __init__(self):\n        # Stack of statements currently being executed\n        self.statement_stack = []  # type: List[ast.stmt]\n\n        # Stack of expression nodes within the above statement that\n        # the interpreter is planning on evaluating, or has just evaluated\n        # in the case of the last element of the list. For example, given\n        # the expression f(g(x)), the stack would be [f, g, x] before and just\n        # after evaluating x, since function arguments are evaluated before the\n        # actual function call.\n        self.expression_stack = []  # type: List[ast.expr]\n\n        # Mapping from the expression node to its most recent value\n        # in the corresponding frame\n        self.expression_values = {}  # type: Dict[ast.expr, Any]\n\n        # Node where the frame has explicitly returned\n        # There may be parent nodes such as enclosing loops that still need to finish executing\n        self.return_node = None  # type: Optional[ast.Return]\n\n        # Most recent exception raised in the frame\n        self.exc_value = None"
        ],
        [
            "STORE_NAME",
            "class FrameInfo(object):\n    \"\"\"\n    Contains extra data about an execution frame.\n    Can be obtained from the stack attribute of a TreeTracerBase instance\n    \"\"\"\n    def __init__(self):\n        # Stack of statements currently being executed\n        self.statement_stack = []  # type: List[ast.stmt]\n\n        # Stack of expression nodes within the above statement that\n        # the interpreter is planning on evaluating, or has just evaluated\n        # in the case of the last element of the list. For example, given\n        # the expression f(g(x)), the stack would be [f, g, x] before and just\n        # after evaluating x, since function arguments are evaluated before the\n        # actual function call.\n        self.expression_stack = []  # type: List[ast.expr]\n\n        # Mapping from the expression node to its most recent value\n        # in the corresponding frame\n        self.expression_values = {}  # type: Dict[ast.expr, Any]\n\n        # Node where the frame has explicitly returned\n        # There may be parent nodes such as enclosing loops that still need to finish executing\n        self.return_node = None  # type: Optional[ast.Return]\n\n        # Most recent exception raised in the frame\n        self.exc_value = None"
        ],
        [
            "LOAD_NAME",
            "NamedTuple"
        ],
        [
            "LOAD_NAME",
            "Optional"
        ],
        [
            "LOAD_NAME",
            "Union"
        ],
        [
            "LOAD_NAME",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.expr"
        ],
        [
            "LOAD_NAME",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.stmt"
        ],
        [
            "BINARY_SUBSCR",
            "Union[ast.expr, ast.stmt]"
        ],
        [
            "BINARY_SUBSCR",
            "Optional[Union[ast.expr, ast.stmt]]"
        ],
        [
            "LOAD_NAME",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.AST"
        ],
        [
            "LOAD_NAME",
            "FrameType"
        ],
        [
            "LOAD_NAME",
            "FrameType"
        ],
        [
            "CALL",
            "NamedTuple('EnterCallInfo', [\n\n    # Node  from where the call was made\n    ('call_node', Optional[Union[ast.expr, ast.stmt]]),\n\n    # Node where the call begins\n    ('enter_node', ast.AST),\n\n    # Frame from which the call was made\n    ('caller_frame', FrameType),\n\n    # Frame of the call\n    ('current_frame', FrameType)])"
        ],
        [
            "STORE_NAME",
            "EnterCallInfo"
        ],
        [
            "LOAD_NAME",
            "NamedTuple"
        ],
        [
            "LOAD_NAME",
            "Optional"
        ],
        [
            "LOAD_NAME",
            "Union"
        ],
        [
            "LOAD_NAME",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.expr"
        ],
        [
            "LOAD_NAME",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.stmt"
        ],
        [
            "BINARY_SUBSCR",
            "Union[ast.expr, ast.stmt]"
        ],
        [
            "BINARY_SUBSCR",
            "Optional[Union[ast.expr, ast.stmt]]"
        ],
        [
            "LOAD_NAME",
            "Optional"
        ],
        [
            "LOAD_NAME",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Return"
        ],
        [
            "BINARY_SUBSCR",
            "Optional[ast.Return]"
        ],
        [
            "LOAD_NAME",
            "FrameType"
        ],
        [
            "LOAD_NAME",
            "FrameType"
        ],
        [
            "LOAD_NAME",
            "Any"
        ],
        [
            "LOAD_NAME",
            "Optional"
        ],
        [
            "LOAD_NAME",
            "Exception"
        ],
        [
            "BINARY_SUBSCR",
            "Optional[Exception]"
        ],
        [
            "LOAD_NAME",
            "Optional"
        ],
        [
            "LOAD_NAME",
            "TracebackType"
        ],
        [
            "BINARY_SUBSCR",
            "Optional[TracebackType]"
        ],
        [
            "CALL",
            "NamedTuple('ExitCallInfo', [\n\n    # Node  from where the call was made\n    ('call_node', Optional[Union[ast.expr, ast.stmt]]),\n\n    # Node where the call explicitly returned\n    ('return_node', Optional[ast.Return]),\n\n    # Frame from which the call was made\n    ('caller_frame', FrameType),\n\n    # Frame of the call\n    ('current_frame', FrameType),\n\n    # Node where the call explicitly returned\n    ('return_value', Any),\n\n    # Exception raised in the call causing it to end,\n    # will propagate to the caller\n    ('exc_value', Optional[Exception]),\n\n    # Traceback corresponding to exc_value\n    ('exc_tb', Optional[TracebackType])])"
        ],
        [
            "STORE_NAME",
            "ExitCallInfo"
        ],
        [
            "LOAD_NAME",
            "namedtuple"
        ],
        [
            "CALL",
            "namedtuple('ChangeValue', 'value')"
        ],
        [
            "STORE_NAME",
            "ChangeValue"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class TreeTracerBase(object):\n    \"\"\"\n    Create a subclass of this class with one or more of the 'hooks'\n    (methods which are empty in this class) overridden to take a custom action\n    in the given situation. Then decorate functions with an instance of this class\n    to trace them.\n    \"\"\"\n\n    def __init__(self):\n        # Mapping from frames of execution being traced to FrameInfo objects\n        # for extra metadata.\n        self.stack = {}  # type: Dict[FrameType, FrameInfo]\n        self.main_to_secondary_frames = defaultdict(list)\n        self.secondary_to_main_frames = {}\n\n    @lru_cache()\n    def compile(self, source, filename, flags=0):\n        # type: (str, str, int) -> TracedFile\n        return TracedFile(self, source, filename, flags)\n\n    def _trace_methods_dict(self, traced_file):\n        # type: (TracedFile) -> Dict[str, Callable]\n        return {f.__name__: partial(f, traced_file)\n                for f in [\n                    self._treetrace_hidden_with_stmt,\n                    self._treetrace_hidden_before_expr,\n                    self._treetrace_hidden_after_expr,\n                ]}\n\n    def trace_function(self, func):\n        # type: (FunctionType) -> FunctionType\n        \"\"\"\n        Returns a version of the passed function with the AST modified to\n        trigger the tracing hooks.\n        \"\"\"\n        if not isinstance(func, FunctionType):\n            raise ValueError('You can only trace user-defined functions. '\n                             'The birdseye decorator must be applied first, '\n                             'at the bottom of the list.')\n\n        try:\n            if inspect.iscoroutinefunction(func) or inspect.isasyncgenfunction(func):\n                raise ValueError('You cannot trace async functions')\n        except AttributeError:\n            pass\n\n        if is_lambda(func):\n            raise ValueError('You cannot trace lambdas')\n\n        filename = inspect.getsourcefile(func)  # type: str\n\n        if is_ipython_cell(filename):\n            # noinspection PyPackageRequirements\n            from IPython import get_ipython\n            import linecache\n\n            flags = get_ipython().compile.flags\n            source = ''.join(linecache.cache[filename][2])\n        else:\n            source = read_source_file(filename)\n            flags = 0\n\n        # We compile the entire file instead of just the function source\n        # because it can contain context which affects the function code,\n        # e.g. enclosing functions and classes or __future__ imports\n        traced_file = self.compile(source, filename, flags)\n\n        if func.__dict__:\n            raise ValueError('The birdseye decorator must be applied first, '\n                             'at the bottom of the list.')\n\n        # Then we have to recursively search through the newly compiled\n        # code to find the code we actually want corresponding to this function\n        code_options = []  # type: List[CodeType]\n\n        def find_code(root_code):\n            # type: (CodeType) -> None\n            for const in root_code.co_consts:  # type: CodeType\n                if not inspect.iscode(const):\n                    continue\n                matches = (const.co_firstlineno == func.__code__.co_firstlineno and\n                           const.co_name == func.__code__.co_name)\n                if matches:\n                    code_options.append(const)\n                find_code(const)\n\n        find_code(traced_file.code)\n\n        if len(code_options) > 1:\n            # Currently lambdas aren't allowed anyway, but should be in the future\n            assert is_lambda(func)\n            raise ValueError(\"Failed to trace lambda. Convert the function to a def.\")\n        new_func_code = code_options[0]  # type: CodeType\n\n        # Give the new function access to the hooks\n        # We have to use the original __globals__ and not a copy\n        # because it's the actual module namespace that may get updated by other code\n        func.__globals__.update(self._trace_methods_dict(traced_file))\n\n        # http://stackoverflow.com/a/13503277/2482744\n        # noinspection PyArgumentList\n        new_func = FunctionType(new_func_code, func.__globals__, func.__name__, func.__defaults__, func.__closure__)\n        update_wrapper(new_func, func)  # type: FunctionType\n        if PY3:\n            new_func.__kwdefaults__ = getattr(func, '__kwdefaults__', None)\n        new_func.traced_file = traced_file\n        return new_func\n\n    def __call__(self, func=None, optional=False):\n        # type: (FunctionType, bool) -> Callable\n        \"\"\"\n        Decorator which returns a (possibly optionally) traced function.\n        This decorator can be called with or without arguments.\n        Typically it is called without arguments, in which case it returns\n        a traced function.\n        If optional=True, it returns a function similar to the original\n        but with an additional optional parameter trace_call, default False.\n        If trace_call is false, the underlying untraced function is used.\n        If true, the traced version is used.\n        \"\"\"\n        if inspect.isclass(func):\n            raise TypeError('Decorating classes is no longer supported')\n\n        if func:\n            # The decorator has been called without arguments/parentheses,\n            # e.g.\n            # @eye\n            # def ...\n            return self.trace_function(func)\n\n        # The decorator has been called with arguments/parentheses,\n        # e.g.\n        # @eye(...)\n        # def ...\n        # We must return a decorator\n\n        if not optional:\n            return self.trace_function\n\n        def decorator(actual_func):\n\n            traced = self.trace_function(actual_func)\n\n            @wraps(actual_func)\n            def wrapper(*args, **kwargs):\n                trace_call = kwargs.pop('trace_call', False)\n                if trace_call:\n                    f = traced\n                else:\n                    f = actual_func\n                return f(*args, **kwargs)\n\n            return wrapper\n\n        return decorator\n\n    def _main_frame(self, node):\n        # type: (ast.AST) -> Optional[FrameType]\n        frame = sys._getframe(2)\n        result = self.secondary_to_main_frames.get(frame)\n        if result:\n            return result\n\n        original_frame = frame\n\n        while frame.f_code.co_name in ('<listcomp>', '<dictcomp>', '<setcomp>'):\n            frame = frame.f_back\n\n        for node in ancestors(node):\n            if isinstance(node, (ast.FunctionDef, ast.Lambda)):\n                break\n\n            if isinstance(node, ast.ClassDef):\n                frame = frame.f_back\n\n        if frame.f_code.co_name in ('<lambda>', '<genexpr>'):\n            return None\n\n        self.secondary_to_main_frames[original_frame] = frame\n        self.main_to_secondary_frames[frame].append(original_frame)\n        return frame\n\n    def _treetrace_hidden_with_stmt(self, traced_file, _tree_index):\n        # type: (TracedFile, int) -> _StmtContext\n        \"\"\"\n        Called directly from the modified code.\n        Every statement in the original code becomes:\n\n        with _treetrace_hidden_with_stmt(...):\n            <statement>\n        \"\"\"\n        node = traced_file.nodes[_tree_index]\n        node = cast(ast.stmt, node)\n        frame = self._main_frame(node)\n        return _StmtContext(self, node, frame)\n\n    def _treetrace_hidden_before_expr(self, traced_file, _tree_index):\n        # type: (TracedFile, int) -> ast.expr\n        \"\"\"\n        Called directly from the modified code before an expression is\n        evaluated.\n        \"\"\"\n        node = traced_file.nodes[_tree_index]\n        node = cast(ast.expr, node)\n        frame = self._main_frame(node)\n        if frame is None:\n            return node\n\n        frame_info = self.stack[frame]\n        frame_info.expression_stack.append(node)\n\n        self.before_expr(node, frame)\n        return node\n\n    def _treetrace_hidden_after_expr(self, _, node, value):\n        # type: (TracedFile, ast.expr, Any) -> Any\n        \"\"\"\n        Called directly from the modified code after an expression is\n        evaluated.\n        \"\"\"\n        frame = self._main_frame(node)\n        if frame is None:\n            return value\n\n        result = self._after_expr(node, frame, value, None, None)\n        if result is not None:\n            assert isinstance(result, ChangeValue), \"after_expr must return None or an instance of ChangeValue\"\n            value = result.value\n        return value\n\n    def _after_expr(self, node, frame, value, exc_value, exc_tb):\n        frame_info = self.stack[frame]\n        frame_info.expression_stack.pop()\n        frame_info.expression_values[node] = value\n        return self.after_expr(node, frame, value, exc_value, exc_tb)\n\n    def _enter_call(self, enter_node, current_frame):\n        # type: (ast.AST, FrameType) -> None\n        caller_frame, call_node = self._get_caller_stuff(current_frame)\n        self.stack[current_frame] = FrameInfo()\n        self.enter_call(EnterCallInfo(call_node, enter_node, caller_frame, current_frame))\n\n    def _get_caller_stuff(self, frame):\n        # type: (FrameType) -> Tuple[FrameType, Optional[Union[ast.expr, ast.stmt]]]\n        caller_frame = frame.f_back\n        call_node = None\n        main_frame = self.secondary_to_main_frames.get(caller_frame)\n        if main_frame:\n            caller_frame = main_frame\n            frame_info = self.stack[caller_frame]\n            expression_stack = frame_info.expression_stack\n            if expression_stack:\n                call_node = expression_stack[-1]\n            else:\n                call_node = frame_info.statement_stack[-1]  # type: ignore\n        return caller_frame, call_node\n\n    # The methods below are hooks meant to be overridden in subclasses to take custom actions\n\n    def before_expr(self, node, frame):\n        # type: (ast.expr, FrameType) -> None\n        \"\"\"\n        Called right before the expression corresponding to `node` is evaluated\n        within `frame`.\n        \"\"\"\n\n    def after_expr(self, node, frame, value, exc_value, exc_tb):\n        # type: (ast.expr, FrameType, Any, Optional[BaseException], Optional[TracebackType]) -> Optional[ChangeValue]\n        \"\"\"\n        Called right after the expression corresponding to `node` is evaluated\n        within `frame`. `value` is the value of the expression, if it succeeded.\n        If the evaluation raised an exception, exc_value will be the exception object\n        and exc_tb the traceback.\n\n        Return `ChangeValue(x)` to change the value of the expression as\n        seen by the rest of the program from `value` to `x`.\n        \"\"\"\n\n    def before_stmt(self, node, frame):\n        # type: (ast.stmt, FrameType) -> None\n        \"\"\"\n        Called right before the statement corresponding to `node` is executed\n        within `frame`.\n        \"\"\"\n\n    def after_stmt(self, node, frame, exc_value, exc_traceback, exc_node):\n        # type: (ast.stmt, FrameType, Optional[BaseException], Optional[TracebackType], Optional[ast.AST]) -> Optional[bool]\n        \"\"\"\n        Called right after the statement corresponding to `node` is executed\n        within `frame`.\n        If the statement raised an exception, exc_value will be the exception object,\n        exc_tb the traceback, and exc_node the node where the exception was raised\n        (either this statement or an expression within).\n\n        Returning True will suppress any exception raised (as with __exit__ in general).\n        \"\"\"\n\n    def enter_call(self, enter_info):\n        # type: (EnterCallInfo) -> None\n        \"\"\"\n        Called before a function call begins executing. For typical `def` functions,\n        this is called before the `before_stmt` for to the first statement in the function.\n        \"\"\"\n\n    def exit_call(self, exit_info):\n        # type: (ExitCallInfo) -> None\n        \"\"\"\n        Called after a function call finishes executing. For typical `def` functions,\n        this is called after the `after_stmt` for to the last statement to execute.\n        \"\"\"\n\n    def parse_extra(self, root, source, filename):\n        # type: (ast.Module, str, str) -> Optional[ast.Module]\n        \"\"\"\n        Called before the AST (root) is modified to let subclasses make additional changes first.\n        \"\"\""
        ],
        [
            "STORE_NAME",
            "class TreeTracerBase(object):\n    \"\"\"\n    Create a subclass of this class with one or more of the 'hooks'\n    (methods which are empty in this class) overridden to take a custom action\n    in the given situation. Then decorate functions with an instance of this class\n    to trace them.\n    \"\"\"\n\n    def __init__(self):\n        # Mapping from frames of execution being traced to FrameInfo objects\n        # for extra metadata.\n        self.stack = {}  # type: Dict[FrameType, FrameInfo]\n        self.main_to_secondary_frames = defaultdict(list)\n        self.secondary_to_main_frames = {}\n\n    @lru_cache()\n    def compile(self, source, filename, flags=0):\n        # type: (str, str, int) -> TracedFile\n        return TracedFile(self, source, filename, flags)\n\n    def _trace_methods_dict(self, traced_file):\n        # type: (TracedFile) -> Dict[str, Callable]\n        return {f.__name__: partial(f, traced_file)\n                for f in [\n                    self._treetrace_hidden_with_stmt,\n                    self._treetrace_hidden_before_expr,\n                    self._treetrace_hidden_after_expr,\n                ]}\n\n    def trace_function(self, func):\n        # type: (FunctionType) -> FunctionType\n        \"\"\"\n        Returns a version of the passed function with the AST modified to\n        trigger the tracing hooks.\n        \"\"\"\n        if not isinstance(func, FunctionType):\n            raise ValueError('You can only trace user-defined functions. '\n                             'The birdseye decorator must be applied first, '\n                             'at the bottom of the list.')\n\n        try:\n            if inspect.iscoroutinefunction(func) or inspect.isasyncgenfunction(func):\n                raise ValueError('You cannot trace async functions')\n        except AttributeError:\n            pass\n\n        if is_lambda(func):\n            raise ValueError('You cannot trace lambdas')\n\n        filename = inspect.getsourcefile(func)  # type: str\n\n        if is_ipython_cell(filename):\n            # noinspection PyPackageRequirements\n            from IPython import get_ipython\n            import linecache\n\n            flags = get_ipython().compile.flags\n            source = ''.join(linecache.cache[filename][2])\n        else:\n            source = read_source_file(filename)\n            flags = 0\n\n        # We compile the entire file instead of just the function source\n        # because it can contain context which affects the function code,\n        # e.g. enclosing functions and classes or __future__ imports\n        traced_file = self.compile(source, filename, flags)\n\n        if func.__dict__:\n            raise ValueError('The birdseye decorator must be applied first, '\n                             'at the bottom of the list.')\n\n        # Then we have to recursively search through the newly compiled\n        # code to find the code we actually want corresponding to this function\n        code_options = []  # type: List[CodeType]\n\n        def find_code(root_code):\n            # type: (CodeType) -> None\n            for const in root_code.co_consts:  # type: CodeType\n                if not inspect.iscode(const):\n                    continue\n                matches = (const.co_firstlineno == func.__code__.co_firstlineno and\n                           const.co_name == func.__code__.co_name)\n                if matches:\n                    code_options.append(const)\n                find_code(const)\n\n        find_code(traced_file.code)\n\n        if len(code_options) > 1:\n            # Currently lambdas aren't allowed anyway, but should be in the future\n            assert is_lambda(func)\n            raise ValueError(\"Failed to trace lambda. Convert the function to a def.\")\n        new_func_code = code_options[0]  # type: CodeType\n\n        # Give the new function access to the hooks\n        # We have to use the original __globals__ and not a copy\n        # because it's the actual module namespace that may get updated by other code\n        func.__globals__.update(self._trace_methods_dict(traced_file))\n\n        # http://stackoverflow.com/a/13503277/2482744\n        # noinspection PyArgumentList\n        new_func = FunctionType(new_func_code, func.__globals__, func.__name__, func.__defaults__, func.__closure__)\n        update_wrapper(new_func, func)  # type: FunctionType\n        if PY3:\n            new_func.__kwdefaults__ = getattr(func, '__kwdefaults__', None)\n        new_func.traced_file = traced_file\n        return new_func\n\n    def __call__(self, func=None, optional=False):\n        # type: (FunctionType, bool) -> Callable\n        \"\"\"\n        Decorator which returns a (possibly optionally) traced function.\n        This decorator can be called with or without arguments.\n        Typically it is called without arguments, in which case it returns\n        a traced function.\n        If optional=True, it returns a function similar to the original\n        but with an additional optional parameter trace_call, default False.\n        If trace_call is false, the underlying untraced function is used.\n        If true, the traced version is used.\n        \"\"\"\n        if inspect.isclass(func):\n            raise TypeError('Decorating classes is no longer supported')\n\n        if func:\n            # The decorator has been called without arguments/parentheses,\n            # e.g.\n            # @eye\n            # def ...\n            return self.trace_function(func)\n\n        # The decorator has been called with arguments/parentheses,\n        # e.g.\n        # @eye(...)\n        # def ...\n        # We must return a decorator\n\n        if not optional:\n            return self.trace_function\n\n        def decorator(actual_func):\n\n            traced = self.trace_function(actual_func)\n\n            @wraps(actual_func)\n            def wrapper(*args, **kwargs):\n                trace_call = kwargs.pop('trace_call', False)\n                if trace_call:\n                    f = traced\n                else:\n                    f = actual_func\n                return f(*args, **kwargs)\n\n            return wrapper\n\n        return decorator\n\n    def _main_frame(self, node):\n        # type: (ast.AST) -> Optional[FrameType]\n        frame = sys._getframe(2)\n        result = self.secondary_to_main_frames.get(frame)\n        if result:\n            return result\n\n        original_frame = frame\n\n        while frame.f_code.co_name in ('<listcomp>', '<dictcomp>', '<setcomp>'):\n            frame = frame.f_back\n\n        for node in ancestors(node):\n            if isinstance(node, (ast.FunctionDef, ast.Lambda)):\n                break\n\n            if isinstance(node, ast.ClassDef):\n                frame = frame.f_back\n\n        if frame.f_code.co_name in ('<lambda>', '<genexpr>'):\n            return None\n\n        self.secondary_to_main_frames[original_frame] = frame\n        self.main_to_secondary_frames[frame].append(original_frame)\n        return frame\n\n    def _treetrace_hidden_with_stmt(self, traced_file, _tree_index):\n        # type: (TracedFile, int) -> _StmtContext\n        \"\"\"\n        Called directly from the modified code.\n        Every statement in the original code becomes:\n\n        with _treetrace_hidden_with_stmt(...):\n            <statement>\n        \"\"\"\n        node = traced_file.nodes[_tree_index]\n        node = cast(ast.stmt, node)\n        frame = self._main_frame(node)\n        return _StmtContext(self, node, frame)\n\n    def _treetrace_hidden_before_expr(self, traced_file, _tree_index):\n        # type: (TracedFile, int) -> ast.expr\n        \"\"\"\n        Called directly from the modified code before an expression is\n        evaluated.\n        \"\"\"\n        node = traced_file.nodes[_tree_index]\n        node = cast(ast.expr, node)\n        frame = self._main_frame(node)\n        if frame is None:\n            return node\n\n        frame_info = self.stack[frame]\n        frame_info.expression_stack.append(node)\n\n        self.before_expr(node, frame)\n        return node\n\n    def _treetrace_hidden_after_expr(self, _, node, value):\n        # type: (TracedFile, ast.expr, Any) -> Any\n        \"\"\"\n        Called directly from the modified code after an expression is\n        evaluated.\n        \"\"\"\n        frame = self._main_frame(node)\n        if frame is None:\n            return value\n\n        result = self._after_expr(node, frame, value, None, None)\n        if result is not None:\n            assert isinstance(result, ChangeValue), \"after_expr must return None or an instance of ChangeValue\"\n            value = result.value\n        return value\n\n    def _after_expr(self, node, frame, value, exc_value, exc_tb):\n        frame_info = self.stack[frame]\n        frame_info.expression_stack.pop()\n        frame_info.expression_values[node] = value\n        return self.after_expr(node, frame, value, exc_value, exc_tb)\n\n    def _enter_call(self, enter_node, current_frame):\n        # type: (ast.AST, FrameType) -> None\n        caller_frame, call_node = self._get_caller_stuff(current_frame)\n        self.stack[current_frame] = FrameInfo()\n        self.enter_call(EnterCallInfo(call_node, enter_node, caller_frame, current_frame))\n\n    def _get_caller_stuff(self, frame):\n        # type: (FrameType) -> Tuple[FrameType, Optional[Union[ast.expr, ast.stmt]]]\n        caller_frame = frame.f_back\n        call_node = None\n        main_frame = self.secondary_to_main_frames.get(caller_frame)\n        if main_frame:\n            caller_frame = main_frame\n            frame_info = self.stack[caller_frame]\n            expression_stack = frame_info.expression_stack\n            if expression_stack:\n                call_node = expression_stack[-1]\n            else:\n                call_node = frame_info.statement_stack[-1]  # type: ignore\n        return caller_frame, call_node\n\n    # The methods below are hooks meant to be overridden in subclasses to take custom actions\n\n    def before_expr(self, node, frame):\n        # type: (ast.expr, FrameType) -> None\n        \"\"\"\n        Called right before the expression corresponding to `node` is evaluated\n        within `frame`.\n        \"\"\"\n\n    def after_expr(self, node, frame, value, exc_value, exc_tb):\n        # type: (ast.expr, FrameType, Any, Optional[BaseException], Optional[TracebackType]) -> Optional[ChangeValue]\n        \"\"\"\n        Called right after the expression corresponding to `node` is evaluated\n        within `frame`. `value` is the value of the expression, if it succeeded.\n        If the evaluation raised an exception, exc_value will be the exception object\n        and exc_tb the traceback.\n\n        Return `ChangeValue(x)` to change the value of the expression as\n        seen by the rest of the program from `value` to `x`.\n        \"\"\"\n\n    def before_stmt(self, node, frame):\n        # type: (ast.stmt, FrameType) -> None\n        \"\"\"\n        Called right before the statement corresponding to `node` is executed\n        within `frame`.\n        \"\"\"\n\n    def after_stmt(self, node, frame, exc_value, exc_traceback, exc_node):\n        # type: (ast.stmt, FrameType, Optional[BaseException], Optional[TracebackType], Optional[ast.AST]) -> Optional[bool]\n        \"\"\"\n        Called right after the statement corresponding to `node` is executed\n        within `frame`.\n        If the statement raised an exception, exc_value will be the exception object,\n        exc_tb the traceback, and exc_node the node where the exception was raised\n        (either this statement or an expression within).\n\n        Returning True will suppress any exception raised (as with __exit__ in general).\n        \"\"\"\n\n    def enter_call(self, enter_info):\n        # type: (EnterCallInfo) -> None\n        \"\"\"\n        Called before a function call begins executing. For typical `def` functions,\n        this is called before the `before_stmt` for to the first statement in the function.\n        \"\"\"\n\n    def exit_call(self, exit_info):\n        # type: (ExitCallInfo) -> None\n        \"\"\"\n        Called after a function call finishes executing. For typical `def` functions,\n        this is called after the `after_stmt` for to the last statement to execute.\n        \"\"\"\n\n    def parse_extra(self, root, source, filename):\n        # type: (ast.Module, str, str) -> Optional[ast.Module]\n        \"\"\"\n        Called before the AST (root) is modified to let subclasses make additional changes first.\n        \"\"\""
        ],
        [
            "LOAD_NAME",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.NodeTransformer"
        ],
        [
            "CALL",
            "class _NodeVisitor(ast.NodeTransformer):\n    \"\"\"\n    This does the AST modifications that call the hooks.\n    \"\"\"\n\n    def generic_visit(self, node):\n        # type: (ast.AST) -> ast.AST\n        if not getattr(node, '_visit_ignore', False):\n            if (isinstance(node, ast.expr) and\n                    not (hasattr(node, \"ctx\") and not isinstance(node.ctx, ast.Load)) and\n                    not isinstance(node, getattr(ast, 'Starred', ()))):\n                return self.visit_expr(node)\n            if isinstance(node, ast.stmt):\n                return self.visit_stmt(node)\n        return super(_NodeVisitor, self).generic_visit(node)\n\n    def visit_expr(self, node):\n        # type: (ast.expr) -> ast.Call\n        \"\"\"\n        each expression e gets wrapped like this:\n            _treetrace_hidden_after_expr(_treetrace_hidden_before_expr(_tree_index), e)\n\n        where the _treetrace_* functions are the corresponding methods with the\n        TreeTracerBase and traced_file arguments already filled in (see _trace_methods_dict)\n        \"\"\"\n\n        before_marker = self._create_simple_marker_call(node, TreeTracerBase._treetrace_hidden_before_expr)\n        ast.copy_location(before_marker, node)\n\n        after_marker = ast.Call(\n            func=ast.Name(id=TreeTracerBase._treetrace_hidden_after_expr.__name__,\n                          ctx=ast.Load()),\n            args=[\n                before_marker,\n                super(_NodeVisitor, self).generic_visit(node),\n            ],\n            keywords=[],\n        )\n        ast.copy_location(after_marker, node)\n        ast.fix_missing_locations(after_marker)\n\n        return after_marker\n\n    def visit_stmt(self, node):\n        # type: (ast.stmt) -> ast.With\n        \"\"\"\n        Every statement in the original code becomes:\n\n        with _treetrace_hidden_with_stmt(_tree_index):\n            <statement>\n\n        where the _treetrace_hidden_with_stmt function is the the corresponding method with the\n        TreeTracerBase and traced_file arguments already filled in (see _trace_methods_dict)\n        \"\"\"\n        context_expr = self._create_simple_marker_call(\n            super(_NodeVisitor, self).generic_visit(node),\n            TreeTracerBase._treetrace_hidden_with_stmt)\n\n        if PY3:\n            wrapped = ast.With(\n                items=[ast.withitem(context_expr=context_expr)],\n                body=[node],\n            )\n        else:\n            wrapped = ast.With(\n                context_expr=context_expr,\n                body=[node],\n            )\n        ast.copy_location(wrapped, node)\n        ast.fix_missing_locations(wrapped)\n        return wrapped\n\n    @staticmethod\n    def _create_simple_marker_call(node, func):\n        # type: (ast.AST, Callable) -> ast.Call\n        \"\"\"\n        Returns a Call node representing `func(node._tree_index)`\n        where node._tree_index is a numerical literal which allows the node object\n        to be retrieved later through the nodes attribute of a TracedFile.\n        \"\"\"\n        return ast.Call(\n            func=ast.Name(id=func.__name__,\n                          ctx=ast.Load()),\n            args=[ast.Num(node._tree_index)],\n            keywords=[],\n        )"
        ],
        [
            "STORE_NAME",
            "class _NodeVisitor(ast.NodeTransformer):\n    \"\"\"\n    This does the AST modifications that call the hooks.\n    \"\"\"\n\n    def generic_visit(self, node):\n        # type: (ast.AST) -> ast.AST\n        if not getattr(node, '_visit_ignore', False):\n            if (isinstance(node, ast.expr) and\n                    not (hasattr(node, \"ctx\") and not isinstance(node.ctx, ast.Load)) and\n                    not isinstance(node, getattr(ast, 'Starred', ()))):\n                return self.visit_expr(node)\n            if isinstance(node, ast.stmt):\n                return self.visit_stmt(node)\n        return super(_NodeVisitor, self).generic_visit(node)\n\n    def visit_expr(self, node):\n        # type: (ast.expr) -> ast.Call\n        \"\"\"\n        each expression e gets wrapped like this:\n            _treetrace_hidden_after_expr(_treetrace_hidden_before_expr(_tree_index), e)\n\n        where the _treetrace_* functions are the corresponding methods with the\n        TreeTracerBase and traced_file arguments already filled in (see _trace_methods_dict)\n        \"\"\"\n\n        before_marker = self._create_simple_marker_call(node, TreeTracerBase._treetrace_hidden_before_expr)\n        ast.copy_location(before_marker, node)\n\n        after_marker = ast.Call(\n            func=ast.Name(id=TreeTracerBase._treetrace_hidden_after_expr.__name__,\n                          ctx=ast.Load()),\n            args=[\n                before_marker,\n                super(_NodeVisitor, self).generic_visit(node),\n            ],\n            keywords=[],\n        )\n        ast.copy_location(after_marker, node)\n        ast.fix_missing_locations(after_marker)\n\n        return after_marker\n\n    def visit_stmt(self, node):\n        # type: (ast.stmt) -> ast.With\n        \"\"\"\n        Every statement in the original code becomes:\n\n        with _treetrace_hidden_with_stmt(_tree_index):\n            <statement>\n\n        where the _treetrace_hidden_with_stmt function is the the corresponding method with the\n        TreeTracerBase and traced_file arguments already filled in (see _trace_methods_dict)\n        \"\"\"\n        context_expr = self._create_simple_marker_call(\n            super(_NodeVisitor, self).generic_visit(node),\n            TreeTracerBase._treetrace_hidden_with_stmt)\n\n        if PY3:\n            wrapped = ast.With(\n                items=[ast.withitem(context_expr=context_expr)],\n                body=[node],\n            )\n        else:\n            wrapped = ast.With(\n                context_expr=context_expr,\n                body=[node],\n            )\n        ast.copy_location(wrapped, node)\n        ast.fix_missing_locations(wrapped)\n        return wrapped\n\n    @staticmethod\n    def _create_simple_marker_call(node, func):\n        # type: (ast.AST, Callable) -> ast.Call\n        \"\"\"\n        Returns a Call node representing `func(node._tree_index)`\n        where node._tree_index is a numerical literal which allows the node object\n        to be retrieved later through the nodes attribute of a TracedFile.\n        \"\"\"\n        return ast.Call(\n            func=ast.Name(id=func.__name__,\n                          ctx=ast.Load()),\n            args=[ast.Num(node._tree_index)],\n            keywords=[],\n        )"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class _StmtContext(object):\n    __slots__ = ('tracer', 'node', 'frame')\n\n    def __init__(self, tracer, node, frame):\n        # type: (TreeTracerBase, ast.stmt, FrameType) -> None\n        self.tracer = tracer\n        self.node = node\n        self.frame = frame\n\n    def __enter__(self):\n        tracer = self.tracer\n        node = self.node\n        frame = self.frame\n        if getattr(node, '_enter_call_node', False):\n            tracer._enter_call(node, frame)\n        frame_info = tracer.stack[frame]\n        frame_info.expression_stack = []\n        frame_info.statement_stack.append(node)\n        tracer.before_stmt(node, frame)\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        # type: (Type[Exception], Exception, TracebackType) -> bool\n        node = self.node\n        tracer = self.tracer\n        frame = self.frame\n        frame_info = tracer.stack[frame]\n\n        frame_info.statement_stack.pop()\n\n        exc_node = None  # type: Optional[Union[ast.expr, ast.stmt]]\n        if exc_val and exc_val is not frame_info.exc_value:\n            exc_node = node\n            frame_info.exc_value = exc_val\n\n            # Call the after_expr hook if the exception was raised by an expression\n            expression_stack = frame_info.expression_stack\n            if expression_stack:\n                exc_node = expression_stack[-1]\n                tracer._after_expr(exc_node, frame, None, exc_val, exc_tb)\n\n        result = tracer.after_stmt(node, frame, exc_val, exc_tb, exc_node)\n\n        if isinstance(node, ast.Return):\n            frame_info.return_node = node\n\n        parent = node.parent  # type: ast.AST\n        return_node = frame_info.return_node\n        exiting = (isinstance(parent, (ast.FunctionDef, ast.Module)) and\n                   (node is parent.body[-1] or\n                    exc_val or\n                    return_node))\n        if exiting:\n            caller_frame, call_node = tracer._get_caller_stuff(frame)\n            return_value = None\n            if return_node and return_node.value and not exc_val:\n                return_value = frame_info.expression_values[return_node.value]\n            tracer.exit_call(ExitCallInfo(call_node,\n                                          return_node,\n                                          caller_frame,\n                                          frame,\n                                          return_value,\n                                          exc_val,\n                                          exc_tb\n                                          ))\n\n            del tracer.stack[frame]\n            for secondary_frame in self.tracer.main_to_secondary_frames.pop(frame):\n                del self.tracer.secondary_to_main_frames[secondary_frame]\n\n        return result"
        ],
        [
            "STORE_NAME",
            "class _StmtContext(object):\n    __slots__ = ('tracer', 'node', 'frame')\n\n    def __init__(self, tracer, node, frame):\n        # type: (TreeTracerBase, ast.stmt, FrameType) -> None\n        self.tracer = tracer\n        self.node = node\n        self.frame = frame\n\n    def __enter__(self):\n        tracer = self.tracer\n        node = self.node\n        frame = self.frame\n        if getattr(node, '_enter_call_node', False):\n            tracer._enter_call(node, frame)\n        frame_info = tracer.stack[frame]\n        frame_info.expression_stack = []\n        frame_info.statement_stack.append(node)\n        tracer.before_stmt(node, frame)\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        # type: (Type[Exception], Exception, TracebackType) -> bool\n        node = self.node\n        tracer = self.tracer\n        frame = self.frame\n        frame_info = tracer.stack[frame]\n\n        frame_info.statement_stack.pop()\n\n        exc_node = None  # type: Optional[Union[ast.expr, ast.stmt]]\n        if exc_val and exc_val is not frame_info.exc_value:\n            exc_node = node\n            frame_info.exc_value = exc_val\n\n            # Call the after_expr hook if the exception was raised by an expression\n            expression_stack = frame_info.expression_stack\n            if expression_stack:\n                exc_node = expression_stack[-1]\n                tracer._after_expr(exc_node, frame, None, exc_val, exc_tb)\n\n        result = tracer.after_stmt(node, frame, exc_val, exc_tb, exc_node)\n\n        if isinstance(node, ast.Return):\n            frame_info.return_node = node\n\n        parent = node.parent  # type: ast.AST\n        return_node = frame_info.return_node\n        exiting = (isinstance(parent, (ast.FunctionDef, ast.Module)) and\n                   (node is parent.body[-1] or\n                    exc_val or\n                    return_node))\n        if exiting:\n            caller_frame, call_node = tracer._get_caller_stuff(frame)\n            return_value = None\n            if return_node and return_node.value and not exc_val:\n                return_value = frame_info.expression_values[return_node.value]\n            tracer.exit_call(ExitCallInfo(call_node,\n                                          return_node,\n                                          caller_frame,\n                                          frame,\n                                          return_value,\n                                          exc_val,\n                                          exc_tb\n                                          ))\n\n            del tracer.stack[frame]\n            for secondary_frame in self.tracer.main_to_secondary_frames.pop(frame):\n                del self.tracer.secondary_to_main_frames[secondary_frame]\n\n        return result"
        ],
        [
            "STORE_NAME",
            "def ancestors(node):\n    # type: (ast.AST) -> Iterator[ast.AST]\n    while True:\n        try:\n            node = node.parent\n        except AttributeError:\n            break\n        yield node"
        ],
        [
            "LOAD_NAME",
            "Union"
        ],
        [
            "LOAD_NAME",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.For"
        ],
        [
            "LOAD_NAME",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.While"
        ],
        [
            "LOAD_NAME",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.comprehension"
        ],
        [
            "BINARY_SUBSCR",
            "Union[ast.For, ast.While, ast.comprehension]"
        ],
        [
            "STORE_NAME",
            "Loop"
        ],
        [
            "STORE_NAME",
            "def loops(node):\n    # type: (ast.AST) -> Tuple[Loop, ...]\n    \"\"\"\n    Return all the 'enclosing loops' of a node, up to the innermost class or\n    function definition. This also includes the 'for in' clauses in list/dict/set/generator\n    comprehensions. So for example, in this code:\n\n      for x in ...:\n          def foo():\n              while True:\n                  print([z for y in ...])\n\n    The loops enclosing the node 'z' are 'while True' and 'for y in ...', in that order.\n    \"\"\"\n    result = []\n    while True:\n        try:\n            parent = node.parent\n        except AttributeError:\n            break\n        if isinstance(parent, ast.FunctionDef):\n            break\n\n        is_containing_loop = (((isinstance(parent, ast.For) and parent.iter is not node or\n                                isinstance(parent, ast.While))\n                               and node not in parent.orelse) or\n                              (isinstance(parent, ast.comprehension) and node in parent.ifs))\n        if is_containing_loop:\n            result.append(parent)\n\n        elif isinstance(parent, (ast.ListComp,\n                                 ast.GeneratorExp,\n                                 ast.DictComp,\n                                 ast.SetComp)):\n            generators = parent.generators\n            if node in generators:\n                generators = list(takewhile(lambda n: n != node, generators))\n            result.extend(reversed(generators))\n\n        node = parent\n\n    result.reverse()\n    return tuple(result)"
        ],
        [
            "STORE_NAME",
            "\"\"\"\n    An instance of this class corresponds to a single .py file.\n    It contains some useful data in the following attributes:\n\n    - filename: name of the source file\n    - source: textual contents of the file\n    - root: root of the original Abstract Syntax Tree (AST) of the source,\n            where the nodes of this tree have an additional handy attribute:\n            - parent: parent of the node, so this node is a child node of its parent\n    - tracer: instance of TreeTracerBase\n    - code: executable code object compiled from the modified AST\n    \"\"\""
        ],
        [
            "STORE_NAME",
            "is_ipython_cell"
        ],
        [
            "STORE_NAME",
            "    def __init__(self, tracer, source, filename, flags):\n        # type: (TreeTracerBase, str, str, int) -> None\n        # Here the source code is parsed, modified, and compiled\n        self.root = compile(source, filename, 'exec', ast.PyCF_ONLY_AST | flags, dont_inherit=True)  # type: ast.Module\n\n        self.nodes = []  # type: List[ast.AST]\n\n        self.set_basic_node_attributes()\n\n        new_root = tracer.parse_extra(self.root, source, filename)\n        if new_root is not None:\n            self.root = new_root\n\n        self.set_basic_node_attributes()\n        self.set_enter_call_nodes()\n\n        new_root = deepcopy(self.root)\n        new_root = _NodeVisitor().visit(new_root)\n\n        self.code = compile(new_root, filename, \"exec\", dont_inherit=True, flags=flags)  # type: CodeType\n        self.tracer = tracer\n        self.source = source\n        self.filename = filename"
        ],
        [
            "STORE_NAME",
            "    def set_basic_node_attributes(self):\n        self.nodes = []  # type: List[ast.AST]\n        for node in ast.walk(self.root):  # type: ast.AST\n            for child in ast.iter_child_nodes(node):\n                child.parent = node\n            node._tree_index = len(self.nodes)\n            self.nodes.append(node)\n\n        # Mark __future__ imports and anything before (i.e. module docstrings)\n        # to be ignored by the AST transformer\n        for i, stmt in enumerate(self.root.body):\n            if is_future_import(stmt):\n                for s in self.root.body[:i + 1]:\n                    for node in ast.walk(s):\n                        node._visit_ignore = True"
        ],
        [
            "STORE_NAME",
            "    def set_enter_call_nodes(self):\n        for node in self.nodes:\n            if isinstance(node, (ast.Module, ast.FunctionDef)):\n                for stmt in node.body:\n                    if not is_future_import(stmt):\n                        stmt._enter_call_node = True\n                        break"
        ],
        [
            "LOAD_GLOBAL",
            "compile"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.PyCF_ONLY_AST"
        ],
        [
            "LOAD_FAST",
            "flags"
        ],
        [
            "BINARY_OP",
            "ast.PyCF_ONLY_AST | flags"
        ],
        [
            "CALL",
            "compile(source, filename, 'exec', ast.PyCF_ONLY_AST | flags, dont_inherit=True)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.root"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.nodes"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.set_basic_node_attributes"
        ],
        [
            "CALL",
            "self.set_basic_node_attributes()"
        ],
        [
            "LOAD_FAST",
            "tracer"
        ],
        [
            "LOAD_METHOD",
            "tracer.parse_extra"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.root"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "CALL",
            "tracer.parse_extra(self.root, source, filename)"
        ],
        [
            "STORE_FAST",
            "new_root"
        ],
        [
            "LOAD_FAST",
            "new_root"
        ],
        [
            "LOAD_FAST",
            "new_root"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.root"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.set_basic_node_attributes"
        ],
        [
            "CALL",
            "self.set_basic_node_attributes()"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.set_enter_call_nodes"
        ],
        [
            "CALL",
            "self.set_enter_call_nodes()"
        ],
        [
            "LOAD_GLOBAL",
            "deepcopy"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.root"
        ],
        [
            "CALL",
            "deepcopy(self.root)"
        ],
        [
            "STORE_FAST",
            "new_root"
        ],
        [
            "LOAD_GLOBAL",
            "_NodeVisitor"
        ],
        [
            "CALL",
            "_NodeVisitor()"
        ],
        [
            "LOAD_METHOD",
            "_NodeVisitor().visit"
        ],
        [
            "LOAD_FAST",
            "new_root"
        ],
        [
            "CALL",
            "_NodeVisitor().visit(new_root)"
        ],
        [
            "STORE_FAST",
            "new_root"
        ],
        [
            "LOAD_GLOBAL",
            "compile"
        ],
        [
            "LOAD_FAST",
            "new_root"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "flags"
        ],
        [
            "CALL",
            "compile(new_root, filename, \"exec\", dont_inherit=True, flags=flags)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.code"
        ],
        [
            "LOAD_FAST",
            "tracer"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.tracer"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.source"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.filename"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.nodes"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.walk"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.root"
        ],
        [
            "CALL",
            "ast.walk(self.root)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.iter_child_nodes"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "ast.iter_child_nodes(node)"
        ],
        [
            "STORE_FAST",
            "child"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "child"
        ],
        [
            "STORE_ATTR",
            "child.parent"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.nodes"
        ],
        [
            "CALL",
            "len(self.nodes)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "STORE_ATTR",
            "node._tree_index"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.nodes"
        ],
        [
            "LOAD_METHOD",
            "self.nodes.append"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "self.nodes.append(node)"
        ],
        [
            "LOAD_GLOBAL",
            "enumerate"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.root"
        ],
        [
            "LOAD_ATTR",
            "self.root.body"
        ],
        [
            "CALL",
            "enumerate(self.root.body)"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "STORE_FAST",
            "stmt"
        ],
        [
            "LOAD_GLOBAL",
            "is_future_import"
        ],
        [
            "LOAD_FAST",
            "stmt"
        ],
        [
            "CALL",
            "is_future_import(stmt)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.root"
        ],
        [
            "LOAD_ATTR",
            "self.root.body"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_OP",
            "i + 1"
        ],
        [
            "BINARY_SUBSCR",
            "self.root.body[:i + 1]"
        ],
        [
            "STORE_FAST",
            "s"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.walk"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "CALL",
            "ast.walk(s)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "STORE_ATTR",
            "node._visit_ignore"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.nodes"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Module"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.FunctionDef"
        ],
        [
            "CALL",
            "isinstance(node, (ast.Module, ast.FunctionDef))"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.body"
        ],
        [
            "STORE_FAST",
            "stmt"
        ],
        [
            "LOAD_GLOBAL",
            "is_future_import"
        ],
        [
            "LOAD_FAST",
            "stmt"
        ],
        [
            "CALL",
            "is_future_import(stmt)"
        ],
        [
            "LOAD_FAST",
            "stmt"
        ],
        [
            "STORE_ATTR",
            "stmt._enter_call_node"
        ],
        [
            "STORE_NAME",
            "\"\"\"\n    Contains extra data about an execution frame.\n    Can be obtained from the stack attribute of a TreeTracerBase instance\n    \"\"\""
        ],
        [
            "STORE_NAME",
            "    def __init__(self):\n        # Stack of statements currently being executed\n        self.statement_stack = []  # type: List[ast.stmt]\n\n        # Stack of expression nodes within the above statement that\n        # the interpreter is planning on evaluating, or has just evaluated\n        # in the case of the last element of the list. For example, given\n        # the expression f(g(x)), the stack would be [f, g, x] before and just\n        # after evaluating x, since function arguments are evaluated before the\n        # actual function call.\n        self.expression_stack = []  # type: List[ast.expr]\n\n        # Mapping from the expression node to its most recent value\n        # in the corresponding frame\n        self.expression_values = {}  # type: Dict[ast.expr, Any]\n\n        # Node where the frame has explicitly returned\n        # There may be parent nodes such as enclosing loops that still need to finish executing\n        self.return_node = None  # type: Optional[ast.Return]\n\n        # Most recent exception raised in the frame\n        self.exc_value = None"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.statement_stack"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.expression_stack"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.expression_values"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.return_node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.exc_value"
        ],
        [
            "STORE_NAME",
            "\"\"\"\n    Create a subclass of this class with one or more of the 'hooks'\n    (methods which are empty in this class) overridden to take a custom action\n    in the given situation. Then decorate functions with an instance of this class\n    to trace them.\n    \"\"\""
        ],
        [
            "STORE_NAME",
            "    def __init__(self):\n        # Mapping from frames of execution being traced to FrameInfo objects\n        # for extra metadata.\n        self.stack = {}  # type: Dict[FrameType, FrameInfo]\n        self.main_to_secondary_frames = defaultdict(list)\n        self.secondary_to_main_frames = {}"
        ],
        [
            "LOAD_NAME",
            "lru_cache"
        ],
        [
            "CALL",
            "lru_cache()"
        ],
        [
            "CALL",
            "lru_cache()"
        ],
        [
            "STORE_NAME",
            "    @lru_cache()\n    def compile(self, source, filename, flags=0):\n        # type: (str, str, int) -> TracedFile\n        return TracedFile(self, source, filename, flags)"
        ],
        [
            "STORE_NAME",
            "    def _trace_methods_dict(self, traced_file):\n        # type: (TracedFile) -> Dict[str, Callable]\n        return {f.__name__: partial(f, traced_file)\n                for f in [\n                    self._treetrace_hidden_with_stmt,\n                    self._treetrace_hidden_before_expr,\n                    self._treetrace_hidden_after_expr,\n                ]}"
        ],
        [
            "STORE_NAME",
            "    def trace_function(self, func):\n        # type: (FunctionType) -> FunctionType\n        \"\"\"\n        Returns a version of the passed function with the AST modified to\n        trigger the tracing hooks.\n        \"\"\"\n        if not isinstance(func, FunctionType):\n            raise ValueError('You can only trace user-defined functions. '\n                             'The birdseye decorator must be applied first, '\n                             'at the bottom of the list.')\n\n        try:\n            if inspect.iscoroutinefunction(func) or inspect.isasyncgenfunction(func):\n                raise ValueError('You cannot trace async functions')\n        except AttributeError:\n            pass\n\n        if is_lambda(func):\n            raise ValueError('You cannot trace lambdas')\n\n        filename = inspect.getsourcefile(func)  # type: str\n\n        if is_ipython_cell(filename):\n            # noinspection PyPackageRequirements\n            from IPython import get_ipython\n            import linecache\n\n            flags = get_ipython().compile.flags\n            source = ''.join(linecache.cache[filename][2])\n        else:\n            source = read_source_file(filename)\n            flags = 0\n\n        # We compile the entire file instead of just the function source\n        # because it can contain context which affects the function code,\n        # e.g. enclosing functions and classes or __future__ imports\n        traced_file = self.compile(source, filename, flags)\n\n        if func.__dict__:\n            raise ValueError('The birdseye decorator must be applied first, '\n                             'at the bottom of the list.')\n\n        # Then we have to recursively search through the newly compiled\n        # code to find the code we actually want corresponding to this function\n        code_options = []  # type: List[CodeType]\n\n        def find_code(root_code):\n            # type: (CodeType) -> None\n            for const in root_code.co_consts:  # type: CodeType\n                if not inspect.iscode(const):\n                    continue\n                matches = (const.co_firstlineno == func.__code__.co_firstlineno and\n                           const.co_name == func.__code__.co_name)\n                if matches:\n                    code_options.append(const)\n                find_code(const)\n\n        find_code(traced_file.code)\n\n        if len(code_options) > 1:\n            # Currently lambdas aren't allowed anyway, but should be in the future\n            assert is_lambda(func)\n            raise ValueError(\"Failed to trace lambda. Convert the function to a def.\")\n        new_func_code = code_options[0]  # type: CodeType\n\n        # Give the new function access to the hooks\n        # We have to use the original __globals__ and not a copy\n        # because it's the actual module namespace that may get updated by other code\n        func.__globals__.update(self._trace_methods_dict(traced_file))\n\n        # http://stackoverflow.com/a/13503277/2482744\n        # noinspection PyArgumentList\n        new_func = FunctionType(new_func_code, func.__globals__, func.__name__, func.__defaults__, func.__closure__)\n        update_wrapper(new_func, func)  # type: FunctionType\n        if PY3:\n            new_func.__kwdefaults__ = getattr(func, '__kwdefaults__', None)\n        new_func.traced_file = traced_file\n        return new_func"
        ],
        [
            "STORE_NAME",
            "    def __call__(self, func=None, optional=False):\n        # type: (FunctionType, bool) -> Callable\n        \"\"\"\n        Decorator which returns a (possibly optionally) traced function.\n        This decorator can be called with or without arguments.\n        Typically it is called without arguments, in which case it returns\n        a traced function.\n        If optional=True, it returns a function similar to the original\n        but with an additional optional parameter trace_call, default False.\n        If trace_call is false, the underlying untraced function is used.\n        If true, the traced version is used.\n        \"\"\"\n        if inspect.isclass(func):\n            raise TypeError('Decorating classes is no longer supported')\n\n        if func:\n            # The decorator has been called without arguments/parentheses,\n            # e.g.\n            # @eye\n            # def ...\n            return self.trace_function(func)\n\n        # The decorator has been called with arguments/parentheses,\n        # e.g.\n        # @eye(...)\n        # def ...\n        # We must return a decorator\n\n        if not optional:\n            return self.trace_function\n\n        def decorator(actual_func):\n\n            traced = self.trace_function(actual_func)\n\n            @wraps(actual_func)\n            def wrapper(*args, **kwargs):\n                trace_call = kwargs.pop('trace_call', False)\n                if trace_call:\n                    f = traced\n                else:\n                    f = actual_func\n                return f(*args, **kwargs)\n\n            return wrapper\n\n        return decorator"
        ],
        [
            "STORE_NAME",
            "    def _main_frame(self, node):\n        # type: (ast.AST) -> Optional[FrameType]\n        frame = sys._getframe(2)\n        result = self.secondary_to_main_frames.get(frame)\n        if result:\n            return result\n\n        original_frame = frame\n\n        while frame.f_code.co_name in ('<listcomp>', '<dictcomp>', '<setcomp>'):\n            frame = frame.f_back\n\n        for node in ancestors(node):\n            if isinstance(node, (ast.FunctionDef, ast.Lambda)):\n                break\n\n            if isinstance(node, ast.ClassDef):\n                frame = frame.f_back\n\n        if frame.f_code.co_name in ('<lambda>', '<genexpr>'):\n            return None\n\n        self.secondary_to_main_frames[original_frame] = frame\n        self.main_to_secondary_frames[frame].append(original_frame)\n        return frame"
        ],
        [
            "STORE_NAME",
            "    def _treetrace_hidden_with_stmt(self, traced_file, _tree_index):\n        # type: (TracedFile, int) -> _StmtContext\n        \"\"\"\n        Called directly from the modified code.\n        Every statement in the original code becomes:\n\n        with _treetrace_hidden_with_stmt(...):\n            <statement>\n        \"\"\"\n        node = traced_file.nodes[_tree_index]\n        node = cast(ast.stmt, node)\n        frame = self._main_frame(node)\n        return _StmtContext(self, node, frame)"
        ],
        [
            "STORE_NAME",
            "    def _treetrace_hidden_before_expr(self, traced_file, _tree_index):\n        # type: (TracedFile, int) -> ast.expr\n        \"\"\"\n        Called directly from the modified code before an expression is\n        evaluated.\n        \"\"\"\n        node = traced_file.nodes[_tree_index]\n        node = cast(ast.expr, node)\n        frame = self._main_frame(node)\n        if frame is None:\n            return node\n\n        frame_info = self.stack[frame]\n        frame_info.expression_stack.append(node)\n\n        self.before_expr(node, frame)\n        return node"
        ],
        [
            "STORE_NAME",
            "    def _treetrace_hidden_after_expr(self, _, node, value):\n        # type: (TracedFile, ast.expr, Any) -> Any\n        \"\"\"\n        Called directly from the modified code after an expression is\n        evaluated.\n        \"\"\"\n        frame = self._main_frame(node)\n        if frame is None:\n            return value\n\n        result = self._after_expr(node, frame, value, None, None)\n        if result is not None:\n            assert isinstance(result, ChangeValue), \"after_expr must return None or an instance of ChangeValue\"\n            value = result.value\n        return value"
        ],
        [
            "STORE_NAME",
            "    def _after_expr(self, node, frame, value, exc_value, exc_tb):\n        frame_info = self.stack[frame]\n        frame_info.expression_stack.pop()\n        frame_info.expression_values[node] = value\n        return self.after_expr(node, frame, value, exc_value, exc_tb)"
        ],
        [
            "STORE_NAME",
            "    def _enter_call(self, enter_node, current_frame):\n        # type: (ast.AST, FrameType) -> None\n        caller_frame, call_node = self._get_caller_stuff(current_frame)\n        self.stack[current_frame] = FrameInfo()\n        self.enter_call(EnterCallInfo(call_node, enter_node, caller_frame, current_frame))"
        ],
        [
            "STORE_NAME",
            "    def _get_caller_stuff(self, frame):\n        # type: (FrameType) -> Tuple[FrameType, Optional[Union[ast.expr, ast.stmt]]]\n        caller_frame = frame.f_back\n        call_node = None\n        main_frame = self.secondary_to_main_frames.get(caller_frame)\n        if main_frame:\n            caller_frame = main_frame\n            frame_info = self.stack[caller_frame]\n            expression_stack = frame_info.expression_stack\n            if expression_stack:\n                call_node = expression_stack[-1]\n            else:\n                call_node = frame_info.statement_stack[-1]  # type: ignore\n        return caller_frame, call_node"
        ],
        [
            "STORE_NAME",
            "    def before_expr(self, node, frame):\n        # type: (ast.expr, FrameType) -> None\n        \"\"\"\n        Called right before the expression corresponding to `node` is evaluated\n        within `frame`.\n        \"\"\""
        ],
        [
            "STORE_NAME",
            "    def after_expr(self, node, frame, value, exc_value, exc_tb):\n        # type: (ast.expr, FrameType, Any, Optional[BaseException], Optional[TracebackType]) -> Optional[ChangeValue]\n        \"\"\"\n        Called right after the expression corresponding to `node` is evaluated\n        within `frame`. `value` is the value of the expression, if it succeeded.\n        If the evaluation raised an exception, exc_value will be the exception object\n        and exc_tb the traceback.\n\n        Return `ChangeValue(x)` to change the value of the expression as\n        seen by the rest of the program from `value` to `x`.\n        \"\"\""
        ],
        [
            "STORE_NAME",
            "    def before_stmt(self, node, frame):\n        # type: (ast.stmt, FrameType) -> None\n        \"\"\"\n        Called right before the statement corresponding to `node` is executed\n        within `frame`.\n        \"\"\""
        ],
        [
            "STORE_NAME",
            "    def after_stmt(self, node, frame, exc_value, exc_traceback, exc_node):\n        # type: (ast.stmt, FrameType, Optional[BaseException], Optional[TracebackType], Optional[ast.AST]) -> Optional[bool]\n        \"\"\"\n        Called right after the statement corresponding to `node` is executed\n        within `frame`.\n        If the statement raised an exception, exc_value will be the exception object,\n        exc_tb the traceback, and exc_node the node where the exception was raised\n        (either this statement or an expression within).\n\n        Returning True will suppress any exception raised (as with __exit__ in general).\n        \"\"\""
        ],
        [
            "STORE_NAME",
            "    def enter_call(self, enter_info):\n        # type: (EnterCallInfo) -> None\n        \"\"\"\n        Called before a function call begins executing. For typical `def` functions,\n        this is called before the `before_stmt` for to the first statement in the function.\n        \"\"\""
        ],
        [
            "STORE_NAME",
            "    def exit_call(self, exit_info):\n        # type: (ExitCallInfo) -> None\n        \"\"\"\n        Called after a function call finishes executing. For typical `def` functions,\n        this is called after the `after_stmt` for to the last statement to execute.\n        \"\"\""
        ],
        [
            "STORE_NAME",
            "    def parse_extra(self, root, source, filename):\n        # type: (ast.Module, str, str) -> Optional[ast.Module]\n        \"\"\"\n        Called before the AST (root) is modified to let subclasses make additional changes first.\n        \"\"\""
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.stack"
        ],
        [
            "LOAD_GLOBAL",
            "defaultdict"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "CALL",
            "defaultdict(list)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.main_to_secondary_frames"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.secondary_to_main_frames"
        ],
        [
            "LOAD_GLOBAL",
            "TracedFile"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "flags"
        ],
        [
            "CALL",
            "TracedFile(self, source, filename, flags)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._treetrace_hidden_with_stmt"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._treetrace_hidden_before_expr"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._treetrace_hidden_after_expr"
        ],
        [
            "CALL",
            "{f.__name__: partial(f, traced_file)\n                for f in [\n                    self._treetrace_hidden_with_stmt,\n                    self._treetrace_hidden_before_expr,\n                    self._treetrace_hidden_after_expr,\n                ]}"
        ],
        [
            "LOAD_FAST",
            "{f.__name__: partial(f, traced_file)\n                for f in [\n                    self._treetrace_hidden_with_stmt,\n                    self._treetrace_hidden_before_expr,\n                    self._treetrace_hidden_after_expr,\n                ]}"
        ],
        [
            "STORE_FAST",
            "f"
        ],
        [
            "LOAD_FAST",
            "f"
        ],
        [
            "LOAD_ATTR",
            "f.__name__"
        ],
        [
            "LOAD_GLOBAL",
            "partial"
        ],
        [
            "LOAD_FAST",
            "f"
        ],
        [
            "LOAD_DEREF",
            "traced_file"
        ],
        [
            "CALL",
            "partial(f, traced_file)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "LOAD_GLOBAL",
            "FunctionType"
        ],
        [
            "CALL",
            "isinstance(func, FunctionType)"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError('You can only trace user-defined functions. '\n                             'The birdseye decorator must be applied first, '\n                             'at the bottom of the list.')"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.iscoroutinefunction"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "CALL",
            "inspect.iscoroutinefunction(func)"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.isasyncgenfunction"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "CALL",
            "inspect.isasyncgenfunction(func)"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError('You cannot trace async functions')"
        ],
        [
            "LOAD_GLOBAL",
            "AttributeError"
        ],
        [
            "LOAD_GLOBAL",
            "is_lambda"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "CALL",
            "is_lambda(func)"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError('You cannot trace lambdas')"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.getsourcefile"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "CALL",
            "inspect.getsourcefile(func)"
        ],
        [
            "STORE_FAST",
            "filename"
        ],
        [
            "LOAD_GLOBAL",
            "is_ipython_cell"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "CALL",
            "is_ipython_cell(filename)"
        ],
        [
            "STORE_FAST",
            "from IPython import get_ipython"
        ],
        [
            "STORE_FAST",
            "import linecache"
        ],
        [
            "LOAD_FAST",
            "get_ipython"
        ],
        [
            "CALL",
            "get_ipython()"
        ],
        [
            "LOAD_ATTR",
            "get_ipython().compile"
        ],
        [
            "LOAD_ATTR",
            "get_ipython().compile.flags"
        ],
        [
            "STORE_FAST",
            "flags"
        ],
        [
            "LOAD_METHOD",
            "''.join"
        ],
        [
            "LOAD_FAST",
            "linecache"
        ],
        [
            "LOAD_ATTR",
            "linecache.cache"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "BINARY_SUBSCR",
            "linecache.cache[filename]"
        ],
        [
            "BINARY_SUBSCR",
            "linecache.cache[filename][2]"
        ],
        [
            "CALL",
            "''.join(linecache.cache[filename][2])"
        ],
        [
            "STORE_FAST",
            "source"
        ],
        [
            "LOAD_GLOBAL",
            "read_source_file"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "CALL",
            "read_source_file(filename)"
        ],
        [
            "STORE_FAST",
            "source"
        ],
        [
            "STORE_FAST",
            "flags"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.compile"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_FAST",
            "flags"
        ],
        [
            "CALL",
            "self.compile(source, filename, flags)"
        ],
        [
            "STORE_FAST",
            "traced_file"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.__dict__"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError('The birdseye decorator must be applied first, '\n                             'at the bottom of the list.')"
        ],
        [
            "STORE_DEREF",
            "code_options"
        ],
        [
            "STORE_DEREF",
            "        def find_code(root_code):\n            # type: (CodeType) -> None\n            for const in root_code.co_consts:  # type: CodeType\n                if not inspect.iscode(const):\n                    continue\n                matches = (const.co_firstlineno == func.__code__.co_firstlineno and\n                           const.co_name == func.__code__.co_name)\n                if matches:\n                    code_options.append(const)\n                find_code(const)"
        ],
        [
            "LOAD_DEREF",
            "find_code"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.code"
        ],
        [
            "CALL",
            "find_code(traced_file.code)"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_DEREF",
            "code_options"
        ],
        [
            "CALL",
            "len(code_options)"
        ],
        [
            "COMPARE_OP",
            "len(code_options) > 1"
        ],
        [
            "LOAD_GLOBAL",
            "is_lambda"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "CALL",
            "is_lambda(func)"
        ],
        [
            "LOAD_GLOBAL",
            "ValueError"
        ],
        [
            "CALL",
            "ValueError(\"Failed to trace lambda. Convert the function to a def.\")"
        ],
        [
            "LOAD_DEREF",
            "code_options"
        ],
        [
            "BINARY_SUBSCR",
            "code_options[0]"
        ],
        [
            "STORE_FAST",
            "new_func_code"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.__globals__"
        ],
        [
            "LOAD_METHOD",
            "func.__globals__.update"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._trace_methods_dict"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "CALL",
            "self._trace_methods_dict(traced_file)"
        ],
        [
            "CALL",
            "func.__globals__.update(self._trace_methods_dict(traced_file))"
        ],
        [
            "LOAD_GLOBAL",
            "FunctionType"
        ],
        [
            "LOAD_FAST",
            "new_func_code"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.__globals__"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.__name__"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.__defaults__"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.__closure__"
        ],
        [
            "CALL",
            "FunctionType(new_func_code, func.__globals__, func.__name__, func.__defaults__, func.__closure__)"
        ],
        [
            "STORE_FAST",
            "new_func"
        ],
        [
            "LOAD_GLOBAL",
            "update_wrapper"
        ],
        [
            "LOAD_FAST",
            "new_func"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "CALL",
            "update_wrapper(new_func, func)"
        ],
        [
            "LOAD_GLOBAL",
            "PY3"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "CALL",
            "getattr(func, '__kwdefaults__', None)"
        ],
        [
            "LOAD_FAST",
            "new_func"
        ],
        [
            "STORE_ATTR",
            "new_func.__kwdefaults__"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_FAST",
            "new_func"
        ],
        [
            "STORE_ATTR",
            "new_func.traced_file"
        ],
        [
            "LOAD_FAST",
            "new_func"
        ],
        [
            "LOAD_FAST",
            "root_code"
        ],
        [
            "LOAD_ATTR",
            "root_code.co_consts"
        ],
        [
            "STORE_FAST",
            "const"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.iscode"
        ],
        [
            "LOAD_FAST",
            "const"
        ],
        [
            "CALL",
            "inspect.iscode(const)"
        ],
        [
            "LOAD_FAST",
            "const"
        ],
        [
            "LOAD_ATTR",
            "const.co_firstlineno"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.__code__"
        ],
        [
            "LOAD_ATTR",
            "func.__code__.co_firstlineno"
        ],
        [
            "COMPARE_OP",
            "const.co_firstlineno == func.__code__.co_firstlineno"
        ],
        [
            "LOAD_FAST",
            "const"
        ],
        [
            "LOAD_ATTR",
            "const.co_name"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.__code__"
        ],
        [
            "LOAD_ATTR",
            "func.__code__.co_name"
        ],
        [
            "COMPARE_OP",
            "const.co_name == func.__code__.co_name"
        ],
        [
            "STORE_FAST",
            "matches"
        ],
        [
            "LOAD_FAST",
            "matches"
        ],
        [
            "LOAD_DEREF",
            "code_options"
        ],
        [
            "LOAD_METHOD",
            "code_options.append"
        ],
        [
            "LOAD_FAST",
            "const"
        ],
        [
            "CALL",
            "code_options.append(const)"
        ],
        [
            "LOAD_DEREF",
            "find_code"
        ],
        [
            "LOAD_FAST",
            "const"
        ],
        [
            "CALL",
            "find_code(const)"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.isclass"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "CALL",
            "inspect.isclass(func)"
        ],
        [
            "LOAD_GLOBAL",
            "TypeError"
        ],
        [
            "CALL",
            "TypeError('Decorating classes is no longer supported')"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.trace_function"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "CALL",
            "self.trace_function(func)"
        ],
        [
            "LOAD_FAST",
            "optional"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.trace_function"
        ],
        [
            "STORE_FAST",
            "        def decorator(actual_func):\n\n            traced = self.trace_function(actual_func)\n\n            @wraps(actual_func)\n            def wrapper(*args, **kwargs):\n                trace_call = kwargs.pop('trace_call', False)\n                if trace_call:\n                    f = traced\n                else:\n                    f = actual_func\n                return f(*args, **kwargs)\n\n            return wrapper"
        ],
        [
            "LOAD_FAST",
            "decorator"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.trace_function"
        ],
        [
            "LOAD_DEREF",
            "actual_func"
        ],
        [
            "CALL",
            "self.trace_function(actual_func)"
        ],
        [
            "STORE_DEREF",
            "traced"
        ],
        [
            "LOAD_GLOBAL",
            "wraps"
        ],
        [
            "LOAD_DEREF",
            "actual_func"
        ],
        [
            "CALL",
            "wraps(actual_func)"
        ],
        [
            "CALL",
            "wraps(actual_func)"
        ],
        [
            "STORE_FAST",
            "            @wraps(actual_func)\n            def wrapper(*args, **kwargs):\n                trace_call = kwargs.pop('trace_call', False)\n                if trace_call:\n                    f = traced\n                else:\n                    f = actual_func\n                return f(*args, **kwargs)"
        ],
        [
            "LOAD_FAST",
            "wrapper"
        ],
        [
            "LOAD_FAST",
            "kwargs"
        ],
        [
            "LOAD_METHOD",
            "kwargs.pop"
        ],
        [
            "CALL",
            "kwargs.pop('trace_call', False)"
        ],
        [
            "STORE_FAST",
            "trace_call"
        ],
        [
            "LOAD_FAST",
            "trace_call"
        ],
        [
            "LOAD_DEREF",
            "traced"
        ],
        [
            "STORE_FAST",
            "f"
        ],
        [
            "LOAD_DEREF",
            "actual_func"
        ],
        [
            "STORE_FAST",
            "f"
        ],
        [
            "LOAD_FAST",
            "f"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_FAST",
            "kwargs"
        ],
        [
            "CALL_FUNCTION_EX",
            "f(*args, **kwargs)"
        ],
        [
            "LOAD_GLOBAL",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys._getframe"
        ],
        [
            "CALL",
            "sys._getframe(2)"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.secondary_to_main_frames"
        ],
        [
            "LOAD_METHOD",
            "self.secondary_to_main_frames.get"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "self.secondary_to_main_frames.get(frame)"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "STORE_FAST",
            "original_frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_name"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code.co_name in ('<listcomp>', '<dictcomp>', '<setcomp>')"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_back"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_name"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code.co_name in ('<listcomp>', '<dictcomp>', '<setcomp>')"
        ],
        [
            "LOAD_GLOBAL",
            "ancestors"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "ancestors(node)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.FunctionDef"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Lambda"
        ],
        [
            "CALL",
            "isinstance(node, (ast.FunctionDef, ast.Lambda))"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.ClassDef"
        ],
        [
            "CALL",
            "isinstance(node, ast.ClassDef)"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_back"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_name"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code.co_name in ('<lambda>', '<genexpr>')"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.secondary_to_main_frames"
        ],
        [
            "LOAD_FAST",
            "original_frame"
        ],
        [
            "STORE_SUBSCR",
            "self.secondary_to_main_frames[original_frame]"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.main_to_secondary_frames"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "BINARY_SUBSCR",
            "self.main_to_secondary_frames[frame]"
        ],
        [
            "LOAD_METHOD",
            "self.main_to_secondary_frames[frame].append"
        ],
        [
            "LOAD_FAST",
            "original_frame"
        ],
        [
            "CALL",
            "self.main_to_secondary_frames[frame].append(original_frame)"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.nodes"
        ],
        [
            "LOAD_FAST",
            "_tree_index"
        ],
        [
            "BINARY_SUBSCR",
            "traced_file.nodes[_tree_index]"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "cast"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.stmt"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "cast(ast.stmt, node)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._main_frame"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "self._main_frame(node)"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_GLOBAL",
            "_StmtContext"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "_StmtContext(self, node, frame)"
        ],
        [
            "LOAD_FAST",
            "traced_file"
        ],
        [
            "LOAD_ATTR",
            "traced_file.nodes"
        ],
        [
            "LOAD_FAST",
            "_tree_index"
        ],
        [
            "BINARY_SUBSCR",
            "traced_file.nodes[_tree_index]"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "cast"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.expr"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "cast(ast.expr, node)"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._main_frame"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "self._main_frame(node)"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "STORE_FAST",
            "frame_info"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.expression_stack"
        ],
        [
            "LOAD_METHOD",
            "frame_info.expression_stack.append"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "frame_info.expression_stack.append(node)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.before_expr"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "self.before_expr(node, frame)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._main_frame"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "self._main_frame(node)"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._after_expr"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "CALL",
            "self._after_expr(node, frame, value, None, None)"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_GLOBAL",
            "ChangeValue"
        ],
        [
            "CALL",
            "isinstance(result, ChangeValue)"
        ],
        [
            "CALL",
            "assert isinstance(result, ChangeValue), \"after_expr must return None or an instance of ChangeValue\""
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_ATTR",
            "result.value"
        ],
        [
            "STORE_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[frame]"
        ],
        [
            "STORE_FAST",
            "frame_info"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.expression_stack"
        ],
        [
            "LOAD_METHOD",
            "frame_info.expression_stack.pop"
        ],
        [
            "CALL",
            "frame_info.expression_stack.pop()"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.expression_values"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "STORE_SUBSCR",
            "frame_info.expression_values[node]"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.after_expr"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "exc_value"
        ],
        [
            "LOAD_FAST",
            "exc_tb"
        ],
        [
            "CALL",
            "self.after_expr(node, frame, value, exc_value, exc_tb)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._get_caller_stuff"
        ],
        [
            "LOAD_FAST",
            "current_frame"
        ],
        [
            "CALL",
            "self._get_caller_stuff(current_frame)"
        ],
        [
            "STORE_FAST",
            "caller_frame"
        ],
        [
            "STORE_FAST",
            "call_node"
        ],
        [
            "LOAD_GLOBAL",
            "FrameInfo"
        ],
        [
            "CALL",
            "FrameInfo()"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_FAST",
            "current_frame"
        ],
        [
            "STORE_SUBSCR",
            "self.stack[current_frame]"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.enter_call"
        ],
        [
            "LOAD_GLOBAL",
            "EnterCallInfo"
        ],
        [
            "LOAD_FAST",
            "call_node"
        ],
        [
            "LOAD_FAST",
            "enter_node"
        ],
        [
            "LOAD_FAST",
            "caller_frame"
        ],
        [
            "LOAD_FAST",
            "current_frame"
        ],
        [
            "CALL",
            "EnterCallInfo(call_node, enter_node, caller_frame, current_frame)"
        ],
        [
            "CALL",
            "self.enter_call(EnterCallInfo(call_node, enter_node, caller_frame, current_frame))"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_back"
        ],
        [
            "STORE_FAST",
            "caller_frame"
        ],
        [
            "STORE_FAST",
            "call_node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.secondary_to_main_frames"
        ],
        [
            "LOAD_METHOD",
            "self.secondary_to_main_frames.get"
        ],
        [
            "LOAD_FAST",
            "caller_frame"
        ],
        [
            "CALL",
            "self.secondary_to_main_frames.get(caller_frame)"
        ],
        [
            "STORE_FAST",
            "main_frame"
        ],
        [
            "LOAD_FAST",
            "main_frame"
        ],
        [
            "LOAD_FAST",
            "main_frame"
        ],
        [
            "STORE_FAST",
            "caller_frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.stack"
        ],
        [
            "LOAD_FAST",
            "caller_frame"
        ],
        [
            "BINARY_SUBSCR",
            "self.stack[caller_frame]"
        ],
        [
            "STORE_FAST",
            "frame_info"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.expression_stack"
        ],
        [
            "STORE_FAST",
            "expression_stack"
        ],
        [
            "LOAD_FAST",
            "expression_stack"
        ],
        [
            "LOAD_FAST",
            "expression_stack"
        ],
        [
            "BINARY_SUBSCR",
            "expression_stack[-1]"
        ],
        [
            "STORE_FAST",
            "call_node"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.statement_stack"
        ],
        [
            "BINARY_SUBSCR",
            "frame_info.statement_stack[-1]"
        ],
        [
            "STORE_FAST",
            "call_node"
        ],
        [
            "LOAD_FAST",
            "caller_frame"
        ],
        [
            "LOAD_FAST",
            "call_node"
        ],
        [
            "STORE_NAME",
            "\"\"\"\n    This does the AST modifications that call the hooks.\n    \"\"\""
        ],
        [
            "STORE_NAME",
            "    def generic_visit(self, node):\n        # type: (ast.AST) -> ast.AST\n        if not getattr(node, '_visit_ignore', False):\n            if (isinstance(node, ast.expr) and\n                    not (hasattr(node, \"ctx\") and not isinstance(node.ctx, ast.Load)) and\n                    not isinstance(node, getattr(ast, 'Starred', ()))):\n                return self.visit_expr(node)\n            if isinstance(node, ast.stmt):\n                return self.visit_stmt(node)\n        return super(_NodeVisitor, self).generic_visit(node)"
        ],
        [
            "STORE_NAME",
            "    def visit_expr(self, node):\n        # type: (ast.expr) -> ast.Call\n        \"\"\"\n        each expression e gets wrapped like this:\n            _treetrace_hidden_after_expr(_treetrace_hidden_before_expr(_tree_index), e)\n\n        where the _treetrace_* functions are the corresponding methods with the\n        TreeTracerBase and traced_file arguments already filled in (see _trace_methods_dict)\n        \"\"\"\n\n        before_marker = self._create_simple_marker_call(node, TreeTracerBase._treetrace_hidden_before_expr)\n        ast.copy_location(before_marker, node)\n\n        after_marker = ast.Call(\n            func=ast.Name(id=TreeTracerBase._treetrace_hidden_after_expr.__name__,\n                          ctx=ast.Load()),\n            args=[\n                before_marker,\n                super(_NodeVisitor, self).generic_visit(node),\n            ],\n            keywords=[],\n        )\n        ast.copy_location(after_marker, node)\n        ast.fix_missing_locations(after_marker)\n\n        return after_marker"
        ],
        [
            "STORE_NAME",
            "    def visit_stmt(self, node):\n        # type: (ast.stmt) -> ast.With\n        \"\"\"\n        Every statement in the original code becomes:\n\n        with _treetrace_hidden_with_stmt(_tree_index):\n            <statement>\n\n        where the _treetrace_hidden_with_stmt function is the the corresponding method with the\n        TreeTracerBase and traced_file arguments already filled in (see _trace_methods_dict)\n        \"\"\"\n        context_expr = self._create_simple_marker_call(\n            super(_NodeVisitor, self).generic_visit(node),\n            TreeTracerBase._treetrace_hidden_with_stmt)\n\n        if PY3:\n            wrapped = ast.With(\n                items=[ast.withitem(context_expr=context_expr)],\n                body=[node],\n            )\n        else:\n            wrapped = ast.With(\n                context_expr=context_expr,\n                body=[node],\n            )\n        ast.copy_location(wrapped, node)\n        ast.fix_missing_locations(wrapped)\n        return wrapped"
        ],
        [
            "LOAD_NAME",
            "staticmethod"
        ],
        [
            "CALL",
            "staticmethod"
        ],
        [
            "STORE_NAME",
            "    @staticmethod\n    def _create_simple_marker_call(node, func):\n        # type: (ast.AST, Callable) -> ast.Call\n        \"\"\"\n        Returns a Call node representing `func(node._tree_index)`\n        where node._tree_index is a numerical literal which allows the node object\n        to be retrieved later through the nodes attribute of a TracedFile.\n        \"\"\"\n        return ast.Call(\n            func=ast.Name(id=func.__name__,\n                          ctx=ast.Load()),\n            args=[ast.Num(node._tree_index)],\n            keywords=[],\n        )"
        ],
        [
            "STORE_NAME",
            "    @staticmethod\n    def _create_simple_marker_call(node, func):\n        # type: (ast.AST, Callable) -> ast.Call\n        \"\"\"\n        Returns a Call node representing `func(node._tree_index)`\n        where node._tree_index is a numerical literal which allows the node object\n        to be retrieved later through the nodes attribute of a TracedFile.\n        \"\"\"\n        return ast.Call(\n            func=ast.Name(id=func.__name__,\n                          ctx=ast.Load()),\n            args=[ast.Num(node._tree_index)],\n            keywords=[],\n        )"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "getattr(node, '_visit_ignore', False)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.expr"
        ],
        [
            "CALL",
            "isinstance(node, ast.expr)"
        ],
        [
            "LOAD_GLOBAL",
            "hasattr"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "hasattr(node, \"ctx\")"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.ctx"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Load"
        ],
        [
            "CALL",
            "isinstance(node.ctx, ast.Load)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "CALL",
            "getattr(ast, 'Starred', ())"
        ],
        [
            "CALL",
            "isinstance(node, getattr(ast, 'Starred', ()))"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.visit_expr"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "self.visit_expr(node)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.stmt"
        ],
        [
            "CALL",
            "isinstance(node, ast.stmt)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.visit_stmt"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "self.visit_stmt(node)"
        ],
        [
            "LOAD_GLOBAL",
            "super"
        ],
        [
            "LOAD_GLOBAL",
            "_NodeVisitor"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "super(_NodeVisitor, self)"
        ],
        [
            "LOAD_METHOD",
            "super(_NodeVisitor, self).generic_visit"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "super(_NodeVisitor, self).generic_visit(node)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._create_simple_marker_call"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "TreeTracerBase"
        ],
        [
            "LOAD_ATTR",
            "TreeTracerBase._treetrace_hidden_before_expr"
        ],
        [
            "CALL",
            "self._create_simple_marker_call(node, TreeTracerBase._treetrace_hidden_before_expr)"
        ],
        [
            "STORE_FAST",
            "before_marker"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.copy_location"
        ],
        [
            "LOAD_FAST",
            "before_marker"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "ast.copy_location(before_marker, node)"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Call"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Name"
        ],
        [
            "LOAD_GLOBAL",
            "TreeTracerBase"
        ],
        [
            "LOAD_ATTR",
            "TreeTracerBase._treetrace_hidden_after_expr"
        ],
        [
            "LOAD_ATTR",
            "TreeTracerBase._treetrace_hidden_after_expr.__name__"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Load"
        ],
        [
            "CALL",
            "ast.Load()"
        ],
        [
            "CALL",
            "ast.Name(id=TreeTracerBase._treetrace_hidden_after_expr.__name__,\n                          ctx=ast.Load())"
        ],
        [
            "LOAD_FAST",
            "before_marker"
        ],
        [
            "LOAD_GLOBAL",
            "super"
        ],
        [
            "LOAD_GLOBAL",
            "_NodeVisitor"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "super(_NodeVisitor, self)"
        ],
        [
            "LOAD_METHOD",
            "super(_NodeVisitor, self).generic_visit"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "super(_NodeVisitor, self).generic_visit(node)"
        ],
        [
            "CALL",
            "ast.Call(\n            func=ast.Name(id=TreeTracerBase._treetrace_hidden_after_expr.__name__,\n                          ctx=ast.Load()),\n            args=[\n                before_marker,\n                super(_NodeVisitor, self).generic_visit(node),\n            ],\n            keywords=[],\n        )"
        ],
        [
            "STORE_FAST",
            "after_marker"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.copy_location"
        ],
        [
            "LOAD_FAST",
            "after_marker"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "ast.copy_location(after_marker, node)"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.fix_missing_locations"
        ],
        [
            "LOAD_FAST",
            "after_marker"
        ],
        [
            "CALL",
            "ast.fix_missing_locations(after_marker)"
        ],
        [
            "LOAD_FAST",
            "after_marker"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._create_simple_marker_call"
        ],
        [
            "LOAD_GLOBAL",
            "super"
        ],
        [
            "LOAD_GLOBAL",
            "_NodeVisitor"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "super(_NodeVisitor, self)"
        ],
        [
            "LOAD_METHOD",
            "super(_NodeVisitor, self).generic_visit"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "super(_NodeVisitor, self).generic_visit(node)"
        ],
        [
            "LOAD_GLOBAL",
            "TreeTracerBase"
        ],
        [
            "LOAD_ATTR",
            "TreeTracerBase._treetrace_hidden_with_stmt"
        ],
        [
            "CALL",
            "self._create_simple_marker_call(\n            super(_NodeVisitor, self).generic_visit(node),\n            TreeTracerBase._treetrace_hidden_with_stmt)"
        ],
        [
            "STORE_FAST",
            "context_expr"
        ],
        [
            "LOAD_GLOBAL",
            "PY3"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.With"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.withitem"
        ],
        [
            "LOAD_FAST",
            "context_expr"
        ],
        [
            "CALL",
            "ast.withitem(context_expr=context_expr)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "ast.With(\n                items=[ast.withitem(context_expr=context_expr)],\n                body=[node],\n            )"
        ],
        [
            "STORE_FAST",
            "wrapped"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.With"
        ],
        [
            "LOAD_FAST",
            "context_expr"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "ast.With(\n                context_expr=context_expr,\n                body=[node],\n            )"
        ],
        [
            "STORE_FAST",
            "wrapped"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.copy_location"
        ],
        [
            "LOAD_FAST",
            "wrapped"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "ast.copy_location(wrapped, node)"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.fix_missing_locations"
        ],
        [
            "LOAD_FAST",
            "wrapped"
        ],
        [
            "CALL",
            "ast.fix_missing_locations(wrapped)"
        ],
        [
            "LOAD_FAST",
            "wrapped"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Call"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Name"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "LOAD_ATTR",
            "func.__name__"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Load"
        ],
        [
            "CALL",
            "ast.Load()"
        ],
        [
            "CALL",
            "ast.Name(id=func.__name__,\n                          ctx=ast.Load())"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Num"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node._tree_index"
        ],
        [
            "CALL",
            "ast.Num(node._tree_index)"
        ],
        [
            "CALL",
            "ast.Call(\n            func=ast.Name(id=func.__name__,\n                          ctx=ast.Load()),\n            args=[ast.Num(node._tree_index)],\n            keywords=[],\n        )"
        ],
        [
            "STORE_NAME",
            "__slots__"
        ],
        [
            "STORE_NAME",
            "    def __init__(self, tracer, node, frame):\n        # type: (TreeTracerBase, ast.stmt, FrameType) -> None\n        self.tracer = tracer\n        self.node = node\n        self.frame = frame"
        ],
        [
            "STORE_NAME",
            "    def __enter__(self):\n        tracer = self.tracer\n        node = self.node\n        frame = self.frame\n        if getattr(node, '_enter_call_node', False):\n            tracer._enter_call(node, frame)\n        frame_info = tracer.stack[frame]\n        frame_info.expression_stack = []\n        frame_info.statement_stack.append(node)\n        tracer.before_stmt(node, frame)"
        ],
        [
            "STORE_NAME",
            "    def __exit__(self, exc_type, exc_val, exc_tb):\n        # type: (Type[Exception], Exception, TracebackType) -> bool\n        node = self.node\n        tracer = self.tracer\n        frame = self.frame\n        frame_info = tracer.stack[frame]\n\n        frame_info.statement_stack.pop()\n\n        exc_node = None  # type: Optional[Union[ast.expr, ast.stmt]]\n        if exc_val and exc_val is not frame_info.exc_value:\n            exc_node = node\n            frame_info.exc_value = exc_val\n\n            # Call the after_expr hook if the exception was raised by an expression\n            expression_stack = frame_info.expression_stack\n            if expression_stack:\n                exc_node = expression_stack[-1]\n                tracer._after_expr(exc_node, frame, None, exc_val, exc_tb)\n\n        result = tracer.after_stmt(node, frame, exc_val, exc_tb, exc_node)\n\n        if isinstance(node, ast.Return):\n            frame_info.return_node = node\n\n        parent = node.parent  # type: ast.AST\n        return_node = frame_info.return_node\n        exiting = (isinstance(parent, (ast.FunctionDef, ast.Module)) and\n                   (node is parent.body[-1] or\n                    exc_val or\n                    return_node))\n        if exiting:\n            caller_frame, call_node = tracer._get_caller_stuff(frame)\n            return_value = None\n            if return_node and return_node.value and not exc_val:\n                return_value = frame_info.expression_values[return_node.value]\n            tracer.exit_call(ExitCallInfo(call_node,\n                                          return_node,\n                                          caller_frame,\n                                          frame,\n                                          return_value,\n                                          exc_val,\n                                          exc_tb\n                                          ))\n\n            del tracer.stack[frame]\n            for secondary_frame in self.tracer.main_to_secondary_frames.pop(frame):\n                del self.tracer.secondary_to_main_frames[secondary_frame]\n\n        return result"
        ],
        [
            "LOAD_FAST",
            "tracer"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.tracer"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.node"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.tracer"
        ],
        [
            "STORE_FAST",
            "tracer"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.node"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.frame"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_GLOBAL",
            "getattr"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "getattr(node, '_enter_call_node', False)"
        ],
        [
            "LOAD_FAST",
            "tracer"
        ],
        [
            "LOAD_METHOD",
            "tracer._enter_call"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "tracer._enter_call(node, frame)"
        ],
        [
            "LOAD_FAST",
            "tracer"
        ],
        [
            "LOAD_ATTR",
            "tracer.stack"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "BINARY_SUBSCR",
            "tracer.stack[frame]"
        ],
        [
            "STORE_FAST",
            "frame_info"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "STORE_ATTR",
            "frame_info.expression_stack"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.statement_stack"
        ],
        [
            "LOAD_METHOD",
            "frame_info.statement_stack.append"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "CALL",
            "frame_info.statement_stack.append(node)"
        ],
        [
            "LOAD_FAST",
            "tracer"
        ],
        [
            "LOAD_METHOD",
            "tracer.before_stmt"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "tracer.before_stmt(node, frame)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.node"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.tracer"
        ],
        [
            "STORE_FAST",
            "tracer"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.frame"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "tracer"
        ],
        [
            "LOAD_ATTR",
            "tracer.stack"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "BINARY_SUBSCR",
            "tracer.stack[frame]"
        ],
        [
            "STORE_FAST",
            "frame_info"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.statement_stack"
        ],
        [
            "LOAD_METHOD",
            "frame_info.statement_stack.pop"
        ],
        [
            "CALL",
            "frame_info.statement_stack.pop()"
        ],
        [
            "STORE_FAST",
            "exc_node"
        ],
        [
            "LOAD_FAST",
            "exc_val"
        ],
        [
            "LOAD_FAST",
            "exc_val"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.exc_value"
        ],
        [
            "IS_OP",
            "exc_val is not frame_info.exc_value"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "STORE_FAST",
            "exc_node"
        ],
        [
            "LOAD_FAST",
            "exc_val"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "STORE_ATTR",
            "frame_info.exc_value"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.expression_stack"
        ],
        [
            "STORE_FAST",
            "expression_stack"
        ],
        [
            "LOAD_FAST",
            "expression_stack"
        ],
        [
            "LOAD_FAST",
            "expression_stack"
        ],
        [
            "BINARY_SUBSCR",
            "expression_stack[-1]"
        ],
        [
            "STORE_FAST",
            "exc_node"
        ],
        [
            "LOAD_FAST",
            "tracer"
        ],
        [
            "LOAD_METHOD",
            "tracer._after_expr"
        ],
        [
            "LOAD_FAST",
            "exc_node"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "exc_val"
        ],
        [
            "LOAD_FAST",
            "exc_tb"
        ],
        [
            "CALL",
            "tracer._after_expr(exc_node, frame, None, exc_val, exc_tb)"
        ],
        [
            "LOAD_FAST",
            "tracer"
        ],
        [
            "LOAD_METHOD",
            "tracer.after_stmt"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "exc_val"
        ],
        [
            "LOAD_FAST",
            "exc_tb"
        ],
        [
            "LOAD_FAST",
            "exc_node"
        ],
        [
            "CALL",
            "tracer.after_stmt(node, frame, exc_val, exc_tb, exc_node)"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Return"
        ],
        [
            "CALL",
            "isinstance(node, ast.Return)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "STORE_ATTR",
            "frame_info.return_node"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "STORE_FAST",
            "parent"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.return_node"
        ],
        [
            "STORE_FAST",
            "return_node"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "parent"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.FunctionDef"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Module"
        ],
        [
            "CALL",
            "isinstance(parent, (ast.FunctionDef, ast.Module))"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_FAST",
            "parent"
        ],
        [
            "LOAD_ATTR",
            "parent.body"
        ],
        [
            "BINARY_SUBSCR",
            "parent.body[-1]"
        ],
        [
            "IS_OP",
            "node is parent.body[-1]"
        ],
        [
            "LOAD_FAST",
            "exc_val"
        ],
        [
            "LOAD_FAST",
            "return_node"
        ],
        [
            "STORE_FAST",
            "exiting"
        ],
        [
            "LOAD_FAST",
            "exiting"
        ],
        [
            "LOAD_FAST",
            "tracer"
        ],
        [
            "LOAD_METHOD",
            "tracer._get_caller_stuff"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "tracer._get_caller_stuff(frame)"
        ],
        [
            "STORE_FAST",
            "caller_frame"
        ],
        [
            "STORE_FAST",
            "call_node"
        ],
        [
            "STORE_FAST",
            "return_value"
        ],
        [
            "LOAD_FAST",
            "return_node"
        ],
        [
            "LOAD_FAST",
            "return_node"
        ],
        [
            "LOAD_ATTR",
            "return_node.value"
        ],
        [
            "LOAD_FAST",
            "exc_val"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.expression_values"
        ],
        [
            "LOAD_FAST",
            "return_node"
        ],
        [
            "LOAD_ATTR",
            "return_node.value"
        ],
        [
            "BINARY_SUBSCR",
            "frame_info.expression_values[return_node.value]"
        ],
        [
            "STORE_FAST",
            "return_value"
        ],
        [
            "LOAD_FAST",
            "tracer"
        ],
        [
            "LOAD_METHOD",
            "tracer.exit_call"
        ],
        [
            "LOAD_GLOBAL",
            "ExitCallInfo"
        ],
        [
            "LOAD_FAST",
            "call_node"
        ],
        [
            "LOAD_FAST",
            "return_node"
        ],
        [
            "LOAD_FAST",
            "caller_frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "return_value"
        ],
        [
            "LOAD_FAST",
            "exc_val"
        ],
        [
            "LOAD_FAST",
            "exc_tb"
        ],
        [
            "CALL",
            "ExitCallInfo(call_node,\n                                          return_node,\n                                          caller_frame,\n                                          frame,\n                                          return_value,\n                                          exc_val,\n                                          exc_tb\n                                          )"
        ],
        [
            "CALL",
            "tracer.exit_call(ExitCallInfo(call_node,\n                                          return_node,\n                                          caller_frame,\n                                          frame,\n                                          return_value,\n                                          exc_val,\n                                          exc_tb\n                                          ))"
        ],
        [
            "LOAD_FAST",
            "tracer"
        ],
        [
            "LOAD_ATTR",
            "tracer.stack"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "DELETE_SUBSCR",
            "tracer.stack[frame]"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.tracer"
        ],
        [
            "LOAD_ATTR",
            "self.tracer.main_to_secondary_frames"
        ],
        [
            "LOAD_METHOD",
            "self.tracer.main_to_secondary_frames.pop"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "self.tracer.main_to_secondary_frames.pop(frame)"
        ],
        [
            "STORE_FAST",
            "secondary_frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.tracer"
        ],
        [
            "LOAD_ATTR",
            "self.tracer.secondary_to_main_frames"
        ],
        [
            "LOAD_FAST",
            "secondary_frame"
        ],
        [
            "DELETE_SUBSCR",
            "self.tracer.secondary_to_main_frames[secondary_frame]"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "STORE_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "AttributeError"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_DEREF",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.parent"
        ],
        [
            "STORE_FAST",
            "parent"
        ],
        [
            "LOAD_GLOBAL",
            "AttributeError"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "parent"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.FunctionDef"
        ],
        [
            "CALL",
            "isinstance(parent, ast.FunctionDef)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "parent"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.For"
        ],
        [
            "CALL",
            "isinstance(parent, ast.For)"
        ],
        [
            "LOAD_FAST",
            "parent"
        ],
        [
            "LOAD_ATTR",
            "parent.iter"
        ],
        [
            "LOAD_DEREF",
            "node"
        ],
        [
            "IS_OP",
            "parent.iter is not node"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "parent"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.While"
        ],
        [
            "CALL",
            "isinstance(parent, ast.While)"
        ],
        [
            "LOAD_DEREF",
            "node"
        ],
        [
            "LOAD_FAST",
            "parent"
        ],
        [
            "LOAD_ATTR",
            "parent.orelse"
        ],
        [
            "CONTAINS_OP",
            "node not in parent.orelse"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "parent"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.comprehension"
        ],
        [
            "CALL",
            "isinstance(parent, ast.comprehension)"
        ],
        [
            "LOAD_DEREF",
            "node"
        ],
        [
            "LOAD_FAST",
            "parent"
        ],
        [
            "LOAD_ATTR",
            "parent.ifs"
        ],
        [
            "CONTAINS_OP",
            "node in parent.ifs"
        ],
        [
            "STORE_FAST",
            "is_containing_loop"
        ],
        [
            "LOAD_FAST",
            "is_containing_loop"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_METHOD",
            "result.append"
        ],
        [
            "LOAD_FAST",
            "parent"
        ],
        [
            "CALL",
            "result.append(parent)"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "parent"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.ListComp"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.GeneratorExp"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.DictComp"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.SetComp"
        ],
        [
            "CALL",
            "isinstance(parent, (ast.ListComp,\n                                 ast.GeneratorExp,\n                                 ast.DictComp,\n                                 ast.SetComp))"
        ],
        [
            "LOAD_FAST",
            "parent"
        ],
        [
            "LOAD_ATTR",
            "parent.generators"
        ],
        [
            "STORE_FAST",
            "generators"
        ],
        [
            "LOAD_DEREF",
            "node"
        ],
        [
            "LOAD_FAST",
            "generators"
        ],
        [
            "CONTAINS_OP",
            "node in generators"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_GLOBAL",
            "takewhile"
        ],
        [
            "LOAD_FAST",
            "generators"
        ],
        [
            "CALL",
            "takewhile(lambda n: n != node, generators)"
        ],
        [
            "CALL",
            "list(takewhile(lambda n: n != node, generators))"
        ],
        [
            "STORE_FAST",
            "generators"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_METHOD",
            "result.extend"
        ],
        [
            "LOAD_GLOBAL",
            "reversed"
        ],
        [
            "LOAD_FAST",
            "generators"
        ],
        [
            "CALL",
            "reversed(generators)"
        ],
        [
            "CALL",
            "result.extend(reversed(generators))"
        ],
        [
            "LOAD_FAST",
            "parent"
        ],
        [
            "STORE_DEREF",
            "node"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_METHOD",
            "result.reverse"
        ],
        [
            "CALL",
            "result.reverse()"
        ],
        [
            "LOAD_GLOBAL",
            "tuple"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "CALL",
            "tuple(result)"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "LOAD_DEREF",
            "node"
        ],
        [
            "COMPARE_OP",
            "n != node"
        ]
    ],
    "tracer2.py": [
        [
            "STORE_NAME",
            "import functools"
        ],
        [
            "STORE_NAME",
            "import inspect"
        ],
        [
            "STORE_NAME",
            "import os"
        ],
        [
            "STORE_NAME",
            "import re"
        ],
        [
            "STORE_NAME",
            "import sys"
        ],
        [
            "STORE_NAME",
            "import threading"
        ],
        [
            "STORE_NAME",
            "from collections import OrderedDict"
        ],
        [
            "STORE_NAME",
            "import six"
        ],
        [
            "STORE_NAME",
            "from cheap_repr import cheap_repr, find_repr_function"
        ],
        [
            "STORE_NAME",
            "from cheap_repr import cheap_repr, find_repr_function"
        ],
        [
            "STORE_NAME",
            "from snoop.utils import my_cheap_repr, NO_ASTTOKENS, ArgDefaultDict, iscoroutinefunction, \\\n    truncate_list, ensure_tuple, is_comprehension_frame, no_args_decorator"
        ],
        [
            "STORE_NAME",
            "from snoop.utils import my_cheap_repr, NO_ASTTOKENS, ArgDefaultDict, iscoroutinefunction, \\\n    truncate_list, ensure_tuple, is_comprehension_frame, no_args_decorator"
        ],
        [
            "STORE_NAME",
            "from snoop.utils import my_cheap_repr, NO_ASTTOKENS, ArgDefaultDict, iscoroutinefunction, \\\n    truncate_list, ensure_tuple, is_comprehension_frame, no_args_decorator"
        ],
        [
            "STORE_NAME",
            "from snoop.utils import my_cheap_repr, NO_ASTTOKENS, ArgDefaultDict, iscoroutinefunction, \\\n    truncate_list, ensure_tuple, is_comprehension_frame, no_args_decorator"
        ],
        [
            "STORE_NAME",
            "from snoop.utils import my_cheap_repr, NO_ASTTOKENS, ArgDefaultDict, iscoroutinefunction, \\\n    truncate_list, ensure_tuple, is_comprehension_frame, no_args_decorator"
        ],
        [
            "STORE_NAME",
            "from snoop.utils import my_cheap_repr, NO_ASTTOKENS, ArgDefaultDict, iscoroutinefunction, \\\n    truncate_list, ensure_tuple, is_comprehension_frame, no_args_decorator"
        ],
        [
            "STORE_NAME",
            "from snoop.utils import my_cheap_repr, NO_ASTTOKENS, ArgDefaultDict, iscoroutinefunction, \\\n    truncate_list, ensure_tuple, is_comprehension_frame, no_args_decorator"
        ],
        [
            "STORE_NAME",
            "from snoop.utils import my_cheap_repr, NO_ASTTOKENS, ArgDefaultDict, iscoroutinefunction, \\\n    truncate_list, ensure_tuple, is_comprehension_frame, no_args_decorator"
        ],
        [
            "STORE_NAME",
            "from .formatting import Event, Source"
        ],
        [
            "STORE_NAME",
            "from .formatting import Event, Source"
        ],
        [
            "STORE_NAME",
            "from .variables import CommonVariable, Exploding, BaseVariable"
        ],
        [
            "STORE_NAME",
            "from .variables import CommonVariable, Exploding, BaseVariable"
        ],
        [
            "STORE_NAME",
            "from .variables import CommonVariable, Exploding, BaseVariable"
        ],
        [
            "LOAD_NAME",
            "find_repr_function"
        ],
        [
            "LOAD_NAME",
            "six"
        ],
        [
            "LOAD_ATTR",
            "six.text_type"
        ],
        [
            "CALL",
            "find_repr_function(six.text_type)"
        ],
        [
            "STORE_ATTR",
            "find_repr_function(six.text_type).maxparts"
        ],
        [
            "LOAD_NAME",
            "find_repr_function"
        ],
        [
            "LOAD_NAME",
            "six"
        ],
        [
            "LOAD_ATTR",
            "six.binary_type"
        ],
        [
            "CALL",
            "find_repr_function(six.binary_type)"
        ],
        [
            "STORE_ATTR",
            "find_repr_function(six.binary_type).maxparts"
        ],
        [
            "LOAD_NAME",
            "find_repr_function"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "find_repr_function(object)"
        ],
        [
            "STORE_ATTR",
            "find_repr_function(object).maxparts"
        ],
        [
            "LOAD_NAME",
            "find_repr_function"
        ],
        [
            "LOAD_NAME",
            "int"
        ],
        [
            "CALL",
            "find_repr_function(int)"
        ],
        [
            "STORE_ATTR",
            "find_repr_function(int).maxparts"
        ],
        [
            "LOAD_NAME",
            "cheap_repr"
        ],
        [
            "STORE_ATTR",
            "cheap_repr.suppression_threshold"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class FrameInfo(object):\n    def __init__(self, frame):\n        self.frame = frame\n        self.local_reprs = {}\n        self.last_line_no = frame.f_lineno\n        self.comprehension_variables = OrderedDict()\n        self.source = Source.for_frame(frame)\n        self.is_generator = frame.f_code.co_flags & inspect.CO_GENERATOR\n        self.had_exception = False\n        if is_comprehension_frame(frame):\n            self.comprehension_type = (\n                    re.match(r'<(\\w+)comp>', frame.f_code.co_name).group(1).title()\n                    + u' comprehension'\n            )\n        else:\n            self.comprehension_type = ''\n\n    def update_variables(self, watch, watch_extras, event):\n        self.last_line_no = self.frame.f_lineno\n        old_local_reprs = self.local_reprs\n        self.local_reprs = OrderedDict(\n            (source, my_cheap_repr(value))\n            for source, value in\n            self.get_local_reprs(watch, watch_extras)\n        )\n\n        if self.comprehension_type:\n            for name, value_repr in self.local_reprs.items():\n                values = self.comprehension_variables.setdefault(name, [])\n                if not values or values[-1] != value_repr:\n                    values.append(value_repr)\n                    values[:] = truncate_list(values, 11)\n            if event in ('return', 'exception'):\n                return [\n                    (name, ', '.join(values))\n                    for name, values in self.comprehension_variables.items()\n                ]\n            else:\n                return []\n\n        variables = []\n        for name, value_repr in self.local_reprs.items():\n            if name not in old_local_reprs or old_local_reprs[name] != value_repr:\n                variables.append((name, value_repr))\n        return variables\n\n    def get_local_reprs(self, watch, watch_extras):\n        frame = self.frame\n        code = frame.f_code\n        vars_order = code.co_varnames + code.co_cellvars + code.co_freevars + tuple(frame.f_locals.keys())\n\n        result_items = sorted(\n            frame.f_locals.items(),\n            key=lambda key_value: vars_order.index(key_value[0])\n        )\n\n        for variable in watch:\n            result_items += sorted(variable.items(frame))\n\n        for source, value in result_items:\n            yield source, value\n            for extra in watch_extras:\n                try:\n                    pair = extra(source, value)\n                except Exception:\n                    pass\n                else:\n                    if pair is not None:\n                        assert len(pair) == 2, \"Watch extra must return pair or None\"\n                        yield pair"
        ],
        [
            "STORE_NAME",
            "class FrameInfo(object):\n    def __init__(self, frame):\n        self.frame = frame\n        self.local_reprs = {}\n        self.last_line_no = frame.f_lineno\n        self.comprehension_variables = OrderedDict()\n        self.source = Source.for_frame(frame)\n        self.is_generator = frame.f_code.co_flags & inspect.CO_GENERATOR\n        self.had_exception = False\n        if is_comprehension_frame(frame):\n            self.comprehension_type = (\n                    re.match(r'<(\\w+)comp>', frame.f_code.co_name).group(1).title()\n                    + u' comprehension'\n            )\n        else:\n            self.comprehension_type = ''\n\n    def update_variables(self, watch, watch_extras, event):\n        self.last_line_no = self.frame.f_lineno\n        old_local_reprs = self.local_reprs\n        self.local_reprs = OrderedDict(\n            (source, my_cheap_repr(value))\n            for source, value in\n            self.get_local_reprs(watch, watch_extras)\n        )\n\n        if self.comprehension_type:\n            for name, value_repr in self.local_reprs.items():\n                values = self.comprehension_variables.setdefault(name, [])\n                if not values or values[-1] != value_repr:\n                    values.append(value_repr)\n                    values[:] = truncate_list(values, 11)\n            if event in ('return', 'exception'):\n                return [\n                    (name, ', '.join(values))\n                    for name, values in self.comprehension_variables.items()\n                ]\n            else:\n                return []\n\n        variables = []\n        for name, value_repr in self.local_reprs.items():\n            if name not in old_local_reprs or old_local_reprs[name] != value_repr:\n                variables.append((name, value_repr))\n        return variables\n\n    def get_local_reprs(self, watch, watch_extras):\n        frame = self.frame\n        code = frame.f_code\n        vars_order = code.co_varnames + code.co_cellvars + code.co_freevars + tuple(frame.f_locals.keys())\n\n        result_items = sorted(\n            frame.f_locals.items(),\n            key=lambda key_value: vars_order.index(key_value[0])\n        )\n\n        for variable in watch:\n            result_items += sorted(variable.items(frame))\n\n        for source, value in result_items:\n            yield source, value\n            for extra in watch_extras:\n                try:\n                    pair = extra(source, value)\n                except Exception:\n                    pass\n                else:\n                    if pair is not None:\n                        assert len(pair) == 2, \"Watch extra must return pair or None\"\n                        yield pair"
        ],
        [
            "LOAD_NAME",
            "threading"
        ],
        [
            "LOAD_ATTR",
            "threading.local"
        ],
        [
            "CALL",
            "threading.local()"
        ],
        [
            "STORE_NAME",
            "thread_global"
        ],
        [
            "LOAD_NAME",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.dirname"
        ],
        [
            "LOAD_ATTR",
            "(lambda: 0).__code__"
        ],
        [
            "LOAD_ATTR",
            "(lambda: 0).__code__.co_filename"
        ],
        [
            "CALL",
            "os.path.dirname((lambda: 0).__code__.co_filename)"
        ],
        [
            "STORE_NAME",
            "internal_directories"
        ],
        [
            "STORE_NAME",
            "import birdseye"
        ],
        [
            "LOAD_NAME",
            "internal_directories"
        ],
        [
            "LOAD_NAME",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.dirname"
        ],
        [
            "LOAD_NAME",
            "birdseye"
        ],
        [
            "LOAD_ATTR",
            "birdseye.__file__"
        ],
        [
            "CALL",
            "os.path.dirname(birdseye.__file__)"
        ],
        [
            "BINARY_OP",
            "internal_directories += (os.path.dirname(birdseye.__file__),)"
        ],
        [
            "STORE_NAME",
            "internal_directories"
        ],
        [
            "LOAD_NAME",
            "ImportError"
        ],
        [
            "LOAD_NAME",
            "type"
        ],
        [
            "CALL",
            "class TracerMeta(type):\n    def __new__(mcs, *args, **kwargs):\n        result = super(TracerMeta, mcs).__new__(mcs, *args, **kwargs)\n        result.default = result()\n        return result\n\n    def __call__(cls, *args, **kwargs):\n        if no_args_decorator(args, kwargs):\n            return cls.default(args[0])\n        else:\n            return super(TracerMeta, cls).__call__(*args, **kwargs)\n\n    def __enter__(self):\n        return self.default.__enter__(context=1)\n\n    def __exit__(self, *args):\n        return self.default.__exit__(*args, context=1)"
        ],
        [
            "STORE_NAME",
            "class TracerMeta(type):\n    def __new__(mcs, *args, **kwargs):\n        result = super(TracerMeta, mcs).__new__(mcs, *args, **kwargs)\n        result.default = result()\n        return result\n\n    def __call__(cls, *args, **kwargs):\n        if no_args_decorator(args, kwargs):\n            return cls.default(args[0])\n        else:\n            return super(TracerMeta, cls).__call__(*args, **kwargs)\n\n    def __enter__(self):\n        return self.default.__enter__(context=1)\n\n    def __exit__(self, *args):\n        return self.default.__exit__(*args, context=1)"
        ],
        [
            "LOAD_NAME",
            "six"
        ],
        [
            "LOAD_ATTR",
            "six.add_metaclass"
        ],
        [
            "LOAD_NAME",
            "TracerMeta"
        ],
        [
            "CALL",
            "six.add_metaclass(TracerMeta)"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "@six.add_metaclass(TracerMeta)\nclass Tracer(object):\n    def __init__(\n            self,\n            watch=(),\n            watch_explode=(),\n            depth=1,\n    ):\n        self.watch = [\n            v if isinstance(v, BaseVariable) else CommonVariable(v)\n            for v in ensure_tuple(watch)\n        ] + [\n            v if isinstance(v, BaseVariable) else Exploding(v)\n            for v in ensure_tuple(watch_explode)\n        ]\n        self.frame_infos = ArgDefaultDict(FrameInfo)\n        self.depth = depth\n        assert self.depth >= 1\n        self.target_codes = set()\n        self.target_frames = set()\n\n    def __call__(self, function):\n        if iscoroutinefunction(function):\n            raise NotImplementedError(\"coroutines are not supported, sorry!\")\n\n        self.target_codes.add(function.__code__)\n\n        @functools.wraps(function)\n        def simple_wrapper(*args, **kwargs):\n            with self:\n                return function(*args, **kwargs)\n\n        @functools.wraps(function)\n        def generator_wrapper(*args, **kwargs):\n            gen = function(*args, **kwargs)\n            method, incoming = gen.send, None\n            while True:\n                with self:\n                    try:\n                        outgoing = method(incoming)\n                    except StopIteration:\n                        return\n                try:\n                    method, incoming = gen.send, (yield outgoing)\n                except Exception as e:\n                    method, incoming = gen.throw, e\n\n        if inspect.isgeneratorfunction(function):\n            return generator_wrapper\n        else:\n            return simple_wrapper\n\n    def __enter__(self, context=0):\n        if not self.config.enabled:\n            return\n\n        calling_frame = sys._getframe(context + 1)\n        if not self._is_internal_frame(calling_frame):\n            calling_frame.f_trace = self.trace\n            self.target_frames.add(calling_frame)\n            self.config.last_frame = calling_frame\n            self.trace(calling_frame, 'enter', None)\n\n        stack = thread_global.__dict__.setdefault('original_trace_functions', [])\n        stack.append(sys.gettrace())\n        sys.settrace(self.trace)\n\n    def __exit__(self, exc_type, exc_value, exc_traceback, context=0):\n        if not self.config.enabled:\n            return\n\n        stack = thread_global.original_trace_functions\n        sys.settrace(stack.pop())\n        calling_frame = sys._getframe(context + 1)\n        self.trace(calling_frame, 'exit', None)\n        self.target_frames.discard(calling_frame)\n        self.frame_infos.pop(calling_frame, None)\n\n    def _is_internal_frame(self, frame):\n        return frame.f_code.co_filename.startswith(internal_directories)\n    \n    def _is_traced_frame(self, frame):\n        return frame.f_code in self.target_codes or frame in self.target_frames\n\n    def trace(self, frame, event, arg):\n        if not self._is_traced_frame(frame):\n            if (\n                    self.depth == 1\n                    or self._is_internal_frame(frame)\n            ) and not is_comprehension_frame(frame):\n                return None\n            else:\n                candidate = frame\n                i = 0\n                while True:\n                    if is_comprehension_frame(candidate):\n                        candidate = candidate.f_back\n                        continue\n                    i += 1\n                    if self._is_traced_frame(candidate):\n                        break\n                    candidate = candidate.f_back\n                    if i >= self.depth or candidate is None or self._is_internal_frame(candidate):\n                        return None\n\n        thread_local = self.config.thread_local\n        thread_local.__dict__.setdefault('depth', -1)\n        frame_info = self.frame_infos[frame]\n        if event in ('call', 'enter'):\n            thread_local.depth += 1\n        elif self.config.last_frame and self.config.last_frame is not frame:\n            line_no = frame_info.last_line_no\n            trace_event = Event(frame_info, event, arg, thread_local.depth, line_no=line_no)\n            line = self.config.formatter.format_line_only(trace_event)\n            self.config.write(line)\n\n        if event == 'exception':\n            frame_info.had_exception = True\n\n        self.config.last_frame = frame\n\n        trace_event = Event(frame_info, event, arg, thread_local.depth)\n        if not (frame.f_code.co_name == '<genexpr>' and event not in ('return', 'exception')):\n            trace_event.variables = frame_info.update_variables(\n                self.watch,\n                self.config.watch_extras,\n                event,\n            )\n\n        if event in ('return', 'exit'):\n            del self.frame_infos[frame]\n            thread_local.depth -= 1\n\n        formatted = self.config.formatter.format(trace_event)\n        self.config.write(formatted)\n\n        return self.trace"
        ],
        [
            "CALL",
            "six.add_metaclass(TracerMeta)"
        ],
        [
            "STORE_NAME",
            "@six.add_metaclass(TracerMeta)\nclass Tracer(object):\n    def __init__(\n            self,\n            watch=(),\n            watch_explode=(),\n            depth=1,\n    ):\n        self.watch = [\n            v if isinstance(v, BaseVariable) else CommonVariable(v)\n            for v in ensure_tuple(watch)\n        ] + [\n            v if isinstance(v, BaseVariable) else Exploding(v)\n            for v in ensure_tuple(watch_explode)\n        ]\n        self.frame_infos = ArgDefaultDict(FrameInfo)\n        self.depth = depth\n        assert self.depth >= 1\n        self.target_codes = set()\n        self.target_frames = set()\n\n    def __call__(self, function):\n        if iscoroutinefunction(function):\n            raise NotImplementedError(\"coroutines are not supported, sorry!\")\n\n        self.target_codes.add(function.__code__)\n\n        @functools.wraps(function)\n        def simple_wrapper(*args, **kwargs):\n            with self:\n                return function(*args, **kwargs)\n\n        @functools.wraps(function)\n        def generator_wrapper(*args, **kwargs):\n            gen = function(*args, **kwargs)\n            method, incoming = gen.send, None\n            while True:\n                with self:\n                    try:\n                        outgoing = method(incoming)\n                    except StopIteration:\n                        return\n                try:\n                    method, incoming = gen.send, (yield outgoing)\n                except Exception as e:\n                    method, incoming = gen.throw, e\n\n        if inspect.isgeneratorfunction(function):\n            return generator_wrapper\n        else:\n            return simple_wrapper\n\n    def __enter__(self, context=0):\n        if not self.config.enabled:\n            return\n\n        calling_frame = sys._getframe(context + 1)\n        if not self._is_internal_frame(calling_frame):\n            calling_frame.f_trace = self.trace\n            self.target_frames.add(calling_frame)\n            self.config.last_frame = calling_frame\n            self.trace(calling_frame, 'enter', None)\n\n        stack = thread_global.__dict__.setdefault('original_trace_functions', [])\n        stack.append(sys.gettrace())\n        sys.settrace(self.trace)\n\n    def __exit__(self, exc_type, exc_value, exc_traceback, context=0):\n        if not self.config.enabled:\n            return\n\n        stack = thread_global.original_trace_functions\n        sys.settrace(stack.pop())\n        calling_frame = sys._getframe(context + 1)\n        self.trace(calling_frame, 'exit', None)\n        self.target_frames.discard(calling_frame)\n        self.frame_infos.pop(calling_frame, None)\n\n    def _is_internal_frame(self, frame):\n        return frame.f_code.co_filename.startswith(internal_directories)\n    \n    def _is_traced_frame(self, frame):\n        return frame.f_code in self.target_codes or frame in self.target_frames\n\n    def trace(self, frame, event, arg):\n        if not self._is_traced_frame(frame):\n            if (\n                    self.depth == 1\n                    or self._is_internal_frame(frame)\n            ) and not is_comprehension_frame(frame):\n                return None\n            else:\n                candidate = frame\n                i = 0\n                while True:\n                    if is_comprehension_frame(candidate):\n                        candidate = candidate.f_back\n                        continue\n                    i += 1\n                    if self._is_traced_frame(candidate):\n                        break\n                    candidate = candidate.f_back\n                    if i >= self.depth or candidate is None or self._is_internal_frame(candidate):\n                        return None\n\n        thread_local = self.config.thread_local\n        thread_local.__dict__.setdefault('depth', -1)\n        frame_info = self.frame_infos[frame]\n        if event in ('call', 'enter'):\n            thread_local.depth += 1\n        elif self.config.last_frame and self.config.last_frame is not frame:\n            line_no = frame_info.last_line_no\n            trace_event = Event(frame_info, event, arg, thread_local.depth, line_no=line_no)\n            line = self.config.formatter.format_line_only(trace_event)\n            self.config.write(line)\n\n        if event == 'exception':\n            frame_info.had_exception = True\n\n        self.config.last_frame = frame\n\n        trace_event = Event(frame_info, event, arg, thread_local.depth)\n        if not (frame.f_code.co_name == '<genexpr>' and event not in ('return', 'exception')):\n            trace_event.variables = frame_info.update_variables(\n                self.watch,\n                self.config.watch_extras,\n                event,\n            )\n\n        if event in ('return', 'exit'):\n            del self.frame_infos[frame]\n            thread_local.depth -= 1\n\n        formatted = self.config.formatter.format(trace_event)\n        self.config.write(formatted)\n\n        return self.trace"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "class Spy(object):\n    def __init__(self, config):\n        self.config = config\n\n    def __call__(self, *args, **kwargs):\n        if NO_ASTTOKENS:\n            raise Exception(\"birdseye doesn't support this version of Python\")\n\n        try:\n            import birdseye\n        except ImportError:\n            raise Exception(\"You must install birdseye separately to use spy: pip install birdseye\")\n\n        # Decorator without parentheses\n        if no_args_decorator(args, kwargs):\n            return self._trace(args[0])\n\n        # Decorator with parentheses and perhaps arguments\n        def decorator(func):\n            return self._trace(func, *args, **kwargs)\n\n        return decorator\n\n    def _trace(self, func, *args, **kwargs):\n        # noinspection PyUnresolvedReferences\n        from birdseye import eye\n\n        traced = eye(func)\n        traced = self.config.snoop(*args, **kwargs)(traced)\n\n        @functools.wraps(func)\n        def wrapper(*func_args, **func_kwargs):\n            if self.config.enabled:\n                final_func = traced\n            else:\n                final_func = func\n\n            return final_func(*func_args, **func_kwargs)\n\n        return wrapper"
        ],
        [
            "STORE_NAME",
            "class Spy(object):\n    def __init__(self, config):\n        self.config = config\n\n    def __call__(self, *args, **kwargs):\n        if NO_ASTTOKENS:\n            raise Exception(\"birdseye doesn't support this version of Python\")\n\n        try:\n            import birdseye\n        except ImportError:\n            raise Exception(\"You must install birdseye separately to use spy: pip install birdseye\")\n\n        # Decorator without parentheses\n        if no_args_decorator(args, kwargs):\n            return self._trace(args[0])\n\n        # Decorator with parentheses and perhaps arguments\n        def decorator(func):\n            return self._trace(func, *args, **kwargs)\n\n        return decorator\n\n    def _trace(self, func, *args, **kwargs):\n        # noinspection PyUnresolvedReferences\n        from birdseye import eye\n\n        traced = eye(func)\n        traced = self.config.snoop(*args, **kwargs)(traced)\n\n        @functools.wraps(func)\n        def wrapper(*func_args, **func_kwargs):\n            if self.config.enabled:\n                final_func = traced\n            else:\n                final_func = func\n\n            return final_func(*func_args, **func_kwargs)\n\n        return wrapper"
        ],
        [
            "STORE_NAME",
            "    def __init__(self, frame):\n        self.frame = frame\n        self.local_reprs = {}\n        self.last_line_no = frame.f_lineno\n        self.comprehension_variables = OrderedDict()\n        self.source = Source.for_frame(frame)\n        self.is_generator = frame.f_code.co_flags & inspect.CO_GENERATOR\n        self.had_exception = False\n        if is_comprehension_frame(frame):\n            self.comprehension_type = (\n                    re.match(r'<(\\w+)comp>', frame.f_code.co_name).group(1).title()\n                    + u' comprehension'\n            )\n        else:\n            self.comprehension_type = ''"
        ],
        [
            "STORE_NAME",
            "    def update_variables(self, watch, watch_extras, event):\n        self.last_line_no = self.frame.f_lineno\n        old_local_reprs = self.local_reprs\n        self.local_reprs = OrderedDict(\n            (source, my_cheap_repr(value))\n            for source, value in\n            self.get_local_reprs(watch, watch_extras)\n        )\n\n        if self.comprehension_type:\n            for name, value_repr in self.local_reprs.items():\n                values = self.comprehension_variables.setdefault(name, [])\n                if not values or values[-1] != value_repr:\n                    values.append(value_repr)\n                    values[:] = truncate_list(values, 11)\n            if event in ('return', 'exception'):\n                return [\n                    (name, ', '.join(values))\n                    for name, values in self.comprehension_variables.items()\n                ]\n            else:\n                return []\n\n        variables = []\n        for name, value_repr in self.local_reprs.items():\n            if name not in old_local_reprs or old_local_reprs[name] != value_repr:\n                variables.append((name, value_repr))\n        return variables"
        ],
        [
            "STORE_NAME",
            "    def get_local_reprs(self, watch, watch_extras):\n        frame = self.frame\n        code = frame.f_code\n        vars_order = code.co_varnames + code.co_cellvars + code.co_freevars + tuple(frame.f_locals.keys())\n\n        result_items = sorted(\n            frame.f_locals.items(),\n            key=lambda key_value: vars_order.index(key_value[0])\n        )\n\n        for variable in watch:\n            result_items += sorted(variable.items(frame))\n\n        for source, value in result_items:\n            yield source, value\n            for extra in watch_extras:\n                try:\n                    pair = extra(source, value)\n                except Exception:\n                    pass\n                else:\n                    if pair is not None:\n                        assert len(pair) == 2, \"Watch extra must return pair or None\"\n                        yield pair"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.local_reprs"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_lineno"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.last_line_no"
        ],
        [
            "LOAD_GLOBAL",
            "OrderedDict"
        ],
        [
            "CALL",
            "OrderedDict()"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.comprehension_variables"
        ],
        [
            "LOAD_GLOBAL",
            "Source"
        ],
        [
            "LOAD_ATTR",
            "Source.for_frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "Source.for_frame(frame)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.source"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_flags"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.CO_GENERATOR"
        ],
        [
            "BINARY_OP",
            "frame.f_code.co_flags & inspect.CO_GENERATOR"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.is_generator"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.had_exception"
        ],
        [
            "LOAD_GLOBAL",
            "is_comprehension_frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "is_comprehension_frame(frame)"
        ],
        [
            "LOAD_GLOBAL",
            "re"
        ],
        [
            "LOAD_ATTR",
            "re.match"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_name"
        ],
        [
            "CALL",
            "re.match(r'<(\\w+)comp>', frame.f_code.co_name)"
        ],
        [
            "LOAD_METHOD",
            "re.match(r'<(\\w+)comp>', frame.f_code.co_name).group"
        ],
        [
            "CALL",
            "re.match(r'<(\\w+)comp>', frame.f_code.co_name).group(1)"
        ],
        [
            "LOAD_METHOD",
            "re.match(r'<(\\w+)comp>', frame.f_code.co_name).group(1).title"
        ],
        [
            "CALL",
            "re.match(r'<(\\w+)comp>', frame.f_code.co_name).group(1).title()"
        ],
        [
            "BINARY_OP",
            "re.match(r'<(\\w+)comp>', frame.f_code.co_name).group(1).title()\n                    + u' comprehension'"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.comprehension_type"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.comprehension_type"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.frame"
        ],
        [
            "LOAD_ATTR",
            "self.frame.f_lineno"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.last_line_no"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.local_reprs"
        ],
        [
            "STORE_FAST",
            "old_local_reprs"
        ],
        [
            "LOAD_GLOBAL",
            "OrderedDict"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.get_local_reprs"
        ],
        [
            "LOAD_FAST",
            "watch"
        ],
        [
            "LOAD_FAST",
            "watch_extras"
        ],
        [
            "CALL",
            "self.get_local_reprs(watch, watch_extras)"
        ],
        [
            "CALL",
            "(\n            (source, my_cheap_repr(value))\n            for source, value in\n            self.get_local_reprs(watch, watch_extras)\n        )"
        ],
        [
            "CALL",
            "OrderedDict(\n            (source, my_cheap_repr(value))\n            for source, value in\n            self.get_local_reprs(watch, watch_extras)\n        )"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.local_reprs"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.comprehension_type"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.local_reprs"
        ],
        [
            "LOAD_METHOD",
            "self.local_reprs.items"
        ],
        [
            "CALL",
            "self.local_reprs.items()"
        ],
        [
            "STORE_FAST",
            "name"
        ],
        [
            "STORE_FAST",
            "value_repr"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.comprehension_variables"
        ],
        [
            "LOAD_METHOD",
            "self.comprehension_variables.setdefault"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "CALL",
            "self.comprehension_variables.setdefault(name, [])"
        ],
        [
            "STORE_FAST",
            "values"
        ],
        [
            "LOAD_FAST",
            "values"
        ],
        [
            "LOAD_FAST",
            "values"
        ],
        [
            "BINARY_SUBSCR",
            "values[-1]"
        ],
        [
            "LOAD_FAST",
            "value_repr"
        ],
        [
            "COMPARE_OP",
            "values[-1] != value_repr"
        ],
        [
            "LOAD_FAST",
            "values"
        ],
        [
            "LOAD_METHOD",
            "values.append"
        ],
        [
            "LOAD_FAST",
            "value_repr"
        ],
        [
            "CALL",
            "values.append(value_repr)"
        ],
        [
            "LOAD_GLOBAL",
            "truncate_list"
        ],
        [
            "LOAD_FAST",
            "values"
        ],
        [
            "CALL",
            "truncate_list(values, 11)"
        ],
        [
            "LOAD_FAST",
            "values"
        ],
        [
            "STORE_SUBSCR",
            "values[:]"
        ],
        [
            "LOAD_FAST",
            "event"
        ],
        [
            "CONTAINS_OP",
            "event in ('return', 'exception')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.comprehension_variables"
        ],
        [
            "LOAD_METHOD",
            "self.comprehension_variables.items"
        ],
        [
            "CALL",
            "self.comprehension_variables.items()"
        ],
        [
            "CALL",
            "[\n                    (name, ', '.join(values))\n                    for name, values in self.comprehension_variables.items()\n                ]"
        ],
        [
            "STORE_FAST",
            "variables"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.local_reprs"
        ],
        [
            "LOAD_METHOD",
            "self.local_reprs.items"
        ],
        [
            "CALL",
            "self.local_reprs.items()"
        ],
        [
            "STORE_FAST",
            "name"
        ],
        [
            "STORE_FAST",
            "value_repr"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "old_local_reprs"
        ],
        [
            "CONTAINS_OP",
            "name not in old_local_reprs"
        ],
        [
            "LOAD_FAST",
            "old_local_reprs"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "BINARY_SUBSCR",
            "old_local_reprs[name]"
        ],
        [
            "LOAD_FAST",
            "value_repr"
        ],
        [
            "COMPARE_OP",
            "old_local_reprs[name] != value_repr"
        ],
        [
            "LOAD_FAST",
            "variables"
        ],
        [
            "LOAD_METHOD",
            "variables.append"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_FAST",
            "value_repr"
        ],
        [
            "CALL",
            "variables.append((name, value_repr))"
        ],
        [
            "LOAD_FAST",
            "variables"
        ],
        [
            "LOAD_FAST",
            "(\n            (source, my_cheap_repr(value))\n            for source, value in\n            self.get_local_reprs(watch, watch_extras)\n        )"
        ],
        [
            "STORE_FAST",
            "source"
        ],
        [
            "STORE_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_GLOBAL",
            "my_cheap_repr"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "CALL",
            "my_cheap_repr(value)"
        ],
        [
            "LOAD_FAST",
            "[\n                    (name, ', '.join(values))\n                    for name, values in self.comprehension_variables.items()\n                ]"
        ],
        [
            "STORE_FAST",
            "name"
        ],
        [
            "STORE_FAST",
            "values"
        ],
        [
            "LOAD_FAST",
            "name"
        ],
        [
            "LOAD_METHOD",
            "', '.join"
        ],
        [
            "LOAD_FAST",
            "values"
        ],
        [
            "CALL",
            "', '.join(values)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.frame"
        ],
        [
            "STORE_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "STORE_FAST",
            "code"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_varnames"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_cellvars"
        ],
        [
            "BINARY_OP",
            "code.co_varnames + code.co_cellvars"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_freevars"
        ],
        [
            "BINARY_OP",
            "code.co_varnames + code.co_cellvars + code.co_freevars"
        ],
        [
            "LOAD_GLOBAL",
            "tuple"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_locals"
        ],
        [
            "LOAD_METHOD",
            "frame.f_locals.keys"
        ],
        [
            "CALL",
            "frame.f_locals.keys()"
        ],
        [
            "CALL",
            "tuple(frame.f_locals.keys())"
        ],
        [
            "BINARY_OP",
            "code.co_varnames + code.co_cellvars + code.co_freevars + tuple(frame.f_locals.keys())"
        ],
        [
            "STORE_DEREF",
            "vars_order"
        ],
        [
            "LOAD_GLOBAL",
            "sorted"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_locals"
        ],
        [
            "LOAD_METHOD",
            "frame.f_locals.items"
        ],
        [
            "CALL",
            "frame.f_locals.items()"
        ],
        [
            "CALL",
            "sorted(\n            frame.f_locals.items(),\n            key=lambda key_value: vars_order.index(key_value[0])\n        )"
        ],
        [
            "STORE_FAST",
            "result_items"
        ],
        [
            "LOAD_FAST",
            "watch"
        ],
        [
            "STORE_FAST",
            "variable"
        ],
        [
            "LOAD_FAST",
            "result_items"
        ],
        [
            "LOAD_GLOBAL",
            "sorted"
        ],
        [
            "LOAD_FAST",
            "variable"
        ],
        [
            "LOAD_METHOD",
            "variable.items"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "variable.items(frame)"
        ],
        [
            "CALL",
            "sorted(variable.items(frame))"
        ],
        [
            "BINARY_OP",
            "result_items += sorted(variable.items(frame))"
        ],
        [
            "STORE_FAST",
            "result_items"
        ],
        [
            "LOAD_FAST",
            "result_items"
        ],
        [
            "STORE_FAST",
            "source"
        ],
        [
            "STORE_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "LOAD_FAST",
            "watch_extras"
        ],
        [
            "STORE_FAST",
            "extra"
        ],
        [
            "LOAD_FAST",
            "extra"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "value"
        ],
        [
            "CALL",
            "extra(source, value)"
        ],
        [
            "STORE_FAST",
            "pair"
        ],
        [
            "LOAD_FAST",
            "pair"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "pair"
        ],
        [
            "CALL",
            "len(pair)"
        ],
        [
            "COMPARE_OP",
            "len(pair) == 2"
        ],
        [
            "CALL",
            "assert len(pair) == 2, \"Watch extra must return pair or None\""
        ],
        [
            "LOAD_FAST",
            "pair"
        ],
        [
            "LOAD_GLOBAL",
            "Exception"
        ],
        [
            "LOAD_DEREF",
            "vars_order"
        ],
        [
            "LOAD_METHOD",
            "vars_order.index"
        ],
        [
            "LOAD_FAST",
            "key_value"
        ],
        [
            "BINARY_SUBSCR",
            "key_value[0]"
        ],
        [
            "CALL",
            "vars_order.index(key_value[0])"
        ],
        [
            "STORE_NAME",
            "    def __new__(mcs, *args, **kwargs):\n        result = super(TracerMeta, mcs).__new__(mcs, *args, **kwargs)\n        result.default = result()\n        return result"
        ],
        [
            "STORE_NAME",
            "    def __call__(cls, *args, **kwargs):\n        if no_args_decorator(args, kwargs):\n            return cls.default(args[0])\n        else:\n            return super(TracerMeta, cls).__call__(*args, **kwargs)"
        ],
        [
            "STORE_NAME",
            "    def __enter__(self):\n        return self.default.__enter__(context=1)"
        ],
        [
            "STORE_NAME",
            "    def __exit__(self, *args):\n        return self.default.__exit__(*args, context=1)"
        ],
        [
            "STORE_NAME",
            "    def __exit__(self, *args):\n        return self.default.__exit__(*args, context=1)"
        ],
        [
            "LOAD_GLOBAL",
            "super"
        ],
        [
            "LOAD_GLOBAL",
            "TracerMeta"
        ],
        [
            "LOAD_FAST",
            "mcs"
        ],
        [
            "CALL",
            "super(TracerMeta, mcs)"
        ],
        [
            "LOAD_ATTR",
            "super(TracerMeta, mcs).__new__"
        ],
        [
            "LOAD_FAST",
            "mcs"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_FAST",
            "kwargs"
        ],
        [
            "CALL_FUNCTION_EX",
            "super(TracerMeta, mcs).__new__(mcs, *args, **kwargs)"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "CALL",
            "result()"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "STORE_ATTR",
            "result.default"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_GLOBAL",
            "no_args_decorator"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_FAST",
            "kwargs"
        ],
        [
            "CALL",
            "no_args_decorator(args, kwargs)"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "LOAD_METHOD",
            "cls.default"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "BINARY_SUBSCR",
            "args[0]"
        ],
        [
            "CALL",
            "cls.default(args[0])"
        ],
        [
            "LOAD_GLOBAL",
            "super"
        ],
        [
            "LOAD_GLOBAL",
            "TracerMeta"
        ],
        [
            "LOAD_FAST",
            "cls"
        ],
        [
            "CALL",
            "super(TracerMeta, cls)"
        ],
        [
            "LOAD_ATTR",
            "super(TracerMeta, cls).__call__"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_FAST",
            "kwargs"
        ],
        [
            "CALL_FUNCTION_EX",
            "super(TracerMeta, cls).__call__(*args, **kwargs)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.default"
        ],
        [
            "LOAD_METHOD",
            "self.default.__enter__"
        ],
        [
            "CALL",
            "self.default.__enter__(context=1)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.default"
        ],
        [
            "LOAD_ATTR",
            "self.default.__exit__"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "CALL_FUNCTION_EX",
            "self.default.__exit__(*args, context=1)"
        ],
        [
            "STORE_NAME",
            "    def __init__(\n            self,\n            watch=(),\n            watch_explode=(),\n            depth=1,\n    ):\n        self.watch = [\n            v if isinstance(v, BaseVariable) else CommonVariable(v)\n            for v in ensure_tuple(watch)\n        ] + [\n            v if isinstance(v, BaseVariable) else Exploding(v)\n            for v in ensure_tuple(watch_explode)\n        ]\n        self.frame_infos = ArgDefaultDict(FrameInfo)\n        self.depth = depth\n        assert self.depth >= 1\n        self.target_codes = set()\n        self.target_frames = set()"
        ],
        [
            "STORE_NAME",
            "    def __call__(self, function):\n        if iscoroutinefunction(function):\n            raise NotImplementedError(\"coroutines are not supported, sorry!\")\n\n        self.target_codes.add(function.__code__)\n\n        @functools.wraps(function)\n        def simple_wrapper(*args, **kwargs):\n            with self:\n                return function(*args, **kwargs)\n\n        @functools.wraps(function)\n        def generator_wrapper(*args, **kwargs):\n            gen = function(*args, **kwargs)\n            method, incoming = gen.send, None\n            while True:\n                with self:\n                    try:\n                        outgoing = method(incoming)\n                    except StopIteration:\n                        return\n                try:\n                    method, incoming = gen.send, (yield outgoing)\n                except Exception as e:\n                    method, incoming = gen.throw, e\n\n        if inspect.isgeneratorfunction(function):\n            return generator_wrapper\n        else:\n            return simple_wrapper"
        ],
        [
            "STORE_NAME",
            "    def __enter__(self, context=0):\n        if not self.config.enabled:\n            return\n\n        calling_frame = sys._getframe(context + 1)\n        if not self._is_internal_frame(calling_frame):\n            calling_frame.f_trace = self.trace\n            self.target_frames.add(calling_frame)\n            self.config.last_frame = calling_frame\n            self.trace(calling_frame, 'enter', None)\n\n        stack = thread_global.__dict__.setdefault('original_trace_functions', [])\n        stack.append(sys.gettrace())\n        sys.settrace(self.trace)"
        ],
        [
            "STORE_NAME",
            "    def __exit__(self, exc_type, exc_value, exc_traceback, context=0):\n        if not self.config.enabled:\n            return\n\n        stack = thread_global.original_trace_functions\n        sys.settrace(stack.pop())\n        calling_frame = sys._getframe(context + 1)\n        self.trace(calling_frame, 'exit', None)\n        self.target_frames.discard(calling_frame)\n        self.frame_infos.pop(calling_frame, None)"
        ],
        [
            "STORE_NAME",
            "    def _is_internal_frame(self, frame):\n        return frame.f_code.co_filename.startswith(internal_directories)"
        ],
        [
            "STORE_NAME",
            "    def _is_traced_frame(self, frame):\n        return frame.f_code in self.target_codes or frame in self.target_frames"
        ],
        [
            "STORE_NAME",
            "    def trace(self, frame, event, arg):\n        if not self._is_traced_frame(frame):\n            if (\n                    self.depth == 1\n                    or self._is_internal_frame(frame)\n            ) and not is_comprehension_frame(frame):\n                return None\n            else:\n                candidate = frame\n                i = 0\n                while True:\n                    if is_comprehension_frame(candidate):\n                        candidate = candidate.f_back\n                        continue\n                    i += 1\n                    if self._is_traced_frame(candidate):\n                        break\n                    candidate = candidate.f_back\n                    if i >= self.depth or candidate is None or self._is_internal_frame(candidate):\n                        return None\n\n        thread_local = self.config.thread_local\n        thread_local.__dict__.setdefault('depth', -1)\n        frame_info = self.frame_infos[frame]\n        if event in ('call', 'enter'):\n            thread_local.depth += 1\n        elif self.config.last_frame and self.config.last_frame is not frame:\n            line_no = frame_info.last_line_no\n            trace_event = Event(frame_info, event, arg, thread_local.depth, line_no=line_no)\n            line = self.config.formatter.format_line_only(trace_event)\n            self.config.write(line)\n\n        if event == 'exception':\n            frame_info.had_exception = True\n\n        self.config.last_frame = frame\n\n        trace_event = Event(frame_info, event, arg, thread_local.depth)\n        if not (frame.f_code.co_name == '<genexpr>' and event not in ('return', 'exception')):\n            trace_event.variables = frame_info.update_variables(\n                self.watch,\n                self.config.watch_extras,\n                event,\n            )\n\n        if event in ('return', 'exit'):\n            del self.frame_infos[frame]\n            thread_local.depth -= 1\n\n        formatted = self.config.formatter.format(trace_event)\n        self.config.write(formatted)\n\n        return self.trace"
        ],
        [
            "LOAD_GLOBAL",
            "ensure_tuple"
        ],
        [
            "LOAD_FAST",
            "watch"
        ],
        [
            "CALL",
            "ensure_tuple(watch)"
        ],
        [
            "CALL",
            "[\n            v if isinstance(v, BaseVariable) else CommonVariable(v)\n            for v in ensure_tuple(watch)\n        ]"
        ],
        [
            "LOAD_GLOBAL",
            "ensure_tuple"
        ],
        [
            "LOAD_FAST",
            "watch_explode"
        ],
        [
            "CALL",
            "ensure_tuple(watch_explode)"
        ],
        [
            "CALL",
            "[\n            v if isinstance(v, BaseVariable) else Exploding(v)\n            for v in ensure_tuple(watch_explode)\n        ]"
        ],
        [
            "BINARY_OP",
            "[\n            v if isinstance(v, BaseVariable) else CommonVariable(v)\n            for v in ensure_tuple(watch)\n        ] + [\n            v if isinstance(v, BaseVariable) else Exploding(v)\n            for v in ensure_tuple(watch_explode)\n        ]"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.watch"
        ],
        [
            "LOAD_GLOBAL",
            "ArgDefaultDict"
        ],
        [
            "LOAD_GLOBAL",
            "FrameInfo"
        ],
        [
            "CALL",
            "ArgDefaultDict(FrameInfo)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.frame_infos"
        ],
        [
            "LOAD_FAST",
            "depth"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.depth"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.depth"
        ],
        [
            "COMPARE_OP",
            "self.depth >= 1"
        ],
        [
            "LOAD_GLOBAL",
            "set"
        ],
        [
            "CALL",
            "set()"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.target_codes"
        ],
        [
            "LOAD_GLOBAL",
            "set"
        ],
        [
            "CALL",
            "set()"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.target_frames"
        ],
        [
            "LOAD_FAST",
            "[\n            v if isinstance(v, BaseVariable) else CommonVariable(v)\n            for v in ensure_tuple(watch)\n        ]"
        ],
        [
            "STORE_FAST",
            "v"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "LOAD_GLOBAL",
            "BaseVariable"
        ],
        [
            "CALL",
            "isinstance(v, BaseVariable)"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "LOAD_GLOBAL",
            "CommonVariable"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "CALL",
            "CommonVariable(v)"
        ],
        [
            "LOAD_FAST",
            "[\n            v if isinstance(v, BaseVariable) else Exploding(v)\n            for v in ensure_tuple(watch_explode)\n        ]"
        ],
        [
            "STORE_FAST",
            "v"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "LOAD_GLOBAL",
            "BaseVariable"
        ],
        [
            "CALL",
            "isinstance(v, BaseVariable)"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "LOAD_GLOBAL",
            "Exploding"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "CALL",
            "Exploding(v)"
        ],
        [
            "LOAD_GLOBAL",
            "iscoroutinefunction"
        ],
        [
            "LOAD_DEREF",
            "function"
        ],
        [
            "CALL",
            "iscoroutinefunction(function)"
        ],
        [
            "LOAD_GLOBAL",
            "NotImplementedError"
        ],
        [
            "CALL",
            "NotImplementedError(\"coroutines are not supported, sorry!\")"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.target_codes"
        ],
        [
            "LOAD_METHOD",
            "self.target_codes.add"
        ],
        [
            "LOAD_DEREF",
            "function"
        ],
        [
            "LOAD_ATTR",
            "function.__code__"
        ],
        [
            "CALL",
            "self.target_codes.add(function.__code__)"
        ],
        [
            "LOAD_GLOBAL",
            "functools"
        ],
        [
            "LOAD_ATTR",
            "functools.wraps"
        ],
        [
            "LOAD_DEREF",
            "function"
        ],
        [
            "CALL",
            "functools.wraps(function)"
        ],
        [
            "CALL",
            "functools.wraps(function)"
        ],
        [
            "STORE_FAST",
            "        @functools.wraps(function)\n        def simple_wrapper(*args, **kwargs):\n            with self:\n                return function(*args, **kwargs)"
        ],
        [
            "LOAD_GLOBAL",
            "functools"
        ],
        [
            "LOAD_ATTR",
            "functools.wraps"
        ],
        [
            "LOAD_DEREF",
            "function"
        ],
        [
            "CALL",
            "functools.wraps(function)"
        ],
        [
            "CALL",
            "functools.wraps(function)"
        ],
        [
            "STORE_FAST",
            "        @functools.wraps(function)\n        def generator_wrapper(*args, **kwargs):\n            gen = function(*args, **kwargs)\n            method, incoming = gen.send, None\n            while True:\n                with self:\n                    try:\n                        outgoing = method(incoming)\n                    except StopIteration:\n                        return\n                try:\n                    method, incoming = gen.send, (yield outgoing)\n                except Exception as e:\n                    method, incoming = gen.throw, e"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.isgeneratorfunction"
        ],
        [
            "LOAD_DEREF",
            "function"
        ],
        [
            "CALL",
            "inspect.isgeneratorfunction(function)"
        ],
        [
            "LOAD_FAST",
            "generator_wrapper"
        ],
        [
            "LOAD_FAST",
            "simple_wrapper"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_DEREF",
            "function"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_FAST",
            "kwargs"
        ],
        [
            "CALL_FUNCTION_EX",
            "function(*args, **kwargs)"
        ],
        [
            "CALL",
            "            with self:\n                return function(*args, **kwargs)"
        ],
        [
            "LOAD_DEREF",
            "function"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_FAST",
            "kwargs"
        ],
        [
            "CALL_FUNCTION_EX",
            "function(*args, **kwargs)"
        ],
        [
            "STORE_FAST",
            "gen"
        ],
        [
            "LOAD_FAST",
            "gen"
        ],
        [
            "LOAD_ATTR",
            "gen.send"
        ],
        [
            "STORE_FAST",
            "incoming"
        ],
        [
            "STORE_FAST",
            "method"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_FAST",
            "method"
        ],
        [
            "LOAD_FAST",
            "incoming"
        ],
        [
            "CALL",
            "method(incoming)"
        ],
        [
            "STORE_FAST",
            "outgoing"
        ],
        [
            "LOAD_GLOBAL",
            "StopIteration"
        ],
        [
            "CALL",
            "                with self:\n                    try:\n                        outgoing = method(incoming)\n                    except StopIteration:\n                        return"
        ],
        [
            "CALL",
            "                with self:\n                    try:\n                        outgoing = method(incoming)\n                    except StopIteration:\n                        return"
        ],
        [
            "LOAD_FAST",
            "gen"
        ],
        [
            "LOAD_ATTR",
            "gen.send"
        ],
        [
            "LOAD_FAST",
            "outgoing"
        ],
        [
            "STORE_FAST",
            "incoming"
        ],
        [
            "STORE_FAST",
            "method"
        ],
        [
            "LOAD_GLOBAL",
            "Exception"
        ],
        [
            "STORE_FAST",
            "                except Exception as e:\n                    method, incoming = gen.throw, e"
        ],
        [
            "LOAD_FAST",
            "gen"
        ],
        [
            "LOAD_ATTR",
            "gen.throw"
        ],
        [
            "LOAD_FAST",
            "e"
        ],
        [
            "STORE_FAST",
            "incoming"
        ],
        [
            "STORE_FAST",
            "method"
        ],
        [
            "STORE_FAST",
            "method"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.enabled"
        ],
        [
            "LOAD_GLOBAL",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys._getframe"
        ],
        [
            "LOAD_FAST",
            "context"
        ],
        [
            "BINARY_OP",
            "context + 1"
        ],
        [
            "CALL",
            "sys._getframe(context + 1)"
        ],
        [
            "STORE_FAST",
            "calling_frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._is_internal_frame"
        ],
        [
            "LOAD_FAST",
            "calling_frame"
        ],
        [
            "CALL",
            "self._is_internal_frame(calling_frame)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.trace"
        ],
        [
            "LOAD_FAST",
            "calling_frame"
        ],
        [
            "STORE_ATTR",
            "calling_frame.f_trace"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.target_frames"
        ],
        [
            "LOAD_METHOD",
            "self.target_frames.add"
        ],
        [
            "LOAD_FAST",
            "calling_frame"
        ],
        [
            "CALL",
            "self.target_frames.add(calling_frame)"
        ],
        [
            "LOAD_FAST",
            "calling_frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "STORE_ATTR",
            "self.config.last_frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.trace"
        ],
        [
            "LOAD_FAST",
            "calling_frame"
        ],
        [
            "CALL",
            "self.trace(calling_frame, 'enter', None)"
        ],
        [
            "LOAD_GLOBAL",
            "thread_global"
        ],
        [
            "LOAD_ATTR",
            "thread_global.__dict__"
        ],
        [
            "LOAD_METHOD",
            "thread_global.__dict__.setdefault"
        ],
        [
            "CALL",
            "thread_global.__dict__.setdefault('original_trace_functions', [])"
        ],
        [
            "STORE_FAST",
            "stack"
        ],
        [
            "LOAD_FAST",
            "stack"
        ],
        [
            "LOAD_METHOD",
            "stack.append"
        ],
        [
            "LOAD_GLOBAL",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.gettrace"
        ],
        [
            "CALL",
            "sys.gettrace()"
        ],
        [
            "CALL",
            "stack.append(sys.gettrace())"
        ],
        [
            "LOAD_GLOBAL",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.settrace"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.trace"
        ],
        [
            "CALL",
            "sys.settrace(self.trace)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.enabled"
        ],
        [
            "LOAD_GLOBAL",
            "thread_global"
        ],
        [
            "LOAD_ATTR",
            "thread_global.original_trace_functions"
        ],
        [
            "STORE_FAST",
            "stack"
        ],
        [
            "LOAD_GLOBAL",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.settrace"
        ],
        [
            "LOAD_FAST",
            "stack"
        ],
        [
            "LOAD_METHOD",
            "stack.pop"
        ],
        [
            "CALL",
            "stack.pop()"
        ],
        [
            "CALL",
            "sys.settrace(stack.pop())"
        ],
        [
            "LOAD_GLOBAL",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys._getframe"
        ],
        [
            "LOAD_FAST",
            "context"
        ],
        [
            "BINARY_OP",
            "context + 1"
        ],
        [
            "CALL",
            "sys._getframe(context + 1)"
        ],
        [
            "STORE_FAST",
            "calling_frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.trace"
        ],
        [
            "LOAD_FAST",
            "calling_frame"
        ],
        [
            "CALL",
            "self.trace(calling_frame, 'exit', None)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.target_frames"
        ],
        [
            "LOAD_METHOD",
            "self.target_frames.discard"
        ],
        [
            "LOAD_FAST",
            "calling_frame"
        ],
        [
            "CALL",
            "self.target_frames.discard(calling_frame)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.frame_infos"
        ],
        [
            "LOAD_METHOD",
            "self.frame_infos.pop"
        ],
        [
            "LOAD_FAST",
            "calling_frame"
        ],
        [
            "CALL",
            "self.frame_infos.pop(calling_frame, None)"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_filename"
        ],
        [
            "LOAD_METHOD",
            "frame.f_code.co_filename.startswith"
        ],
        [
            "LOAD_GLOBAL",
            "internal_directories"
        ],
        [
            "CALL",
            "frame.f_code.co_filename.startswith(internal_directories)"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.target_codes"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code in self.target_codes"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.target_frames"
        ],
        [
            "CONTAINS_OP",
            "frame in self.target_frames"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._is_traced_frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "self._is_traced_frame(frame)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.depth"
        ],
        [
            "COMPARE_OP",
            "self.depth == 1"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._is_internal_frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "self._is_internal_frame(frame)"
        ],
        [
            "LOAD_GLOBAL",
            "is_comprehension_frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "CALL",
            "is_comprehension_frame(frame)"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "STORE_FAST",
            "candidate"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "LOAD_GLOBAL",
            "is_comprehension_frame"
        ],
        [
            "LOAD_FAST",
            "candidate"
        ],
        [
            "CALL",
            "is_comprehension_frame(candidate)"
        ],
        [
            "LOAD_FAST",
            "candidate"
        ],
        [
            "LOAD_ATTR",
            "candidate.f_back"
        ],
        [
            "STORE_FAST",
            "candidate"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_OP",
            "i += 1"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._is_traced_frame"
        ],
        [
            "LOAD_FAST",
            "candidate"
        ],
        [
            "CALL",
            "self._is_traced_frame(candidate)"
        ],
        [
            "LOAD_FAST",
            "candidate"
        ],
        [
            "LOAD_ATTR",
            "candidate.f_back"
        ],
        [
            "STORE_FAST",
            "candidate"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.depth"
        ],
        [
            "COMPARE_OP",
            "i >= self.depth"
        ],
        [
            "LOAD_FAST",
            "candidate"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._is_internal_frame"
        ],
        [
            "LOAD_FAST",
            "candidate"
        ],
        [
            "CALL",
            "self._is_internal_frame(candidate)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.thread_local"
        ],
        [
            "STORE_FAST",
            "thread_local"
        ],
        [
            "LOAD_FAST",
            "thread_local"
        ],
        [
            "LOAD_ATTR",
            "thread_local.__dict__"
        ],
        [
            "LOAD_METHOD",
            "thread_local.__dict__.setdefault"
        ],
        [
            "CALL",
            "thread_local.__dict__.setdefault('depth', -1)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.frame_infos"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "BINARY_SUBSCR",
            "self.frame_infos[frame]"
        ],
        [
            "STORE_FAST",
            "frame_info"
        ],
        [
            "LOAD_FAST",
            "event"
        ],
        [
            "CONTAINS_OP",
            "event in ('call', 'enter')"
        ],
        [
            "LOAD_FAST",
            "thread_local"
        ],
        [
            "LOAD_ATTR",
            "thread_local.depth"
        ],
        [
            "BINARY_OP",
            "thread_local.depth += 1"
        ],
        [
            "STORE_ATTR",
            "thread_local.depth"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.last_frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.last_frame"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "IS_OP",
            "self.config.last_frame is not frame"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_ATTR",
            "frame_info.last_line_no"
        ],
        [
            "STORE_FAST",
            "line_no"
        ],
        [
            "LOAD_GLOBAL",
            "Event"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_FAST",
            "event"
        ],
        [
            "LOAD_FAST",
            "arg"
        ],
        [
            "LOAD_FAST",
            "thread_local"
        ],
        [
            "LOAD_ATTR",
            "thread_local.depth"
        ],
        [
            "LOAD_FAST",
            "line_no"
        ],
        [
            "CALL",
            "Event(frame_info, event, arg, thread_local.depth, line_no=line_no)"
        ],
        [
            "STORE_FAST",
            "trace_event"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.formatter"
        ],
        [
            "LOAD_METHOD",
            "self.config.formatter.format_line_only"
        ],
        [
            "LOAD_FAST",
            "trace_event"
        ],
        [
            "CALL",
            "self.config.formatter.format_line_only(trace_event)"
        ],
        [
            "STORE_FAST",
            "line"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_METHOD",
            "self.config.write"
        ],
        [
            "LOAD_FAST",
            "line"
        ],
        [
            "CALL",
            "self.config.write(line)"
        ],
        [
            "LOAD_FAST",
            "event"
        ],
        [
            "COMPARE_OP",
            "event == 'exception'"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "STORE_ATTR",
            "frame_info.had_exception"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "STORE_ATTR",
            "self.config.last_frame"
        ],
        [
            "LOAD_GLOBAL",
            "Event"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_FAST",
            "event"
        ],
        [
            "LOAD_FAST",
            "arg"
        ],
        [
            "LOAD_FAST",
            "thread_local"
        ],
        [
            "LOAD_ATTR",
            "thread_local.depth"
        ],
        [
            "CALL",
            "Event(frame_info, event, arg, thread_local.depth)"
        ],
        [
            "STORE_FAST",
            "trace_event"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_name"
        ],
        [
            "COMPARE_OP",
            "frame.f_code.co_name == '<genexpr>'"
        ],
        [
            "LOAD_FAST",
            "event"
        ],
        [
            "CONTAINS_OP",
            "event not in ('return', 'exception')"
        ],
        [
            "LOAD_FAST",
            "frame_info"
        ],
        [
            "LOAD_METHOD",
            "frame_info.update_variables"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.watch"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.watch_extras"
        ],
        [
            "LOAD_FAST",
            "event"
        ],
        [
            "CALL",
            "frame_info.update_variables(\n                self.watch,\n                self.config.watch_extras,\n                event,\n            )"
        ],
        [
            "LOAD_FAST",
            "trace_event"
        ],
        [
            "STORE_ATTR",
            "trace_event.variables"
        ],
        [
            "LOAD_FAST",
            "event"
        ],
        [
            "CONTAINS_OP",
            "event in ('return', 'exit')"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.frame_infos"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "DELETE_SUBSCR",
            "self.frame_infos[frame]"
        ],
        [
            "LOAD_FAST",
            "thread_local"
        ],
        [
            "LOAD_ATTR",
            "thread_local.depth"
        ],
        [
            "BINARY_OP",
            "thread_local.depth -= 1"
        ],
        [
            "STORE_ATTR",
            "thread_local.depth"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.formatter"
        ],
        [
            "LOAD_METHOD",
            "self.config.formatter.format"
        ],
        [
            "LOAD_FAST",
            "trace_event"
        ],
        [
            "CALL",
            "self.config.formatter.format(trace_event)"
        ],
        [
            "STORE_FAST",
            "formatted"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_METHOD",
            "self.config.write"
        ],
        [
            "LOAD_FAST",
            "formatted"
        ],
        [
            "CALL",
            "self.config.write(formatted)"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.trace"
        ],
        [
            "STORE_NAME",
            "    def __init__(self, config):\n        self.config = config"
        ],
        [
            "STORE_NAME",
            "    def __call__(self, *args, **kwargs):\n        if NO_ASTTOKENS:\n            raise Exception(\"birdseye doesn't support this version of Python\")\n\n        try:\n            import birdseye\n        except ImportError:\n            raise Exception(\"You must install birdseye separately to use spy: pip install birdseye\")\n\n        # Decorator without parentheses\n        if no_args_decorator(args, kwargs):\n            return self._trace(args[0])\n\n        # Decorator with parentheses and perhaps arguments\n        def decorator(func):\n            return self._trace(func, *args, **kwargs)\n\n        return decorator"
        ],
        [
            "STORE_NAME",
            "    def _trace(self, func, *args, **kwargs):\n        # noinspection PyUnresolvedReferences\n        from birdseye import eye\n\n        traced = eye(func)\n        traced = self.config.snoop(*args, **kwargs)(traced)\n\n        @functools.wraps(func)\n        def wrapper(*func_args, **func_kwargs):\n            if self.config.enabled:\n                final_func = traced\n            else:\n                final_func = func\n\n            return final_func(*func_args, **func_kwargs)\n\n        return wrapper"
        ],
        [
            "LOAD_FAST",
            "config"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.config"
        ],
        [
            "LOAD_GLOBAL",
            "NO_ASTTOKENS"
        ],
        [
            "LOAD_GLOBAL",
            "Exception"
        ],
        [
            "CALL",
            "Exception(\"birdseye doesn't support this version of Python\")"
        ],
        [
            "STORE_FAST",
            "import birdseye"
        ],
        [
            "LOAD_GLOBAL",
            "ImportError"
        ],
        [
            "LOAD_GLOBAL",
            "Exception"
        ],
        [
            "CALL",
            "Exception(\"You must install birdseye separately to use spy: pip install birdseye\")"
        ],
        [
            "LOAD_GLOBAL",
            "no_args_decorator"
        ],
        [
            "LOAD_DEREF",
            "args"
        ],
        [
            "LOAD_DEREF",
            "kwargs"
        ],
        [
            "CALL",
            "no_args_decorator(args, kwargs)"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self._trace"
        ],
        [
            "LOAD_DEREF",
            "args"
        ],
        [
            "BINARY_SUBSCR",
            "args[0]"
        ],
        [
            "CALL",
            "self._trace(args[0])"
        ],
        [
            "STORE_FAST",
            "        def decorator(func):\n            return self._trace(func, *args, **kwargs)"
        ],
        [
            "LOAD_FAST",
            "decorator"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self._trace"
        ],
        [
            "LOAD_FAST",
            "func"
        ],
        [
            "LOAD_DEREF",
            "args"
        ],
        [
            "LOAD_DEREF",
            "kwargs"
        ],
        [
            "CALL_FUNCTION_EX",
            "self._trace(func, *args, **kwargs)"
        ],
        [
            "STORE_FAST",
            "from birdseye import eye"
        ],
        [
            "LOAD_FAST",
            "eye"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "CALL",
            "eye(func)"
        ],
        [
            "STORE_DEREF",
            "traced"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.snoop"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_FAST",
            "kwargs"
        ],
        [
            "CALL_FUNCTION_EX",
            "self.config.snoop(*args, **kwargs)"
        ],
        [
            "LOAD_DEREF",
            "traced"
        ],
        [
            "CALL",
            "self.config.snoop(*args, **kwargs)(traced)"
        ],
        [
            "STORE_DEREF",
            "traced"
        ],
        [
            "LOAD_GLOBAL",
            "functools"
        ],
        [
            "LOAD_ATTR",
            "functools.wraps"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "CALL",
            "functools.wraps(func)"
        ],
        [
            "CALL",
            "functools.wraps(func)"
        ],
        [
            "STORE_FAST",
            "        @functools.wraps(func)\n        def wrapper(*func_args, **func_kwargs):\n            if self.config.enabled:\n                final_func = traced\n            else:\n                final_func = func\n\n            return final_func(*func_args, **func_kwargs)"
        ],
        [
            "LOAD_FAST",
            "wrapper"
        ],
        [
            "LOAD_DEREF",
            "self"
        ],
        [
            "LOAD_ATTR",
            "self.config"
        ],
        [
            "LOAD_ATTR",
            "self.config.enabled"
        ],
        [
            "LOAD_DEREF",
            "traced"
        ],
        [
            "STORE_FAST",
            "final_func"
        ],
        [
            "LOAD_DEREF",
            "func"
        ],
        [
            "STORE_FAST",
            "final_func"
        ],
        [
            "LOAD_FAST",
            "final_func"
        ],
        [
            "LOAD_FAST",
            "func_args"
        ],
        [
            "LOAD_FAST",
            "func_kwargs"
        ],
        [
            "CALL_FUNCTION_EX",
            "final_func(*func_args, **func_kwargs)"
        ]
    ],
    "utils.py": [
        [
            "STORE_NAME",
            "from __future__ import print_function, division, absolute_import"
        ],
        [
            "STORE_NAME",
            "from __future__ import print_function, division, absolute_import"
        ],
        [
            "STORE_NAME",
            "from __future__ import print_function, division, absolute_import"
        ],
        [
            "STORE_NAME",
            "import ast"
        ],
        [
            "STORE_NAME",
            "import json"
        ],
        [
            "STORE_NAME",
            "from future import standard_library"
        ],
        [
            "LOAD_NAME",
            "standard_library"
        ],
        [
            "LOAD_ATTR",
            "standard_library.install_aliases"
        ],
        [
            "CALL",
            "standard_library.install_aliases()"
        ],
        [
            "STORE_NAME",
            "import token"
        ],
        [
            "STORE_NAME",
            "from future.utils import raise_from"
        ],
        [
            "STORE_NAME",
            "import ntpath"
        ],
        [
            "STORE_NAME",
            "import os"
        ],
        [
            "STORE_NAME",
            "import types"
        ],
        [
            "STORE_NAME",
            "from sys import version_info"
        ],
        [
            "STORE_NAME",
            "from typing import TypeVar, Union, List, Any, Iterator, Tuple, Iterable"
        ],
        [
            "STORE_NAME",
            "from typing import TypeVar, Union, List, Any, Iterator, Tuple, Iterable"
        ],
        [
            "STORE_NAME",
            "from typing import TypeVar, Union, List, Any, Iterator, Tuple, Iterable"
        ],
        [
            "STORE_NAME",
            "from typing import TypeVar, Union, List, Any, Iterator, Tuple, Iterable"
        ],
        [
            "STORE_NAME",
            "from typing import TypeVar, Union, List, Any, Iterator, Tuple, Iterable"
        ],
        [
            "STORE_NAME",
            "from typing import TypeVar, Union, List, Any, Iterator, Tuple, Iterable"
        ],
        [
            "STORE_NAME",
            "from typing import TypeVar, Union, List, Any, Iterator, Tuple, Iterable"
        ],
        [
            "STORE_NAME",
            "from typing import Type"
        ],
        [
            "LOAD_NAME",
            "ImportError"
        ],
        [
            "LOAD_NAME",
            "type"
        ],
        [
            "STORE_NAME",
            "Type"
        ],
        [
            "STORE_NAME",
            "from typing import Deque"
        ],
        [
            "LOAD_NAME",
            "ImportError"
        ],
        [
            "STORE_NAME",
            "from collections import deque as Deque"
        ],
        [
            "STORE_NAME",
            "from functools import lru_cache"
        ],
        [
            "LOAD_NAME",
            "ImportError"
        ],
        [
            "STORE_NAME",
            "from backports.functools_lru_cache import lru_cache"
        ],
        [
            "STORE_NAME",
            "from littleutils import strip_required_prefix"
        ],
        [
            "LOAD_NAME",
            "version_info"
        ],
        [
            "LOAD_ATTR",
            "version_info.major"
        ],
        [
            "COMPARE_OP",
            "version_info.major == 2"
        ],
        [
            "STORE_NAME",
            "PY2"
        ],
        [
            "LOAD_NAME",
            "PY2"
        ],
        [
            "UNARY_NOT",
            "not PY2"
        ],
        [
            "STORE_NAME",
            "PY3"
        ],
        [
            "LOAD_NAME",
            "TypeVar"
        ],
        [
            "CALL",
            "TypeVar('T')"
        ],
        [
            "STORE_NAME",
            "T"
        ],
        [
            "LOAD_NAME",
            "TypeVar"
        ],
        [
            "CALL",
            "TypeVar('RT')"
        ],
        [
            "STORE_NAME",
            "RT"
        ],
        [
            "STORE_NAME",
            "IPYTHON_FILE_PATH"
        ],
        [
            "STORE_NAME",
            "FILE_SENTINEL_NAME"
        ],
        [
            "LOAD_NAME",
            "PY2"
        ],
        [
            "LOAD_NAME",
            "unicode"
        ],
        [
            "STORE_NAME",
            "Text"
        ],
        [
            "LOAD_NAME",
            "str"
        ],
        [
            "STORE_NAME",
            "Text"
        ],
        [
            "STORE_NAME",
            "def path_leaf(path):\n    # type: (str) -> str\n    # http://stackoverflow.com/a/8384788/2482744\n    head, tail = ntpath.split(path)\n    return tail or ntpath.basename(head)"
        ],
        [
            "STORE_NAME",
            "def common_ancestor(paths):\n    # type: (List[str]) -> str\n    \"\"\"\n    Returns a path to a directory that contains all the given absolute paths\n    \"\"\"\n    prefix = os.path.commonprefix(paths)\n\n    # Ensure that the prefix doesn't end in part of the name of a file/directory\n    prefix = ntpath.split(prefix)[0]\n\n    # Ensure that it ends with a slash\n    first_char_after = paths[0][len(prefix)]\n    if first_char_after in r'\\/':\n        prefix += first_char_after\n\n    return prefix"
        ],
        [
            "STORE_NAME",
            "def short_path(path, all_paths):\n    # type: (str, List[str]) -> str\n    if path == IPYTHON_FILE_PATH:\n        return path\n\n    all_paths = [f for f in all_paths\n                 if f != IPYTHON_FILE_PATH]\n    prefix = common_ancestor(all_paths)\n    if prefix in r'\\/':\n        prefix = ''\n    return strip_required_prefix(path, prefix) or path_leaf(path)"
        ],
        [
            "STORE_NAME",
            "def fix_abs_path(path):\n    if path == IPYTHON_FILE_PATH:\n        return path\n    if os.path.sep == '/' and not path.startswith('/'):\n        path = '/' + path\n    return path"
        ],
        [
            "LOAD_NAME",
            "PY2"
        ],
        [
            "STORE_NAME",
            "    def correct_type(obj):\n        \"\"\"\n        Returns the correct type of obj, regardless of __class__ assignment\n        or old-style classes:\n\n        >>> class A:\n        ...     pass\n        ...\n        ...\n        ... class B(object):\n        ...     pass\n        ...\n        ...\n        ... class C(object):\n        ...     __class__ = A\n        ...\n        >>> correct_type(A()) is A\n        True\n        >>> correct_type(B()) is B\n        True\n        >>> correct_type(C()) is C\n        True\n        \"\"\"\n        t = type(obj)\n        # noinspection PyUnresolvedReferences\n        if t is types.InstanceType:\n            return obj.__class__\n        return t"
        ],
        [
            "LOAD_NAME",
            "type"
        ],
        [
            "STORE_NAME",
            "correct_type"
        ],
        [
            "STORE_NAME",
            "def of_type(type_or_tuple, iterable):\n    # type: (Union[type, Tuple[Union[type, tuple], ...]], Iterable[Any]) -> Iterator[Any]\n    return (x for x in iterable if isinstance(x, type_or_tuple))"
        ],
        [
            "STORE_NAME",
            "def safe_next(it):\n    # type: (Iterator[T]) -> T\n    \"\"\"\n    next() can raise a StopIteration which can cause strange bugs inside generators.\n    \"\"\"\n    try:\n        return next(it)\n    except StopIteration as e:\n        raise_from(RuntimeError, e)\n        raise"
        ],
        [
            "STORE_NAME",
            "def one_or_none(expression):\n    \"\"\"Performs a one_or_none on a sqlalchemy expression.\"\"\"\n    if hasattr(expression, 'one_or_none'):\n        return expression.one_or_none()\n    result = expression.all()\n    if len(result) == 0:\n        return None\n    elif len(result) == 1:\n        return result[0]\n    else:\n        raise Exception(\"There is more than one item returned for the supplied filter\")"
        ],
        [
            "STORE_NAME",
            "def flatten_list(lst):\n    result = []\n    for x in lst:\n        if isinstance(x, list):\n            result.extend(flatten_list(x))\n        else:\n            result.append(x)\n    return result"
        ],
        [
            "STORE_NAME",
            "def is_lambda(f):\n    try:\n        code = f.__code__\n    except AttributeError:\n        return False\n    return code.co_name == (lambda: 0).__code__.co_name"
        ],
        [
            "LOAD_NAME",
            "json"
        ],
        [
            "LOAD_ATTR",
            "json.JSONEncoder"
        ],
        [
            "CALL",
            "class ProtocolEncoder(json.JSONEncoder):\n    def default(self, o):\n        try:\n            method = o.as_json\n        except AttributeError:\n            return super(ProtocolEncoder, self).default(o)\n        else:\n            return method()"
        ],
        [
            "STORE_NAME",
            "class ProtocolEncoder(json.JSONEncoder):\n    def default(self, o):\n        try:\n            method = o.as_json\n        except AttributeError:\n            return super(ProtocolEncoder, self).default(o)\n        else:\n            return method()"
        ],
        [
            "STORE_NAME",
            "from tokenize import open as open_with_encoding_check"
        ],
        [
            "LOAD_NAME",
            "ImportError"
        ],
        [
            "STORE_NAME",
            "from lib2to3.pgen2.tokenize import detect_encoding"
        ],
        [
            "STORE_NAME",
            "import io"
        ],
        [
            "STORE_NAME",
            "    def open_with_encoding_check(filename):  # type: ignore\n        \"\"\"Open a file in read only mode using the encoding detected by\n        detect_encoding().\n        \"\"\"\n        fp = io.open(filename, 'rb')\n        try:\n            encoding, lines = detect_encoding(fp.readline)\n            fp.seek(0)\n            text = io.TextIOWrapper(fp, encoding, line_buffering=True)\n            text.mode = 'r'\n            return text\n        except:\n            fp.close()\n            raise"
        ],
        [
            "STORE_NAME",
            "def read_source_file(filename):\n    from lib2to3.pgen2.tokenize import cookie_re\n\n    if filename.endswith('.pyc'):\n        filename = filename[:-1]\n\n    with open_with_encoding_check(filename) as f:\n        return ''.join([\n            '\\n' if i < 2 and cookie_re.match(line)\n            else line\n            for i, line in enumerate(f)\n        ])"
        ],
        [
            "STORE_NAME",
            "def source_without_decorators(tokens, function_node):\n    def_token = safe_next(t for t in tokens.get_tokens(function_node)\n                          if t.string == 'def' and t.type == token.NAME)\n\n    startpos = def_token.startpos\n    source = tokens.text[startpos:function_node.last_token.endpos].rstrip()\n    assert source.startswith('def')\n\n    return startpos, source"
        ],
        [
            "STORE_NAME",
            "def prn(*args):\n    for arg in args:\n        print(arg)\n    if len(args) == 1:\n        return args[0]\n    return args"
        ],
        [
            "STORE_NAME",
            "def is_ipython_cell(filename):\n    return filename.startswith('<ipython-input-')"
        ],
        [
            "STORE_NAME",
            "def is_future_import(node):\n    return isinstance(node, ast.ImportFrom) and node.module == \"__future__\""
        ],
        [
            "STORE_NAME",
            "def get_unfrozen_datetime():\n    try:\n        # if freezegun could be active, we need to use real_datetime to ensure we use the actual time instead of the\n        # time set by freezegun.\n        # we have to import this at the last possible moment because birdeye is very likely to be imported before\n        # freezegun is activated.\n        from freezegun.api import real_datetime\n    except ImportError:\n        from datetime import datetime as real_datetime\n\n    return real_datetime.now()"
        ],
        [
            "LOAD_GLOBAL",
            "ntpath"
        ],
        [
            "LOAD_ATTR",
            "ntpath.split"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "CALL",
            "ntpath.split(path)"
        ],
        [
            "STORE_FAST",
            "head"
        ],
        [
            "STORE_FAST",
            "tail"
        ],
        [
            "LOAD_FAST",
            "tail"
        ],
        [
            "LOAD_GLOBAL",
            "ntpath"
        ],
        [
            "LOAD_ATTR",
            "ntpath.basename"
        ],
        [
            "LOAD_FAST",
            "head"
        ],
        [
            "CALL",
            "ntpath.basename(head)"
        ],
        [
            "LOAD_GLOBAL",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.commonprefix"
        ],
        [
            "LOAD_FAST",
            "paths"
        ],
        [
            "CALL",
            "os.path.commonprefix(paths)"
        ],
        [
            "STORE_FAST",
            "prefix"
        ],
        [
            "LOAD_GLOBAL",
            "ntpath"
        ],
        [
            "LOAD_ATTR",
            "ntpath.split"
        ],
        [
            "LOAD_FAST",
            "prefix"
        ],
        [
            "CALL",
            "ntpath.split(prefix)"
        ],
        [
            "BINARY_SUBSCR",
            "ntpath.split(prefix)[0]"
        ],
        [
            "STORE_FAST",
            "prefix"
        ],
        [
            "LOAD_FAST",
            "paths"
        ],
        [
            "BINARY_SUBSCR",
            "paths[0]"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "prefix"
        ],
        [
            "CALL",
            "len(prefix)"
        ],
        [
            "BINARY_SUBSCR",
            "paths[0][len(prefix)]"
        ],
        [
            "STORE_FAST",
            "first_char_after"
        ],
        [
            "LOAD_FAST",
            "first_char_after"
        ],
        [
            "CONTAINS_OP",
            "first_char_after in r'\\/'"
        ],
        [
            "LOAD_FAST",
            "prefix"
        ],
        [
            "LOAD_FAST",
            "first_char_after"
        ],
        [
            "BINARY_OP",
            "prefix += first_char_after"
        ],
        [
            "STORE_FAST",
            "prefix"
        ],
        [
            "LOAD_FAST",
            "prefix"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_GLOBAL",
            "IPYTHON_FILE_PATH"
        ],
        [
            "COMPARE_OP",
            "path == IPYTHON_FILE_PATH"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_FAST",
            "all_paths"
        ],
        [
            "CALL",
            "[f for f in all_paths\n                 if f != IPYTHON_FILE_PATH]"
        ],
        [
            "STORE_FAST",
            "all_paths"
        ],
        [
            "LOAD_GLOBAL",
            "common_ancestor"
        ],
        [
            "LOAD_FAST",
            "all_paths"
        ],
        [
            "CALL",
            "common_ancestor(all_paths)"
        ],
        [
            "STORE_FAST",
            "prefix"
        ],
        [
            "LOAD_FAST",
            "prefix"
        ],
        [
            "CONTAINS_OP",
            "prefix in r'\\/'"
        ],
        [
            "STORE_FAST",
            "prefix"
        ],
        [
            "LOAD_GLOBAL",
            "strip_required_prefix"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_FAST",
            "prefix"
        ],
        [
            "CALL",
            "strip_required_prefix(path, prefix)"
        ],
        [
            "LOAD_GLOBAL",
            "path_leaf"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "CALL",
            "path_leaf(path)"
        ],
        [
            "LOAD_FAST",
            "[f for f in all_paths\n                 if f != IPYTHON_FILE_PATH]"
        ],
        [
            "STORE_FAST",
            "f"
        ],
        [
            "LOAD_FAST",
            "f"
        ],
        [
            "LOAD_GLOBAL",
            "IPYTHON_FILE_PATH"
        ],
        [
            "COMPARE_OP",
            "f != IPYTHON_FILE_PATH"
        ],
        [
            "LOAD_FAST",
            "f"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_GLOBAL",
            "IPYTHON_FILE_PATH"
        ],
        [
            "COMPARE_OP",
            "path == IPYTHON_FILE_PATH"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_GLOBAL",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_ATTR",
            "os.path.sep"
        ],
        [
            "COMPARE_OP",
            "os.path.sep == '/'"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_METHOD",
            "path.startswith"
        ],
        [
            "CALL",
            "path.startswith('/')"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "BINARY_OP",
            "'/' + path"
        ],
        [
            "STORE_FAST",
            "path"
        ],
        [
            "LOAD_FAST",
            "path"
        ],
        [
            "LOAD_GLOBAL",
            "type"
        ],
        [
            "LOAD_FAST",
            "obj"
        ],
        [
            "CALL",
            "type(obj)"
        ],
        [
            "STORE_FAST",
            "t"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "LOAD_GLOBAL",
            "types"
        ],
        [
            "LOAD_ATTR",
            "types.InstanceType"
        ],
        [
            "IS_OP",
            "t is types.InstanceType"
        ],
        [
            "LOAD_FAST",
            "obj"
        ],
        [
            "LOAD_ATTR",
            "obj.__class__"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "LOAD_FAST",
            "iterable"
        ],
        [
            "CALL",
            "(x for x in iterable if isinstance(x, type_or_tuple))"
        ],
        [
            "LOAD_FAST",
            "(x for x in iterable if isinstance(x, type_or_tuple))"
        ],
        [
            "STORE_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_DEREF",
            "type_or_tuple"
        ],
        [
            "CALL",
            "isinstance(x, type_or_tuple)"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "next"
        ],
        [
            "LOAD_FAST",
            "it"
        ],
        [
            "CALL",
            "next(it)"
        ],
        [
            "LOAD_GLOBAL",
            "StopIteration"
        ],
        [
            "STORE_FAST",
            "    except StopIteration as e:\n        raise_from(RuntimeError, e)\n        raise"
        ],
        [
            "LOAD_GLOBAL",
            "raise_from"
        ],
        [
            "LOAD_GLOBAL",
            "RuntimeError"
        ],
        [
            "LOAD_FAST",
            "e"
        ],
        [
            "CALL",
            "raise_from(RuntimeError, e)"
        ],
        [
            "LOAD_GLOBAL",
            "hasattr"
        ],
        [
            "LOAD_FAST",
            "expression"
        ],
        [
            "CALL",
            "hasattr(expression, 'one_or_none')"
        ],
        [
            "LOAD_FAST",
            "expression"
        ],
        [
            "LOAD_METHOD",
            "expression.one_or_none"
        ],
        [
            "CALL",
            "expression.one_or_none()"
        ],
        [
            "LOAD_FAST",
            "expression"
        ],
        [
            "LOAD_METHOD",
            "expression.all"
        ],
        [
            "CALL",
            "expression.all()"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "CALL",
            "len(result)"
        ],
        [
            "COMPARE_OP",
            "len(result) == 0"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "CALL",
            "len(result)"
        ],
        [
            "COMPARE_OP",
            "len(result) == 1"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "BINARY_SUBSCR",
            "result[0]"
        ],
        [
            "LOAD_GLOBAL",
            "Exception"
        ],
        [
            "CALL",
            "Exception(\"There is more than one item returned for the supplied filter\")"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "lst"
        ],
        [
            "STORE_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "CALL",
            "isinstance(x, list)"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_METHOD",
            "result.extend"
        ],
        [
            "LOAD_GLOBAL",
            "flatten_list"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "flatten_list(x)"
        ],
        [
            "CALL",
            "result.extend(flatten_list(x))"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_METHOD",
            "result.append"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "result.append(x)"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "f"
        ],
        [
            "LOAD_ATTR",
            "f.__code__"
        ],
        [
            "STORE_FAST",
            "code"
        ],
        [
            "LOAD_GLOBAL",
            "AttributeError"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_name"
        ],
        [
            "LOAD_ATTR",
            "(lambda: 0).__code__"
        ],
        [
            "LOAD_ATTR",
            "(lambda: 0).__code__.co_name"
        ],
        [
            "COMPARE_OP",
            "code.co_name == (lambda: 0).__code__.co_name"
        ],
        [
            "STORE_NAME",
            "    def default(self, o):\n        try:\n            method = o.as_json\n        except AttributeError:\n            return super(ProtocolEncoder, self).default(o)\n        else:\n            return method()"
        ],
        [
            "STORE_NAME",
            "    def default(self, o):\n        try:\n            method = o.as_json\n        except AttributeError:\n            return super(ProtocolEncoder, self).default(o)\n        else:\n            return method()"
        ],
        [
            "LOAD_FAST",
            "o"
        ],
        [
            "LOAD_ATTR",
            "o.as_json"
        ],
        [
            "STORE_FAST",
            "method"
        ],
        [
            "LOAD_FAST",
            "method"
        ],
        [
            "CALL",
            "method()"
        ],
        [
            "LOAD_GLOBAL",
            "AttributeError"
        ],
        [
            "LOAD_GLOBAL",
            "super"
        ],
        [
            "LOAD_GLOBAL",
            "ProtocolEncoder"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "super(ProtocolEncoder, self)"
        ],
        [
            "LOAD_METHOD",
            "super(ProtocolEncoder, self).default"
        ],
        [
            "LOAD_FAST",
            "o"
        ],
        [
            "CALL",
            "super(ProtocolEncoder, self).default(o)"
        ],
        [
            "LOAD_GLOBAL",
            "io"
        ],
        [
            "LOAD_ATTR",
            "io.open"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "CALL",
            "io.open(filename, 'rb')"
        ],
        [
            "STORE_FAST",
            "fp"
        ],
        [
            "LOAD_GLOBAL",
            "detect_encoding"
        ],
        [
            "LOAD_FAST",
            "fp"
        ],
        [
            "LOAD_ATTR",
            "fp.readline"
        ],
        [
            "CALL",
            "detect_encoding(fp.readline)"
        ],
        [
            "STORE_FAST",
            "encoding"
        ],
        [
            "STORE_FAST",
            "lines"
        ],
        [
            "LOAD_FAST",
            "fp"
        ],
        [
            "LOAD_METHOD",
            "fp.seek"
        ],
        [
            "CALL",
            "fp.seek(0)"
        ],
        [
            "LOAD_GLOBAL",
            "io"
        ],
        [
            "LOAD_ATTR",
            "io.TextIOWrapper"
        ],
        [
            "LOAD_FAST",
            "fp"
        ],
        [
            "LOAD_FAST",
            "encoding"
        ],
        [
            "CALL",
            "io.TextIOWrapper(fp, encoding, line_buffering=True)"
        ],
        [
            "STORE_FAST",
            "text"
        ],
        [
            "LOAD_FAST",
            "text"
        ],
        [
            "STORE_ATTR",
            "text.mode"
        ],
        [
            "LOAD_FAST",
            "text"
        ],
        [
            "LOAD_FAST",
            "fp"
        ],
        [
            "LOAD_METHOD",
            "fp.close"
        ],
        [
            "CALL",
            "fp.close()"
        ],
        [
            "STORE_DEREF",
            "from lib2to3.pgen2.tokenize import cookie_re"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_METHOD",
            "filename.endswith"
        ],
        [
            "CALL",
            "filename.endswith('.pyc')"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "BINARY_SUBSCR",
            "filename[:-1]"
        ],
        [
            "STORE_FAST",
            "filename"
        ],
        [
            "LOAD_GLOBAL",
            "open_with_encoding_check"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "CALL",
            "open_with_encoding_check(filename)"
        ],
        [
            "STORE_FAST",
            "f"
        ],
        [
            "LOAD_METHOD",
            "''.join"
        ],
        [
            "LOAD_GLOBAL",
            "enumerate"
        ],
        [
            "LOAD_FAST",
            "f"
        ],
        [
            "CALL",
            "enumerate(f)"
        ],
        [
            "CALL",
            "[\n            '\\n' if i < 2 and cookie_re.match(line)\n            else line\n            for i, line in enumerate(f)\n        ]"
        ],
        [
            "CALL",
            "''.join([\n            '\\n' if i < 2 and cookie_re.match(line)\n            else line\n            for i, line in enumerate(f)\n        ])"
        ],
        [
            "CALL",
            "    with open_with_encoding_check(filename) as f:\n        return ''.join([\n            '\\n' if i < 2 and cookie_re.match(line)\n            else line\n            for i, line in enumerate(f)\n        ])"
        ],
        [
            "LOAD_FAST",
            "[\n            '\\n' if i < 2 and cookie_re.match(line)\n            else line\n            for i, line in enumerate(f)\n        ]"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "STORE_FAST",
            "line"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "COMPARE_OP",
            "i < 2"
        ],
        [
            "LOAD_DEREF",
            "cookie_re"
        ],
        [
            "LOAD_METHOD",
            "cookie_re.match"
        ],
        [
            "LOAD_FAST",
            "line"
        ],
        [
            "CALL",
            "cookie_re.match(line)"
        ],
        [
            "LOAD_FAST",
            "line"
        ],
        [
            "LOAD_GLOBAL",
            "safe_next"
        ],
        [
            "LOAD_FAST",
            "tokens"
        ],
        [
            "LOAD_METHOD",
            "tokens.get_tokens"
        ],
        [
            "LOAD_FAST",
            "function_node"
        ],
        [
            "CALL",
            "tokens.get_tokens(function_node)"
        ],
        [
            "CALL",
            "(t for t in tokens.get_tokens(function_node)\n                          if t.string == 'def' and t.type == token.NAME)"
        ],
        [
            "CALL",
            "safe_next(t for t in tokens.get_tokens(function_node)\n                          if t.string == 'def' and t.type == token.NAME)"
        ],
        [
            "STORE_FAST",
            "def_token"
        ],
        [
            "LOAD_FAST",
            "def_token"
        ],
        [
            "LOAD_ATTR",
            "def_token.startpos"
        ],
        [
            "STORE_FAST",
            "startpos"
        ],
        [
            "LOAD_FAST",
            "tokens"
        ],
        [
            "LOAD_ATTR",
            "tokens.text"
        ],
        [
            "LOAD_FAST",
            "startpos"
        ],
        [
            "LOAD_FAST",
            "function_node"
        ],
        [
            "LOAD_ATTR",
            "function_node.last_token"
        ],
        [
            "LOAD_ATTR",
            "function_node.last_token.endpos"
        ],
        [
            "BINARY_SUBSCR",
            "tokens.text[startpos:function_node.last_token.endpos]"
        ],
        [
            "LOAD_METHOD",
            "tokens.text[startpos:function_node.last_token.endpos].rstrip"
        ],
        [
            "CALL",
            "tokens.text[startpos:function_node.last_token.endpos].rstrip()"
        ],
        [
            "STORE_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_METHOD",
            "source.startswith"
        ],
        [
            "CALL",
            "source.startswith('def')"
        ],
        [
            "LOAD_FAST",
            "startpos"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_FAST",
            "(t for t in tokens.get_tokens(function_node)\n                          if t.string == 'def' and t.type == token.NAME)"
        ],
        [
            "STORE_FAST",
            "t"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "LOAD_ATTR",
            "t.string"
        ],
        [
            "COMPARE_OP",
            "t.string == 'def'"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "LOAD_ATTR",
            "t.type"
        ],
        [
            "LOAD_GLOBAL",
            "token"
        ],
        [
            "LOAD_ATTR",
            "token.NAME"
        ],
        [
            "COMPARE_OP",
            "t.type == token.NAME"
        ],
        [
            "LOAD_FAST",
            "t"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "STORE_FAST",
            "arg"
        ],
        [
            "LOAD_GLOBAL",
            "print"
        ],
        [
            "LOAD_FAST",
            "arg"
        ],
        [
            "CALL",
            "print(arg)"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "CALL",
            "len(args)"
        ],
        [
            "COMPARE_OP",
            "len(args) == 1"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "BINARY_SUBSCR",
            "args[0]"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "LOAD_FAST",
            "filename"
        ],
        [
            "LOAD_METHOD",
            "filename.startswith"
        ],
        [
            "CALL",
            "filename.startswith('<ipython-input-')"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_GLOBAL",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.ImportFrom"
        ],
        [
            "CALL",
            "isinstance(node, ast.ImportFrom)"
        ],
        [
            "LOAD_FAST",
            "node"
        ],
        [
            "LOAD_ATTR",
            "node.module"
        ],
        [
            "COMPARE_OP",
            "node.module == \"__future__\""
        ],
        [
            "STORE_FAST",
            "from freezegun.api import real_datetime"
        ],
        [
            "LOAD_GLOBAL",
            "ImportError"
        ],
        [
            "STORE_FAST",
            "from datetime import datetime as real_datetime"
        ],
        [
            "LOAD_FAST",
            "real_datetime"
        ],
        [
            "LOAD_METHOD",
            "real_datetime.now"
        ],
        [
            "CALL",
            "real_datetime.now()"
        ]
    ],
    "utils2.py": [
        [
            "STORE_NAME",
            "import ast"
        ],
        [
            "STORE_NAME",
            "import inspect"
        ],
        [
            "STORE_NAME",
            "import os"
        ],
        [
            "STORE_NAME",
            "import sys"
        ],
        [
            "STORE_NAME",
            "from itertools import chain"
        ],
        [
            "STORE_NAME",
            "import six"
        ],
        [
            "STORE_NAME",
            "from cheap_repr import cheap_repr, try_register_repr"
        ],
        [
            "STORE_NAME",
            "from cheap_repr import cheap_repr, try_register_repr"
        ],
        [
            "LOAD_NAME",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.version"
        ],
        [
            "LOAD_METHOD",
            "sys.version.lower"
        ],
        [
            "CALL",
            "sys.version.lower()"
        ],
        [
            "CONTAINS_OP",
            "'pypy' in sys.version.lower()"
        ],
        [
            "LOAD_NAME",
            "sys"
        ],
        [
            "LOAD_ATTR",
            "sys.version_info"
        ],
        [
            "BINARY_SUBSCR",
            "sys.version_info[:2]"
        ],
        [
            "CONTAINS_OP",
            "sys.version_info[:2] in [(3, 4), (3, 8)]"
        ],
        [
            "STORE_NAME",
            "NO_ASTTOKENS"
        ],
        [
            "LOAD_NAME",
            "IOError"
        ],
        [
            "LOAD_NAME",
            "OSError"
        ],
        [
            "LOAD_NAME",
            "ValueError"
        ],
        [
            "STORE_NAME",
            "file_reading_errors"
        ],
        [
            "STORE_NAME",
            "def shitcode(s):\n    return ''.join(\n        (c if (0 < ord(c) < 256) else '?') for c in s\n    )"
        ],
        [
            "STORE_NAME",
            "def truncate(seq, max_length, middle):\n    if len(seq) > max_length:\n        left = (max_length - len(middle)) // 2\n        right = max_length - len(middle) - left\n        seq = seq[:left] + middle + seq[-right:]\n    return seq"
        ],
        [
            "STORE_NAME",
            "def truncate_string(string, max_length):\n    return truncate(string, max_length, '...')"
        ],
        [
            "STORE_NAME",
            "def truncate_list(lst, max_length):\n    return truncate(lst, max_length, ['...'])"
        ],
        [
            "STORE_NAME",
            "def ensure_tuple(x, split=False):\n    if split and isinstance(x, six.string_types):\n        x = x.replace(',', ' ').split()\n    if not isinstance(x, (list, set, tuple)):\n        x = (x,)\n    return tuple(x)"
        ],
        [
            "STORE_NAME",
            "def short_filename(code):\n    result = os.path.basename(code.co_filename)\n    if result.endswith('.pyc'):\n        result = result[:-1]\n    return result"
        ],
        [
            "STORE_NAME",
            "def is_comprehension_frame(frame):\n    return frame.f_code.co_name in ('<listcomp>', '<dictcomp>', '<setcomp>')"
        ],
        [
            "STORE_NAME",
            "def needs_parentheses(source):\n    def code(s):\n        return compile(s.format(source), '<variable>', 'eval').co_code\n\n    try:\n        without_parens = code('{}.x')\n    except SyntaxError:\n        # Likely a multiline expression that needs parentheses to be valid\n        code('({})')\n        return True\n    else:\n        return without_parens != code('({}).x')"
        ],
        [
            "STORE_NAME",
            "def with_needed_parentheses(source):\n    if needs_parentheses(source):\n        return '({})'.format(source)\n    else:\n        return source"
        ],
        [
            "STORE_NAME",
            "REPR_TARGET_LENGTH"
        ],
        [
            "STORE_NAME",
            "def my_cheap_repr(x):\n    return cheap_repr(x, target_length=REPR_TARGET_LENGTH)"
        ],
        [
            "LOAD_NAME",
            "dict"
        ],
        [
            "CALL",
            "class ArgDefaultDict(dict):\n    def __init__(self, factory):\n        super(ArgDefaultDict, self).__init__()\n        self.factory = factory\n\n    def __missing__(self, key):\n        result = self[key] = self.factory(key)\n        return result"
        ],
        [
            "STORE_NAME",
            "class ArgDefaultDict(dict):\n    def __init__(self, factory):\n        super(ArgDefaultDict, self).__init__()\n        self.factory = factory\n\n    def __missing__(self, key):\n        result = self[key] = self.factory(key)\n        return result"
        ],
        [
            "STORE_NAME",
            "def optional_numeric_label(i, lst):\n    if len(lst) == 1:\n        return ''\n    else:\n        return ' ' + str(i + 1)"
        ],
        [
            "STORE_NAME",
            "def is_pathlike(x):\n    if hasattr(os, 'PathLike'):\n        return isinstance(x, os.PathLike)\n\n    return (\n            hasattr(x, '__fspath__') or\n            # Make a concession for older `pathlib` versions:\n            (hasattr(x, 'open') and\n             'path' in x.__class__.__name__.lower())\n    )"
        ],
        [
            "LOAD_NAME",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.iscoroutinefunction"
        ],
        [
            "STORE_NAME",
            "iscoroutinefunction"
        ],
        [
            "LOAD_NAME",
            "AttributeError"
        ],
        [
            "STORE_NAME",
            "    def iscoroutinefunction(_):\n        return False"
        ],
        [
            "LOAD_NAME",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.Try"
        ],
        [
            "STORE_NAME",
            "try_statement"
        ],
        [
            "LOAD_NAME",
            "AttributeError"
        ],
        [
            "LOAD_NAME",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.TryExcept"
        ],
        [
            "STORE_NAME",
            "try_statement"
        ],
        [
            "LOAD_NAME",
            "__import__"
        ],
        [
            "CALL",
            "__import__(\"__builtin__\")"
        ],
        [
            "STORE_NAME",
            "builtins"
        ],
        [
            "LOAD_NAME",
            "ImportError"
        ],
        [
            "LOAD_NAME",
            "__import__"
        ],
        [
            "CALL",
            "__import__(\"builtins\")"
        ],
        [
            "STORE_NAME",
            "builtins"
        ],
        [
            "LOAD_NAME",
            "ast"
        ],
        [
            "LOAD_ATTR",
            "ast.FormattedValue"
        ],
        [
            "STORE_NAME",
            "FormattedValue"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "    class FormattedValue(object):\n        pass"
        ],
        [
            "STORE_NAME",
            "    class FormattedValue(object):\n        pass"
        ],
        [
            "STORE_NAME",
            "def no_args_decorator(args, kwargs):\n    return len(args) == 1 and inspect.isfunction(args[0]) and not kwargs"
        ],
        [
            "STORE_NAME",
            "from functools import lru_cache"
        ],
        [
            "LOAD_NAME",
            "ImportError"
        ],
        [
            "STORE_NAME",
            "from backports.functools_lru_cache import lru_cache"
        ],
        [
            "LOAD_NAME",
            "str"
        ],
        [
            "CALL",
            "class DirectRepr(str):\n    def __repr__(self):\n        return self"
        ],
        [
            "STORE_NAME",
            "class DirectRepr(str):\n    def __repr__(self):\n        return self"
        ],
        [
            "STORE_NAME",
            "from django.db.models import QuerySet"
        ],
        [
            "LOAD_NAME",
            "ImportError"
        ],
        [
            "LOAD_NAME",
            "object"
        ],
        [
            "CALL",
            "    class QuerySet(object):\n        pass"
        ],
        [
            "STORE_NAME",
            "    class QuerySet(object):\n        pass"
        ],
        [
            "STORE_NAME",
            "def _sample_indices(length, max_length):\n    if length <= max_length + 2:\n        return range(length)\n    else:\n        return chain(range(max_length // 2),\n                     range(length - max_length // 2,\n                           length))"
        ],
        [
            "LOAD_NAME",
            "try_register_repr"
        ],
        [
            "CALL",
            "try_register_repr('pandas', 'Series')"
        ],
        [
            "CALL",
            "try_register_repr('pandas', 'Series')"
        ],
        [
            "STORE_NAME",
            "@try_register_repr('pandas', 'Series')\ndef _repr_series_one_line(x, helper):\n    n = len(x)\n    if n == 0:\n        return repr(x)\n    newlevel = helper.level - 1\n    pieces = []\n    maxparts = _repr_series_one_line.maxparts\n    for i in _sample_indices(n, maxparts):\n        k = x.index[i:i + 1].format(sparsify=False)[0]\n        v = x.iloc[i]\n        pieces.append('%s = %s' % (k, cheap_repr(v, newlevel)))\n    if n > maxparts + 2:\n        pieces.insert(maxparts // 2, '...')\n    return '; '.join(pieces)"
        ],
        [
            "LOAD_METHOD",
            "''.join"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "CALL",
            "(\n        (c if (0 < ord(c) < 256) else '?') for c in s\n    )"
        ],
        [
            "CALL",
            "''.join(\n        (c if (0 < ord(c) < 256) else '?') for c in s\n    )"
        ],
        [
            "LOAD_FAST",
            "(\n        (c if (0 < ord(c) < 256) else '?') for c in s\n    )"
        ],
        [
            "STORE_FAST",
            "c"
        ],
        [
            "LOAD_GLOBAL",
            "ord"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "CALL",
            "ord(c)"
        ],
        [
            "COMPARE_OP",
            "c if (0 < ord(c) < 256) else '?'"
        ],
        [
            "COMPARE_OP",
            "c if (0 < ord(c) < 256) else '?'"
        ],
        [
            "LOAD_FAST",
            "c"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "seq"
        ],
        [
            "CALL",
            "len(seq)"
        ],
        [
            "LOAD_FAST",
            "max_length"
        ],
        [
            "COMPARE_OP",
            "len(seq) > max_length"
        ],
        [
            "LOAD_FAST",
            "max_length"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "middle"
        ],
        [
            "CALL",
            "len(middle)"
        ],
        [
            "BINARY_OP",
            "max_length - len(middle)"
        ],
        [
            "BINARY_OP",
            "(max_length - len(middle)) // 2"
        ],
        [
            "STORE_FAST",
            "left"
        ],
        [
            "LOAD_FAST",
            "max_length"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "middle"
        ],
        [
            "CALL",
            "len(middle)"
        ],
        [
            "BINARY_OP",
            "max_length - len(middle)"
        ],
        [
            "LOAD_FAST",
            "left"
        ],
        [
            "BINARY_OP",
            "max_length - len(middle) - left"
        ],
        [
            "STORE_FAST",
            "right"
        ],
        [
            "LOAD_FAST",
            "seq"
        ],
        [
            "LOAD_FAST",
            "left"
        ],
        [
            "BINARY_SUBSCR",
            "seq[:left]"
        ],
        [
            "LOAD_FAST",
            "middle"
        ],
        [
            "BINARY_OP",
            "seq[:left] + middle"
        ],
        [
            "LOAD_FAST",
            "seq"
        ],
        [
            "LOAD_FAST",
            "right"
        ],
        [
            "UNARY_NEGATIVE",
            "-right"
        ],
        [
            "BINARY_SUBSCR",
            "seq[-right:]"
        ],
        [
            "BINARY_OP",
            "seq[:left] + middle + seq[-right:]"
        ],
        [
            "STORE_FAST",
            "seq"
        ],
        [
            "LOAD_FAST",
            "seq"
        ],
        [
            "LOAD_GLOBAL",
            "truncate"
        ],
        [
            "LOAD_FAST",
            "string"
        ],
        [
            "LOAD_FAST",
            "max_length"
        ],
        [
            "CALL",
            "truncate(string, max_length, '...')"
        ],
        [
            "LOAD_GLOBAL",
            "truncate"
        ],
        [
            "LOAD_FAST",
            "lst"
        ],
        [
            "LOAD_FAST",
            "max_length"
        ],
        [
            "CALL",
            "truncate(lst, max_length, ['...'])"
        ],
        [
            "LOAD_FAST",
            "split"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "six"
        ],
        [
            "LOAD_ATTR",
            "six.string_types"
        ],
        [
            "CALL",
            "isinstance(x, six.string_types)"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_METHOD",
            "x.replace"
        ],
        [
            "CALL",
            "x.replace(',', ' ')"
        ],
        [
            "LOAD_METHOD",
            "x.replace(',', ' ').split"
        ],
        [
            "CALL",
            "x.replace(',', ' ').split()"
        ],
        [
            "STORE_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "list"
        ],
        [
            "LOAD_GLOBAL",
            "set"
        ],
        [
            "LOAD_GLOBAL",
            "tuple"
        ],
        [
            "CALL",
            "isinstance(x, (list, set, tuple))"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "STORE_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "tuple"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "tuple(x)"
        ],
        [
            "LOAD_GLOBAL",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.path"
        ],
        [
            "LOAD_METHOD",
            "os.path.basename"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "LOAD_ATTR",
            "code.co_filename"
        ],
        [
            "CALL",
            "os.path.basename(code.co_filename)"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_METHOD",
            "result.endswith"
        ],
        [
            "CALL",
            "result.endswith('.pyc')"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "BINARY_SUBSCR",
            "result[:-1]"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "frame"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code"
        ],
        [
            "LOAD_ATTR",
            "frame.f_code.co_name"
        ],
        [
            "CONTAINS_OP",
            "frame.f_code.co_name in ('<listcomp>', '<dictcomp>', '<setcomp>')"
        ],
        [
            "STORE_FAST",
            "    def code(s):\n        return compile(s.format(source), '<variable>', 'eval').co_code"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "CALL",
            "code('{}.x')"
        ],
        [
            "STORE_FAST",
            "without_parens"
        ],
        [
            "LOAD_FAST",
            "without_parens"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "CALL",
            "code('({}).x')"
        ],
        [
            "COMPARE_OP",
            "without_parens != code('({}).x')"
        ],
        [
            "LOAD_GLOBAL",
            "SyntaxError"
        ],
        [
            "LOAD_FAST",
            "code"
        ],
        [
            "CALL",
            "code('({})')"
        ],
        [
            "LOAD_GLOBAL",
            "compile"
        ],
        [
            "LOAD_FAST",
            "s"
        ],
        [
            "LOAD_METHOD",
            "s.format"
        ],
        [
            "LOAD_DEREF",
            "source"
        ],
        [
            "CALL",
            "s.format(source)"
        ],
        [
            "CALL",
            "compile(s.format(source), '<variable>', 'eval')"
        ],
        [
            "LOAD_ATTR",
            "compile(s.format(source), '<variable>', 'eval').co_code"
        ],
        [
            "LOAD_GLOBAL",
            "needs_parentheses"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CALL",
            "needs_parentheses(source)"
        ],
        [
            "LOAD_METHOD",
            "'({})'.format"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "CALL",
            "'({})'.format(source)"
        ],
        [
            "LOAD_FAST",
            "source"
        ],
        [
            "LOAD_GLOBAL",
            "cheap_repr"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "REPR_TARGET_LENGTH"
        ],
        [
            "CALL",
            "cheap_repr(x, target_length=REPR_TARGET_LENGTH)"
        ],
        [
            "STORE_NAME",
            "    def __init__(self, factory):\n        super(ArgDefaultDict, self).__init__()\n        self.factory = factory"
        ],
        [
            "STORE_NAME",
            "    def __missing__(self, key):\n        result = self[key] = self.factory(key)\n        return result"
        ],
        [
            "STORE_NAME",
            "    def __missing__(self, key):\n        result = self[key] = self.factory(key)\n        return result"
        ],
        [
            "LOAD_GLOBAL",
            "super"
        ],
        [
            "LOAD_GLOBAL",
            "ArgDefaultDict"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "CALL",
            "super(ArgDefaultDict, self)"
        ],
        [
            "LOAD_METHOD",
            "super(ArgDefaultDict, self).__init__"
        ],
        [
            "CALL",
            "super(ArgDefaultDict, self).__init__()"
        ],
        [
            "LOAD_FAST",
            "factory"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "STORE_ATTR",
            "self.factory"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_METHOD",
            "self.factory"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "CALL",
            "self.factory(key)"
        ],
        [
            "STORE_FAST",
            "result"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "key"
        ],
        [
            "STORE_SUBSCR",
            "self[key]"
        ],
        [
            "LOAD_FAST",
            "result"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "lst"
        ],
        [
            "CALL",
            "len(lst)"
        ],
        [
            "COMPARE_OP",
            "len(lst) == 1"
        ],
        [
            "LOAD_GLOBAL",
            "str"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_OP",
            "i + 1"
        ],
        [
            "CALL",
            "str(i + 1)"
        ],
        [
            "BINARY_OP",
            "' ' + str(i + 1)"
        ],
        [
            "LOAD_GLOBAL",
            "hasattr"
        ],
        [
            "LOAD_GLOBAL",
            "os"
        ],
        [
            "CALL",
            "hasattr(os, 'PathLike')"
        ],
        [
            "LOAD_GLOBAL",
            "isinstance"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_GLOBAL",
            "os"
        ],
        [
            "LOAD_ATTR",
            "os.PathLike"
        ],
        [
            "CALL",
            "isinstance(x, os.PathLike)"
        ],
        [
            "LOAD_GLOBAL",
            "hasattr"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "hasattr(x, '__fspath__')"
        ],
        [
            "LOAD_GLOBAL",
            "hasattr"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "hasattr(x, 'open')"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_ATTR",
            "x.__class__"
        ],
        [
            "LOAD_ATTR",
            "x.__class__.__name__"
        ],
        [
            "LOAD_METHOD",
            "x.__class__.__name__.lower"
        ],
        [
            "CALL",
            "x.__class__.__name__.lower()"
        ],
        [
            "CONTAINS_OP",
            "'path' in x.__class__.__name__.lower()"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "CALL",
            "len(args)"
        ],
        [
            "COMPARE_OP",
            "len(args) == 1"
        ],
        [
            "LOAD_GLOBAL",
            "inspect"
        ],
        [
            "LOAD_ATTR",
            "inspect.isfunction"
        ],
        [
            "LOAD_FAST",
            "args"
        ],
        [
            "BINARY_SUBSCR",
            "args[0]"
        ],
        [
            "CALL",
            "inspect.isfunction(args[0])"
        ],
        [
            "LOAD_FAST",
            "kwargs"
        ],
        [
            "UNARY_NOT",
            "not kwargs"
        ],
        [
            "STORE_NAME",
            "    def __repr__(self):\n        return self"
        ],
        [
            "LOAD_FAST",
            "self"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "LOAD_FAST",
            "max_length"
        ],
        [
            "BINARY_OP",
            "max_length + 2"
        ],
        [
            "COMPARE_OP",
            "length <= max_length + 2"
        ],
        [
            "LOAD_GLOBAL",
            "range"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "CALL",
            "range(length)"
        ],
        [
            "LOAD_GLOBAL",
            "chain"
        ],
        [
            "LOAD_GLOBAL",
            "range"
        ],
        [
            "LOAD_FAST",
            "max_length"
        ],
        [
            "BINARY_OP",
            "max_length // 2"
        ],
        [
            "CALL",
            "range(max_length // 2)"
        ],
        [
            "LOAD_GLOBAL",
            "range"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "LOAD_FAST",
            "max_length"
        ],
        [
            "BINARY_OP",
            "max_length // 2"
        ],
        [
            "BINARY_OP",
            "length - max_length // 2"
        ],
        [
            "LOAD_FAST",
            "length"
        ],
        [
            "CALL",
            "range(length - max_length // 2,\n                           length)"
        ],
        [
            "CALL",
            "chain(range(max_length // 2),\n                     range(length - max_length // 2,\n                           length))"
        ],
        [
            "LOAD_GLOBAL",
            "len"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "len(x)"
        ],
        [
            "STORE_FAST",
            "n"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "COMPARE_OP",
            "n == 0"
        ],
        [
            "LOAD_GLOBAL",
            "repr"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "CALL",
            "repr(x)"
        ],
        [
            "LOAD_FAST",
            "helper"
        ],
        [
            "LOAD_ATTR",
            "helper.level"
        ],
        [
            "BINARY_OP",
            "helper.level - 1"
        ],
        [
            "STORE_FAST",
            "newlevel"
        ],
        [
            "STORE_FAST",
            "pieces"
        ],
        [
            "LOAD_GLOBAL",
            "_repr_series_one_line"
        ],
        [
            "LOAD_ATTR",
            "_repr_series_one_line.maxparts"
        ],
        [
            "STORE_FAST",
            "maxparts"
        ],
        [
            "LOAD_GLOBAL",
            "_sample_indices"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "LOAD_FAST",
            "maxparts"
        ],
        [
            "CALL",
            "_sample_indices(n, maxparts)"
        ],
        [
            "STORE_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_ATTR",
            "x.index"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_OP",
            "i + 1"
        ],
        [
            "BINARY_SUBSCR",
            "x.index[i:i + 1]"
        ],
        [
            "LOAD_METHOD",
            "x.index[i:i + 1].format"
        ],
        [
            "CALL",
            "x.index[i:i + 1].format(sparsify=False)"
        ],
        [
            "BINARY_SUBSCR",
            "x.index[i:i + 1].format(sparsify=False)[0]"
        ],
        [
            "STORE_FAST",
            "k"
        ],
        [
            "LOAD_FAST",
            "x"
        ],
        [
            "LOAD_ATTR",
            "x.iloc"
        ],
        [
            "LOAD_FAST",
            "i"
        ],
        [
            "BINARY_SUBSCR",
            "x.iloc[i]"
        ],
        [
            "STORE_FAST",
            "v"
        ],
        [
            "LOAD_FAST",
            "pieces"
        ],
        [
            "LOAD_METHOD",
            "pieces.append"
        ],
        [
            "LOAD_FAST",
            "k"
        ],
        [
            "LOAD_GLOBAL",
            "cheap_repr"
        ],
        [
            "LOAD_FAST",
            "v"
        ],
        [
            "LOAD_FAST",
            "newlevel"
        ],
        [
            "CALL",
            "cheap_repr(v, newlevel)"
        ],
        [
            "BUILD_STRING",
            "'%s = %s' % (k, cheap_repr(v, newlevel))"
        ],
        [
            "CALL",
            "pieces.append('%s = %s' % (k, cheap_repr(v, newlevel)))"
        ],
        [
            "LOAD_FAST",
            "n"
        ],
        [
            "LOAD_FAST",
            "maxparts"
        ],
        [
            "BINARY_OP",
            "maxparts + 2"
        ],
        [
            "COMPARE_OP",
            "n > maxparts + 2"
        ],
        [
            "LOAD_FAST",
            "pieces"
        ],
        [
            "LOAD_METHOD",
            "pieces.insert"
        ],
        [
            "LOAD_FAST",
            "maxparts"
        ],
        [
            "BINARY_OP",
            "maxparts // 2"
        ],
        [
            "CALL",
            "pieces.insert(maxparts // 2, '...')"
        ],
        [
            "LOAD_METHOD",
            "'; '.join"
        ],
        [
            "LOAD_FAST",
            "pieces"
        ],
        [
            "CALL",
            "'; '.join(pieces)"
        ]
    ]
}